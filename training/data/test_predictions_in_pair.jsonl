{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::ref_get_signatures", "test": ["fn drop(&mut self) {\n            let data = mem::take(&mut self.data);\n            assert!(self\n               .buffer\n               .lock()\n               .unwrap()\n               .insert(self.page, Arc::new(data))\n               .is_none());\n        } [SEP] fn ref_get_signatures() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..10u8 {\n            table.insert([i].as_slice(), [i + 1].as_slice()).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(SLICE_TABLE).unwrap();\n\n    let zero = vec![0u8];\n    assert_eq!(&[1], table.get([0].as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(b\"\\0\".as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(zero.as_slice()).unwrap().unwrap().value());\n\n    let start = vec![0u8];\n    let end = vec![10u8];\n    let mut iter = table.range::<&[u8]>(..).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range(start.as_slice()..&end).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(\n"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_t", "test": ["pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    } [SEP] fn test_skip_iter_t() {\n    // Test iterators that skip single, trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n       .digit_separator(num::NonZeroU8::new(b'_'))\n       .integer_trailing_digit_separator(true)\n       .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_45_5\");\n    skip_iter__"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::class_type_parameters", "test": ["fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n} [SEP] fn class_type_parameters() {\n    let source = r#\"class X[T: str, U, *Ts, **P]:...\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_lifetime", "test": ["fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_batch", "test": ["fn lock(primary: &[u8]) -> PessimisticLock {\n        PessimisticLock {\n            primary: primary.to_vec().into_boxed_slice(),\n            start_ts: 100.into(),\n            ttl: 3000,\n            for_update_ts: 110.into(),\n            min_commit_ts: 110.into(),\n            last_change_ts: 105.into(),\n            versions_to_last_change: 2,\n        }\n    } [SEP] fn test_batch() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    let metrics = builder.metrics.clone();\n    system.spawn(\"test\".to_owned(), builder);\n    let mut expected_metrics = HandleMetrics::default();\n    assert_eq!(*metrics.lock().unwrap(), expected_metrics);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    router\n       .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                let mailbox = BasicMailbox::new(tx, runner, Arc::default());\n                r.register(1, mailbox);\n                tx_.send(1).unwrap();\n            },\n        )))\n       .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n    // sleep to wait Batch-System to finish calling end().\n    sleep(Duration::from_millis(20));\n    router\n       .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(2).unwrap();\n            })),\n        )\n       .unwrap();\n    assert_eq!(rx.recv_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/failpoints/test_life.rs::test_destroy_by_larger_id_while_applying", "test": ["pub async fn wait_committed(&mut self) -> bool {\n        WaitEvent {\n            event: CmdResChannel::COMMITTED_EVENT,\n            core: &self.core,\n        }\n       .await\n    } [SEP] fn test_destroy_by_larger_id_while_applying() {\n    let fp = \"APPLY_COMMITTED_ENTRIES\";\n    let mut cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    fail::cfg(fp, \"pause\").unwrap();\n\n    let header = Box::new(router.new_request_for(2).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n    let (msg, mut sub) = PeerMsg::simple_write(header.clone(), put.clone().encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub.wait_committed()));\n\n    let mut larger_id_msg = Box::<RaftMessage>::default();\n    larger_id_msg.set_region_id(2);\n    let mut target_peer = header.get_peer().clone();\n    target_peer.set_id(target_peer.get_id() + 1);\n    larger_id_msg.set_to_peer(target_peer.clone());\n    larger_id_msg.set_region_epoch(header.get_region_epoch().clone());\n    larger_id_msg\n       .mut_region_epoch()\n       .set_conf_ver(header.get_region_epoch().get_conf_ver() + 1);\n    larger_id_msg.set_from_peer(new_peer(2, 8));\n    let raft_message = larger_id_msg.mut_message();\n    raft_message.set_msg_type(MessageType::MsgHeartbeat);\n    raft__"]}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::large_add_test", "test": ["pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n} [SEP] fn large_add_test() {\n    // Overflow, both single values\n    let mut x = VecType::from_u64(4294967295);\n    let y = VecType::from_u64(5);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    // No overflow, single value\n    let mut x = VecType::from_u64(5);\n    let y = VecType::from_u64(7);\n    bigint::large_add(&mut x, &y);\n    let expected = VecType::from_u64(12);\n    assert_eq!(&*x, &*expected);\n\n    // Single carry, internal overflow\n    let mut x = VecType::from_u64(0x80000000FFFFFFFF);\n    let y = VecType::from_u64(7);\n    bigint::large_add(&mut x, &y_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typed_struct_with_field_name", "test": ["pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    } [SEP] fn parse_typed_struct_with_field_name() {\n    let sql = r#\"SELECT STRUCT<x INT64>(5), STRUCT<y STRING>(\"foo\")\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"x\")),\n                field_type: DataType::Int64\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\"foo\".to_string())),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"y\")),\n                field_type: DataType::String(None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<x INT64, y INT64>(5, 5)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(1, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")), Expr::Value(number(\"5\")),],\n            fields: vec![\n                StructField {\n                    field_name: Some(Ident::from(\"x\")),\n                    field_type: DataType::Int64\n                },\n                StructField {\n                    field_name: Some(Ident::from(\"y\")),\n"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::small_add_test", "test": ["pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n} [SEP] fn small_add_test() {\n    let mut x = VecType::from_u32(4294967295);\n    bigint::small_add(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(5);\n    bigint::small_add(&mut x, 7);\n    let expected = VecType::from_u32(12);\n    assert_eq!(&*x, &*expected);\n\n    // Single carry, internal overflow\n    let mut x = VecType::from_u64(0x80000000FFFFFFFF);\n    bigint::small_add(&mut x, 7);\n    let expected: VecType = vec_from_u32(&[6, 0x80000001]);\n    assert_eq!(&*x, &*expected);\n\n    // Double carry, overflow\n    let mut x = VecType::from_u64(0("]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::help", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn help() {\n    new_ucmd!().arg(\"--help\").succeeds();\n    new_ucmd!().arg(\"-h\").succeeds();\n}_"]}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/snapshots.rs::convert_glsl_folder", "test": ["fn write_output_wgsl(\n    input: &Input,\n    module: &naga::Module,\n    info: &naga::valid::ModuleInfo,\n    params: &WgslOutParameters,\n) {\n    use naga::back::wgsl;\n\n    println!(\"generating WGSL\");\n\n    let mut flags = wgsl::WriterFlags::empty();\n    flags.set(wgsl::WriterFlags::EXPLICIT_TYPES, params.explicit_types);\n\n    let string = wgsl::write_string(module, info, flags).expect(\"WGSL write failed\");\n\n    input.write_output_file(\"wgsl\", \"wgsl\", string);\n} [SEP] fn convert_glsl_folder() {\n    let _ = env_logger::try_init();\n\n    for input in Input::files_in_dir(\"glsl\") {\n        let input = Input {\n            keep_input_extension: true,\n           ..input\n        };\n        let file_name = &input.file_name;\n        if file_name.ends_with(\".ron\") {\n            // No needed to validate ron files\n            continue;\n        }\n\n        let mut parser = naga::front::glsl::Frontend::default();\n        let module = parser\n           .parse(\n                &naga::front::glsl::Options {\n                    stage: match file_name.extension().and_then(|s| s.to_str()).unwrap() {\n                        \"vert\" => naga::ShaderStage::Vertex,\n                        \"frag\" => naga::ShaderStage::Fragment,\n                        \"comp\" => naga::ShaderStage::Compute,\n                        ext => panic!(\"Unknown extension for glsl file {ext}\"),\n                    },\n                    defines: Default::default(),\n                },\n                &input.read_source(),\n            )\n           .unwrap();\n\n        let info = naga::valid::Validator::new(\n            naga::valid::ValidationFlags::all(),\n            naga::valid::Capabilities::all(),\n        )\n       .validate(&module)\n       .un"]}
{"test_id": "pyfisch-cbor/pyfisch-cbor-347a3f0/tests/ser.rs::test_str", "test": ["fn serialize_and_compare<T: Serialize>(value: T, expected: &[u8]) {\n    let mut slice = [0u8; 64];\n    let writer = SliceWrite::new(&mut slice);\n    let mut serializer = Serializer::new(writer);\n    value.serialize(&mut serializer).unwrap();\n    let writer = serializer.into_inner();\n    let end = writer.bytes_written();\n    let slice = writer.into_inner();\n    assert_eq!(&slice[..end], expected);\n} [SEP] fn test_str() {\n    serialize_and_compare(\"foobar\", b\"ffoobar\");\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_slash_long_columns", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_trailing_slash_long_columns() {\n    new_ucmd!()\n       .arg(\"--tabs=1,/3\")\n       .pipe_in(\"\\taaaa\\tbbbb\\tcccc\")\n       .succeeds()\n        //          0         1\n        //          01234567890123456\n       .stdout_is(\" aaaa bbbb  cccc\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_control_block", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_control_block() {\n    let s = include_str!(\"data/serde/control_block_hex\");\n    let block = ControlBlock::decode(&Vec::<u8>::from_hex(s.trim()).unwrap()).unwrap();\n    let got = serialize(&block).unwrap();\n\n    let want = include_bytes!(\"data/serde/control_block_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::old_octal_syntax", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn old_octal_syntax() {\n    new_ucmd!()\n       .arg(\"-e\")\n       .arg(\"\\\\1foo\")\n       .succeeds()\n       .stdout_is(\"\\x01foo\\n\");\n\n    new_ucmd!()\n       .arg(\"-e\")\n       .arg(\"\\\\43foo\")\n       .succeeds()\n       .stdout_is(\"#foo\\n\");\n\n    new_ucmd!()\n       .arg(\"-e\")\n       .arg(\"\\\\101 foo\")\n       .succeeds()\n       .stdout_is(\"A foo\\n\");\n\n    new_ucmd!()\n       .arg(\"-e\")\n       .arg(\"\\\\1011\")\n       .succeeds()\n       .stdout_is(\"A1\\n\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_hex_rejects_sign_after_identifier", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_hex_rejects_sign_after_identifier() {\n    new_ucmd!()\n       .args(&[\"0x-123ABC\"])\n       .fails()\n       .no_stdout()\n       .usage_error(\"invalid floating point argument: '0x-123ABC'\");\n    new_ucmd!()\n       .args(&[\"0x+123ABC\"])\n       .fails()\n       .no_stdout()\n       .usage_error(\"invalid floating point argument: '0x+123ABC'\");\n\n    new_ucmd!()\n       .args(&[\"--\", \"-0x-123ABC\"])\n       .fails()\n       .no_stdout()\n       .usage_error(\"invalid floating point argument: '-0x-123ABC'\");\n    new_ucmd!()\n       .args(&[\"--\", \"-0x+123ABC\"])\n       .fails()\n       .no_stdout()\n       .usage_error(\"invalid floating point argument: '-0x+123ABC'\");\n\n    // test without \"--\" => argument parsed as (invalid) flag\n    new_ucmd!()\n       .args(&[\"-0x-123ABC\"])\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"unexpected argument '-0' found\");\n    new_ucmd!()\n       .args(&[\"-0x+123ABC\"])\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"unexpected argument '-0' found\");\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_seq_object_borrow", "test": ["pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    } [SEP] fn test_seq_object_borrow() {\n    fn connect(values: &dyn SeqObject) -> String {\n        let mut rv = String::new();\n        for item in values.iter() {\n            rv.push_str(&item.to_string())\n        }\n        rv\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"connect\", connect);\n    let state = env.empty_state();\n    assert_eq!(\n        state\n           .apply_filter(\n                \"connect\",\n                args!(vec![Value::from(\"HELLO\"), Value::from(42)])\n            )\n           .unwrap(),\n        Value::from(\"HELLO42\")\n    );\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_seq_with_no_len", "test": ["pub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n    T:?Sized + Serialize,\n{\n    let vec = tri!(to_vec_pretty(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n} [SEP] fn test_serialize_seq_with_no_len() {\n    #[derive(Clone, Debug, PartialEq)]\n    struct MyVec<T>(Vec<T>);\n\n    impl<T> ser::Serialize for MyVec<T>\n    where\n        T: ser::Serialize,\n    {\n        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: ser::Serializer,\n        {\n            let mut seq = serializer.serialize_seq(None)?;\n            for elem in &self.0 {\n                seq.serialize_element(elem)?;\n            }\n            seq.end()\n        }\n    }\n\n    struct Visitor<T> {\n        marker: PhantomData<MyVec<T>>,\n    }\n\n    impl<'de, T> de::Visitor<'de> for Visitor<T>\n    where\n        T: de::Deserialize<'de>,\n    {\n        type Value = MyVec<T>;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(\"array\")\n        }\n\n        fn visit_unit<E>(self) -> Result<MyVec<T>, E>\n        where\n            E: de::Error,\n        {\n            Ok(MyVec(Vec::new()))\n        }\n\n        fn visit_seq<V>(self, mut visitor: V) -> Result<MyVec<T>, V::Error>\n        where\n            V: de::SeqAccess<'de>,\n        {\n            let mut values = Vec::new();\n\n            while let Some(value) =\n"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_loss_and_retry_too_low_mtu", "test": ["fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    } [SEP] fn packet_loss_and_retry_too_low_mtu() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(b\"hello\").unwrap();\n    pair.drive();\n\n    // Nothing will get past this mtu\n    pair.mtu = 10;\n    pair.client_send(client_ch, s).write(b\" world\").unwrap();\n    pair.drive_client();\n\n    // The packet was dropped\n    assert!(pair.client.outbound.is_empty());\n    assert!(pair.server.inbound.is_empty());\n\n    // Restore the default mtu, so future packets are properly transmitted\n    pair.mtu = DEFAULT_MTU;\n\n    // The lost packet is resent\n    pair.drive();\n    assert!(pair.client.outbound.is_empty());\n\n    let recv = pair.server_recv(server_ch, s);\n    let buf = stream_chunks(recv);\n\n    assert_eq!(buf, b\"hello world\".as_slice());\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_pop_none", "test": ["fn assert_engine_error<T>(r: engine_traits::Result<T>) {\n    match r {\n        Err(engine_traits::Error::Engine(_)) => {}\n        Err(e) => panic!(\"expected Error::Engine, got {:?}\", e),\n        Ok(_) => panic!(\"expected Error::Engine, got Ok\"),\n    }\n} [SEP] fn save_point_pop_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n}"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::two_case_switch", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn two_case_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            switch (a) {\n                case 5:\n                    a = 15;\n                    break;\n                case 10:\n                    a = 20;\n                    break;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_dir", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"DIR\");\n    ucmd.arg(\"DIR\")\n       .run()\n       .stderr_is(\"tail: error reading 'DIR': Is a directory\\n\")\n       .code_is(1);\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_column", "test": ["pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    } [SEP] fn test_with_column() {\n    let test_file_path = \"column.log\";\n    let expected_test_file_path = \"column.log.expected\";\n    for arg in [\"-3\", \"--column=3\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n           .args(&[\"--pages=3:5\", arg, \"-n\", test_file_path])\n           .succeeds()\n           .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple2_type", "test": ["fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    } [SEP] fn tuple2_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}_"]}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_misc", "test": ["pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.locations();\n        self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n            text: text,\n            locs: locs,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    } [SEP] fn capture_misc() {\n    let re = regex!(r\"(.)(?P<a>a)?(.)(?P<b>.)\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n\n    assert_eq!(5, cap.len());\n\n    assert_eq!((0, 3), { let m = cap.get(0).unwrap(); (m.start(), m.end()) });\n    assert_eq!(None, cap.get(2));\n    assert_eq!((2, 3), { let m = cap.get(4).unwrap(); (m.start(), m.end()) });\n\n    assert_eq!(t!(\"abc\"), match_text!(cap.get(0).unwrap()));\n    assert_eq!(None, cap.get(2));\n    assert_eq!(t!(\"c\"), match_text!(cap.get(4).unwrap()));\n\n    assert_eq!(None, cap.name(\"a\"));\n    assert_eq!(t!(\"c\"), match_text!(cap.name(\"b\").unwrap()));\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_msck", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_msck() {\n    let msck = r#\"MSCK REPAIR TABLE db.table_name ADD PARTITIONS\"#;\n    let msck2 = r#\"MSCK REPAIR TABLE db.table_name\"#;\n    hive().verified_stmt(msck);\n    hive().verified_stmt(msck2);\n}_"]}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_data_overflows_stream_window", "test": ["pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    } [SEP] async fn recv_data_overflows_stream_window() {\n    // this tests for when streams have smaller windows than their connection\n    h2_support::trace_init!();\n\n    let (io, mut srv) = mock::new();\n\n    let mock = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n               .request(\"GET\", \"https://http2.akamai.com/\")\n               .eos(),\n        )\n       .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        // fill the whole window\n        srv.send_frame(frames::data(1, vec![0u8; 16_384])).await;\n        // this frame overflows the window!\n        srv.send_frame(frames::data(1, &[0; 16][..]).eos()).await;\n        srv.recv_frame(frames::reset(1).flow_control()).await;\n    };\n\n    let h2 = async move {\n        let (mut client, conn) = client::Builder::new()\n           .initial_window_size(16_384)\n           .handshake::<_, Bytes>(io)\n           .await\n           .unwrap();\n        let request = Request::builder()\n           .method(Method::GET)\n           .uri(\"https://http2.akamai.com/\")\n           .body(())\n           .unwrap();\n\n        let req = async move {\n            let resp = client.send_request(request, true).unwrap().0.await.unwrap();\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let res = util::concat(\n"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse", "test": ["pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n       .items\n       .values()\n       .map(|item| introspect_item(item, &lookup))\n       .collect();\n\n    let tokens = lookup\n       .tokens\n       .into_iter()\n       .map(|(name, ty)| (ty, name))\n       .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n} [SEP] fn ident_parse() {\n    parse(\"String\").unwrap();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_no_create_file_absent", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_no_create_file_absent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_no_create_file_absent\";\n\n    ucmd.arg(\"-c\").arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_some_int_compares", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_some_int_compares() {\n    let scenario = TestScenario::new(util_name!());\n\n    let tests = [\n        [\"0\", \"-eq\", \"0\"],\n        [\"0\", \"-ne\", \"1\"],\n        [\"421\", \"-lt\", \"3720\"],\n        [\"0\", \"-le\", \"0\"],\n        [\"11\", \"-gt\", \"10\"],\n        [\"1024\", \"-ge\", \"512\"],\n        [\"9223372036854775806\", \"-le\", \"9223372036854775807\"],\n    ];\n\n    for test in &tests {\n        scenario.ucmd().args(&test[..]).succeeds();\n    }\n\n    // run the inverse of all these tests\n    for test in &tests {\n        scenario.ucmd().arg(\"!\").args(&test[..]).run().code_is(1);\n    }\n}\n"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::alias_table", "test": ["fn drop(&mut self) {\n            let data = mem::take(&mut self.data);\n            assert!(self\n               .buffer\n               .lock()\n               .unwrap()\n               .insert(self.page, Arc::new(data))\n               .is_none());\n        } [SEP] fn alias_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let table = write_txn.open_table(STR_TABLE).unwrap();\n    let result = write_txn.open_table(STR_TABLE);\n    assert!(matches!(\n        result.err().unwrap(),\n        TableError::TableAlreadyOpen(_, _)\n    ));\n    drop(table);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_hard_link", "test": ["pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    } [SEP] fn test_du_hard_link() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.hard_link(SUB_FILE, SUB_LINK);\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    // We do not double count hard links as the inodes are identical\n    _du_hard_link(result.stdout_str());\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_deps_no_indent", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::extended_connect_protocol_enabled_during_handshake", "test": ["pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val!= 0)\n    } [SEP] async fn extended_connect_protocol_enabled_during_handshake() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n           .send_frame(\n                frames::headers(1)\n                   .request(\"CONNECT\", \"http://bread/baguette\")\n                   .protocol(\"the-bread-protocol\"),\n            )\n           .await;\n\n        client.recv_frame(frames::headers(1).response(200)).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(\n            req.extensions().get::<crate::ext::Protocol>(),\n            Some(&crate::ext::Protocol::from_static(\"the-bread-protocol\"))\n        );\n\n        let rsp = Response::new(());\n        stream.send_response(rsp, false).unwrap();\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n           .await\n           .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/readme.rs::readme", "test": ["pub(crate) fn assert_success(output: &std::process::Output) {\n  if!output.status.success() {\n    eprintln!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n    eprintln!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n    panic!(\"{}\", output.status);\n  }\n} [SEP] fn readme() {\n  let mut justfiles = vec![];\n  let mut current = None;\n\n  for line in fs::read_to_string(\"README.md\").unwrap().lines() {\n    if let Some(mut justfile) = current {\n      if line == \"```\" {\n        justfiles.push(justfile);\n        current = None;\n      } else {\n        justfile += line;\n        justfile += \"\\n\";\n        current = Some(justfile);\n      }\n    } else if line == \"```just\" {\n      current = Some(String::new());\n    }\n  }\n\n  for justfile in justfiles {\n    let tmp = tempdir();\n\n    let path = tmp.path().join(\"justfile\");\n\n    fs::write(path, justfile).unwrap();\n\n    let output = Command::new(executable_path(\"just\"))\n     .current_dir(tmp.path())\n     .arg(\"--dump\")\n     .output()\n     .unwrap();\n\n    assert_success(&output);\n  }\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_destroy_uninitialized_peer_when_there_exists_old_peer", "test": ["pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    } [SEP] fn test_destroy_uninitialized_peer_when_there_exists_old_peer() {\n    // 4 stores cluster.\n    let mut cluster = new_node_cluster(0, 4);\n    cluster.cfg.raft_store.pd_store_heartbeat_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.hibernate_regions = false;\n\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // Now region 1 only has peer (1, 1);\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let epoch = pd_client.get_region_epoch(r1);\n\n    // Conf version must change.\n    assert!(epoch.get_conf_ver() > 2);\n\n    // Transfer leader to peer (2, 2).\n    cluster.must_transfer_leader(r1, new_peer(2, 2));\n\n    // Isolate node 1\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n\n    cluster.must_put(format!(\"k{}\", 2).as_bytes(), b\"v1\");\n\n    // Remove 3 and add 4\n    pd_client.must_add_peer(r1, new_learner_peer(4, 4));\n    _"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_delimited_identifiers", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_delimited_identifiers() {\n    // check that quoted identifiers in any position remain quoted after serialization\n    let select = clickhouse().verified_only_select(\n        r#\"SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"\"#,\n    );\n    // check FROM\n    match only(select.from).relation {\n        TableFactor::Table {\n            name,\n            alias,\n            args,\n            with_hints,\n            version,\n            partitions: _,\n        } => {\n            assert_eq!(vec![Ident::with_quote('\"', \"a table\")], name.0);\n            assert_eq!(Ident::with_quote('\"', \"alias\"), alias.unwrap().name);\n            assert!(args.is_none());\n            assert!(with_hints.is_empty());\n            assert!(version.is_none());\n        }\n        _ => panic!(\"Expecting TableFactor::Table\"),\n    }\n    // check SELECT\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::CompoundIdentifier(vec![\n            Ident::with_quote('\"', \"alias\"),\n            Ident::with_quote('\"', \"bar baz\"),\n        ]),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::with_quote('\"', \"myfun\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[1]),\n    );\n    match &select.projection[2] {\n        SelectItem_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_seq_wrong_arg", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_seq_wrong_arg() {\n    new_ucmd!().args(&[\"-w\", \"5\", \"10\", \"33\", \"32\"]).fails();\n}_"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_nan_test", "test": ["pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    } [SEP] fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_loop", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_realpath_loop() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.symlink_file(\"2\", \"1\");\n    at.symlink_file(\"3\", \"2\");\n    at.symlink_file(\"1\", \"3\");\n    ucmd.arg(\"1\")\n       .fails()\n       .stderr_contains(\"Too many levels of symbolic links\");\n}    "]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large_cli_limit", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n           .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir_req_verbose", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_install_dir_req_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"source_file1\";\n    at.touch(file_1);\n    scene\n       .ucmd()\n       .arg(\"-Dv\")\n       .arg(file_1)\n       .arg(\"sub3/a/b/c/file\")\n       .succeeds()\n       .stdout_contains(\"install: creating directory'sub3'\\ninstall: creating directory'sub3/a'\\ninstall: creating directory'sub3/a/b'\\ninstall: creating directory'sub3/a/b/c'\\n'source_file1' ->'sub3/a/b/c/file'\");\n\n    scene\n       .ucmd()\n       .arg(\"-t\")\n       .arg(\"sub4/a\")\n       .arg(\"-Dv\")\n       .arg(file_1)\n       .succeeds()\n       .stdout_contains(\"install: creating directory'sub4'\\ninstall: creating directory'sub4/a'\\n'source_file1' ->'sub4/a/source_file1'\");\n\n    at.mkdir(\"sub5\");\n    scene\n       .ucmd()\n       .arg(\"-Dv\")\n       .arg(file_1)\n       .arg(\"sub5/a/b/c/file\")\n       .succeeds()\n       .stdout_contains(\"install: creating directory'sub5/a'\\ninstall: creating directory'sub5/a/b'\\ninstall: creating directory'sub5/a/b/c'\\n'source_file1' ->"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_table_properties.rs::test_check_need_gc", "test": ["fn get(&self, _: &[u8]) -> Option<&[u8]> {\n        None\n    } [SEP] fn test_check_need_gc() {\n    GC_COMPACTION_FILTER_PERFORM.reset();\n    GC_COMPACTION_FILTER_SKIP.reset();\n\n    let mut cfg = DbConfig::default();\n    cfg.defaultcf.disable_auto_compactions = true;\n    cfg.defaultcf.dynamic_level_bytes = false;\n    let dir = tempfile::TempDir::new().unwrap();\n    let builder = TestEngineBuilder::new().path(dir.path());\n    let engine = builder\n       .api_version(ApiVersion::V2)\n       .build_with_cfg(&cfg)\n       .unwrap();\n    let raw_engine = engine.get_rocksdb();\n    let mut gc_runner = TestGcRunner::new(0);\n\n    do_write(&engine, false, 5);\n\n    // Check init value\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n           .with_label_values(&[STAT_RAW_KEYMODE])\n           .get(),\n        0\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n           .with_label_values(&[STAT_RAW_KEYMODE])\n           .get(),\n        0\n    );\n\n    // TEST 1: If ratio_threshold < 1.0 || context.is_bottommost_level() is true,\n    // check_need_gc return true, call dofilter\n    gc_runner\n       .safe_point(TimeStamp::max().into_inner())\n       .gc_raw(&raw_engine);\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n           .with_label_values(&[STAT_RAW_KEYMODE])\n           .get(),\n        1\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n           .with_label_values(&[STAT_RAW_KEYMODE])\n           .get(),\n        0\n    );\n\n    // TEST 2_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::reinscribe_with_flag", "test": ["pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  } [SEP] fn reinscribe_with_flag() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let inscribe = CommandBuilder::new(\"wallet inscribe --file tulip.png --fee-rate 5.0 \")\n   .write(\"tulip.png\", [1; 520])\n   .rpc_server(&rpc_server)\n   .run_and_deserialize_output::<Inscribe>();\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let txid = rpc_server.mine_blocks(1)[0].txdata[2].txid();\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[]);\n  let request = ord_server.request(format!(\"/content/{}\", inscribe.inscriptions[0].id));\n\n  assert_eq!(request.status(), 200);\n\n  let reinscribe = CommandBuilder::new(format!(\n    \"wallet inscribe --file orchid.png --fee-rate 1.1 --reinscribe --satpoint {txid}:0:0\"\n  ))\n .write(\"orchid.png\", [1; 520])\n .rpc_server(&rpc_server)\n .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[\"--index-sats\"]);\n  let request = ord_server.request(format!(\"/content/{}\", reinscribe.inscriptions[0].id));\n\n  assert_eq!(request.status(), 200);\n  ord_server.assert_response_regex(\n    format!(\"/sat/{}\", 50 *_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/os_attributes.rs::os", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_8", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn gfm_table_test_8() {\n    let original = r##\"| abc | def |\n| --- | --- |\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}("]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::object", "test": ["fn say_hello(this: &JsValue, _: &[JsValue], _: &mut Context<'_>) -> JsResult<JsValue> {\n        // We check if this is an object.\n        if let Some(object) = this.as_object() {\n            // If it is we downcast the type to type `Person`.\n            if let Some(person) = object.downcast_ref::<Person>() {\n                // and print a message to stdout.\n                println!(\n                    \"Hello my name is {}, I'm {} years old\",\n                    person.name.to_std_string_escaped(),\n                    person.age // Here we can access the native rust fields of the struct.\n                );\n                return Ok(JsValue::undefined());\n            }\n        }\n        // If `this` was not an object or the type of `this` was not a native object `Person`,\n        // we throw a `TypeError`.\n        Err(JsNativeError::typ()\n           .with_message(\"'this' is not a Person object\")\n           .into())\n    } [SEP] fn object() {\n    test_formatting(\n        r#\"\n        let other = {\n            c: 10,\n        };\n        let inst = {\n            val: 5,\n            b: \"hello world\",\n            nested: {\n                a: 5,\n                b: 6,\n            },\n           ...other,\n            say_hi: function() {\n                console.log(\"hello!\");\n            },\n            get a() {\n                return this.val + 1;\n            },\n            set a(new_value) {\n                this.val = new_value;\n            },\n            say_hello(msg) {\n                console.log(\"hello \" + msg);\n            },\n        };\n        inst.a = 20;\n        inst.a;\n        inst.say_hello(\"humans\");\n        \"#,\n    );\n}\ufffd"]}
{"test_id": "casey-just/casey-just-af55be3/tests/parser.rs::dont_run_duplicate_recipes", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/240_array_pretty.rs::small_array", "test": ["pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T:?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    } [SEP] fn small_array() {\n    let arr = &[(), (), ()][..];\n    assert_eq!(\n        to_string_pretty(&arr, PrettyConfig::new().new_line(\"\\n\".to_string())).unwrap(),\n        \"[\n    (),\n    (),\n    (),\n]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n               .new_line(\"\\n\".to_string())\n               .compact_arrays(true)\n        )\n       .unwrap(),\n        \"[(), (), ()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n               .new_line(\"\\n\".to_string())\n               .compact_arrays(true)\n               .separator(\"\".to_string())\n        )\n       .unwrap(),\n        \"[(),(),()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &vec![(1, 2), (3, 4)],\n            PrettyConfig::new()\n               .new_line(\"\\n\".to_string())\n               .separate_tuple_members(true)\n               .compact_arrays(true)\n        )\n       .unwrap(),\n        \"[(\n    1,\n    2,\n), (\n    3,\n    4,\n)]\"\n    );\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::trailing_spaces_after_include_are_ignored", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_no_file", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_no_file() {\n    let temp = env::temp_dir();\n    let tmpdir = Path::new(&temp);\n    let file = tmpdir.join(\"}surely'none'would'thus'a'file'name\"); // spell-checker:disable-line\n\n    new_ucmd!().arg(file.as_os_str()).fails();\n}_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_unknown", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn fs_error_unknown() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert_error(PathBuf::from(\"prefix/ci.js\"), ErrorEntry::UnknownFileType);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), (\"prefix\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_unknown\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_var_read_write", "test": ["fn test() {\n    use crate::tester::Tester;\n\n    let pass = vec![\n        (\"console.log(\\\"abc\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def\\\");\", None),\n        (\"console.log('abc', \\\"def\\\");\", None),\n        (\"console.log(`abc`, \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\\t\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\\n\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"  abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\" abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def \\\");\", None),\n        (\"console.log();\", None),\n        (\"console.log(\\\"\\\");\", None),\n        (\"console.log(123);\", None),\n        (\"console.log(null);\", None),\n        (\"console.log(undefined);\", None),\n        (\"console.dir(\\\"abc \\\");\", None),\n        (\"new console.log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.error(\\\" a \\\", \\\" b \\\");\", None),\n        (\"log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"error(\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[log](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[debug](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[info](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[warn](\\\" a \\\", \\\" b \\"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_priority", "test": ["pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n} [SEP] fn test_priority() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    let state_cnt = Arc::new(AtomicUsize::new(0));\n    router\n       .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                r.register(1, BasicMailbox::new(tx, runner, state_cnt.clone()));\n                let (tx2, mut runner2) = Runner::new(10);\n                runner2.set_priority(Priority::Low);\n                r.register(2, BasicMailbox::new(tx2, runner2, state_cnt));\n                tx_.send(1).unwrap();\n            },\n        )))\n       .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n\n    let tx_ = tx.clone();\n    router\n       .send(\n            1,\n            Message::Callback(Box::new(move |h: &Handler, r: &mut Runner| {\n                assert_eq!(h.get_priority(), Priority::Normal);\n                assert_eq!(h.get_priority(), r.get_priority());\n                tx_.send(2).unwrap();\n            })),\n        )\n       .unwrap();\n    assert_eq!(rx._"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::checked_math", "test": ["pub fn checked_add(self, offset: TextSize) -> Option<TextRange> {\n        Some(TextRange {\n            start: self.start.checked_add(offset)?,\n            end: self.end.checked_add(offset)?,\n        })\n    } [SEP] fn checked_math() {\n    assert_eq!(size(1).checked_add(size(1)), Some(size(2)));\n    assert_eq!(size(1).checked_sub(size(1)), Some(size(0)));\n    assert_eq!(size(1).checked_sub(size(2)), None);\n    assert_eq!(size(!0).checked_add(size(1)), None);\n}_"]}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_map", "test": ["fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n} [SEP] fn test_map() {\n    let mut thing = BTreeMap::new();\n    thing.insert(\"x\".to_owned(), 1);\n    thing.insert(\"y\".to_owned(), 2);\n    let yaml = indoc! {\"\n        x: 1\n        y: 2\n    \"};\n    test_serde(&thing, yaml);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_negative_zero_scientific_notation", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_width_negative_zero_scientific_notation() {\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e0\", \"1\"])\n       .succeeds()\n       .stdout_is(\"-0\\n01\\n\")\n       .no_stderr();\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e0\", \"1\", \"2\"])\n       .succeeds()\n       .stdout_is(\"-0\\n01\\n02\\n\")\n       .no_stderr();\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e0\", \"1\", \"2.0\"])\n       .succeeds()\n       .stdout_is(\"-0\\n01\\n02\\n\")\n       .no_stderr();\n\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e+1\", \"1\"])\n       .succeeds()\n       .stdout_is(\"-00\\n001\\n\")\n       .no_stderr();\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e+1\", \"1\", \"2\"])\n       .succeeds()\n       .stdout_is(\"-00\\n001\\n002\\n\")\n       .no_stderr();\n    new_ucmd!()\n       .args(&[\"-w\", \"-0e+1\", \"1\", \"2.0\"])\n       .succeeds()\n       .stdout_is(\"-00\\n001\\n002\\n\")\n       .no_stderr();\n\n    new_ucmd!()\n       .args(&[\"-w\", \"-0.000e0\", \"1\"])\n       .succeeds()\n       ."]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::insert_reserve", "test": ["fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> &'a [u8]\n    where\n        Self: 'a,\n        Self: 'b,\n    {\n        &value.data\n    } [SEP] fn insert_reserve() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let def: TableDefinition<&str, &[u8]> = TableDefinition::new(\"x\");\n    let value = \"world\";\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(def).unwrap();\n        let mut reserved = table\n           .insert_reserve(\"hello\", value.len().try_into().unwrap())\n           .unwrap();\n        reserved.as_mut().copy_from_slice(value.as_bytes());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(def).unwrap();\n    assert_eq!(\n        value.as_bytes(),\n        table.get(\"hello\").unwrap().unwrap().value()\n    );\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_old_value_cache_without_downstreams", "test": ["pub fn recv(&mut self, peer_msg_buf: &mut Vec<PeerMsg>, batch_size: usize) -> usize {\n        let l = peer_msg_buf.len();\n        for i in l..batch_size {\n            match self.receiver.try_recv() {\n                Ok(msg) => peer_msg_buf.push(msg),\n                Err(e) => {\n                    if let TryRecvError::Disconnected = e {\n                        self.is_stopped = true;\n                    }\n                    return i - l;\n                }\n            }\n        }\n        batch_size - l\n    } [SEP] fn test_old_value_cache_without_downstreams() {\n    fn check_old_value_cache(scheduler: &Scheduler<Task>, updates: usize) {\n        let (tx, rx) = mpsc::sync_channel(1);\n        let checker = move |c: &OldValueCache| tx.send(c.update_count()).unwrap();\n        scheduler\n           .schedule(Task::Validate(Validate::OldValueCache(Box::new(checker))))\n           .unwrap();\n        assert_eq!(rx.recv().unwrap(), updates);\n    }\n\n    let mutation = || {\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.key = b\"key\".to_vec();\n        mutation.value = b\"value\".to_vec();\n        mutation\n    };\n\n    fail::cfg(\"cdc_flush_old_value_metrics\", \"return\").unwrap();\n\n    let cluster = new_server_cluster(0, 1);\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let scheduler = suite.endpoints[&1].scheduler();\n\n    // Add a subscription and then check old value cache.\n    let (mut req_tx, event_feed, receive_event) = new_event_feed(suite.get_region_cdc_client(1));\n    let req = suite.new_changedata_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::quote_properties_parse_errors_letter_case", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn quote_properties_parse_errors_letter_case() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--quote-properties\"),\n                (\"As-needed\"),\n                (\"file.js\"),\n            ]\n           .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"quote_properties_parse_errors_letter_case\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_to_key_then_forward_snapshot", "test": ["fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    } [SEP] fn seek_to_key_then_forward_snapshot() {\n    let db = default_engine();\n    seek_to_key_then_forward(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}ust"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::custom_ordering", "test": ["fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    } [SEP] fn custom_ordering() {\n    #[derive(Debug)]\n    struct ReverseKey(Vec<u8>);\n\n    impl RedbValue for ReverseKey {\n        type SelfType<'a> = ReverseKey\n        where\n        Self: 'a;\n        type AsBytes<'a> = &'a [u8]\n        where\n        Self: 'a;\n\n        fn fixed_width() -> Option<usize> {\n            None\n        }\n\n        fn from_bytes<'a>(data: &'a [u8]) -> ReverseKey\n        where\n            Self: 'a,\n        {\n            ReverseKey(data.to_vec())\n        }\n\n        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> &'a [u8]\n        where\n            Self: 'a,\n            Self: 'b,\n        {\n            &value.0\n        }\n\n        fn type_name() -> TypeName {\n            TypeName::new(\"test::ReverseKey\")\n        }\n    }\n\n    impl RedbKey for ReverseKey {\n        fn compare(data1: &[u8], data2: &[u8]) -> Ordering {\n            data2.cmp(data1)\n        }\n    }\n\n    let definition: TableDefinition<ReverseKey, &str> = TableDefinition::new(\"x\");\n\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in 0..10u8 {\n            let key = vec![i];\n            table.insert(&ReverseKey(key), \"value\").unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table =_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::property_accessor_member_expression_bracket_notation_on_string_literal", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn property_accessor_member_expression_bracket_notation_on_string_literal() {\n    run_test_actions([TestAction::assert_eq(\n        \"typeof 'asd'['matchAll']\",\n        \"function\",\n    )]);\n}"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_with_options", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_create_table_with_options() {\n    let sql = \"CREATE TABLE t (c INT) WITH (foo = 'bar', a = 123)\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { with_options,.. } => {\n            assert_eq!(\n                vec![\n                    SqlOption {\n                        name: \"foo\".into(),\n                        value: Value::SingleQuotedString(\"bar\".into()),\n                    },\n                    SqlOption {\n                        name: \"a\".into(),\n                        value: number(\"123\"),\n                    },\n                ],\n                with_options\n            );\n        }\n        _ => unreachable!(),\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_file_and_links_strip_zero", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_realpath_file_and_links_strip_zero() {\n    let strip_args = [\"-s\", \"--strip\", \"--no-symlinks\"];\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    for strip_arg in strip_args {\n        scene\n           .ucmd()\n           .arg(\"foo\")\n           .arg(strip_arg)\n           .arg(\"-z\")\n           .succeeds()\n           .stdout_contains(\"foo\\u{0}\");\n\n        scene\n           .ucmd()\n           .arg(\"bar\")\n           .arg(strip_arg)\n           .arg(\"-z\")\n           .succeeds()\n           .stdout_contains(\"bar\\u{0}\");\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_worker.rs::test_orphan_versions_from_compaction_filter", "test": ["fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    } [SEP] fn test_orphan_versions_from_compaction_filter() {\n    let (cluster, leader, ctx) = must_new_and_configure_cluster(|cluster| {\n        cluster.cfg.gc.enable_compaction_filter = true;\n        cluster.cfg.gc.compaction_filter_skip_version_check = true;\n        cluster.pd_client.disable_default_operator();\n    });\n\n    let env = Arc::new(Environment::new(1));\n    let leader_store = leader.get_store_id();\n    let channel = ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader_store));\n    let client = TikvClient::new(channel);\n\n    init_compaction_filter(&cluster, leader_store);\n    let engine = cluster.engines.get(&leader_store).unwrap();\n\n    let pk = b\"k1\".to_vec();\n    let large_value = vec![b'x'; 300];\n    for &start_ts in &[10, 20, 30, 40] {\n        let commit_ts = start_ts + 5;\n        let op = if start_ts < 40 { Op::Put } else { Op::Del };\n        let muts = vec![new_mutation(op, b\"k1\", &large_value)];\n        must_kv_prewrite(&client, ctx.clone(), muts, pk.clone(), start_ts);\n        let keys = vec![pk.clone()];\n        must_kv_commit(&client, ctx.clone(), keys, start_ts, commit_ts, commit_ts);\n        if start_ts < 40 {\n            let key = Key::from_raw(b\"k1\").append_ts(start_ts.into());\n            let key = data_key(key.as_encoded());\n            assert!(engine.kv.get_value(&key_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_mtime", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_only_mtime() {\n    let mtime_args = [\"-m\", \"--time=modify\", \"--time=mtime\"];\n    let file = \"test_touch_set_only_mtime\";\n\n    for mtime_arg in mtime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", mtime_arg, file])\n           .succeeds()\n           .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime!= mtime);\n        assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_empty_directory_no_parents", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_rmdir_empty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n\n    ucmd.arg(DIR).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(DIR));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_deadline_3", "test": ["pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    } [SEP] fn test_deadline_3() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = {\n        let engine = tikv::storage::TestEngineBuilder::new().build().unwrap();\n        let cfg = tikv::server::Config {\n            end_point_request_max_handle_duration: tikv_util::config::ReadableDuration::secs(1),\n           ..Default::default()\n        };\n        init_data_with_details(Context::default(), engine, &product, &data, true, &cfg)\n    };\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"kv_cursor_seek\", \"sleep(2000)\").unwrap();\n    fail::cfg(\"copr_batch_initial_size\", \"return(1)\").unwrap();\n    let cop_resp = handle_request(&endpoint, req);\n    let mut resp = SelectResponse::default();\n    resp.merge_from_bytes(cop_resp.get_data()).unwrap();\n\n    assert!(\n        cop_resp.other_error.contains(\"exceeding the deadline\")\n            || resp\n               .get_error()\n               .get_msg()\n               .contains(\"exceeding the deadline\")\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_tab_counts_as_one_byte", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tab_counts_as_one_byte() {\n    new_ucmd!()\n       .args(&[\"-w2\", \"-b\"])\n       .pipe_in(\"1\\t2\\n\")\n       .succeeds()\n       .stdout_is(\"1\\t\\n2\\n\");\n}    "]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_does_not_organize_imports_via_cli", "test": ["pub fn assert_cli_snapshot(payload: SnapshotPayload<'_>) {\n    let module_path = payload.module_path.to_owned();\n    let test_name = payload.test_name;\n    let cli_snapshot = CliSnapshot::from(payload);\n\n    let content = cli_snapshot.emit_content_snapshot();\n\n    let module_path = module_path.replace(\"::\", \"_\");\n    let snapshot_path = PathBuf::from(\"snapshots\").join(module_path);\n\n    insta::with_settings!({\n        prepend_module_to_snapshot => false,\n        snapshot_path => snapshot_path\n    }, {\n        insta::assert_snapshot!(test_name, content);\n\n    });\n} [SEP] fn ci_does_not_organize_imports_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"file.js\");\n\n    let content = r#\"import { lorem, foom, bar } from \"foo\";\nimport * as something from \"../something\";\n\"#;\n    fs.insert(file_path.into(), content.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--organize-imports-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n           .as_slice(),\n        ),\n    );\n\n    // assert!(result.is_ok(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n       .open(file_path)\n       .expect(\"formatting target file was removed by the CLI\");\n\n    let mut received = String::new();\n    file.read_to_string(&mut received)\n       .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(received, content);\n\n    drop(file);\n    assert_cli_snapshot"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_on_learner", "test": ["fn to_vec(&self) -> Vec<Option<Enum>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            if let Some(value) = self.values.get_option_ref(i) {\n                let name = self.names.get(i).unwrap().to_vec();\n                x.push(Some(Enum::new(name, *value as u64)));\n            } else {\n                x.push(None);\n            }\n        }\n        x\n    } [SEP] fn test_stale_read_on_learner() {\n    let (cluster, pd_client, leader_client) = prepare_for_stale_read(new_peer(1, 1));\n\n    // Write `(key1, value1)`\n    leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Replace peer 2 with learner\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    pd_client.must_add_peer(1, new_learner_peer(2, 4));\n    let mut learner_client2 = PeerClient::new(&cluster, 1, new_learner_peer(2, 4));\n    learner_client2.ctx.set_stale_read(true);\n\n    // We can read on the learner with the newst ts\n    learner_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_role", "test": ["pub fn assert_eq_vec<T: ToString>(expected: &[&str], actual: &[T]) {\n    assert_eq!(\n        expected,\n        actual.iter().map(ToString::to_string).collect::<Vec<_>>()\n    );\n} [SEP] fn parse_create_role() {\n    let sql = \"CREATE ROLE consultant\";\n    match verified_stmt(sql) {\n        Statement::CreateRole { names,.. } => {\n            assert_eq_vec(&[\"consultant\"], &names);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"CREATE ROLE IF NOT EXISTS mysql_a, mysql_b\";\n    match verified_stmt(sql) {\n        Statement::CreateRole {\n            names,\n            if_not_exists,\n           ..\n        } => {\n            assert_eq_vec(&[\"mysql_a\", \"mysql_b\"], &names);\n            assert!(if_not_exists);\n        }\n        _ => unreachable!(),\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_decimal_scientific_notation_increment", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_width_decimal_scientific_notation_increment() {\n    new_ucmd!()\n       .args(&[\"-w\", \".1\", \"1e-2\", \".11\"])\n       .succeeds()\n       .stdout_is(\"0.10\\n0.11\\n\")\n       .no_stderr();\n\n    new_ucmd!()\n       .args(&[\"-w\", \".0\", \"1.500e-1\", \".2\"])\n       .succeeds()\n       .stdout_is(\"0.0000\\n0.1500\\n\")\n       .no_stderr();\n}_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large_cli_limit", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n           .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_flattening_sub_item_shielded_print", "test": ["pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n               .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n               .unwrap_or_else(|| context!());\n            slf.inner\n               .lock()\n               .unwrap()\n               .env\n               .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n               .map_err(to_py_error)\n        })\n    } [SEP] fn test_flattening_sub_item_shielded_print() {\n    let bad = Bad {\n        a: 42,\n        more: Value::from(BTreeMap::from([(\"b\", 23)])),\n    };\n\n    let ctx = context!(good => context!(bad));\n    let env = Environment::new();\n\n    // this on the other hand is okay\n    let value = env.render_str(\"{{ good }}\", ctx).unwrap();\n    assert_eq!(\n        value,\n        r#\"{\"bad\": <invalid value: can only flatten structs and maps (got an enum)>}\"#\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_directory", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_trailing_slash_directory() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"directory\");\n    for query in [\"./directory\", \"./directory/\"] {\n        scene\n           .ucmd()\n           .args(&[\"-e\", query])\n           .succeeds()\n           .stdout_contains(\"directory\");\n    }\n}\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/cf_names.rs::cf_names", "test": ["fn cf_names(&self, _region_id: u64) -> Vec<String> {\n        engine_traits::DATA_CFS\n           .iter()\n           .map(|s| s.to_string())\n           .collect()\n    } [SEP] fn cf_names() {\n    let db = engine_cfs(ALL_CFS);\n    let names = db.engine.cf_names();\n    assert_eq!(names.len(), ALL_CFS.len());\n    for cf in ALL_CFS {\n        assert!(names.contains(cf));\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_file_symlink_after_non_existing_file", "test": ["pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    } [SEP] fn test_chmod_file_symlink_after_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let existing = \"file\";\n    let test_existing_symlink = \"file_symlink\";\n\n    let non_existing = \"test_chmod_symlink_non_existing_file\";\n    let test_dangling_symlink = \"test_chmod_symlink_non_existing_file_symlink\";\n    let expected_stdout = &format!(\n        \"failed to change mode of '{test_dangling_symlink}' from 0000 (---------) to 1500 (r-x-----T)\"\n    );\n    let expected_stderr = &format!(\"cannot operate on dangling symlink '{test_dangling_symlink}'\");\n\n    at.touch(existing);\n    set_permissions(at.plus(existing), Permissions::from_mode(0o664)).unwrap();\n    at.symlink_file(non_existing, test_dangling_symlink);\n    at.symlink_file(existing, test_existing_symlink);\n\n    // this cannot succeed since the symbolic link dangles\n    // but the metadata for the existing target should change\n    scene\n       .ucmd()\n       .arg(\"u+x\")\n       .arg(\"-v\")\n       .arg(test_dangling_symlink)\n       .arg(test_existing_symlink)\n       .fails()\n       .code_is(1)\n       .stdout_contains(expected_stdout)\n       .stderr_contains(expected_stderr);\n    assert_eq!(\n        at.metadata(test_existing_symlink).permissions().mode(),\n        0o100_764\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_quoting", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_quoting() {\n    new_ucmd!()\n       .pipe_in(\"exec 'echo Hello;:'\\n\")\n       .args(&[\"-b\", \"-\"])\n       .succeeds()\n       .stdout_is(\"LS_COLORS='ex='\\\\''echo Hello;\\\\:'\\\\'':';\\nexport LS_COLORS\\n\")\n       .no_stderr();\n}    "]}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/test_default.rs::disallow_non_utf8", "test": ["pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    } [SEP] fn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)\u2603\").is_err());\n}\n\n    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_too_few_xs_suffix_directory", "test": ["pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    } [SEP] fn test_too_few_xs_suffix_directory() {\n    new_ucmd!()\n       .args(&[\"-d\", \"--suffix=X\", \"aXX\"])\n       .fails()\n       .stderr_only(\"mktemp: too few X's in template 'aXXX'\\n\");\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::break_out_of_inner_loop", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn break_out_of_inner_loop() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var a = 0, b = 0;\n                for (let i = 0; i < 2; i++) {\n                    a++;\n                    for (let j = 0; j < 10; j++) {\n                        b++;\n                        if (j == 3)\n                            break;\n                    }\n                    a++;\n                }\n            \"#}),\n        TestAction::assert_eq(\"a\", 4),\n        TestAction::assert_eq(\"b\", 8),\n    ]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(125);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_yes.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_combined_file_set", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_combined_file_set() {\n    let out = new_ucmd!()\n       .arg(\"-f\")\n       .arg(\"vars.conf.txt\")\n       .arg(\"FOO=bar.alt\")\n       .run()\n       .stdout_move_str();\n\n    assert_eq!(out.lines().filter(|&line| line == \"FOO=bar.alt\").count(), 1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_resolve", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_resolve() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    scene.ucmd().arg(\"bar\").succeeds().stdout_contains(\"foo\\n\");\n}    "]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow10_test", "test": ["pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if!is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n} [SEP] fn u16_pow10_test() {\n    let values: &[u16] = &[\n        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001, 10005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_as_bytes", "test": ["pub fn as_bytes(&self) -> Option<&[u8]> {\n        match &self.0 {\n            ValueRepr::String(ref s, _) => Some(s.as_bytes()),\n            ValueRepr::Bytes(ref b) => Some(&b[..]),\n            _ => None,\n        }\n    } [SEP] fn test_value_as_bytes() {\n    assert_eq!(Value::from(\"foo\").as_bytes(), Some(&b\"foo\"[..]));\n    assert_eq!(Value::from(&b\"foo\"[..]).as_bytes(), Some(&b\"foo\"[..]));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_incompatible_version", "test": ["fn to_string(&self) -> String {\n        let (mut buf, word_start_idx, int_len, int_cnt, frac_cnt) = self.prepare_buf();\n        if self.negative {\n            buf.push(b'-');\n        }\n        let padding = int_len - cmp::max(int_cnt, 1);\n        buf.resize(padding as usize + buf.len(), b'0');\n        if int_cnt > 0 {\n            let base_idx = buf.len();\n            let mut idx = base_idx + int_cnt as usize;\n            let mut widx = word_start_idx + word_cnt!(int_cnt) as usize;\n            buf.resize(idx, 0);\n            while idx > base_idx {\n                widx -= 1;\n                let mut x = self.word_buf[widx];\n                for _ in 0..cmp::min((idx - base_idx) as u8, DIGITS_PER_WORD) {\n                    idx -= 1;\n                    buf[idx] = b'0' + (x % 10) as u8;\n                    x /= 10;\n                }\n            }\n        } else {\n            buf.push(b'0');\n        };\n        if frac_cnt > 0 {\n            buf.push(b'.');\n            let mut widx = word_start_idx + word_cnt!(int_cnt) as usize;\n            let exp_idx = buf.len() + frac_cnt as usize;\n            while buf.len() < exp_idx {\n                let mut x = self.word_buf[widx];\n                for _ in 0..cmp::min((exp_idx - buf.len()) as u8, DIGITS_PER_WORD) {\n                    buf.push((x / DIG_MASK) as u8 + b'0');\n                    x = (x % DIG_MASK) * 10;\n                }\n                widx += 1;\n            }\n            while buf.capacity()!= buf.("]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_dynamic", "test": ["pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    } [SEP] fn test_dynamic() {\n    let mut env = Environment::new();\n    let template = String::from(\"Hello World 2!\");\n    env.add_template_owned(\"hello2\", template).unwrap();\n    env.set_loader(|name| match name {\n        \"hello\" => Ok(Some(\"Hello World!\".into())),\n        _ => Ok(None),\n    });\n    let t = env.get_template(\"hello\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World!\");\n    let t = env.get_template(\"hello2\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World 2!\");\n    let err = env.get_template(\"missing\").unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"template not found: template \\\"missing\\\" does not exist\"\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_off", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_off() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"--backup=off\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/byte_order_mark.rs::ignore_leading_byte_order_mark", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nothing_is_empty", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_nothing_is_empty() {\n    // -z is a literal here and has nonzero length\n    new_ucmd!().arg(\"-z\").succeeds();\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_macro_default_arg_value", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn invalid_macro_default_arg_value() {\n    assert_err_msg(\n        r#\"\n{% macro input(label=something) %}\n{% endmacro input %}\n    \"#,\n        &[\"2:22\", \"expected an integer, a float, a string, or `true` or `false`\"],\n    );\n}"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_2", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn footnotes_test_2() {\n    let original = r##\"> This is the song that never ends.\\\n> Yes it goes on and on my friends.[^lambchops]\n>\n> [^lambchops]: <https://www.youtube.com/watch?v=0U2zJOryHKQ>\n\"##;\n    let expected = r##\"<blockquote>\n<p>This is the song that never ends.<br />\nYes it goes on and on my friends.<sup class=\"footnote-reference\"><a href=\"#lambchops\">1</a></sup></p>\n<div class=\"footnote-definition\" id=\"lambchops\"><sup class=\"footnote-definition-label\">1</sup>\n<p><a href=\"https://www.youtube.com/watch?v=0U2zJOryHKQ\">https://www.youtube.com/watch?v=0U2zJOryHKQ</a></p>\n</div>\n</blockquote>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}("]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_unsupported", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn datagram_unsupported() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: None,\n           ..TransportConfig::default()\n        }),\n       ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), None);\n\n    match pair.client_datagrams(client_ch).send(Bytes::new()) {\n        Err(SendDatagramError::UnsupportedByPe_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_with_dir_as_target", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_mv_interactive_with_dir_as_target() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file = \"test_mv_interactive_file\";\n    let target_dir = \"target\";\n\n    at.mkdir(target_dir);\n    at.touch(file);\n    at.touch(format!(\"{target_dir}/{file}\"));\n\n    ucmd.arg(file)\n       .arg(target_dir)\n       .arg(\"-i\")\n       .pipe_in(\"n\")\n       .fails()\n       .stderr_does_not_contain(\"cannot move\")\n       .no_stdout();\n}_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::regtest_has_no_content_size_limit", "test": ["pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  } [SEP] fn regtest_has_no_content_size_limit() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n   .network(Network::Regtest)\n   .build();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"--chain regtest wallet inscribe --file degenerate.png --fee-rate 1\")\n   .write(\"degenerate.png\", [1; 1025])\n   .rpc_server(&rpc_server)\n   .stdout_regex(\".*\")\n   .run_and_extract_stdout();\n}_"]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::insert_all_std_headers", "test": ["pub fn as_str(&self) -> &str {\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        { &CODE_DIGITS[offset..offset+3] }\n\n        #[cfg(not(debug_assertions))]\n        unsafe { CODE_DIGITS.get_unchecked(offset..offset+3) }\n    } [SEP] fn insert_all_std_headers() {\n    let mut m = HeaderMap::new();\n\n    for (i, hdr) in STD.iter().enumerate() {\n        m.insert(hdr.clone(), hdr.as_str().parse().unwrap());\n\n        for j in 0..(i + 1) {\n            assert_eq!(m[&STD[j]], STD[j].as_str());\n        }\n\n        if i!= 0 {\n            for j in (i + 1)..STD.len() {\n                assert!(\n                    m.get(&STD[j]).is_none(),\n                    \"contained {}; j={}\",\n                    STD[j].as_str(),\n                    j\n                );\n            }\n        }\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_simple_backup", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_symlink_simple_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_simple_backup\";\n    let link = \"test_symlink_simple_backup_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-b\", \"-s\", file, link]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}_"]}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_specifics_default", "test": ["pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    } [SEP] fn check_specifics_default() {\n    let mut engine = get_blocker_engine_default([\n        \"@@||www.google.*/aclk?$first-party\",\n        \"@@||www.googleadservices.*/aclk?$first-party\",\n    ]);\n    {\n        let request = Request::new(\"https://www.youtube.com/youtubei/v1/log_event?alt=json&key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\", \"\", \"\").unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, true);\n    }\n    {\n        let request = Request::new(\n            \"https://www.google.com/aclk?sa=l&ai=DChcSEwioqMfq5ovjAhVvte0KHXBYDKoYABAJGgJkZw&sig=AOD64_0IL5OYOIkZA7qWOBt0yRmKL4hKJw&ctype=5&q=&ved=0ahUKEwjQ88Hq5ovjAhXYiVwKHWAgB5gQww8IXg&adurl=\",\n            \"https://www.google.com/aclk?sa=l&ai=DChcSEwioqMfq5ovjAhVvte0KHXBYDKoYABAJGgJkZw&sig=AOD64_0IL5OYOIkZA7qWOBt0yRmKL4hKJw&ctype=5&q=&ved=0ahUKEwjQ88Hq5ovjAhXYiVwKHWAgB5gQww8IXg&adurl=\",\n            \"main_frame\",\n        ).unwrap();\n        let checked = engine.check_network_request(&_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_atime", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_only_atime() {\n    let atime_args = [\"-a\", \"--time=access\", \"--time=atime\", \"--time=use\"];\n    let file = \"test_touch_set_only_atime\";\n\n    for atime_arg in atime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", atime_arg, file])\n           .succeeds()\n           .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime!= mtime);\n        assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_seek_region", "test": ["pub fn stop(&mut self) {\n        self.handle.stop_observing();\n    } [SEP] fn test_region_collection_seek_region() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n       .sim\n       .wl()\n       .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        // Test traverse all regions\n        let key = b\"\".to_vec();\n        let (tx, rx) = channel();\n        let tx_ = tx.clone();\n        engine\n           .seek_region(\n                &key,\n                Box::new(move |infos| {\n                    tx_.send(infos.map(|i| i.region.clone()).collect()).unwrap();\n                }),\n            )\n           .unwrap();\n        let sought_regions: Vec<_> = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(sought_regions, regions);\n\n        // Test end_key is exclusive\n        let (tx, rx) = channel();\n        let tx_ = tx.clone();\n        engine\n           .seek_region(\n                b\"k1\",\n                Box::new(move |infos| tx_.send(infos.next().unwrap().region.clone()).unwrap()),\n            )\n           .unwrap();\n        let region = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(region_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/unstable.rs::set_unstable_false_with_env_var", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::round_nearest_tie_even_test", "test": ["pub(crate) fn round_nearest_tie_even(fp: &mut ExtendedFloat, shift: i32) {\n    let (is_above, is_halfway) = round_nearest(fp, shift);\n    tie_even(fp, is_above, is_halfway);\n} [SEP] fn round_nearest_tie_even_test() {\n    // Check round-up, halfway\n    let mut fp = ExtendedFloat { mant: 0x60, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 2);\n\n    // Check round-down, halfway\n    let mut fp = ExtendedFloat { mant: 0x20, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 0);\n\n    // Check round-up, above halfway\n    let mut fp = ExtendedFloat { mant: 0x61, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 2);\n\n    let mut fp = ExtendedFloat { mant: 0x21, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    // Check round-down, below halfway\n    let mut fp = ExtendedFloat { mant: 0x5F, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    let mut fp = ExtendedFloat { mant: 0x1F, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 0);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_negative_interval", "test": ["pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    } [SEP] fn test_negative_interval() {\n    new_ucmd!()\n       .args(&[\"--\", \"-1\", \"sleep\", \"0\"])\n       .fails()\n       .usage_error(\"invalid time interval '-1'\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_paging_scan", "test": ["async fn handle_request(&mut self) -> Result<MemoryTraceGuard<Response>> {\n        let ret = match self.req.get_tp() {\n            AnalyzeType::TypeIndex | AnalyzeType::TypeCommonHandle => {\n                let req = self.req.take_idx_req();\n                let ranges = std::mem::take(&mut self.ranges);\n                table::check_table_ranges::<F>(&ranges)?;\n                let mut scanner = RangesScanner::<_, F>::new(RangesScannerOptions {\n                    storage: self.storage.take().unwrap(),\n                    ranges: ranges\n                       .into_iter()\n                       .map(|r| Range::from_pb_range(r, false))\n                       .collect(),\n                    scan_backward_in_range: false,\n                    is_key_only: true,\n                    is_scanned_range_aware: false,\n                });\n                let res = AnalyzeContext::handle_index(\n                    req,\n                    &mut scanner,\n                    self.req.get_tp() == AnalyzeType::TypeCommonHandle,\n                )\n               .await;\n                scanner.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeColumn => {\n                let col_req = self.req.take_col_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n                let mut builder = SampleBuilder::<_, F>::new(col_req, None, storage, ranges)?;\n                let res = AnalyzeContext::handle_column(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            // Type mixed is analyze common handle and columns by scan table rows once.\n            AnalyzeType::TypeMixed => {\n                let col_req = self.req.take_col_req();\n                let idx_req = self.req.take_idx_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_delete_lock_proposed_before_proposing_locks", "test": ["pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    } [SEP] fn test_delete_lock_proposed_before_proposing_locks() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    txn_ext\n       .pessimistic_locks\n       .write()\n       .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 20.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n       .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = Tikv_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_before_propose_deadline", "test": ["pub fn recv(&mut self, peer_msg_buf: &mut Vec<PeerMsg>, batch_size: usize) -> usize {\n        let l = peer_msg_buf.len();\n        for i in l..batch_size {\n            match self.receiver.try_recv() {\n                Ok(msg) => peer_msg_buf.push(msg),\n                Err(e) => {\n                    if let TryRecvError::Disconnected = e {\n                        self.is_stopped = true;\n                    }\n                    return i - l;\n                }\n            }\n        }\n        batch_size - l\n    } [SEP] fn test_before_propose_deadline() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster.sim.read().unwrap().storages[&1].clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n       .build()\n       .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n    ctx.max_execution_duration_ms = 200;\n    let (tx, rx) = channel();\n    fail::cfg(\"pause_on_peer_collect_message\", \"sleep(500)\").unwrap();\n    storage\n       .sched_txn_command(\n            commands::Rollback::new(vec![Key::from_raw(b\"k\")], 10.into(), ctx),\n            Box::new(move |res: storage::Result<_>| {\n                tx.send(res).unwrap();\n            }),\n        )\n       .unwrap();\n    let res = rx.recv().unwrap();\n    assert!(\n        matches!(\n            res,\n            Err(StorageError(box StorageErrorInner::Kv(KvError_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::single_downwards", "test": ["fn search_test<P: AsRef<Path>>(path: P, args: &[&str]) {\n  let binary = executable_path(\"just\");\n\n  let output = Command::new(binary)\n   .current_dir(path)\n   .args(args)\n   .output()\n   .expect(\"just invocation failed\");\n\n  assert_eq!(output.status.code().unwrap(), 0);\n\n  let stdout = str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(stdout, \"ok\\n\");\n\n  let stderr = str::from_utf8(&output.stderr).unwrap();\n  assert_eq!(stderr, \"echo ok\\n\");\n} [SEP] fn single_downwards() {\n  let tmp = temptree! {\n    justfile: \"default:\\n\\techo ok\",\n    child: {},\n  };\n\n  let path = tmp.path();\n\n  search_test(path, &[\"child/\"]);\n}"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/key_log_file_env.rs::exercise_key_log_file_for_server", "test": ["fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    } [SEP] fn exercise_key_log_file_for_server() {\n    serialized(|| {\n        let mut server_config = make_server_config(KeyType::Rsa);\n\n        env::set_var(\"SSLKEYLOGFILE\", \"./sslkeylogfile.txt\");\n        server_config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n            do_handshake(&mut client, &mut server);\n            transfer(&mut client, &mut server);\n            server.process_new_packets().unwrap();\n        }\n    })\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression20", "test": ["fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    } [SEP] fn regression20() {\n    let tmpfile = create_tempfile();\n\n    let table_def: MultimapTableDefinition<'static, u128, u128> =\n        MultimapTableDefinition::new(\"some-table\");\n\n    for _ in 0..3 {\n        let mut db = Database::builder().create(tmpfile.path()).unwrap();\n        db.check_integrity().unwrap();\n\n        let txn = db.begin_write().unwrap();\n        let mut table = txn.open_multimap_table(table_def).unwrap();\n\n        for i in 0..1024 {\n            table.insert(0, i).unwrap();\n        }\n        drop(table);\n\n        txn.commit().unwrap();\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_no_options", "test": ["pub fn stdout_is_fixture<T: AsRef<OsStr>>(&self, file_rel_path: T) -> &Self {\n        let contents = read_scenario_fixture(&self.tmpd, file_rel_path);\n        self.stdout_is(String::from_utf8(contents).unwrap())\n    } [SEP] fn test_no_options() {\n    // spell-checker:disable-next-line\n    for fixture in [\"empty.txt\", \"alpha.txt\", \"nonewline.txt\"] {\n        // Give fixture through command line file argument\n        new_ucmd!()\n           .args(&[fixture])\n           .succeeds()\n           .stdout_is_fixture(fixture);\n        // Give fixture through stdin\n        new_ucmd!()\n           .pipe_in_fixture(fixture)\n           .succeeds()\n           .stdout_is_fixture(fixture);\n    }\n}    "]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::pow_test", "test": ["pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n} [SEP] fn pow_test() {\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 2);\n    let expected = VecType::from_u32(25);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 15);\n    let expected: VecType = vec_from_u32(&[452807053, 7]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 16);\n    let expected: VecType = vec_from_u32(&[2264035265, 35]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 17);\n    let expected_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_small_file", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_small_file() {\n    new_ucmd!()\n       .args(&[\"-n -10\"])\n       .pipe_in(\"a\\nb\\nc\\nd\\ne\\n\")\n       .succeeds()\n       .stdout_is(\"a\\nb\\nc\\nd\\ne\\n\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_resize_async_ios_failed_2", "test": ["pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    } [SEP] fn test_resize_async_ios_failed_2() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 0;\n    cluster.pd_client.disable_default_operator();\n    let _ = cluster.run_conf_change();\n\n    // Save current async-io tids before shrinking\n    let org_writers_tids = get_async_writers_tids();\n    assert_eq!(0, org_writers_tids.len());\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    // Update config, expand from sync-mode(async-ios == 0) to\n    // async-mode(async-ios == 2).\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-io-pool-size\".to_owned(), \"2\".to_owned());\n            change\n        };\n\n        assert!(cfg_controller.update(change).is_err());\n        assert_eq!(\n            cfg_controller.get_current().raft_store.store_io_pool_size,\n            0\n        );\n    }\n    // Save current async-io tids after scaling up, and compared with the\n    // orginial one before scaling up, the thread num should be added up to TWO.\n    let cur_writers_tids = get_async_writers_tids();\n    assert_eq!(cur_\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_suffix", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_mktemp_suffix() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE1)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE2)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE3)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE4)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE5)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE6)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(\"--suffix\")\n       .arg(\"suf\")\n       .arg(TEST_TEMPLATE7)\n       .fails();\n    scene\n       .ucmd()\n_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_processing_multiple_operands", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_tee_processing_multiple_operands() {\n    // POSIX says: \"Processing of at least 13 file operands shall be supported.\"\n\n    let content = \"tee_sample_content\";\n    for n in [1, 2, 12, 13] {\n        let files = (1..=n).map(|x| x.to_string()).collect::<Vec<_>>();\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&files)\n           .pipe_in(content)\n           .succeeds()\n           .stdout_is(content);\n\n        for file in &files {\n            assert!(at.file_exists(file));\n            assert_eq!(at.read(file), content);\n        }\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_zero_terminated_only_delimited", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_zero_terminated_only_delimited() {\n    new_ucmd!()\n       .args(&[\"-d_\", \"-z\", \"-s\", \"-f\", \"1\"])\n       .pipe_in(\"91\\n\\082\\n7_3\")\n       .succeeds()\n       .stdout_only(\"82\\n7\\0\");\n}    "]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_type_check_works", "test": ["pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    } [SEP] fn dynamic_type_check_works() {\n    let mut store = test_setup();\n    let identity = Func::wrap(&mut store, |value: i32| value);\n    let mut result = Value::I32(0);\n    // Case: Too few inputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[], core::slice::from_mut(&mut result)),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too many inputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0), Value::I32(1)],\n            core::slice::from_mut(&mut result)\n        ),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too few outputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[Value::I32(0)], &mut [],),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Too many outputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0)],\n            &mut [Value::I32(0), Value::I32(1)],\n        ),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Mismatching type given as input to function.\n    for input in &[\n        Value::I64(0),\n\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_no_operand", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_rm_force_no_operand() {\n    let mut ucmd = new_ucmd!();\n\n    ucmd.arg(\"-f\").succeeds().no_stderr();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_error", "test": ["pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    } [SEP] fn test_mv_interactive_error() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_errors_dir\";\n    let file_a = \"test_mv_errors_file_a\";\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    // $ at.mkdir dir && at.touch file\n    // $ mv -i dir file\n    // err == mv: cannot overwrite non-directory 'file' with directory 'dir'\n    assert!(!scene\n       .ucmd()\n       .arg(\"-i\")\n       .arg(dir)\n       .arg(file_a)\n       .pipe_in(\"y\")\n       .fails()\n       .stderr_str()\n       .is_empty());\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_return_downcast", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn test_trap_return_downcast() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    #[derive(Debug)]\n    struct MyTrap;\n    impl std::fmt::Display for MyTrap {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"my trap\")\n        }\n    }\n    impl std::error::Error for MyTrap {}\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::from(MyTrap))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func\n       .call(&mut store, ())\n       .err()\n       .expect(\"error calling function\");\n    let dbg = format!(\"{:?}\", e);\n    println!(\"{}\", dbg);\n\n    assert!(!e.to_string().contains(\"my trap\"));\n    assert!(dbg.contains(\"Caused by:\\n    my trap\"));\n\n    e.downcast_ref::<MyTrap>()\n       .expect(\"error downcasts to"]}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/multiline.rs::read_lines_test", "test": ["pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n  many0(read_line)(input)\n} [SEP] fn read_lines_test() {\n  let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n  assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n  assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_merge.rs::test_merge", "test": ["pub fn get_tablet_index(&self) -> u64 {\n        self.tablet_index\n    } [SEP] fn test_merge() {\n    let mut cluster = Cluster::default();\n    let store_id = cluster.node(0).id();\n    let raft_engine = cluster.node(0).running_state().unwrap().raft_engine.clone();\n    let router = &mut cluster.routers[0];\n\n    let do_split =\n        |r: &mut TestRouter, region: Region, peer: &Peer, v: u64| -> (Region, Region, Peer) {\n            let rid = region.get_id();\n            let old_region_state = raft_engine\n               .get_region_state(rid, u64::MAX)\n               .unwrap()\n               .unwrap();\n            let new_peer = new_peer(store_id, peer.get_id() + 1);\n            let (lhs, rhs) = split_region(\n                r,\n                region,\n                peer.clone(),\n                rid + 1,\n                new_peer.clone(),\n                Some(format!(\"k{}{}\", rid, v).as_bytes()),\n                Some(format!(\"k{}{}\", rid + 1, v).as_bytes()),\n                format!(\"k{}\", rid + 1).as_bytes(),\n                format!(\"k{}\", rid + 1).as_bytes(),\n                false,\n            );\n            let region_state = raft_engine\n               .get_region_state(rid, u64::MAX)\n               .unwrap()\n               .unwrap();\n            assert!(region_state.get_tablet_index() > old_region_state.get_tablet_index());\n            assert_eq!(\n                region_state.get_region().get_region_epoch().get_version(),\n                old_region_state\n                   .get_region()\n                   .get_region_epoch()\n                   .get_version()\n                    + 1,\n            );\n            let region_state = raft_engine\n               .get_region_state(rid + 1, u64::MAX)\n                _"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression11", "test": ["fn commit(self) {\n        self.file.sync_all().unwrap();\n        self.inner.commit().unwrap();\n    } [SEP] fn regression11() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 1204];\n        t.insert(&118749, v.as_slice()).unwrap();\n        let v = vec![0u8; 2062];\n        t.insert(&153697, v.as_slice()).unwrap();\n        let v = vec![0u8; 2980];\n        t.insert(&110557, v.as_slice()).unwrap();\n        let v = vec![0u8; 1999];\n        t.insert(&677853, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 691];\n        t.insert(&103591, v.as_slice()).unwrap();\n        let v = vec![0u8; 952];\n        t.insert(&118757, v.as_slice()).unwrap();\n    }\n    tx.abort().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    tx.commit().unwrap();\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_server_split_epoch_not_match_left_derive", "test": ["fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n       .iter()\n       .map(|&k| pd_client.get_region(k).unwrap())\n       .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec!"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_scalar_subqueries", "test": ["pub fn verified_expr(&self, sql: &str) -> Expr {\n        self.expr_parses_to(sql, sql)\n    } [SEP] fn parse_scalar_subqueries() {\n    let sql = \"(SELECT 1) + (SELECT 2)\";\n    assert_matches!(\n        verified_expr(sql),\n        Expr::BinaryOp {\n            op: BinaryOperator::Plus,\n           ..\n        }\n    );\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::mismatched_arguments", "test": ["pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n           !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    } [SEP] fn mismatched_arguments() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (func (export \"foo\") (param i32))\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_func(&mut store, \"foo\").unwrap();\n    assert_eq!(\n        func.call(&mut store, &[], &mut []).unwrap_err().to_string(),\n        \"expected 1 arguments, got 0\"\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::F32(0)], &mut [])\n           .unwrap_err()\n           .to_string(),\n        \"argument type mismatch: found f32 but expected i32\",\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::I32(0), Val::I32(1)], &mut [])\n           .unwrap_err()\n           .to_string(),\n        \"expected 1 arguments, got 2\"\n    );\n    Ok(())\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_negative_offset", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_too_small_line_num_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/-5\", \"10\", \"/40/\"])\n       .succeeds()\n       .stdout_only(\"33\\n0\\n75\\n33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 15));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), generate(15, 40));\n    assert_eq!(at.read(\"xx03\"), generate(40, 51));\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_chroot", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_chroot() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let dir = \"CHROOT_DIR\";\n    at.mkdir(dir);\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"whoami\"]) {\n        result.success().no_stderr().stdout_is(\"root\");\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"pwd\"]) {\n        result.success().no_stderr().stdout_is(\"/\");\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n}\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/snap.rs::test_update_server_config", "test": ["pub fn get_speed_limit(&self) -> f64 {\n        self.core.limiter.speed_limit()\n    } [SEP] fn test_update_server_config() {\n    let (mut config, _dir) = TikvConfig::with_tmp().unwrap();\n    config.validate().unwrap();\n    let (cfg_controller, snap_worker, snap_mgr) = start_server(config.clone(), &_dir);\n    let mut svr_cfg = config.server.clone();\n    // dispatch updated config\n    let change = {\n        let mut m = std::collections::HashMap::new();\n        m.insert(\n            \"server.snap-io-max-bytes-per-sec\".to_owned(),\n            \"512MB\".to_owned(),\n        );\n        m.insert(\n            \"server.concurrent-send-snap-limit\".to_owned(),\n            \"100\".to_owned(),\n        );\n        m\n    };\n    cfg_controller.update(change).unwrap();\n\n    svr_cfg.snap_io_max_bytes_per_sec = ReadableSize::mb(512);\n    svr_cfg.concurrent_send_snap_limit = 100;\n    // config should be updated\n    assert_eq!(snap_mgr.get_speed_limit() as u64, 536870912);\n    validate(&snap_worker.scheduler(), move |cfg: &ServerConfig| {\n        assert_eq!(cfg, &svr_cfg);\n    });\n}_"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_untagged_b_ser", "test": ["fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n} [SEP] fn test_untagged_b_ser() {\n    let v = EnumStructUntagged::VariantB { foo: 1, bar: 2 };\n    let e = \"(foo:1,bar:2)\";\n    test_ser(&v, e);\n}"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtf_spec_test", "test": ["fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK)!= Self::Unsigned::ZERO\n    } [SEP] fn sqrtf_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtf(-1.0).is_nan());\n    assert!(libm::sqrtf(f32::NAN).is_nan());\n    for f in [0.0, -0.0, f32::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtf(f), f);\n    }\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/equals.rs::export_recipe", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_remove_symlink_dangling", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_rmdir_remove_symlink_dangling() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.symlink_dir(\"dir\", \"dl\");\n\n    ucmd.arg(\"dl/\")\n       .fails()\n       .stderr_is(\"rmdir: failed to remove 'dl/': Symbolic link not followed\\n\");\n}    "]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_elif", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn invalid_elif() {\n    assert_err_msg(\n        r#\"\n{% if true %}\n{% else %}\n{% elif false %}\n{% endif %}\n    \"#,\n        &[\"4:1\", \"unexpected tag; expected an endif tag (`{% endif %}`) or some content\"],\n    );\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_r", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_split_separator_semicolon_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator=;\", \"separator_semicolon.txt\"])\n       .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;4;\");\n    assert_eq!(file_read(&at, \"xab\"), \"2;5;\");\n    assert_eq!(file_read(&at, \"xac\"), \"3;\");\n    assert!(!at.plus(\"xad\").exists());\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_and_tabs_shortcut_mixed", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_and_tabs_shortcut_mixed() {\n    new_ucmd!()\n       .args(&[\"-2\", \"--tabs=5\", \"-7\"])\n       .pipe_in(\"\\ta\\tb\\tc\")\n       .succeeds()\n        //          01234567890\n       .stdout_is(\"  a  b c\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::data_size", "test": ["fn data_size(&self) -> usize {\n        panic!()\n    } [SEP] fn data_size() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let size1 = wb.data_size();\n    wb.put(b\"a\", b\"\").unwrap();\n    let size2 = wb.data_size();\n    assert!(size1 < size2);\n    wb.write().unwrap();\n    let size3 = wb.data_size();\n    assert_eq!(size2, size3);\n    wb.clear();\n    let size4 = wb.data_size();\n    assert_eq!(size4, size1);\n    wb.put(b\"a\", b\"\").unwrap();\n    let size5 = wb.data_size();\n    assert!(size4 < size5);\n    wb.delete(b\"a\").unwrap();\n    let size6 = wb.data_size();\n    assert!(size5 < size6);\n    wb.delete_range(b\"a\", b\"b\").unwrap();\n    let size7 = wb.data_size();\n    assert!(size6 < size7);\n    wb.clear();\n    let size8 = wb.data_size();\n    assert_eq!(size8, size1);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    let size1 = wb.data_size();\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    let size2 = wb.data_size();\n    assert!(size1 < size2);\n    wb.write().unwrap();\n    let size3 = wb.data_size();\n    assert_eq!(size2, size3);\n    wb.clear();\n    let size4 = wb.data_size();\n    assert_eq!(size4_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix_hyphen_value", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_short_custom_suffix_hyphen_value() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"-b\")\n       .arg(format!(\"--suffix={suffix}\"))\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_all_repeated_followed_by_filename", "test": ["pub fn write_all(self, settings: &GlobalSettings, output: Output) -> UResult<()> {\n        let mut out = output.into_write();\n        self.write_all_to(settings, &mut out)\n    } [SEP] fn test_all_repeated_followed_by_filename() {\n    let filename = \"test.txt\";\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let mut file = at.make_file(filename);\n    file.write_all(b\"a\\na\\n\").unwrap();\n\n    ucmd.args(&[\"--all-repeated\", filename])\n       .run()\n       .success()\n       .stdout_is(\"a\\na\\n\");\n}    "]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::mantissa_exponent_test", "test": ["pub(crate) fn mantissa_exponent(exponent: i32, fraction_digits: usize, truncated: usize) -> i32 {\n    if fraction_digits > truncated {\n        exponent.saturating_sub(into_i32(fraction_digits - truncated))\n    } else {\n        exponent.saturating_add(into_i32(truncated - fraction_digits))\n    }\n} [SEP] fn mantissa_exponent_test() {\n    assert_eq!(mantissa_exponent(10, 5, 0), 5);\n    assert_eq!(mantissa_exponent(0, 5, 0), -5);\n    assert_eq!(\n        mantissa_exponent(i32::max_value(), 5, 0),\n        i32::max_value() - 5\n    );\n    assert_eq!(mantissa_exponent(i32::max_value(), 0, 5), i32::max_value());\n    assert_eq!(mantissa_exponent(i32::min_value(), 5, 0), i32::min_value());\n    assert_eq!(\n        mantissa_exponent(i32::min_value(), 0, 5),\n        i32::min_value() + 5\n    );\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_macro_call", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn unterminated_macro_call() {\n    assert_err_msg(\"{{ my::macro( }}\", &[\"1:15\", \"expected an identifier (must start with a-z)\"]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_split_region_keep_records", "test": ["pub fn is_empty(&self) -> bool {\n        self.key.is_empty() && self.iv.is_empty()\n    } [SEP] fn test_split_region_keep_records() {\n    let mut cluster = test_raftstore_v2::new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    let leader = cluster.leader_of_region(r1).unwrap();\n    cluster.add_send_filter_on_node(\n        leader.get_store_id(),\n        Box::new(DropMessageFilter::new(Arc::new(|m: &RaftMessage| {\n            // Drop all gc peer requests and responses.\n           !(m.has_extra_msg()\n                && (m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerRequest\n                    || m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerResponse))\n        }))),\n    );\n\n    // Make sure split has applied.\n    let region = pd_client.get_region(b\"\").unwrap();\n    cluster.must_split(&region, b\"k1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region_state = cluster.region_local_state(r1, leader.get_store_id());\n    assert!(\n       !region_state.get_removed_records().is_empty(),\n        \"{:?}\",\n        region_\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_page_range", "test": ["pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    } [SEP] fn test_with_page_range() {\n    let test_file_path = \"test.log\";\n    let expected_test_file_path = \"test_page_range_1.log.expected\";\n    let expected_test_file_path1 = \"test_page_range_2.log.expected\";\n    for arg in [\"--pages=15\", \"+15\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n           .args(&[arg, test_file_path])\n           .succeeds()\n           .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n    for arg in [\"--pages=15:17\", \"+15:17\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n           .args(&[arg, test_file_path])\n           .succeeds()\n           .stdout_is_templated_fixture(\n                expected_test_file_path1,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc2_with_less_keys", "test": ["fn test_txn_store_gc_multiple_keys(key_prefix_len: usize, n: usize) {\n    let prefix = String::from_utf8(vec![b'k'; key_prefix_len]).unwrap();\n    test_txn_store_gc_multiple_keys_cluster_storage(n, prefix.clone());\n    test_txn_store_gc_multiple_keys_single_storage(n, prefix);\n} [SEP] fn test_txn_store_gc2_with_less_keys() {\n    test_txn_store_gc_multiple_keys(1, 3);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_pull_non_witness_availability", "test": ["fn test_non_witness_availability(fp: &str) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.check_peers_availability_interval = ReadableDuration::millis(20);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // non-witness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    std::thread::sleep(Duration::from_millis(100));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    fail::cfg(fp, \"return\").unwrap();\n\n    // witness -> non-witness\n    cluster\n       .pd_client\n       .switch_witnesses(region.get_id(), vec![peer_on_store3.get_id()], vec![false]);\n    std::thread::sleep(Duration::from_millis(500));\n    // snapshot applied\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    assert_eq!(cl"]}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::fallback_from_subdir_message", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::dtor_runs", "test": ["pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    } [SEP] fn dtor_runs() {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let mut store = Store::<()>::default();\n    let a = A;\n    assert_eq!(HITS.load(SeqCst), 0);\n    Func::wrap(&mut store, move || {\n        let _ = &a;\n    });\n    drop(store);\n    assert_eq!(HITS.load(SeqCst), 1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_suffix", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_arg_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(\"-b\")\n       .arg(\"--suffix\")\n       .arg(\".bak\")\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.bak\")),\n        \"How are you?\\n\"\n    );\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::dot_justfile_conflicts_with_justfile", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_suffixes_exhausted", "test": ["pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    } [SEP] fn test_suffixes_exhausted() {\n    new_ucmd!()\n       .args(&[\"-b\", \"1\", \"-a\", \"1\", \"asciilowercase.txt\"])\n       .fails()\n       .stderr_only(\"split: output file suffixes exhausted\\n\");\n}    "]}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_wildcard", "test": ["pub(super) fn req(text: &str) -> VersionReq {\n    VersionReq(crate::util::req(text))\n} [SEP] pub fn test_wildcard() {\n    let err = req_err(\"\");\n    assert_to_string(\n        err,\n        \"unexpected end of input while parsing major version number\",\n    );\n\n    let ref r = req(\"*\");\n    assert_match_all(r, &[\"0.9.1\", \"2.9.0\", \"0.0.9\", \"1.0.1\", \"1.1.1\"]);\n    assert_match_none(r, &[\"1.0.0-pre\"]);\n\n    for s in &[\"x\", \"X\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.1\", \"1.1.1\", \"1.3.0\"]);\n    assert_match_none(r, &[\"0.0.9\", \"1.2.0-pre\"]);\n\n    for s in &[\"1.x\", \"1.X\", \"1.*.*\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.2.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.2\", \"1.2.4\"]);\n    assert_match_none(r, &[\"1.9.0\", \"1.0.9\", \"2.0.1\", \"0.1.3\", \"1.2.2-pre\"]);\n\n    for s in &[\"1.2.x\", \"1.2.X\"] {\n        assert_eq!(*r, req(s));\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_mktemp", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_mktemp_mktemp() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE1)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE2)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE3)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE4)\n       .fails();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE5)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE6)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE7)\n       .succeeds();\n    scene\n       .ucmd()\n       .env(TMPDIR, &pathname)\n       .arg(TEST_TEMPLATE8)\n       .fails();\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_8", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn footnotes_test_8() {\n    let original = r##\"[^Doh] Ray Me Fa So La Te Do! [^1]\n\n[^Doh]: I know. Wrong Doe. And it won't render right.\n[^1]: Common for people practicing music.\n\"##;\n    let expected = r##\"<p><sup class=\"footnote-reference\"><a href=\"#Doh\">1</a></sup> Ray Me Fa So La Te Do! <sup class=\"footnote-reference\"><a href=\"#1\">2</a></sup></p>\n<div class=\"footnote-definition\" id=\"Doh\"><sup class=\"footnote-definition-label\">1</sup>\n<p>I know. Wrong Doe. And it won't render right.\n<sup class=\"footnote-reference\"><a href=\"#1\">2</a></sup>: Common for people practicing music.</p>\n</div>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::type_aliases", "test": ["fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n} [SEP] fn type_aliases() {\n    let source = r#\"type X[T: str, U, *Ts, **P] = list[T]\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_unfixed_floats", "test": ["fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-c\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-b\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n} [SEP] fn test_numeric_unfixed_floats() {\n    test_helper(\n        \"numeric_unfixed_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user_group", "test": ["pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    } [SEP] fn test_chown_no_change_to_user_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n           .ucmd()\n           .arg(\"-v\")\n           .arg(format!(\"--from={from}\"))\n           .arg(\"43:43\")\n           .arg(&file)\n           .succeeds()\n           .stdout_only(format!(\n                \"ownership of '{file}' retained as {user_name}:{group_name}\\n\"\n            ));\n    }\n}_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_to_address_on_different_network", "test": ["pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  } [SEP] fn inscribe_to_address_on_different_network() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\n    \"wallet inscribe --destination tb1qsgx55dp6gn53tsmyjjv4c2ye403hgxynxs0dnm --file degenerate.png --fee-rate 1\"\n  )\n .write(\"degenerate.png\", [1; 520])\n .rpc_server(&rpc_server)\n .expected_exit_code(1)\n .stderr_regex(\"error: address tb1qsgx55dp6gn53tsmyjjv4c2ye403hgxynxs0dnm belongs to network testnet which is different from required bitcoin\\n\")\n .run_and_extract_stdout();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_empty_directory_verbose", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_rm_empty_directory_verbose() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_empty_directory_verbose\";\n\n    at.mkdir(dir);\n\n    ucmd.arg(\"-d\")\n       .arg(\"-v\")\n       .arg(dir)\n       .succeeds()\n       .stdout_only(format!(\"removed directory '{dir}'\\n\"));\n\n    assert!(!at.dir_exists(dir));\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::mixed_durable_commit", "test": ["fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    } [SEP] fn mixed_durable_commit() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(Durability::None);\n    {\n        let mut table = txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &0).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n}_"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue352", "test": ["pub fn from_str(s: &'i str) -> Self {\n        Self::new(Reader::from_str(s))\n    } [SEP] fn issue352() {\n    use std::borrow::Cow;\n\n    #[derive(Deserialize)]\n    struct Root<'a> {\n        #[serde(borrow)]\n        #[serde(rename = \"@attribute\")]\n        attribute: Cow<'a, str>,\n    }\n\n    let r: Root = from_str(\"<Root attribute='borrowed value'></Root>\").unwrap();\n\n    assert!(matches!(r.attribute, Cow::Borrowed(_)));\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_column_across_option_and_column_separator", "test": ["pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    } [SEP] fn test_with_column_across_option_and_column_separator() {\n    let test_file_path = \"column.log\";\n    for (arg, expected) in [\n        (\"-s|\", \"column_across_sep.log.expected\"),\n        (\"-Sdivide\", \"column_across_sep1.log.expected\"),\n    ] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n           .args(&[\"--pages=3:5\", \"--column=3\", arg, \"-a\", \"-n\", test_file_path])\n           .succeeds()\n           .stdout_is_templated_fixture(expected, &[(\"{last_modified_time}\", &value)]);\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_cpu.rs::test_get", "test": ["fn get(&self, mut req: Get) -> PdFuture<pb::GetResponse> {\n        self.prepare_header(req.inner.mut_header());\n        self.inner.get(req)\n    } [SEP] fn test_get() {\n    let tag = \"tag_get\";\n\n    let (test_suite, mut store, _) = setup_test_suite();\n    fail::cfg_callback(\"point_getter_get\", || cpu_load(Duration::from_millis(100))).unwrap();\n    defer!(fail::remove(\"point_getter_get\"));\n\n    let jh = test_suite\n       .rt\n       .spawn(require_cpu_time_not_zero(&test_suite, tag));\n\n    let table = ProductTable::new();\n    let insert = prepare_insert(&mut store, &table);\n    insert.execute();\n    store.commit();\n\n    let storage = store.get_storage();\n    for (k, v) in store.export() {\n        let mut ctx = Context::default();\n        ctx.set_resource_group_tag(tag.as_bytes().to_vec());\n        assert_eq!(\n            storage\n               .get(ctx, &Key::from_raw(&k), TimeStamp::max())\n               .unwrap()\n               .0\n               .unwrap()\n               .as_slice(),\n            v.as_slice()\n        );\n    }\n\n    assert!(block_on(jh).unwrap());\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::hoisting", "test": ["pub fn get_or_intern_static(&mut self, utf8: &'static str, utf16: &'static [u16]) -> Sym {\n        // Uses the utf8 because it's quicker to check inside `COMMON_STRINGS_UTF8`\n        // (which is a perfect hash set) than to check inside `COMMON_STRINGS_UTF16`\n        // (which is a lazy static hash set).\n        self.get(utf8).unwrap_or_else(|| {\n            let index = self.utf8_interner.intern(utf8.as_bytes());\n            let utf16_index = self.utf16_interner.intern(utf16);\n\n            // Just to check everything is okay\n            debug_assert_eq!(index, utf16_index);\n\n            index\n               .checked_add(1 + COMMON_STRINGS_UTF8.len())\n               .and_then(Sym::new)\n               .expect(\"Cannot intern new string: integer overflow\")\n        })\n    } [SEP] fn hoisting() {\n    let interner = &mut Interner::default();\n    let hello = interner.get_or_intern_static(\"hello\", utf16!(\"hello\"));\n    let a = interner.get_or_intern_static(\"a\", utf16!(\"a\"));\n    check_script_parser(\n        r\"\n            var a = hello();\n            a++;\n\n            function hello() { return 10 }\",\n        vec![\n            Statement::Var(VarDeclaration(\n                vec![Variable::from_identifier(\n                    a.into(),\n                    Some(Call::new(Identifier::new(hello).into(), Box::default()).into()),\n                )]\n               .try_into()\n               .unwrap(),\n            ))\n           .into(),\n            Statement::Expression(Expression::from(Update::new(\n                UpdateOp::IncrementPost,\n                UpdateTarget::Identifier(Identifier::new(a)),\n            )))\n           .into(),\n            Declaration::Function(Function::new(\n                Some(hello.into()),\n                FormalParameterList::default(),\n                FunctionBody::_"]}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/issues.rs::issue_655", "test": ["fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  } [SEP] fn issue_655() {\n  use nom::character::streaming::{line_ending, not_line_ending};\n  fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  }\n\n  assert_eq!(twolines(\"foo\\nbar\\n\"), Ok((\"\", (\"foo\", \"bar\"))));\n  assert_eq!(twolines(\"f\u00e9o\\nbar\\n\"), Ok((\"\", (\"f\u00e9o\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\r\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n}\n\n#[cf"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .arg(\"--update=none\")\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_node_tombstone", "test": ["fn test_tombstone<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, b\"k1\");\n    must_get_none(&engine_2, b\"k3\");\n    let mut existing_kvs = vec![];\n    for cf in engine_2.cf_names() {\n        engine_2\n           .scan(cf, b\"\", &[0xFF], false, |k, v| {\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_forward_then_reverse_snapshot", "test": ["fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    } [SEP] fn iter_forward_then_reverse_snapshot() {\n    let db = default_engine();\n    iter_forward_then_reverse(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}_"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_a_roundtrip", "test": ["fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n} [SEP] fn test_adjacently_a_roundtrip() {\n    let v = EnumStructAdjacently::VariantA {\n        foo: 1,\n        bar: 2,\n        different: Inner::Foo,\n    };\n    test_roundtrip(v);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_region_created_replicate", "test": ["pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    } [SEP] fn test_region_created_replicate() {\n    let cluster = new_server_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let region = suite.cluster.get_region(&[]);\n    suite\n       .cluster\n       .must_transfer_leader(region.id, new_peer(2, 2));\n    suite\n       .cluster\n       .pd_client\n       .must_remove_peer(region.id, new_peer(1, 1));\n\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 1)\n           .direction(Direction::Recv)\n           .msg_type(MessageType::MsgAppend),\n    );\n    suite.cluster.sim.wl().add_recv_filter(1, recv_filter);\n    suite\n       .cluster\n       .pd_client\n       .must_add_peer(region.id, new_peer(1, 1));\n    let region = suite.cluster.get_region(&[]);\n    let req = suite.new_changedata_request(region.id);\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    sleep_ms(1000);\n    suite.cluster.sim.wl().clear_recv_filters(1);\n\n    let mut counter = 0;\n    let mut previous_ts = 0;\n    loop {\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            assert!(resolved_ts.ts >= previous_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_lines", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_split_separator_nul_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n       .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_line_syntax", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_line_syntax() {\n    new_ucmd!()\n       .args(&[\"-n\", \"2048m\"])\n       .pipe_in(\"a\\n\")\n       .run()\n       .stdout_is(\"a\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_no_args", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_no_args() {\n    new_ucmd!()\n       .fails()\n       .code_is(1)\n       .stderr_contains(\"missing operand\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_multiple_obs_lines_within_combined", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_split_multiple_obs_lines_within_combined() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"multiple-obs-lines\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n       .ucmd()\n       .args(&[\"-d5000x\", \"-e200d\", name])\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}    "]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/scopes.rs::test_function_level_strict", "test": ["pub fn test(self) {\n        let res: Result<_, _> = self.into();\n\n        res.unwrap();\n    } [SEP] fn test_function_level_strict() {\n    let tester = SemanticTester::js(\n        r#\"\n    function foo() {\n        \"use strict\";\n        let x = 1;\n        return x\n    }\n    \"#,\n    )\n   .with_module(false);\n\n    tester.has_some_symbol(\"x\")\n       .is_in_scope(ScopeFlags::StrictMode | ScopeFlags::Function)\n       .expect(|(semantic, symbol_id)| -> Result<(), &'static str> {\n            let scope_id = semantic.symbol_scope(symbol_id);\n            let Some(parent_scope_id) = semantic.scopes().get_parent_id(scope_id) else {\n                return Err(\"Expected x's scope to have a parent\")\n            };\n            let parent_flags = semantic.scopes().get_flags(parent_scope_id);\n            if parent_flags.contains(ScopeFlags::Top) {\n                Ok(())\n            } else {\n                Err(\"Expected x to be in a top-level function declaration, but its parent scope has flags {parent_flags:?}\")\n            }\n        })\n       .test();\n    tester.has_some_symbol(\"foo\").is_not_in_scope(ScopeFlags::StrictMode).test();\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::versions", "test": ["fn version_test(\n    client_versions: &[&'static rustls::SupportedProtocolVersion],\n    server_versions: &[&'static rustls::SupportedProtocolVersion],\n    result: Option<ProtocolVersion>,\n) {\n    let client_versions = if client_versions.is_empty() {\n        rustls::ALL_VERSIONS\n    } else {\n        client_versions\n    };\n    let server_versions = if server_versions.is_empty() {\n        rustls::ALL_VERSIONS\n    } else {\n        server_versions\n    };\n\n    let client_config = make_client_config_with_versions(KeyType::Rsa, client_versions);\n    let server_config = make_server_config_with_versions(KeyType::Rsa, server_versions);\n\n    println!(\n        \"version {:?} {:?} -> {:?}\",\n        client_versions, server_versions, result\n    );\n\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    assert_eq!(client.protocol_version(), None);\n    assert_eq!(server.protocol_version(), None);\n    if result.is_none() {\n        let err = do_handshake_until_error(&mut client, &mut server);\n        assert!(err.is_err());\n    } else {\n        do_handshake(&mut client, &mut server);\n        assert_eq!(client.protocol_version(), result);\n        assert_eq!(server.protocol_version(), result);\n    }\n} [SEP] fn versions() {\n    // default -> 1.3\n    version_test(&[], &[], Some(ProtocolVersion::TLSv1_3));\n\n    // client default, server 1.2 -> 1.2\n    #[cfg(feature = \"tls12\")]\n    version_test(\n        &[],\n        &[&rustls::version::TLS12],\n        Some(ProtocolVersion::TLSv1_2),\n    );\n\n    // client 1.2, server default -> 1.2\n    #[cfg(feature_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_ingest_sst", "test": ["pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    } [SEP] fn test_ingest_sst() {\n    let mut cfg = TikvConfig::default();\n    cfg.server.grpc_concurrency = 1;\n    let (_cluster, ctx, _tikv, import) = open_cluster_and_tikv_import_client(Some(cfg));\n\n    let temp_dir = Builder::new().prefix(\"test_ingest_sst\").tempdir().unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n\n    // No region id and epoch.\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta.clone());\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(resp.has_error());\n\n    // Set region id and epoch.\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    send_upload_sst(&import, &meta, &data).unwrap();\n    // Can't upload the same file again.\n    assert_to_string_contains!(\n        send_upload_sst(&import, &meta, &data).unwrap_err(),\n        \"FileExists\"\n    );\n\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_wrap_bad_arg", "test": ["pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    } [SEP] fn test_wrap_bad_arg() {\n    for wrap_param in [\"-w\", \"--wrap\"] {\n        new_ucmd!()\n           .arg(wrap_param)\n           .arg(\"b\")\n           .fails()\n           .stderr_only(\"base64: invalid wrap size: 'b'\\n\");\n    }\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_rpc_client", "test": ["fn get_cluster_id(&self) -> Result<u64> {\n        Ok(self.cluster_id)\n    } [SEP] fn test_rpc_client() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), None);\n    assert_ne!(client.get_cluster_id().unwrap(), 0);\n\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    debug!(\"bootstrap store {:?}\", store);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer.clone());\n    debug!(\"bootstrap region {:?}\", region);\n\n    client\n       .bootstrap_cluster(store.clone(), region.clone())\n       .unwrap();\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n\n    let tmp_stores = client.get_all_stores(false).unwrap();\n    assert_eq!(tmp_stores.len(), 1);\n    assert_eq!(tmp_stores[0], store);\n\n    let tmp_store = client.get_store(store_id).unwrap();\n    assert_eq!(tmp_store.get_id(), store.get_id());\n\n    let region_key = region.get_start_key();\n    let tmp_region = client.get_region(region_key).unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let region_info = client.get_region_info(_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_no_leak", "test": ["pub fn load(&self, env: &Environment, key: &str) -> Option<Value> {\n        for frame in self.stack.iter().rev() {\n            // look at locals first\n            if let Some(value) = frame.locals.get(key) {\n                return Some(value.clone());\n            }\n\n            // if we are a loop, check if we are looking up the special loop var.\n            if let Some(ref l) = frame.current_loop {\n                if l.with_loop_var && key == \"loop\" {\n                    return Some(Value::from(l.object.clone()));\n                }\n            }\n\n            // perform a fast lookup.  This one will not produce errors if the\n            // context is undefined or of the wrong type.\n            if let Some(rv) = frame.ctx.get_attr_fast(key) {\n                return Some(rv);\n            }\n        }\n\n        env.get_global(key)\n    } [SEP] fn test_no_leak() {\n    let dropped = Arc::new(AtomicBool::new(false));\n\n    struct X(Arc<AtomicBool>);\n\n    impl StructObject for X {\n        fn get_field(&self, _name: &str) -> Option<Value> {\n            None\n        }\n    }\n\n    impl Drop for X {\n        fn drop(&mut self) {\n            self.0.store(true, std::sync::atomic::Ordering::Relaxed);\n        }\n    }\n\n    let ctx = context! {\n        x => Value::from_struct_object(X(dropped.clone())),\n    };\n    let mut env = Environment::new();\n    env.add_template(\"x\", \"{% macro meh() %}{{ x }}{{ meh }}{% endmacro %}\")\n       .unwrap();\n    let rv = env\n       .render_str(\n            r#\"\n        {%- from 'x' import meh %}\n        {{- meh() }}\n        {%- set closure = x %}\n        {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}\n        _"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_limit_accepts_all", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_limit_accepts_all() {\n    one_statement_parses_to(\n        \"SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT ALL\",\n        \"SELECT id, fname, lname FROM customer WHERE id = 1\",\n    );\n}\n"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_tuples", "test": ["pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    } [SEP] fn parse_tuples() {\n    let sql = \"SELECT (1, 2), (1), ('foo', 3, baz)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        vec![\n            SelectItem::UnnamedExpr(Expr::Tuple(vec![\n                Expr::Value(number(\"1\")),\n                Expr::Value(number(\"2\")),\n            ])),\n            SelectItem::UnnamedExpr(Expr::Nested(Box::new(Expr::Value(number(\"1\"))))),\n            SelectItem::UnnamedExpr(Expr::Tuple(vec![\n                Expr::Value(Value::SingleQuotedString(\"foo\".into())),\n                Expr::Value(number(\"3\")),\n                Expr::Identifier(Ident::new(\"baz\")),\n            ])),\n        ],\n        select.projection\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_chown_directory_invalid", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_install_chown_directory_invalid() {\n    let scene = TestScenario::new(util_name!());\n\n    scene\n       .ucmd()\n       .arg(\"-o\")\n       .arg(\"test_invalid_user\")\n       .arg(\"-d\")\n       .arg(\"dir1/dir2\")\n       .fails()\n       .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n\n    scene\n       .ucmd()\n       .arg(\"-g\")\n       .arg(\"test_invalid_group\")\n       .arg(\"-d\")\n       .arg(\"dir1/dir2\")\n       .fails()\n       .stderr_contains(\"install: invalid group: 'test_invalid_group'\");\n\n    scene\n       .ucmd()\n       .arg(\"-o\")\n       .arg(\"test_invalid_user\")\n       .arg(\"-g\")\n       .arg(\"test_invalid_group\")\n       .arg(\"-d\")\n       .arg(\"dir1/dir2\")\n       .fails()\n       .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n\n    scene\n       .ucmd()\n       .arg(\"-g\")\n       .arg(\"test_invalid_group\")\n       .arg(\"-o\")\n       .arg(\"test_invalid_user\")\n       .arg(\"-d\")\n       .arg(\"dir1/dir2\")\n       .fails()\n       .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_a_bunch_of_not", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_a_bunch_of_not() {\n    new_ucmd!()\n       .args(&[\"!\", \"\", \"!=\", \"\", \"-a\", \"!\", \"\", \"!=\", \"\"])\n       .succeeds();\n}_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/sqlite_tests.rs::test_init_journal", "test": ["pub fn schema_up(&mut self) -> PersistenceResult<i64> {\n        while self.version < CURRENT_VERSION {\n            match self.version + 1 {\n                0 => self.version = self.init_up()?,\n                1 => self.version = self.records_up()?,\n                _ => panic!(\"incorrect version somewhere\"), // valid panic, non-recoverable state\n            }\n\n            self.update_schema_version(self.version)?;\n        }\n\n        Ok(self.version)\n    } [SEP] fn test_init_journal() {\n    let conn = Connection::open_in_memory().expect(\"could not create in memory DB\");\n    let mut journal = Journal::new(conn).unwrap();\n    let version = journal.schema_up().unwrap();\n    assert_eq!(version, CURRENT_VERSION);\n    assert_eq!(\n        Journal::select_schema_version(&journal.conn()).unwrap(),\n        CURRENT_VERSION\n    );\n}_"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_lifetime", "test": ["pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n       .items\n       .values()\n       .map(|item| introspect_item(item, &lookup))\n       .collect();\n\n    let tokens = lookup\n       .tokens\n       .into_iter()\n       .map(|(name, ty)| (ty, name))\n       .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n} [SEP] fn ident_parse_lifetime() {\n    parse(\"'static\").unwrap_err();\n}    "]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_02", "test": ["pub fn resume<T>(\n        self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        inputs: &[Value],\n        outputs: &mut [Value],\n    ) -> Result<ResumableCall, Error> {\n        self.engine\n           .resolve_func_type(self.host_func().ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(inputs, true)\n            })?;\n        self.engine\n           .resolve_func_type(self.func.ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(outputs, false)?;\n                func_type.prepare_outputs(outputs);\n                <Result<(), Error>>::Ok(()) // TODO: why do we need types here?\n            })?;\n        self.engine\n           .clone()\n           .resume_func(ctx.as_context_mut(), self, inputs, outputs)\n           .map_err(Into::into)\n           .map(ResumableCall::new)\n    } [SEP] fn resumable_call_smoldot_02() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (if (result i32) (i32.ne (call $host_fn) (i32.const 0))\n                    (then\n                        (i32.const 11) ;; EXPECTED\n                    )\n                    (else\n                        (i32.const 22) ;; FAILURE\n                    )\n                )\n            )\n        )\n        \"#,\n    );\n    let invocation = wasm_fn.call_resumable(&mut store, ()).unwrap_resumable();\n    match invocation.resume(&mut store, &[Value::I32(42)]).unwrap() {\n        TypedResumableCall::Finished(\n"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::reopen_table", "test": ["pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    } [SEP] fn reopen_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &0).unwrap();\n    }\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&1, &1).unwrap();\n    }\n    write_txn.commit().unwrap();\n}_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_compare_and_swap", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    } [SEP] fn test_compare_and_swap() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n       .create(record.clone(), origin.clone())\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client\n       .compare_and_swap(current.clone(), new.clone(), origin.clone())\n       .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n       .query(new.name(), new.dns_class(), new.record_type())\n       .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n       .answers()\n       .iter()\n       .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n\n    // check the it fails if tried again.\n    new.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n\n    let result = client\n       .compare_and_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::defaultcheck_order_two_different_bad_order_files", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn defaultcheck_order_two_different_bad_order_files() {\n    new_ucmd!()\n       .args(&[\"bad_order_1\", \"bad_order_2\"])\n       .fails()\n       .stdout_is_fixture(\"bad_order12.nocheck_order.expected\")\n       .stderr_is(\"error to be defined\");\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_inheritance", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn can_remove_whitespace_inheritance() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\"{%- extends \"base\" -%} {% block content %}{{super()}}{% endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" -%} {% block content -%}{{super()}}{%- endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" %} {%- block content -%}{{super()}}{%- endblock -%} \"#, \" Hey! \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"base\", \"{% block content %} Hey! {% endblock %}\"),\n            (\"tpl\", input),\n        ])\n       .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_short_custom_suffix() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"-b\")\n       .arg(format!(\"--suffix={suffix}\"))\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_byte_literal", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_byte_literal() {\n    let sql = r#\"SELECT B'abc', B\"abc\"\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::DoubleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT b'abc', b\"abc\"\"#;\n    bigquery().one_statement_parses_to(sql, r#\"SELECT B'abc', B\"abc\"\"#);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_final_newline_when_line_less_than_fold", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_should_preserve_final_newline_when_line_less_than_fold() {\n    new_ucmd!().pipe_in(\"1234\\n\").succeeds().stdout_is(\"1234\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_and_not_is_false", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_and_not_is_false() {\n    new_ucmd!().args(&[\"-a\", \"!\"]).run().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_ascii_5_gibi_to_file", "test": ["pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    } [SEP] fn test_ascii_5_gibi_to_file() {\n    let tname = \"ascii-5G\";\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"status=none\",\n        \"count=5G\",\n        \"iflag=count_bytes\",\n        \"if=/dev/zero\",\n        of!(tmp_fn),\n    ])\n   .run()\n   .no_stderr()\n   .no_stdout()\n   .success();\n\n    assert_eq!(5 * 1024 * 1024 * 1024, fix.metadata(&tmp_fn).len());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_long_header_option", "test": ["pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    } [SEP] fn test_with_long_header_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_header.log.expected\";\n    let header = \"new file\";\n    for args in [&[\"-h\", header][..], &[\"--header=new file\"][..]] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n           .args(args)\n           .arg(test_file_path)\n           .succeeds()\n           .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value), (\"{header}\", header)],\n            );\n    }\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::logical_nullish_assignment", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn logical_nullish_assignment() {\n    run_test_actions([\n        TestAction::assert_eq(\"{ let a = undefined; a??= 10; a }\", 10),\n        TestAction::assert_eq(\"{ let a = 20; a??= 10; a }\", 20),\n    ]);\n}"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_17", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_17() {\n    let original = r##\"# H1 {.z.a.zz}\n\"##;\n    let expected = r##\"<h1 class=\"z a zz\">H1</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_space_only", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_space_only() {\n    new_ucmd!()\n       .args(&[\"--tabs\", \" \"])\n       .pipe_in(\"a\\tb\\tc\")\n       .succeeds()\n       .stdout_is(\"a       b       c\");\n}    "]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_meta_item_list_word", "test": ["fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n} [SEP] fn test_meta_item_list_word() {\n    let meta = test(\"#[foo(bar)]\");\n\n    snapshot!(meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`bar`),\n    }\n    \"###);\n}"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_linked_func", "test": ["pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the.text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    } [SEP] fn call_linked_func() -> Result<(), Error> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::parse_error", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    let _guard = TEST_MUTEX.lock();\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}    "]}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::chooser", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_zero", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_ls_zero() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"0-test-zero\");\n    at.touch(at.plus_as_string(\"2-test-zero\"));\n    at.touch(at.plus_as_string(\"3-test-zero\"));\n\n    let ignored_opts = [\n        \"--quoting-style=c\",\n        \"--color=always\",\n        \"-m\",\n        \"--hide-control-chars\",\n    ];\n\n    scene\n       .ucmd()\n       .arg(\"--zero\")\n       .succeeds()\n       .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n\n    for opt in ignored_opts {\n        scene\n           .ucmd()\n           .args(&[opt, \"--zero\"])\n           .succeeds()\n           .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n    }\n\n    scene\n       .ucmd()\n       .args(&[\"--zero\", \"--quoting-style=c\"])\n       .succeeds()\n       .stdout_only(\"\\\"0-test-zero\\\"\\x00\\\"2-test-zero\\\"\\x00\\\"3-test-zero\\\"\\x00\");\n\n    scene\n       .ucmd()\n       .args(&[\"--zero\", \"--color=always\"])\n       .succeeds()\n       .stdout_only(\"\\x1b[1;34m0-test-zero\\x1b[0m\\x002-test-zero\\x003-test-"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_multiple_snapshots_not_together", "test": ["fn test_node_merge_multiple_snapshots(together: bool) {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    ignore_merge_target_integrity(&mut cluster.cfg, &cluster.pd_client);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    // make it gc quickly to trigger snapshot easily\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(10);\n    cluster.cfg.raft_store.merge_max_log_gap = 9;\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n\n    let target_leader = right\n       .get_peers()\n       .iter()\n       .find(|p| p.get_store_id() == 1)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(right.get_id(), target_leader);\n    let target_leader = left\n       .get_peers()\n       .iter()\n       .find(|p| p.get_store_id() == 2)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(left.get_id(), target_leader);\n    must_get_equal(&cluster.get_engine(1"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_pat.rs::test_pat_ident", "test": ["fn parse2(self, tokens: TokenStream) -> Result<T> {\n        let buf = TokenBuffer::new2(tokens);\n        let state = tokens_to_parse_buffer(&buf);\n        let node = self(&state)?;\n        state.check_unexpected()?;\n        if let Some(unexpected_span) = span_of_unexpected_ignoring_nones(state.cursor()) {\n            Err(Error::new(unexpected_span, \"unexpected token\"))\n        } else {\n            Ok(node)\n        }\n    } [SEP] fn test_pat_ident() {\n    match Pat::parse_single.parse2(quote!(self)).unwrap() {\n        Pat::Ident(_) => (),\n        value => panic!(\"expected PatIdent, got {:?}\", value),\n    }\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_position_not_function_columns", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_position_not_function_columns() {\n    snowflake_and_generic()\n       .verified_stmt(\"SELECT position FROM tbl1 WHERE position NOT IN ('first', 'last')\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_bootstrap.rs::test_bootstrap_half_way_failure_after_bootstrap_store", "test": ["fn test_bootstrap_half_way_failure() {\n    let server = test_pd::Server::new(1);\n    let eps = server.bind_addrs();\n    let pd_client = test_pd::util::new_client(eps, None);\n    let path = TempDir::new().unwrap();\n    let engines = engine_test::new_temp_engine(&path);\n    let bootstrap = || {\n        let logger = slog_global::borrow_global().new(o!());\n        let mut bootstrap = Bootstrap::new(&engines.raft, 0, &pd_client, logger);\n        match bootstrap.bootstrap_store() {\n            Ok(store_id) => {\n                let mut store = Store::default();\n                store.set_id(store_id);\n                bootstrap.bootstrap_first_region(&store, store_id)\n            }\n            Err(e) => Err(e),\n        }\n    };\n\n    // Try to start this node, return after persisted some keys.\n    fail::cfg(\"node_after_bootstrap_store\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_store\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    let ident = engines.raft.get_store_ident().unwrap().unwrap();\n    assert_ne!(ident.get_store_id(), 0);\n\n    // Check whether it can bootstrap cluster successfully.\n    fail::remove(\"node_after_bootstrap_store\");\n    fail::cfg(\"node_after_prepare_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_prepare_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    fail::remove(\"node_after_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_merge_pessimistic_locks_with_concurrent_prewrite", "test": ["pub fn is_writable(&self) -> bool {\n        self.status == LocksStatus::Normal\n    } [SEP] fn test_merge_pessimistic_locks_with_concurrent_prewrite() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    cluster.must_transfer_leader(right.id, new_peer(2, 2));\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let snapshot = cluster.must_get_snapshot_of_region(left.id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    let lock = PessimisticLock {\n        primary: b\"k0\".to_vec().into_boxed_slice(),\n        start_ts: 10.into(),\n        ttl: 3000,\n        for_update_ts: 20.into(),\n        min_commit_ts: 30.into(),\n        last_change_ts: 15.into(),\n        versions_to_last_change: 3,\n    };\n    txn_\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_header() {\n    new_ucmd!()\n       .args(&[\"--from=si\", \"--header=2\"])\n       .pipe_in(\"header\\nheader2\\n1K\\n1.1M\\n0.1G\")\n       .run()\n       .stdout_is(\"header\\nheader2\\n1000\\n1100000\\n100000000\\n\");\n}    "]}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::test_justfile_search", "test": ["fn join() {\n  assert_eval_eq(\"join('a', 'b', 'c', 'd')\", \"a/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', 'c', 'd')\", \"/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', 'd')\", \"/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', '/d')\", \"/d\");\n} [SEP] fn test_justfile_search() {\n  let tmp = temptree! {\n    justfile: \"default:\\n\\techo ok\",\n    a: {\n      b: {\n        c: {\n          d: {},\n        },\n      },\n    },\n  };\n\n  search_test(tmp.path().join(\"a/b/c/d\"), &[]);\n}("]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::not_regression", "test": ["fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n} [SEP] fn not_regression() {\n    // https://github.com/googleprojectzero/weggli/issues/2\n    let needle = \"{free($handle); not: $handle= NULL;}\";\n    let source = r\"\n    void func()\n    {\n        free(data); //this should not match\n        data = NULL ; \n        \n        free(handle); //this should match\n    }\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::store_with_context", "test": ["pub fn data(&self) -> &T {\n        self.inner.data()\n    } [SEP] fn store_with_context() -> Result<()> {\n    struct Ctx {\n        called: bool,\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\"\", \"\", |mut caller: Caller<'_, Ctx>| {\n        caller.data_mut().called = true;\n    })?;\n\n    let mut store = Store::new(&engine, Ctx { called: false });\n\n    let f = linker.get(&mut store, \"\", \"\").unwrap().into_func().unwrap();\n    f.call(&mut store, &[], &mut [])?;\n\n    assert!(store.data().called);\n\n    Ok(())\n}_"]}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::vba", "test": ["pub fn get_module(&self, name: &str) -> Result<String, VbaError> {\n        debug!(\"read module {}\", name);\n        let data = self.get_module_raw(name)?;\n        Ok(self.encoding.decode_all(data))\n    } [SEP] fn vba() {\n    setup();\n\n    let path = format!(\"{}/tests/vba.xlsm\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let mut vba = excel.vba_project().unwrap().unwrap();\n    assert_eq!(\n        vba.to_mut().get_module(\"testVBA\").unwrap(),\n        \"Attribute VB_Name = \\\"testVBA\\\"\\r\\nPublic Sub test()\\r\\n    MsgBox \\\"Hello from \\\n         vba!\\\"\\r\\nEnd Sub\\r\\n\"\n    );\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_when_transfer_region", "test": ["fn must_detect_deadlock(cluster: &mut Cluster<ServerCluster>, key: &[u8], ts: u64) {\n    // Sometimes, deadlocks can't be detected at once due to leader change, but it\n    // will be detected.\n    for _ in 0..5 {\n        let (client, ctx) = build_leader_client(cluster, key);\n        if deadlock(&client, ctx, key, ts) {\n            return;\n        }\n    }\n    panic!(\"failed to detect deadlock\");\n} [SEP] fn test_detect_deadlock_when_transfer_region() {\n    let mut cluster = new_cluster_for_deadlock_test(4);\n    // Transfer the leader region to store(4) and the leader of deadlock detector\n    // should be also transferred.\n    must_transfer_region(&mut cluster, b\"k\", 1, 4, 4);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n\n    must_split_region(&mut cluster, b\"\", b\"k1\");\n    // Transfer the new region to store(1). It shouldn't affect deadlock detector.\n    must_transfer_region(&mut cluster, b\"k1\", 4, 1, 5);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n\n    // Transfer the new region back to store(4) which will send a role change\n    // message with empty key range. It shouldn't affect deadlock detector.\n    must_transfer_region(&mut cluster, b\"k1\", 1, 4, 6);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n}("]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_table", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_drop_table() {\n    let sql = \"DROP TABLE foo\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            object_type,\n            if_exists,\n            names,\n            cascade,\n            purge: _,\n            temporary,\n           ..\n        } => {\n            assert!(!if_exists);\n            assert_eq!(ObjectType::Table, object_type);\n            assert_eq!(\n                vec![\"foo\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert!(!cascade);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"DROP TABLE IF EXISTS foo, bar CASCADE\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            object_type,\n            if_exists,\n            names,\n            cascade,\n            purge: _,\n            temporary,\n           ..\n        } => {\n            assert!(if_exists);\n            assert_eq!(ObjectType::Table, object_type);\n            assert_eq!(\n                vec![\"foo\", \"bar\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert!(cascade);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"DROP TABLE\";\n    assert_eq!(\n        ParserError::ParserError(\"Expected identifier, found: EOF\".to_string()),\n        parse_sql_statements(sql).unwrap_err(),\n    );\n\n    let sql = \"DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT\";\n    assert_eq!(\n        ParserError::ParserError(\"Cannot specify both CASCADE and RESTRICT in DROP\".to_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_to_dir_2args", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_symlink_to_dir_2args() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let filename = \"test_symlink_to_dir_2args_file\";\n    let from_file = &format!(\"{}/{}\", at.as_string(), filename);\n    let to_dir = \"test_symlink_to_dir_2args_to_dir\";\n    let to_file = &format!(\"{to_dir}/{filename}\");\n\n    at.mkdir(to_dir);\n    at.touch(from_file);\n\n    ucmd.args(&[\"-s\", from_file, to_dir]).succeeds().no_stderr();\n\n    assert!(at.file_exists(to_file));\n    assert!(at.is_symlink(to_file));\n    assert_eq!(at.resolve_link(to_file), filename);\n}_"]}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_reserve", "test": ["pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  } [SEP] fn TinyVec_reserve() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(2);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 10);\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_value_in_map_key", "test": ["pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q:?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    } [SEP] fn test_raw_value_in_map_key() {\n    #[derive(RefCast)]\n    #[repr(transparent)]\n    struct RawMapKey(RawValue);\n\n    impl<'de> Deserialize<'de> for &'de RawMapKey {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: serde::Deserializer<'de>,\n        {\n            let raw_value = <&RawValue>::deserialize(deserializer)?;\n            Ok(RawMapKey::ref_cast(raw_value))\n        }\n    }\n\n    impl PartialEq for RawMapKey {\n        fn eq(&self, other: &Self) -> bool {\n            self.0.get() == other.0.get()\n        }\n    }\n\n    impl Eq for RawMapKey {}\n\n    impl Hash for RawMapKey {\n        fn hash<H: Hasher>(&self, hasher: &mut H) {\n            self.0.get().hash(hasher);\n        }\n    }\n\n    let map_from_str: HashMap<&RawMapKey, &RawValue> =\n        serde_json::from_str(r#\" {\"\\\\k\":\"\\\\v\"} \"#).unwrap();\n    let (map_k, map_v) = map_from_str.into_iter().next().unwrap();\n    assert_eq!(\"\\\"\\\\\\\\k\\\"\", map_k.0.get());\n    assert_eq!(\"\\\"\\\\\\\\v\\\"\", map_v.get());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_additional_suffix_hyphen_value", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_split_additional_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_additional_suffix\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[\"--additional-suffix\", \"-300\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]-300$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}    "]}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_capacity", "test": ["pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  } [SEP] fn TinyVec_capacity() {\n  let mut tv: TinyVec<[i32; 1]> = Default::default();\n  assert_eq!(tv.capacity(), 1);\n  tv.move_to_the_heap();\n  tv.extend_from_slice(&[1, 2, 3, 4]);\n  assert_eq!(tv.capacity(), 4);\n}_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_negative", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn indent_size_parse_errors_negative() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=-1\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_negative\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_normal_format", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_normal_format() {\n    let args = [\"-c\", NORMAL_FORMAT_STR, \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_octal", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_escape_octal() {\n    new_ucmd!()\n       .args(&[\"-e\", \"\\\\0100\"])\n       .succeeds()\n       .stdout_only(\"@\\n\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::trap_start_function_import", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn trap_start_function_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"\" (func $foo))\n                (start $foo)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let sig = FuncType::new(None, None);\n    let func = Func::new(&mut store, sig, |_, _, _| bail!(\"user trap\"));\n    let err = Instance::new(&mut store, &module, &[func.into()]).unwrap_err();\n    assert!(format!(\"{err:?}\").contains(\"user trap\"));\n    Ok(())\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::from_float", "test": ["fn assert_normalized_eq(mut x: ExtendedFloat, mut y: ExtendedFloat) {\n    x.normalize();\n    y.normalize();\n    assert_eq!(x, y);\n} [SEP] fn from_float() {\n    let values: [f32; 26] = [\n        1e-40, 2e-40, 1e-35, 2e-35, 1e-30, 2e-30, 1e-25, 2e-25, 1e-20, 2e-20, 1e-15, 2e-15, 1e-10,\n        2e-10, 1e-5, 2e-5, 1.0, 2.0, 1e5, 2e5, 1e10, 2e10, 1e15, 2e15, 1e20, 2e20,\n    ];\n    for value in &values {\n        assert_normalized_eq(\n            ExtendedFloat::from_float(*value),\n            ExtendedFloat::from_float(*value as f64),\n        );\n    }\n}_"]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call", "test": ["fn run_test_typed(wasm_fn: Func, mut store: &mut Store<()>, wasm_trap: bool) {\n    let invocation = wasm_fn\n       .typed::<i32, i32>(&store)\n       .unwrap()\n       .call_resumable(&mut store, wasm_trap as i32)\n       .unwrap()\n       .assert_resumable(store, 10, &[ValueType::I32]);\n    let invocation = invocation\n       .resume(&mut store, &[Value::I32(2)])\n       .unwrap()\n       .assert_resumable(store, 20, &[ValueType::I32]);\n    let call = invocation.resume(&mut store, &[Value::I32(3)]);\n    if wasm_trap {\n        match call.unwrap_err() {\n            Error::Trap(trap) => {\n                assert!(matches!(\n                    trap.trap_code(),\n                    Some(TrapCode::UnreachableCodeReached)\n                ));\n            }\n            _ => panic!(\"expected Wasm trap\"),\n        }\n    } else {\n        assert_eq!(call.unwrap().assert_finish(), 4);\n    }\n} [SEP] fn resumable_call() {\n    let (mut store, mut linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, |input: i32| -> Result<i32, Trap> {\n        match input {\n            1 => Err(Trap::i32_exit(10)),\n            2 => Err(Trap::i32_exit(20)),\n            n => Ok(n + 1),\n        }\n    });\n    linker.define(\"env\", \"host_fn\", host_fn).unwrap();\n    let wasm = wat::parse_str(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (param i32) (result i32)))\n            (func (export \"wasm_fn\") (param $wasm_trap i32) (result i32)\n                (local $i_"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::normalize_test", "test": ["fn check_normalize(mant: u64, exp: i32, ymant: u64, yexp: i32) {\n    let mut x = ExtendedFloat80 {\n        mant,\n        exp,\n    };\n    if x.mant!= 0 {\n        assert_eq!(x.mant & (1 << 63), 0);\n        compact::normalize(&mut x);\n        assert_eq!(x.mant & (1 << 63), 1 << 63);\n    }\n    assert_eq!(\n        x,\n        ExtendedFloat80 {\n            mant: ymant,\n            exp: yexp\n        }\n    );\n} [SEP] fn normalize_test() {\n    // f32 cases\n    check_normalize(0, 0, 0, 0);\n    check_normalize(1, -149, 9223372036854775808, -212);\n    check_normalize(71362, -149, 10043308644012916736, -196);\n    check_normalize(12379400, -90, 13611294244890214400, -130);\n    check_normalize(8388608, -23, 9223372036854775808, -63);\n    check_normalize(11368684, 43, 12500000250510966784, 3);\n    check_normalize(16777213, 104, 18446740775174668288, 64);\n\n    // Test a few cases from radix float writer errors.\n    check_normalize(5178144, -22, 11386859076597055488, -63);\n\n    // f64 cases\n    check_normalize(1, -1074, 9223372036854775808, -1137);\n    check_normalize(6448907850777164, -883, 13207363278391631872, -894);\n    check_normalize(7371020360979573, -551, 15095849699286165504, -562);\n    check_normalize(6427752177035961, -202, 13164036458569648128, -213);\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_standalone", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_split_obs_lines_standalone() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-standalone\";\n    RandomFile::new(&at, name).add_lines(4);\n    ucmd.args(&[\"-2\", name]).succeeds().no_stderr().no_stdout();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}    "]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::semicolon_expression_stop", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn semicolon_expression_stop() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var a = 1;\n            + 1;\n            a\n        \"#},\n        1,\n    )]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_store_resolve_with_illegal_tso", "test": ["pub fn resolve_lock_with_illegal_tso(\n        &self,\n        start_ts: impl Into<TimeStamp>,\n        commit_ts: Option<impl Into<TimeStamp>>,\n    ) {\n        let start_ts = start_ts.into();\n        let commit_ts = commit_ts.map(Into::into);\n        let resp = self\n           .store\n           .resolve_lock(self.ctx.clone(), start_ts, commit_ts);\n        self.expect_invalid_tso_err(resp, start_ts, commit_ts.unwrap())\n    } [SEP] fn test_store_resolve_with_illegal_tso() {\n    let store = AssertionStorage::default();\n    let commit_ts = Some(4);\n    let start_ts = 5;\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"p-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n        ],\n        b\"primary\",\n        start_ts,\n    );\n    store.resolve_lock_with_illegal_tso(start_ts, commit_ts);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_metrics.rs::test_txn_gc_keys_handled", "test": ["fn get(&self, mut req: Get) -> PdFuture<GetResponse> {\n        let timer = Instant::now();\n        self.fill_cluster_id_for(req.inner.mut_header());\n        let executor = move |client: &Client, req: GetRequest| {\n            let handler = {\n                let inner = client.inner.rl();\n                let r = inner\n                   .meta_storage\n                   .get_async_opt(&req, call_option_inner(&inner));\n                futures::future::ready(r).err_into().try_flatten()\n            };\n            Box::pin(async move {\n                fail::fail_point!(\"meta_storage_get\", req.key.ends_with(b\"rejectme\"), |_| {\n                    Err(super::Error::Grpc(grpcio::Error::RemoteStopped))\n                });\n                let resp = handler.await?;\n                PD_REQUEST_HISTOGRAM_VEC\n                   .meta_storage_get\n                   .observe(timer.saturating_elapsed_secs());\n                Ok(resp)\n            }) as _\n        };\n\n        self.pd_client\n           .request(req.into(), executor, LEADER_CHANGE_RETRY)\n           .execute()\n    } [SEP] fn test_txn_gc_keys_handled() {\n    let store_id = 1;\n    GC_COMPACTION_FILTER_MVCC_DELETION_MET.reset();\n    GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED.reset();\n\n    let engine = TestEngineBuilder::new().build().unwrap();\n    let mut prefixed_engine = PrefixedEngine(engine.clone());\n\n    let (tx, _rx) = mpsc::channel();\n    let feature_gate = FeatureGate::default();\n    feature_gate.set_version(\"5.0.0\").unwrap();\n    let mut gc_worker = GcWorker::new(\n        prefixed_engine.clone(),\n        tx,\n        GcConfig::default(),\n        feature_gate,\n        Arc::_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_fetch.rs::test_node_compact_entry_cache", "test": ["pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    } [SEP] fn test_node_compact_entry_cache() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.raft_log_reserve_max_ticks = 2;\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_remove_peer(1, new_peer(5, 5));\n\n    // pause snapshot applied\n    fail::cfg(\"before_region_gen_snap\", \"pause\").unwrap();\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    // change one peer to learner\n    cluster.pd_client.add_peer(1, new_learner_peer(5, 5));\n\n    // cause log lag and pause async fetch to check if entry cache is reserved for\n    // the learner\n    for i in 1..6 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n    }\n    std::thread::sleep(Duration::from_millis(100));\n\n    fail::remove(\"before_region_gen_snap\");\n    cluster.pd_client.must_have_peer(1, new_learner_peer(5, 5));\n\n    // if entry cache is not reserved, the learner will not be able to catch up.\n    must_get_equal(&cl_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_linter_is_disabled_when_run_apply", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn no_lint_if_linter_is_disabled_when_run_apply() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n           .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n       .unwrap()\n       .read_to_string(&mut buffer)\n       .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled_when_run_apply\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::no_arguments", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn no_arguments() {\n    new_ucmd!().fails().no_stdout();\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_local_read.rs::test_consistency_after_lease_pass", "test": ["pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    } [SEP] fn test_consistency_after_lease_pass() {\n    let mut cluster = new_server_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run();\n    let leader = new_peer(1, 1);\n    cluster.must_transfer_leader(1, leader);\n\n    // Create clients.\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(Arc::clone(&env)).connect(&cluster.sim.rl().get_addr(1));\n    let client = TikvClient::new(channel);\n\n    let region = cluster.get_region(&b\"key1\"[..]);\n    let region_id = region.id;\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_peer(leader.clone());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n\n    must_raw_put(&client, ctx.clone(), b\"key1\".to_vec(), b\"value1\".to_vec());\n    must_get_equal(&cluster.get_engine(1), b\"key1\", b\"value1\");\n\n    // Ensure the request is executed by the local reader\n    fail::cfg(\"localreader_before_redirect\", \"panic\").unwrap();\n\n    // Lease read works correctly\n    assert_eq!(\n        must_raw_get(&client, ctx.clone(), b\"key1\".to_vec()).unwrap(),\n        b\"value1\".to_vec()\n    );\n\n    // we pause just after pass the lease check, and then remove the peer. We can\n    // still read the relevant value as we should have already got_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_string_operator_is_literal_after_bang", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_string_operator_is_literal_after_bang() {\n    let scenario = TestScenario::new(util_name!());\n    let tests = [\n        [\"!\", \"=\"],\n        [\"!\", \"!=\"],\n        [\"!\", \"-eq\"],\n        [\"!\", \"-ne\"],\n        [\"!\", \"-lt\"],\n        [\"!\", \"-le\"],\n        [\"!\", \"-gt\"],\n        [\"!\", \"-ge\"],\n        [\"!\", \"-ef\"],\n        [\"!\", \"-nt\"],\n        [\"!\", \"-ot\"],\n    ];\n\n    for test in &tests {\n        scenario.ucmd().args(&test[..]).run().code_is(1);\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_io.rs::test_async_io_commit_without_leader_persist", "test": ["pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    } [SEP] fn test_async_io_commit_without_leader_persist() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.cmd_batch_concurrent_ready_max_count = 0;\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_1 = find_peer(&region, 1).cloned().unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_transfer_leader(region.get_id(), peer_1);\n\n    let raft_before_save_on_store_1_fp = \"raft_before_save_on_store_1\";\n    fail::cfg(raft_before_save_on_store_1_fp, \"pause\").unwrap();\n\n    for i in 2..10 {\n        cluster\n           .async_put(format!(\"k{}\", i).as_bytes(), b\"v1\")\n           .unwrap();\n    }\n\n    // Although leader can not persist entries, these entries can be committed\n    must_get_equal(&cluster.get_engine(2), b\"k9\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k9\", b\"v1\");\n    // For now, entries must be applied after persisting\n    must_get_none(&cluster.get_engine(1), b\"k9\");\n\n    fail::remove(raft_before_save_on_store_1_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_tag", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tag() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.write(\"foobar\", \"foo bar\\n\");\n    scene\n       .ccmd(\"sha256sum\")\n       .arg(\"--tag\")\n       .arg(\"foobar\")\n       .succeeds()\n       .stdout_is(\n            \"SHA256 (foobar) = 1f2ec52b774368781bed1d1fb140a92e0eb6348090619c9291f9a5a3c8e8d151\\n\",\n        );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_long_format_multiple_users", "test": ["pub fn stderr_str(&self) -> &str {\n        std::str::from_utf8(&self.stderr).unwrap()\n    } [SEP] fn test_long_format_multiple_users() {\n    // multiple instances of one account we know exists,\n    // the account of the test runner,\n    // and an account that (probably) doesn't exist\n    let runner = match std::env::var(\"USER\") {\n        Ok(user) => user,\n        Err(_) => String::new(),\n    };\n    let args = [\"-l\", \"root\", \"root\", \"root\", &runner, \"no_such_user\"];\n    let ts = TestScenario::new(util_name!());\n    let expect = unwrap_or_return!(expected_result(&ts, &args));\n\n    ts.ucmd()\n       .args(&args)\n       .succeeds()\n       .stdout_is(expect.stdout_str())\n       .stderr_is(expect.stderr_str());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_squeeze_blank", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_stdin_squeeze_blank() {\n    for same_param in [\"-s\", \"--squeeze-blank\", \"--squeeze\"] {\n        new_ucmd!()\n           .arg(same_param)\n           .pipe_in(\"\\n\\na\\n\\n\\n\\n\\nb\\n\\n\\n\")\n           .succeeds()\n           .stdout_only(\"\\na\\n\\nb\\n\\n\");\n    }\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_mkdir_parent() {\n    let _guard = TEST_MUTEX.lock();\n    let scene = TestScenario::new(util_name!());\n    let test_dir = \"parent_dir/child_dir\";\n\n    scene.ucmd().arg(\"-p\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"-p\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"--parent\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"--parents\").arg(test_dir).succeeds();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_with_tab", "test": ["pub fn stdout_does_not_contain<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n           !self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' contains '{}' but should not\",\n            self.stdout_str(),\n            cmp.as_ref(),\n        );\n        self\n    } [SEP] fn test_with_tab() {\n    new_ucmd!()\n       .arg(\"with-tab.txt\")\n       .succeeds()\n       .stdout_contains(\"        \")\n       .stdout_does_not_contain(\"\\t\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_existing", "test": ["pub fn root_dir_resolved(&self) -> String {\n        log_info(\"current_directory_resolved\", \"\");\n        let s = self\n           .subdir\n           .canonicalize()\n           .unwrap()\n           .to_str()\n           .unwrap()\n           .to_owned();\n\n        // Due to canonicalize()'s use of GetFinalPathNameByHandleW() on Windows, the resolved path\n        // starts with '\\\\?\\' to extend the limit of a given path to 32,767 wide characters.\n        //\n        // To address this issue, we remove this prepended string if available.\n        //\n        // Source:\n        // http://stackoverflow.com/questions/31439011/getfinalpathnamebyhandle-without-prepended\n        let prefix = \"\\\\\\\\?\\\\\";\n\n        if let Some(stripped) = s.strip_prefix(prefix) {\n            String::from(stripped)\n        } else {\n            s\n        }\n    } [SEP] fn test_canonicalize_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let actual = ucmd.arg(\"-e\").arg(\".\").run().stdout_move_str();\n    let expect = at.root_dir_resolved() + \"\\n\";\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    assert_eq!(actual, expect);\n}_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_axfr_refused", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    } [SEP] async fn test_axfr_refused() {\n    let mut test = create_test();\n    test.set_allow_axfr(false);\n\n    let origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(test)));\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n    query.set_query_type(RecordType::AXFR);\n\n    let mut question: Message = Message::new();\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n       .lookup(&question_req, None, response_handler.clone())\n       .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::Refused);\n    assert!(result.answers().is_empty());\n    assert!(result.name_servers().is_empty());\n    assert!(result.additionals().is_empty());\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::dont_ignore_comments_in_recipe_by_default", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_nan_test", "test": ["pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    } [SEP] fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}_"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::roundtrip", "test": ["pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    } [SEP] fn roundtrip() {\n    use ron::{de::from_str, ser::to_string};\n\n    {\n        let s = to_string(&Scene2 {\n            foo: Some((122, 13)),\n        })\n       .unwrap();\n        println!(\"{}\", s);\n        let scene: Value = from_str(&s).unwrap();\n        println!(\"{:?}\", scene);\n    }\n    {\n        let s = to_string(&Scene(Some((13, 122)))).unwrap();\n        println!(\"{}\", s);\n        let scene: Value = from_str(&s).unwrap();\n        println!(\"{:?}\", scene);\n    }\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_empty_template", "test": ["pub fn parse(input: &str) -> TeraResult<Vec<Node>> {\n    let mut pairs = match TeraParser::parse(Rule::template, input) {\n        Ok(p) => p,\n        Err(e) => {\n            let fancy_e = e.renamed_rules(|rule| {\n                match *rule {\n                    Rule::EOI => \"end of input\".to_string(),\n                    Rule::int => \"an integer\".to_string(),\n                    Rule::float => \"a float\".to_string(),\n                    Rule::string\n                    | Rule::double_quoted_string\n                    | Rule::single_quoted_string\n                    | Rule::backquoted_quoted_string => {\n                        \"a string\".to_string()\n                    }\n                    Rule::string_concat => \"a concatenation of strings\".to_string(),\n                    Rule::string_expr_filter => \"a string or a concatenation of strings\".to_string(),\n                    Rule::all_chars => \"a character\".to_string(),\n                    Rule::array => \"an array of values\".to_string(),\n                    Rule::array_filter => \"an array of values with an optional filter\".to_string(),\n                    Rule::string_array => \"an array of strings\".to_string(),\n                    Rule::basic_val => \"a value\".to_string(),\n                    Rule::basic_op => \"a mathematical operator\".to_string(),\n                    Rule::comparison_op => \"a comparison operator\".to_string(),\n                    Rule::boolean => \"`true` or `false`\".to_string(),\n                    Rule::ident => \"an identifier (must start with a-z)\".to_string(),\n                    Rule::dotted_ident => \"a dotted identifier (identifiers separated by `.`)\".to_string(),\n                    Rule::dotted_square_bracket_ident => \"a square bracketed identifier (identifiers separated by `.` or `[]`s)\".to_string(),\n                    Rule::square_brackets => \"an identifier, string or integer inside `[]`s\".to_string(),\n                    Rule::basic_expr_filter => \"an expression with an optional filter\".to_string(),\n                    Rule::_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_backup_arg_first", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_arg_backup_arg_first() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a\";\n    let file_b = \"test_mv_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup\").arg(file_a).arg(file_b).succeeds();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_elements_private", "test": ["fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n       .lines()\n       .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n       .collect::<Vec<&'static str>>()\n       .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n       .parse_script(interner)\n       .expect(\"parsing failed\")\n       .to_interned_string(interner);\n    if scenario!= result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n} [SEP] fn class_declaration_elements_private() {\n    test_formatting(\n        r#\"\n        class A {\n            #a;\n            #b = 1;\n            #c() {}\n            #d(a, b, c) {\n                return a + b + c;\n            }\n            set #e(value) {}\n            get #e() {}\n        }\n        \"#,\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_no_such_dir", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_no_such_dir() {\n    new_ucmd!()\n       .args(&[\"-s\", \"0\", \"a/b\"])\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"cannot open 'a/b' for writing: No such file or directory\");\n}    "]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue343", "test": ["pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T:?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n} [SEP] fn issue343() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Users {\n        users: HashMap<String, User>,\n    }\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Max(u16);\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct User {\n        max: Max,\n    }\n\n    let xml = \"<Users>\\\n                        <users>\\\n                            <roger>\\\n                                <max>10</max>\\\n                            </roger>\\\n                        </users>\\\n                    </Users>\";\n    let users: Users = from_str(xml).unwrap();\n\n    assert_eq!(\n        users,\n        Users {\n            users: HashMap::from([(\"roger\".to_string(), User { max: Max(10) })]),\n        }\n    );\n    assert_eq!(to_string(&users).unwrap(), xml);\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_3", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_3() {\n    let original = r##\"# H1 # {#id1}\n## H2 ## with ## multiple ## hashes ## {#id2}\n### with trailing hash # ### {#id3}\n\n#### non-attribute-block {#id4} ####\n\"##;\n    let expected = r##\"<h1 id=\"id1\">H1</h1>\n<h2 id=\"id2\">H2 ## with ## multiple ## hashes</h2>\n<h3 id=\"id3\">with trailing hash #</h3>\n<h4>non-attribute-block {#id4}</h4>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_invalid_goal", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_fmt_invalid_goal() {\n    for param in [\"-g\", \"--goal\"] {\n        new_ucmd!()\n           .args(&[\"one-word-per-line.txt\", param, \"invalid\"])\n           .fails()\n           .code_is(1)\n           .stderr_contains(\"invalid value 'invalid'\");\n    }\n}    "]}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::large_mul_test", "test": ["pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n} [SEP] fn large_mul_test() {\n    // Test by empty\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::new();\n    bigint::large_mul(&mut x, &y);\n    let expected = VecType::new();\n    assert_eq!(&*x, &*expected);\n\n    // Simple case\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(5);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);\n    assert_eq!(&*x, &*expected);\n\n    // Large u32, but still just as easy.\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(0xFFFFFFFE);\n    bigint::large_mul(&mut_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::signature_lifetimes", "test": ["pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    } [SEP] fn signature_lifetimes() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n\n        let _ = {\n            let key = \"hi\".to_string();\n            let value = \"1\".to_string();\n            table.insert(key.as_str(), value.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.get(key.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.remove(key.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.range(key.as_str()..).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.drain(key.as_str()..).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.drain_filter(key.as_str().., |_, _| true).\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_user_id", "test": ["pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    } [SEP] fn test_chown_only_user_id() {\n    // test chown 1111 file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    let result = scene.ucmd().arg(user_id).arg(\"--verbose\").arg(file1).run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    scene\n       .ucmd()\n       .arg(\"0\")\n       .arg(\"--verbose\")\n       .arg(file1)\n       .fails()\n       .stderr_contains(\"failed to change\");\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mysql.rs::parse_identifiers", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_identifiers() {\n    mysql().verified_stmt(\"SELECT $a$, \u00e0\u00e0\");\n}\n\n_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_ignore_block_size_from_env_in_posix_portability_mode", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    } [SEP] fn test_ignore_block_size_from_env_in_posix_portability_mode() {\n    let default_block_size_header = \"1024-blocks\";\n\n    let output = new_ucmd!()\n       .arg(\"-P\")\n       .env(\"DF_BLOCK_SIZE\", \"111\")\n       .env(\"BLOCK_SIZE\", \"222\")\n       .env(\"BLOCKSIZE\", \"333\")\n       .succeeds()\n       .stdout_move_str();\n    let header = output\n       .lines()\n       .next()\n       .unwrap()\n       .to_string()\n       .split_whitespace()\n       .nth(1)\n       .unwrap()\n       .trim()\n       .to_string();\n\n    assert_eq!(header, default_block_size_header);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_key_live", "test": ["pub fn contains_key(&self, key: &JsValue) -> bool {\n        self.map.contains_key(key)\n    } [SEP] fn weak_map_key_live() {\n    run_test(|| {\n        let key = Gc::new(String::from(\"key\"));\n        let key_copy = key.clone();\n\n        let mut map = WeakMap::new();\n\n        map.insert(&key, ());\n\n        assert!(map.contains_key(&key));\n        assert!(map.contains_key(&key_copy));\n\n        assert_eq!(map.remove(&key), Some(()));\n\n        map.insert(&key, ());\n\n        drop(key);\n\n        force_collect();\n\n        assert!(map.contains_key(&key_copy));\n    });\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_negative_offset", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_skip_to_match_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%23%-3\"])\n       .succeeds()\n       .stdout_only(\"93\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(20, 51));\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_relative_dst_already_symlink", "test": ["pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_relative_dst_already_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"file1\");\n    at.symlink_file(\"file1\", \"file2\");\n    ucmd.arg(\"-srf\").arg(\"file1\").arg(\"file2\").succeeds();\n    at.is_symlink(\"file2\");\n}_"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_taptree", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_taptree() {\n    let ver = LeafVersion::from_consensus(0).unwrap();\n    let script = ScriptBuf::from(vec![0u8, 1u8, 2u8]);\n    let mut builder = TaprootBuilder::new().add_leaf_with_ver(1, script.clone(), ver).unwrap();\n    builder = builder.add_leaf(1, script).unwrap();\n    let tree = TapTree::try_from(builder).unwrap();\n\n    let got = serialize(&tree).unwrap();\n    let want = include_bytes!(\"data/serde/taptree_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_multiple_name_value_pairs", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_multiple_name_value_pairs() {\n    let out = new_ucmd!().arg(\"FOO=bar\").arg(\"ABC=xyz\").run();\n\n    assert_eq!(\n        out.stdout_str()\n           .lines()\n           .filter(|&line| line == \"FOO=bar\" || line == \"ABC=xyz\")\n           .count(),\n        2\n    );\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::funcs_live_on_to_fight_another_day", "test": ["pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    } [SEP] fn funcs_live_on_to_fight_another_day() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    let drop_me = DropMe(flag.clone());\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &drop_me;\n    })?;\n    assert_eq!(flag.load(SeqCst), 0);\n\n    let get_and_call = || -> Result<()> {\n        assert_eq!(flag.load(SeqCst), 0);\n        let mut store = Store::new(&engine, ());\n        let func = linker.get(&mut store, \"\", \"\").unwrap();\n        func.into_func().unwrap().call(&mut store, &[], &mut [])?;\n        assert_eq!(flag.load(SeqCst), 0);\n        Ok(())\n    };\n\n    get_and_call()?;\n    get_and_call()?;\n    drop(linker);\n    assert_eq!(flag.load(SeqCst), 1);\n    Ok(())\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_symlink_non_existing_file_recursive", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_chmod_symlink_non_existing_file_recursive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let non_existing = \"test_chmod_symlink_non_existing_file_recursive\";\n    let test_symlink = \"test_chmod_symlink_non_existing_file_recursive_symlink\";\n    let test_directory = \"test_chmod_symlink_non_existing_file_directory\";\n\n    at.mkdir(test_directory);\n    at.symlink_file(non_existing, &format!(\"{test_directory}/{test_symlink}\"));\n\n    // this should succeed\n    scene\n       .ucmd()\n       .arg(\"-R\")\n       .arg(\"755\")\n       .arg(test_directory)\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n\n    let expected_stdout = &format!(\n        // spell-checker:disable-next-line\n        \"mode of '{test_directory}' retained as 0755 (rwxr-xr-x)\"\n    );\n\n    // '-v': this should succeed without stderr\n    scene\n       .ucmd()\n       .arg(\"-R\")\n       .arg(\"-v\")\n       .arg(\"755\")\n       .arg(test_directory)\n       .succeeds()\n       .stdout_contains(expected_stdout)\n       .no_stderr();\n\n    // '-vf': this should be the same than with just '-v'\n    scene\n       .ucmd()\n       .arg(\"-R\")\n       .arg(\"-v\")\n       .arg(\"-f\")\n       .arg(\"755\")"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_hard_logical_non_exit_fail", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_hard_logical_non_exit_fail() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"/no-such-dir\";\n    let link = \"hard-to-dangle\";\n\n    at.relative_symlink_dir(file_a, \"no-such-dir\");\n\n    scene\n       .ucmd()\n       .args(&[\"-L\", \"no-such-dir\", link])\n       .fails()\n       .stderr_contains(\"failed to access 'no-such-dir'\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_garbage", "test": ["pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    } [SEP] fn test_garbage() {\n    let input = \"aGVsbG8sIHdvcmxkIQ==\\0\"; // spell-checker:disable-line\n    new_ucmd!()\n       .arg(\"-d\")\n       .pipe_in(input)\n       .fails()\n       .stderr_only(\"base32: error: invalid input\\n\");\n}    "]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_unknown_type", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    } [SEP] fn test_server_unknown_type() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {ipaddr}\");\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n       .name(\"test_server:udp:server\".to_string())\n       .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n       .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n    let client_result = client\n       .query(\n            &Name::from_str(\"www.example.com.\").unwrap(),\n            DNSClass::IN,\n            RecordType::Unknown(65535),\n        )\n       .expect(\"query failed for unknown\");\n\n    assert_eq!(client_result.response_code(), ResponseCode::NoError);\n    assert_eq!(\n        client_result.queries().first().unwrap().query_type(),\n        RecordType::Unknown(65535)\n    );\n    assert!(client_result.answers().is_empty());\n    assert!(!client_result.name_servers().is_empty());\n    // SOA should be the first record in the response\n    assert_eq!(\n        client_result\n           .name_servers()\n           .first()\n           .expect(\"no SOA present\")\n           .record_type(),\n        RecordType::SOA\n    );\n\n    server_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_number_l", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_split_separator_nl_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=\\n\", \"fivelines.txt\"])\n       .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_trailing_space_0", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn unexpand_trailing_space_0() {\n    // evil\n    // Individual spaces before fields starting with non blanks should not be\n    // converted, unless they are at the beginning of the line.\n    new_ucmd!()\n       .args(&[\"-t4\"])\n       .pipe_in(\"123 \\t1\\n123 1\\n123 \\n123 \")\n       .run()\n       .stdout_is(\"123\\t\\t1\\n123 1\\n123 \\n123 \");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_failed", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_failed() {\n    new_ucmd!().fails();\n}_"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_a_ser", "test": ["fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n} [SEP] fn test_adjacently_a_ser() {\n    let v = EnumStructAdjacently::VariantA {\n        foo: 1,\n        bar: 2,\n        different: Inner::Foo,\n    };\n    let e = \"(type:VariantA,content:(foo:1,bar:2,different:Foo))\";\n    test_ser(&v, e);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header_error_if_negative", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_header_error_if_negative() {\n    new_ucmd!()\n       .args(&[\"--header=-3\"])\n       .run()\n       .stderr_is(\"numfmt: invalid header value '-3'\\n\");\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::drop_table_purge", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn drop_table_purge() {\n    let purge = \"DROP TABLE db.table_name PURGE\";\n    hive().verified_stmt(purge);\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::empty_statement", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn empty_statement() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            ;;;let a = 10;;\n            if(a) ;\n            a\n        \"#},\n        10,\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible_sync", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_df_compatible_sync() {\n    new_ucmd!().arg(\"--sync\").succeeds();\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_batch_raft_fallback", "test": ["pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if!create &&!self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    } [SEP] fn test_batch_raft_fallback() {\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), false);\n    let (mock_server, port) = create_mock_server(service, 60000, 60100).unwrap();\n\n    let mut raft_client = get_raft_client_by_port(port);\n    (0..100).for_each(|_| {\n        raft_client.send(RaftMessage::default()).unwrap();\n        thread::sleep(time::Duration::from_millis(10));\n        raft_client.flush();\n    });\n\n    assert!(msg_count.load(Ordering::SeqCst) > 0);\n    assert_eq!(batch_msg_count.load(Ordering::SeqCst), 0);\n    drop(mock_server)\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_apply_snapshot_with_network_isolation", "test": ["pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    } [SEP] fn test_witness_apply_snapshot_with_network_isolation() {\n    let mut cluster = new_server_cluster(0, 3);\n    configure_for_snapshot(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_witness_peer(3, 3));\n    // Ensure all peers are initialized.\n    std::thread::sleep(Duration::from_millis(100));\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    for i in 0..20 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n    sleep_ms(500);\n\n    // Ignore witness's MsgAppendResponse, after applying snaphost\n    let dropped_msgs = Arc::new(Mutex::new(Vec::new()));\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(r1, 1)\n           .direction(Direction::Recv)\n           .msg_type(MessageType::MsgAppendResponse)\n           .reserve_dropped(Arc::clone(&dropped_msgs)),\n    );\n    cluster.sim.wl().add_recv_filter(1, recv_filter);\n\n    cluster.clear_send_filters();\n    // Wait for leader send snapshot.\n    sleep_ms(500);\n\n    cluster.sim.wl().clear_recv_filters(1);\n\n    // Witness's ProgressState must have been changed to Probe\n    cluster.must_transfer_leader(1,_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_list_all_signals_as_table", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_kill_list_all_signals_as_table() {\n    // Check for a few signals.  Do not try to be comprehensive.\n    new_ucmd!()\n       .arg(\"-t\")\n       .succeeds()\n       .stdout_contains(\"KILL\")\n       .stdout_contains(\"TERM\")\n       .stdout_contains(\"HUP\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_head_invalid_num", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_head_invalid_num() {\n    new_ucmd!()\n       .args(&[\"-c\", \"1024R\", \"emptyfile.txt\"])\n       .fails()\n       .stderr_is(\"head: invalid number of bytes: '1024R'\\n\");\n    new_ucmd!()\n       .args(&[\"-n\", \"1024R\", \"emptyfile.txt\"])\n       .fails()\n       .stderr_is(\"head: invalid number of lines: '1024R'\\n\");\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n       .args(&[\"-c\", \"1Y\", \"emptyfile.txt\"])\n       .fails()\n       .stderr_is(\"head: invalid number of bytes: '1Y': Value too large for defined data type\\n\");\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n       .args(&[\"-n\", \"1Y\", \"emptyfile.txt\"])\n       .fails()\n       .stderr_is(\"head: invalid number of lines: '1Y': Value too large for defined data type\\n\");\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let sizes = [\"1000G\", \"10T\"];\n        for size in &sizes {\n            new_ucmd!().args(&[\"-c\", size]).succeeds();\n        }\n    }\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let sizes = [\"-1000G\", \"-10T\"];\n        for size in &sizes {\n            new_ucmd!()\n               .args(&[\"-c\", size])\n               .fails()\n               .stderr_is(\"head: out of range integral type conversion attempted: number of bytes is too large\\n\");\n"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_single_quoted_aliases", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_mssql_single_quoted_aliases() {\n    let _ = ms_and_generic().one_statement_parses_to(\"SELECT foo 'alias'\", \"SELECT foo AS 'alias'\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nproc.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_sort", "test": ["pub fn sort(state: &State, value: Value, kwargs: Kwargs) -> Result<Value, Error> {\n        let mut items = ok!(state.undefined_behavior().try_iter(value).map_err(|err| {\n            Error::new(ErrorKind::InvalidOperation, \"cannot convert value to list\").with_source(err)\n        }))\n       .collect::<Vec<_>>();\n        let case_sensitive = ok!(kwargs.get::<Option<bool>>(\"case_sensitive\")).unwrap_or(false);\n        if let Some(attr) = ok!(kwargs.get::<Option<&str>>(\"attribute\")) {\n            items.sort_by(|a, b| match (a.get_path(attr), b.get_path(attr)) {\n                (Ok(a), Ok(b)) => sort_helper(&a, &b, case_sensitive),\n                _ => Ordering::Equal,\n            });\n        } else {\n            items.sort_by(|a, b| sort_helper(a, b, case_sensitive))\n        }\n        if let Some(true) = ok!(kwargs.get(\"reverse\")) {\n            items.reverse();\n        }\n        ok!(kwargs.assert_all_used());\n        Ok(Value::from(items))\n    } [SEP] fn test_sort() {\n    let mut v = vec![\n        Value::from(100u64),\n        Value::from(80u32),\n        Value::from(30i16),\n        Value::from(true),\n        Value::from(false),\n        Value::from(99i128),\n        Value::from(1000f32),\n    ];\n    v.sort();\n    insta::assert_debug_snapshot!(&v, @r###\"\n    [\n        false,\n        true,\n        30,\n        80,\n        99,\n        100,\n        1000.0,\n    ]\n    \"###);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nonexistent_file_does_not_exist", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_nonexistent_file_does_not_exist() {\n    new_ucmd!()\n       .args(&[\"-e\", \"nonexistent_file\"])\n       .run()\n       .code_is(1);\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::print_error_from_parent_if_recipe_not_found_in_current", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_once_prompt", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_rm_interactive_once_prompt() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_once_recursive_prompt_file1\";\n    let file2 = \"test_rm_interactive_once_recursive_prompt_file2\";\n    let file3 = \"test_rm_interactive_once_recursive_prompt_file3\";\n    let file4 = \"test_rm_interactive_once_recursive_prompt_file4\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n    at.touch(file4);\n\n    ucmd.arg(\"--interactive=once\")\n       .arg(file1)\n       .arg(file2)\n       .arg(file3)\n       .arg(file4)\n       .pipe_in(\"y\")\n       .succeeds()\n       .stderr_contains(\"remove 4 arguments?\");\n\n    assert!(!at.file_exists(file1));\n    assert!(!at.file_exists(file2));\n    assert!(!at.file_exists(file3));\n    assert!(!at.file_exists(file4));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_context_overflow", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_skip_to_match_context_overflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%45%+10\"])\n       .fails()\n       .stderr_is(\"csplit: '%45%+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"counting splits\")\n       .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%45%+10\", \"-k\"])\n       .fails()\n       .stderr_only(\"csplit: '%45%+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"counting splits\")\n       .count();\n    assert_eq!(count, 0);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_suffix_length_short_concatenated_with_value", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_split_suffix_length_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-a4\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]][[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}    "]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_new_keyword", "test": ["pub fn new(lifetime: Lifetime) -> Self {\n        LifetimeParam {\n            attrs: Vec::new(),\n            lifetime,\n            colon_token: None,\n            bounds: Punctuated::new(),\n        }\n    } [SEP] fn ident_new_keyword() {\n    new(\"abstract\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_verbose_slash", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_rm_verbose_slash() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_verbose_slash_directory\";\n    let file_a = &format!(\"{dir}/test_rm_verbose_slash_file_a\");\n\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    let file_a_normalized = &format!(\n        \"{}{}test_rm_verbose_slash_file_a\",\n        dir,\n        std::path::MAIN_SEPARATOR\n    );\n\n    ucmd.arg(\"-r\")\n       .arg(\"-f\")\n       .arg(\"-v\")\n       .arg(&format!(\"{dir}///\"))\n       .succeeds()\n       .stdout_only(format!(\n            \"removed '{file_a_normalized}'\\nremoved directory '{dir}'\\n\"\n        ));\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_default", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_sync_default() {\n    new_ucmd!().succeeds();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=simple\")\n       .arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .succeeds()\n       .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::tagged_template", "test": ["fn concat() {\n    run_test_actions([\n        TestAction::run_harness(),\n        // Empty ++ Empty\n        TestAction::assert(\"arrayEquals([].concat([]), [])\"),\n        // Empty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([].concat([1]), [1])\"),\n        // NonEmpty ++ Empty\n        TestAction::assert(\"arrayEquals([1].concat([]), [1])\"),\n        // NonEmpty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([1].concat([1]), [1, 1])\"),\n    ]);\n} [SEP] fn tagged_template() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::assert(indoc! {r#\"\n                function tag(t,...args) {\n                    let a = []\n                    a = a.concat([t[0], t[1], t[2]]);\n                    a = a.concat([t.raw[0], t.raw[1], t.raw[2]]);\n                    a = a.concat([args[0], args[1]]);\n                    return a\n                }\n                let a = 10;\n\n                arrayEquals(\n                    tag`result: ${a} \\x26 ${a+10}`,\n                    [ \"result: \", \" & \", \"\", \"result: \", \" \\\\x26 \", \"\", 10, 20 ]\n                )\n            \"#}),\n    ]);\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_not_is_not_empty", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_not_is_not_empty() {\n    new_ucmd!().args(&[\"!\", \"-s\", \"regular_file\"]).succeeds();\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_inexact", "test": ["fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    } [SEP] fn write_batch_delete_range_inexact() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    db.engine.put(b\"g\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"f\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"g\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    db.engine.put(b\"g\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    for i in (0..256_usize).step_\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_numbered_with_t", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_backup_numbered_with_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=t\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_continue_outside_loop", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn invalid_continue_outside_loop() {\n    assert_err_msg(r#\"{% continue %}\"#, &[\"1:1\", \"{% continue %}\", \"expected a template\"]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_yes.rs::test_args", "test": ["pub fn run(&mut self) -> CmdResult {\n        self.run_no_wait().wait().unwrap()\n    } [SEP] fn test_args() {\n    run(&[\"a\", \"bar\", \"c\"], b\"a bar c\\na bar c\\na ba\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_reboot_majority_followers", "test": ["fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_download_sst_blocking_sst_writer", "test": ["pub fn get_is_empty(&self) -> bool {\n        self.is_empty\n    } [SEP] fn test_download_sst_blocking_sst_writer() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n    let temp_dir = Builder::new()\n       .prefix(\"test_download_sst_blocking_sst_writer\")\n       .tempdir()\n       .unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, _) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    // Sleep 20s, make sure it is large than grpc_keepalive_timeout (3s).\n    let sst_writer_open_fp = \"on_open_sst_writer\";\n    fail::cfg(sst_writer_open_fp, \"sleep(20000)\").unwrap();\n\n    // Now perform a proper download.\n    let mut download = DownloadRequest::default();\n    download.set_sst(meta.clone());\n    download.set_storage_backend(external_storage_export::make_local_backend(temp_dir.path()));\n    download.set_name(\"test.sst\".to_owned());\n    download.mut_sst().mut_range().set_start(vec![sst_range.1]);\n    download\n       .mut_sst()\n       .mut_range()\n       .set_end(vec![sst_range.1 + 1]);\n    download.mut_sst().mut_range().set_start(Vec::new());\n    download.mut_sst().mut_range().set_end(Vec::new());\n    let result = import.download(&download).unwrap();\n    assert!(!result.get_is_empty());\n    assert_eq_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::cannot_use_borrow_for_own", "test": ["pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    } [SEP] fn cannot_use_borrow_for_own() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core module $m\n                    (func (export \"f\") (param i32) (result i32)\n                        local.get 0\n                    )\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (borrow $t)) (result (own $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), (Resource<MyType>,)>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource,)).unwrap_err();\n    assert_eq!(err.to_string(), \"cannot lift own resource from a borrow\");\n    Ok(())\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_i64", "test": ["pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T:?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n} [SEP] fn test_parse_i64() {\n    test_parse_ok(vec![\n        (\"-2\", -2),\n        (\"-1234\", -1234),\n        (\" -1234 \", -1234),\n        (&i64::MIN.to_string(), i64::MIN),\n        (&i64::MAX.to_string(), i64::MAX),\n    ]);\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::should_write_to_engine_but_whatever", "test": ["fn should_write_to_engine(&self) -> bool {\n        panic!()\n    } [SEP] fn should_write_to_engine_but_whatever() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() > max_keys {\n            assert!(wb.should_write_to_engine());\n        }\n        if key.len() == max_keys * 2 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        assert!(db.engine.get_value(&key).unwrap().is_some());\n        if key.len() == max_keys * 2 {\n            break;\n        }\n    }\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() > max_keys {\n            assert!(wb.should_write_to_engine());\n        }\n        if key.len() == max_keys * 2 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n\n    let mut_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::do_while_loop_continue", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn do_while_loop_continue() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var i = 0, a = 0, b = 0;\n                do {\n                    i++;\n                    if (i < 2) {\n                        a++;\n                        continue;\n                    }\n                    b++;\n                } while (i < 3)\n            \"#}),\n        TestAction::assert_eq(\"a\", 1),\n        TestAction::assert_eq(\"b\", 2),\n    ]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_delete_lock_proposed_after_proposing_locks_1", "test": ["fn test_delete_lock_proposed_after_proposing_locks_impl(transfer_msg_count: usize) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    txn_ext\n       .pessimistic_locks\n       .write()\n       .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 20.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n       .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let mut req = CleanupRequest::default();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_region_epoch(cluster.get_region_epoch(region_id));\n    ctx.set_peer(leader);\n    req.set_context(ctx);\n    req.set_key(b\"key\".to_vec());\n    req.set_start_version(10);\n    req.set_current_ts(u64::MAX);\n\n    // Pause the command after it mark the lock as deleted.\n    fail"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_read_from_file", "test": ["pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn unexpand_read_from_file() {\n    new_ucmd!()\n       .arg(\"with_spaces.txt\")\n       .arg(\"-t4\")\n       .run()\n       .success();\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_lock_primary", "test": ["pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    } [SEP] fn test_txn_store_lock_primary() {\n    let store = AssertionStorage::default();\n    // txn1 locks \"p\" then aborts.\n    store.prewrite_ok(\n        vec![Mutation::make_put(Key::from_raw(b\"p\"), b\"p1\".to_vec())],\n        b\"p\",\n        1,\n    );\n\n    // txn2 wants to write \"p\", \"s\".\n    store.prewrite_locked(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p\"), b\"p2\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s\"), b\"s2\".to_vec()),\n        ],\n        b\"p\",\n        2,\n        vec![(b\"p\", b\"p\", 1.into())],\n    );\n    // txn2 cleanups txn1's lock.\n    store.rollback_ok(vec![b\"p\"], 1);\n    store.resolve_lock_ok(1, None::<TimeStamp>);\n\n    // txn3 wants to write \"p\", \"s\", neither of them should be locked.\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p\"), b\"p3\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s\"), b\"s3\".to_vec()),\n        ],\n        b\"p\",\n        3,\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_tmpdir", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_mktemp_tmpdir() {\n    let scene = TestScenario::new(util_name!());\n    let dir = tempdir().unwrap();\n    let path = dir.path().join(scene.fixtures.as_string());\n    let pathname = path.as_os_str();\n\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE1)\n       .succeeds();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE2)\n       .fails();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE3)\n       .fails();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE4)\n       .fails();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE5)\n       .succeeds();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE6)\n       .succeeds();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE7)\n       .succeeds();\n    scene\n       .ucmd()\n       .arg(\"-p\")\n       .arg(pathname)\n       .arg(TEST_TEMPLATE8)\n       .fails();\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_smashed_to_lowercase", "test": ["pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n           .as_ref()\n           .map(<DnsName as AsRef<str>>::as_ref)\n    } [SEP] fn server_exposes_offered_sni_smashed_to_lowercase() {\n    // webpki actually does this for us in its DnsName type\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"SECOND.TESTServer.com\"))\n               .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_sort_floating_nodes", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_sort_floating_nodes() {\n    new_ucmd!()\n       .pipe_in(\"d d\\nc c\\na a\\nb b\")\n       .succeeds()\n       .stdout_only(\"a\\nb\\nc\\nd\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_invalid_usage", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_split_separator_invalid_usage() {\n    let scene = TestScenario::new(util_name!());\n    scene\n       .ucmd()\n       .args(&[\"--separator=xx\"])\n       .ignore_stdin_write_error()\n       .pipe_in(\"a\\n\")\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"split: multi-character separator 'xx'\");\n    scene\n       .ucmd()\n       .args(&[\"-ta\", \"-tb\"])\n       .ignore_stdin_write_error()\n       .pipe_in(\"a\\n\")\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"split: multiple separator characters specified\");\n    scene\n       .ucmd()\n       .args(&[\"-t'\\n'\", \"-tb\"])\n       .ignore_stdin_write_error()\n       .pipe_in(\"a\\n\")\n       .fails()\n       .no_stdout()\n       .stderr_contains(\"split: multiple separator characters specified\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_update_config", "test": ["pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    } [SEP] fn test_update_config() {\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n\n    // normal update\n    cfg_controller\n       .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n       .unwrap();\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update not support config\n    let res = cfg_controller.update(change(\"server.addr\", \"localhost:3000\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update to invalid config\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"0\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // bad update request\n    let res = cfg_controller.update(change(\"xxx.yyy\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.xxx\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_order_by", "test": ["fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::instant_close_2", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn instant_close_2() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config());\n    // Unlike `instant_close`, the server sees a valid Initial packet first.\n    pair.drive_client();\n    pair.client\n       .connections\n       .get_mut(&client_ch)\n       .unwrap()\n       .close(pair.time, VarInt(42), Bytes::new());\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),_"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::array", "test": ["fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    } [SEP] fn array() {\n    test(\"[]\", \"[];\");\n    test(\"[,]\", \"[,];\");\n    test(\"[,,]\", \"[,,];\");\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_do_not_use_unified_readpool_with_legacy_config", "test": ["pub fn is_unified_pool_enabled(&self) -> bool {\n        self.storage.use_unified_pool() || self.coprocessor.use_unified_pool()\n    } [SEP] fn test_do_not_use_unified_readpool_with_legacy_config() {\n    let content = r#\"\n        [readpool.storage]\n        normal-concurrency = 1\n\n        [readpool.coprocessor]\n        normal-concurrency = 1\n    \"#;\n    let cfg: TikvConfig = toml::from_str(content).unwrap();\n    assert!(!cfg.readpool.is_unified_pool_enabled());\n}    "]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_string_variable", "test": ["fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n} [SEP] fn test_string_variable() {\n    let needle = r#\"{printf(\"$x\");}\"#;\n    let source = r#\"\n    void func()\n    {\n        printf(\"foo\");\n        printf(\"bar\");\n        printf(id);\n    }\"#;\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 2);\n}"]}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/snapshots.rs::convert_spv_all", "test": ["fn convert_spv(name: &str, adjust_coordinate_space: bool, targets: Targets) {\n    let _ = env_logger::try_init();\n\n    let input = Input::new(Some(\"spv\"), name, \"spv\");\n    let mut module = naga::front::spv::parse_u8_slice(\n        &input.read_bytes(),\n        &naga::front::spv::Options {\n            adjust_coordinate_space,\n            strict_capabilities: false,\n            block_ctx_dump_prefix: None,\n        },\n    )\n   .unwrap();\n    check_targets(&input, &mut module, targets, None);\n} [SEP] fn convert_spv_all() {\n    convert_spv(\n        \"quad-vert\",\n        false,\n        Targets::METAL | Targets::GLSL | Targets::HLSL | Targets::WGSL,\n    );\n    convert_spv(\"shadow\", true, Targets::IR | Targets::ANALYSIS);\n    convert_spv(\n        \"inv-hyperbolic-trig-functions\",\n        true,\n        Targets::HLSL | Targets::WGSL,\n    );\n    convert_spv(\n        \"empty-global-name\",\n        true,\n        Targets::HLSL | Targets::WGSL | Targets::METAL,\n    );\n    convert_spv(\"degrees\", false, Targets::empty());\n    convert_spv(\"binding-arrays.dynamic\", true, Targets::WGSL);\n    convert_spv(\"binding-arrays.static\", true, Targets::WGSL);\n    convert_spv(\n        \"do-while\",\n        true,\n        Targets::METAL | Targets::GLSL | Targets::HLSL | Targets::WGSL,\n    );\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::get_none", "test": ["pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    } [SEP] fn get_none() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    match table.get(&mut store, 0) {\n        Some(Val::FuncRef(None)) => {}\n        _ => panic!(),\n    }\n    assert!(table.get(&mut store, 1).is_none());\n}_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::wasm_file_with_no_abi", "test": ["fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        } [SEP] fn wasm_file_with_no_abi() {\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"run\")\n       .arg(fixtures::fib())\n       .env(\"RUST_LOG\", &*RUST_LOG)\n       .assert();\n\n    assert.success();\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_expression_in_if", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn missing_expression_in_if() {\n    assert_err_msg(\"{% if %}\", &[\"1:7\", \"expected a value that can be negated\"]);\n}"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::eventual_persistence", "test": ["fn test_persistence(durability: Durability) {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(durability);\n    let pairs = gen_data(100, 16, 20);\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..ELEMENTS {\n            let (key, value) = &pairs[i % pairs.len()];\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n\n    let mut key_order: Vec<usize> = (0..ELEMENTS).collect();\n    key_order.shuffle(&mut rand::thread_rng());\n\n    {\n        for i in &key_order {\n            let (key, value) = &pairs[*i % pairs.len()];\n            assert_eq!(table.get(key.as_slice()).unwrap().unwrap().value(), value);\n        }\n    }\n} [SEP] fn eventual_persistence() {\n    test_persistence(Durability::Eventual);\n}\ufffd"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::max_diagnostics", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn max_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    for i in 0..60 {\n        let file_path = PathBuf::from(format!(\"src/file_{i}.js\"));\n        fs.insert(file_path, UNFORMATTED.as_bytes());\n    }\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), (\"--max-diagnostics\"), (\"10\"), (\"src\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut diagnostic_count = 0;\n    let mut filtered_messages = Vec::new();\n\n    for msg in console.out_buffer {\n        let MarkupBuf(nodes) = &msg.content;\n        let is_diagnostic = nodes.iter().any(|node| {\n            node.content\n               .contains(\"File content differs from formatting output\")\n                || node.content.contains(\"format\")\n                || node.content.contains(\"ci\")\n        });\n\n        if is_diagnostic {\n            diagnostic_count += 1;\n        } else {\n            filtered_messages.push(msg);\n        }\n    }\n\n    console.out_buffer = filtered_messages;\n\n    for i in 0..60 {\n        let file_path = format!(\"src/file_{i}.js\");\n        fs.remove(Path::new(&file_path));\n    }\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"max_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n\n    assert_eq!(diagnostic_count, 10);\n}"]}
{"test_id": "casey-just/casey-just-af55be3/tests/edit.rs::editor_precedence", "test": ["pub(crate) fn assert_stdout(output: &std::process::Output, stdout: &str) {\n  assert_success(output);\n  assert_eq!(String::from_utf8_lossy(&output.stdout), stdout);\n} [SEP] fn editor_precedence() {\n  let tmp = temptree! {\n    justfile: JUSTFILE,\n  };\n\n  let output = Command::new(executable_path(\"just\"))\n   .current_dir(tmp.path())\n   .arg(\"--edit\")\n   .env(\"VISUAL\", \"cat\")\n   .env(\"EDITOR\", \"this-command-doesnt-exist\")\n   .output()\n   .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n\n  let output = Command::new(executable_path(\"just\"))\n   .current_dir(tmp.path())\n   .arg(\"--edit\")\n   .env_remove(\"VISUAL\")\n   .env(\"EDITOR\", \"cat\")\n   .output()\n   .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n\n  let cat = which(\"cat\").unwrap();\n  let vim = tmp.path().join(format!(\"vim{EXE_SUFFIX}\"));\n\n  #[cfg(unix)]\n  std::os::unix::fs::symlink(cat, vim).unwrap();\n\n  #[cfg(windows)]\n  std::os::windows::fs::symlink_file(cat, vim).unwrap();\n\n  let path = env::join_paths(\n    iter::once(tmp.path().to_owned()).chain(env::split_paths(&env::var_os(\"PATH\").unwrap())),\n  )\n .unwrap();\n\n  let output = Command::new(executable_path(\"just\"))\n   .current_dir(tmp.path())\n   .arg(\"--edit\")\n   .env(\"PATH\", path)\n   .env_remove(\"VISUAL\")\n   .env_remove(\"EDITOR\")\n   .output()\n   .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_fixed_floats", "test": ["fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-c\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-b\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n} [SEP] fn test_numeric_fixed_floats() {\n    test_helper(\n        \"numeric_fixed_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_in_parent_block", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn error_location_in_parent_block() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"Hello {{ greeting }} {% block bob %}{{ 1 + true }}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ])\n   .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\' (error happened in 'parent').\"\n    );\n}    "]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_boolean_key", "test": ["fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if!json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_case2", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_case2() {\n    new_ucmd!().pipe_in(\"a\\na\\n\").run().stdout_is(\"a\\n\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::create_get_set_externref_tables_via_api", "test": ["pub fn get(&self, index: u32) -> Option<TableElement> {\n        self.elements()\n           .get(index as usize)\n           .map(|p| unsafe { TableElement::clone_from_table_value(self.element_type(), *p) })\n    } [SEP] fn create_get_set_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(\n        &mut store,\n        table_ty,\n        Val::ExternRef(Some(ExternRef::new(42_usize))),\n    )?;\n\n    assert_eq!(\n        *table\n           .get(&mut store, 5)\n           .unwrap()\n           .unwrap_externref()\n           .unwrap()\n           .data()\n           .downcast_ref::<usize>()\n           .unwrap(),\n        42\n    );\n    table.set(&mut store, 5, Val::ExternRef(None))?;\n    assert!(table\n       .get(&mut store, 5)\n       .unwrap()\n       .unwrap_externref()\n       .is_none());\n\n    Ok(())\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_filter_section", "test": ["fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n} [SEP] fn render_filter_section() {\n    let inputs = vec![\n        (\"{% filter upper %}Hello{% endfilter %}\", \"HELLO\"),\n        (\"{% filter upper %}Hello{% if true %} world{% endif %}{% endfilter %}\", \"HELLO WORLD\"),\n        (\"{% filter upper %}Hello {% for i in range(end=3) %}i{% endfor %}{% endfilter %}\", \"HELLO III\"),\n        (\n            \"{% filter upper %}Hello {% for i in range(end=3) %}{% if i == 1 %}{% break %} {% endif %}i{% endfor %}{% endfilter %}\",\n            \"HELLO I\",\n        ),\n        (\"{% filter title %}Hello {% if true %}{{ 'world' | upper | safe }}{% endif %}{% endfilter %}\", \"Hello World\"),\n        (\"{% filter safe %}{% filter upper %}<Hello>{% endfilter %}{% endfilter%}\", \"<HELLO>\")\n    ];\n\n    let context = Context::new();\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_node_pending_peers", "test": ["fn test_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n\n    let region_worker_fp = \"region_apply_snap\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let region_id = cluster.run_conf_change();\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n\n    // To ensure peer 2 is not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n\n    fail::cfg(region_worker_fp, \"sleep(2000)\").unwrap();\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    sleep_ms(1000);\n    let pending_peers = pd_client.get_pending_peers();\n    // Region worker is not started, snapshot should not be applied yet.\n    assert_eq!(pending_peers[&3], new_peer(3, 3));\n    // But it will be applied finally.\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    sleep_ms(100);\n    let pending_peers = pd_client.get_pending_peers();\n    assert!(pending_peers.is_empty());\n} [SEP] fn test_node_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_pending_peers(&mut cluster);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_crc_for_bigger_than_32_bytes", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        if self.first_iteration {\n            self.first_iteration = false;\n        } else {\n            self.number.increment().ok()?;\n        }\n        // The first and third parts are just taken directly from the\n        // struct parameters unchanged.\n        Some(format!(\n            \"{}{}{}\",\n            self.prefix, self.number, self.additional_suffix\n        ))\n    } [SEP] fn test_crc_for_bigger_than_32_bytes() {\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    let result = ucmd.arg(\"chars.txt\").succeeds();\n\n    let mut stdout_split = result.stdout_str().split(' ');\n\n    let cksum: i64 = stdout_split.next().unwrap().parse().unwrap();\n    let bytes_cnt: i64 = stdout_split.next().unwrap().parse().unwrap();\n\n    assert_eq!(cksum, 586_047_089);\n    assert_eq!(bytes_cnt, 16);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_rejects_nan", "test": ["pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    } [SEP] fn test_rejects_nan() {\n    new_ucmd!()\n       .arg(\"NaN\")\n       .fails()\n       .usage_error(\"invalid 'not-a-number' argument: 'NaN'\");\n}    "]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_tail_01", "test": ["pub fn call_resumable<T>(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        inputs: &[Value],\n        outputs: &mut [Value],\n    ) -> Result<ResumableCall, Error> {\n        self.verify_and_prepare_inputs_outputs(ctx.as_context(), inputs, outputs)?;\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context()\n           .store\n           .engine()\n           .clone()\n           .execute_func_resumable(ctx.as_context_mut(), self, inputs, outputs)\n           .map_err(Into::into)\n           .map(ResumableCall::new)\n    } [SEP] fn resumable_call_smoldot_tail_01() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (return_call $host_fn)\n            )\n        )\n        \"#,\n    );\n    assert_eq!(\n        wasm_fn\n           .call_resumable(&mut store, ())\n           .unwrap_err()\n           .i32_exit_status(),\n        Some(100),\n    );\n}_"]}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::factor_test", "test": ["pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n} [SEP] fn factor_test() {\n  assert_eq!(\n    factor(\"  3  \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"3\")))\n  );\n}    "]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::drain_entry", "test": ["pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo,"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_lines_chars", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_utf8_lines_chars() {\n    new_ucmd!()\n       .arg(\"-ml\")\n       .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n       .run()\n       .stdout_is(\"     25     442\\n\");\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_set_time_zone", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_set_time_zone() {\n    match verified_stmt(\"SET TIMEZONE = 'UTC'\") {\n        Statement::SetVariable {\n            local,\n            hivevar,\n            variable,\n            value,\n        } => {\n            assert!(!local);\n            assert!(!hivevar);\n            assert_eq!(variable, ObjectName(vec![\"TIMEZONE\".into()]));\n            assert_eq!(\n                value,\n                vec![Expr::Value(Value::SingleQuotedString(\"UTC\".into()))]\n            );\n        }\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\"SET TIME ZONE TO 'UTC'\", \"SET TIMEZONE = 'UTC'\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_multiple_folders", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_multiple_folders() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let target_dir = \"test_mv_multiple_dirs_dir\";\n    let dir_a = \"test_mv_multiple_dir_a\";\n    let dir_b = \"test_mv_multiple_dir_b\";\n\n    at.mkdir(target_dir);\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n\n    ucmd.arg(dir_a)\n       .arg(dir_b)\n       .arg(target_dir)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_a}\")));\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_b}\")));\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple_type_lifetime", "test": ["fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    } [SEP] fn tuple_type_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table\n           .insert(&(String::from(\"hello\").as_str(), 5), &(0, 123))\n           .unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_first_1000_integers_with_exponents", "test": ["fn finalize<T>(\n    output: &mut Output,\n    rstat: ReadStat,\n    wstat: WriteStat,\n    start: Instant,\n    prog_tx: &mpsc::Sender<ProgUpdate>,\n    output_thread: thread::JoinHandle<T>,\n) -> std::io::Result<()> {\n    // Flush the output, if configured to do so.\n    output.sync()?;\n\n    // Truncate the file to the final cursor location.\n    //\n    // Calling `set_len()` may result in an error (for example,\n    // when calling it on `/dev/null`), but we don't want to\n    // terminate the process when that happens. Instead, we\n    // suppress the error by calling `Result::ok()`. This matches\n    // the behavior of GNU `dd` when given the command-line\n    // argument `of=/dev/null`.\n    if!output.settings.oconv.notrunc {\n        output.dst.truncate().ok();\n    }\n\n    // Print the final read/write statistics.\n    let prog_update = ProgUpdate::new(rstat, wstat, start.elapsed(), true);\n    prog_tx.send(prog_update).unwrap_or(());\n    // Wait for the output thread to finish\n    output_thread\n       .join()\n       .expect(\"Failed to join with the output thread.\");\n    Ok(())\n} [SEP] fn test_first_1000_integers_with_exponents() {\n    use hex_literal::hex;\n    use sha1::{Digest, Sha1};\n\n    let n_integers = 1000;\n    let mut input_string = String::new();\n    for i in 0..=n_integers {\n        input_string.push_str(&(format!(\"{i} \"))[..]);\n    }\n\n    println!(\"STDIN='{input_string}'\");\n    let result = new_ucmd!()\n       .arg(\"-h\")\n       .pipe_in(input_string.as_bytes())\n       .succeeds();\n\n    // Using factor from GNU"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_latency", "test": ["fn test_multi_latency<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(DelayFilter::new(Duration::from_millis(\n        30,\n    ))));\n    test_multi_base_after_bootstrap(cluster);\n} [SEP] fn test_multi_server_latency() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_latency(&mut cluster);\n}"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::trapping", "test": ["pub fn last(&self) -> Option<&V> {\n        self.elems.last()\n    } [SEP] fn trapping() -> Result<(), Error> {\n    const TRAP_IN_F: i32 = 0;\n    const TRAP_NEXT_CALL_HOST: i32 = 1;\n    const TRAP_NEXT_RETURN_HOST: i32 = 2;\n    const TRAP_NEXT_CALL_WASM: i32 = 3;\n    const TRAP_NEXT_RETURN_WASM: i32 = 4;\n\n    let engine = Engine::default();\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |mut caller: Caller<State>, action: i32, recur: i32| -> Result<()> {\n            assert_eq!(caller.data().context.last(), Some(&Context::Host));\n            assert_eq!(caller.data().calls_into_host, caller.data().calls_into_wasm);\n\n            match action {\n                TRAP_IN_F => bail!(\"trapping in f\"),\n                TRAP_NEXT_CALL_HOST => caller.data_mut().trap_next_call_host = true,\n                TRAP_NEXT_RETURN_HOST => caller.data_mut().trap_next_return_host = true,\n                TRAP_NEXT_CALL_WASM => caller.data_mut().trap_next_call_wasm = true,\n                TRAP_NEXT_RETURN_WASM => caller.data_mut().trap_next_return_wasm = true,\n                _ => {} // Do nothing\n            }\n\n            // recur so that we can trigger a next call.\n            // propogate its trap, if it traps!\n            if recur > 0 {\n                let _ = caller\n                   .get_export(\"export\")\n                   .expect(\"caller exports \\\"export\\\"\")\n                   .into_func()\n                   .expect(\"export is a func\")\n                   .typed::<(i32, i32), ()>(\n"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::copy_wrong", "test": ["fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n} [SEP] fn copy_wrong() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n"]}
{"test_id": "casey-just/casey-just-af55be3/tests/unstable.rs::set_unstable_false_with_env_var_unset", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_exr", "test": ["fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n} [SEP] fn truncate_exr() {\n    truncate_images(\"exr\");\n}"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::scientific_exponent_test", "test": ["pub(crate) fn scientific_exponent(\n    exponent: i32,\n    integer_digits: usize,\n    fraction_start: usize,\n) -> i32 {\n    if integer_digits == 0 {\n        let fraction_start = into_i32(fraction_start);\n        exponent.saturating_sub(fraction_start).saturating_sub(1)\n    } else {\n        let integer_shift = into_i32(integer_digits - 1);\n        exponent.saturating_add(integer_shift)\n    }\n} [SEP] fn scientific_exponent_test() {\n    // 0 digits in the integer\n    assert_eq!(scientific_exponent(0, 0, 5), -6);\n    assert_eq!(scientific_exponent(10, 0, 5), 4);\n    assert_eq!(scientific_exponent(-10, 0, 5), -16);\n\n    // >0 digits in the integer\n    assert_eq!(scientific_exponent(0, 1, 5), 0);\n    assert_eq!(scientific_exponent(0, 2, 5), 1);\n    assert_eq!(scientific_exponent(0, 2, 20), 1);\n    assert_eq!(scientific_exponent(10, 2, 20), 11);\n    assert_eq!(scientific_exponent(-10, 2, 20), -9);\n\n    // Underflow\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 0),\n        i32::min_value()\n    );\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 5),\n        i32::min_value()\n    );\n\n    // Overflow\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 0, 0),\n        i32::max_value() - 1\n    );\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 5, 0),\n        i32::max_value()\n    );\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::redefining_loop_value_doesnt_break_loop", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn redefining_loop_value_doesnt_break_loop() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- set string = \"abcdefghdijklm\" | split(pat=\"d\") -%}\n{% for i in string -%}\n    {%- set j = i ~ \"lol\" ~ \" \" -%}\n    {{ j }}\n{%- endfor -%}\n        \"#,\n    )\n   .unwrap();\n    let context = Context::new();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"abclol efghlol ijklmlol \");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_data_but_not_file", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_sync_data_but_not_file() {\n    new_ucmd!()\n       .arg(\"--data\")\n       .fails()\n       .stderr_contains(\"sync: --data needs at least one argument\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_read_leader_with_unapplied_log", "test": ["fn test_read_leader_with_unapplied_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // if peer 2 is unreachable, leader will not send MsgAppend to peer 2, and the\n    // leader will send MsgAppend with committed information to peer 2 after\n    // network recovered, and peer 2 will apply the entry regardless of we add\n    // an filter, so we put k0/v0 to make sure the network is reachable.\n    let (k0, v0) = (b\"k0\", b\"v0\");\n    cluster.must_put(k0, v0);\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), k0, v0);\n    }\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n           .msg_type(MessageType::MsgAppend)\n           .direction(Direction::Recv)\n           .allow(1),\n    ));\n\n    // Make peer 2's msg won't be replicated when it becomes leader,\n    // so the uncommitted entries won't be applied immediately.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n           .msg_type(MessageType::MsgAppend)\n           .direction(Direction::Send),\n    ));\n\n    // Make peer 2 have no way to know the uncommitted_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::path_resolves", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_lease_expired", "test": ["fn test_lease_expired<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(50), None);\n\n    let node_id = 3u64;\n    let store_id = 3u64;\n    let peer = new_peer(store_id, node_id);\n    cluster.run();\n\n    // Write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    // Isolate the leader `peer` from other peers.\n    cluster.add_send_filter(IsolationFilterFactory::new(store_id));\n\n    // Wait for the leader lease to expire and a new leader is elected.\n    thread::sleep(election_timeout * 2);\n\n    // Issue a read request and check the value on response.\n    must_error_read_on_peer(cluster, peer, region, key, Duration::from_secs(1));\n} [SEP] fn test_node_lease_expired() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_lease_expired(&mut cluster);\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::ignore_comments_in_recipe", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_same_file", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_mv_same_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_same_file_a\";\n\n    at.touch(file_a);\n    ucmd.arg(file_a)\n       .arg(file_a)\n       .fails()\n       .stderr_is(format!(\"mv: '{file_a}' and '{file_a}' are the same file\\n\",));\n}    "]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::template_literal", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn template_literal() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            `result: ${a} and ${a+10}`;\n        \"#},\n        \"result: 10 and 20\",\n    )]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_conf_change.rs::test_write_after_destroy", "test": ["pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    } [SEP] fn test_write_after_destroy() {\n    // 3 nodes cluster.\n    let mut cluster = new_server_cluster(0, 3);\n\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // Now region 1 only has peer (1, 1);\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    let apply_fp = \"apply_on_conf_change_1_3_1\";\n    fail::cfg(apply_fp, \"pause\").unwrap();\n\n    cluster.must_transfer_leader(r1, new_peer(1, 1));\n    let conf_change = new_change_peer_request(ConfChangeType::RemoveNode, new_peer(3, 3));\n    let mut epoch = cluster.pd_client.get_region_epoch(r1);\n    let mut admin_req = new_admin_request(r1, &epoch, conf_change);\n    admin_req.mut_header().set_peer(new_peer(1, 1));\n    let (cb1, mut rx1) = make_cb(&admin_req);\n    let engines_3 = cluster.get_all_engines(3_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/gc_worker.rs::test_gc_config_validate", "test": ["pub fn validate(&self) -> std::result::Result<(), Box<dyn std::error::Error>> {\n        if self.split_balance_score > 1.0\n            || self.split_balance_score < 0.0\n            || self.split_contained_score > 1.0\n            || self.split_contained_score < 0.0\n        {\n            return Err(\n                (\"split_balance_score or split_contained_score should be between 0 and 1.\").into(),\n            );\n        }\n        if self.sample_num >= self.qps_threshold {\n            return Err(\n                (\"sample_num should be less than qps_threshold for load-base-split.\").into(),\n            );\n        }\n        if self.grpc_thread_cpu_overload_threshold_ratio > 1.0\n            || self.grpc_thread_cpu_overload_threshold_ratio < 0.0\n            || self.unified_read_pool_thread_cpu_overload_threshold_ratio > 1.0\n            || self.unified_read_pool_thread_cpu_overload_threshold_ratio < 0.0\n            || self.region_cpu_overload_threshold_ratio > 1.0\n            || self.region_cpu_overload_threshold_ratio < 0.0\n        {\n            return Err((\"threshold ratio should be between 0 and 1.\").into());\n        }\n        Ok(())\n    } [SEP] fn test_gc_config_validate() {\n    let cfg = GcConfig::default();\n    cfg.validate().unwrap();\n\n    let mut invalid_cfg = GcConfig::default();\n    invalid_cfg.batch_keys = 0;\n    invalid_cfg.validate().unwrap_err();\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::bigger_switch_example", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn bigger_switch_example() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                function f(a) {\n                    let b;\n\n                    switch (a) {\n                        case 0:\n                            b = \"Mon\";\n                            break;\n                        case 1:\n                            b = \"Tue\";\n                            break;\n                        case 2:\n                            b = \"Wed\";\n                            break;\n                        case 3:\n                            b = \"Thurs\";\n                            break;\n                        case 4:\n                            b = \"Fri\";\n                            break;\n                        case 5:\n                            b = \"Sat\";\n                            break;\n                        case 6:\n                            b = \"Sun\";\n                            break;\n                    }\n                    return b;\n                }\n            \"#}),\n        TestAction::assert_eq(\"f(0)\", \"Mon\"),\n        TestAction::assert_eq(\"f(1)\", \"Tue\"),\n        TestAction::assert_eq(\"f(2)\", \"Wed\"),\n        TestAction::assert_eq(\"f(3)\", \"Thurs\"),\n        TestAction::assert_eq(\"f(4)\", \"Fri\"),\n        TestAction::assert_eq(\"f(5)\", \"Sat\"),\n        TestAction::assert_eq(\"f(6)\", \"Sun\"),\n    ]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_fifo_missing_operand", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_create_fifo_missing_operand() {\n    new_ucmd!().fails().stderr_is(\"mkfifo: missing operand\\n\");\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_unnest", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_unnest() {\n    let sql = \"SELECT UNNEST(make_array(1, 2, 3))\";\n    one_statement_parses_to(sql, sql);\n    let sql = \"SELECT UNNEST(make_array(1, 2, 3), make_array(4, 5))\";\n    one_statement_parses_to(sql, sql);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_symlink_to_regular_file", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_trailing_slash_symlink_to_regular_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"regfile\");\n    at.relative_symlink_file(\"regfile\", \"link\");\n    scene\n       .ucmd()\n       .args(&[\"-ev\", \"./link/\"])\n       .fails()\n       .code_is(1)\n       .stderr_contains(NOT_A_DIRECTORY)\n       .no_stdout();\n    scene\n       .ucmd()\n       .args(&[\"-e\", \"./link\"])\n       .succeeds()\n       .stdout_contains(\"regfile\");\n    scene\n       .ucmd()\n       .args(&[\"-e\", \"./link/more\"])\n       .fails()\n       .code_is(1)\n       .no_stdout();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_one_slash_multi", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_escape_one_slash_multi() {\n    new_ucmd!()\n       .args(&[\"-e\", \"foo\\\\\", \"bar\"])\n       .succeeds()\n       .stdout_only(\"foo\\\\ bar\\n\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_empty", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_realpath_empty() {\n    new_ucmd!().fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_carriage_return_should_be_preserved", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_bytewise_carriage_return_should_be_preserved() {\n    new_ucmd!()\n       .arg(\"-b\")\n       .pipe_in(\"\\r\")\n       .succeeds()\n       .stdout_is(\"\\r\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::simple", "test": ["pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    } [SEP] fn simple() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"a\" (func $log (param \"a\" string)))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func (export \"call\")\n                (canon lift (core func $i \"call\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            \n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/security.rs::test_check_cn_success", "test": ["pub fn kv_get(&self, req: &super::kvrpcpb::GetRequest) -> ::grpcio::Result<super::kvrpcpb::GetResponse> {\n        self.kv_get_opt(req, ::grpcio::CallOption::default())\n    } [SEP] fn test_check_cn_success() {\n    let mut cluster = new_server_cluster(0, 1);\n    let mut allowed_cn = HashSet::default();\n    allowed_cn.insert(\"tikv-server\".to_owned());\n    cluster.cfg.security = test_util::new_security_cfg(Some(allowed_cn));\n    cluster.run();\n\n    let leader = cluster.get_region(b\"\").get_peers()[0].clone();\n    let addr = cluster.sim.rl().get_addr(leader.get_store_id());\n\n    let env = Arc::new(Environment::new(1));\n    let cred = test_util::new_channel_cred();\n    let channel = ChannelBuilder::new(env).secure_connect(&addr, cred);\n\n    let client = TikvClient::new(channel);\n    client.kv_get(&GetRequest::default()).unwrap();\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/init.rs::write_error", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_unicode_filenames", "test": ["pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_unicode_filenames() {\n    let tname = \"\ud83d\ude0e\ud83d\udc9a\ud83e\udd8a\";\n    let test_fn = format!(\"{tname}.txt\");\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    assert_fixture_exists!(test_fn);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", inf!(test_fn), of!(tmp_fn)])\n       .run()\n       .no_stderr()\n       .no_stdout()\n       .success();\n\n    cmp_file!(\n        File::open(fixture_path!(&test_fn)).unwrap(),\n        fix.open(&tmp_fn)\n    );\n}\n\n#[test]    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_tombstone_block_list", "test": ["pub fn send(&mut self, msg: RaftMessage) -> result::Result<(), DiscardReason> {\n        let store_id = msg.get_to_peer().store_id;\n        let grpc_raft_conn_num = self.builder.cfg.value().grpc_raft_conn_num as u64;\n        let conn_id = if grpc_raft_conn_num == 1 {\n            0\n        } else {\n            if self.last_hash.0 == 0 || msg.region_id!= self.last_hash.0 {\n                self.last_hash = (\n                    msg.region_id,\n                    seahash::hash(&msg.region_id.to_ne_bytes()) % grpc_raft_conn_num,\n                );\n            };\n            self.last_hash.1 as usize\n        };\n\n        #[allow(unused_mut)]\n        let mut transport_on_send_store_fp = || {\n            fail_point!(\n                \"transport_on_send_snapshot\",\n                msg.get_message().get_msg_type() == raft::eraftpb::MessageType::MsgSnapshot,\n                |sid| if let Some(sid) = sid {\n                    let sid: u64 = sid.parse().unwrap();\n                    if sid == store_id {\n                        // Forbid building new connections.\n                        fail::cfg(_ON_RESOLVE_FP, &format!(\"1*return({})\", sid)).unwrap();\n                        self.cache.remove(&(store_id, conn_id));\n                        self.pool\n                           .lock()\n                           .unwrap()\n                           .connections\n                           .remove(&(store_id, conn_id));\n                    }\n                }\n            )\n        };\n        transport_on_send_store_fp();\n        loop {\n            if let Some(s) = self.cache.get_mut(&(store_id, conn_id)) {\n                match s.queue.push(msg) {\n                    Ok(_) => {\n                        if!s.dirty {\n                            s.dirty = true;\n                            self.need_flush.push((store_id, conn_id));\n                        }_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_4", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_4() {\n    let original = r##\"# spaces {#myid1}    \n## tabs {#myid2}        \n\"##;\n    let expected = r##\"<h1 id=\"myid1\">spaces</h1>\n<h2 id=\"myid2\">tabs</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}("]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_padding_with_overflow", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_padding_with_overflow() {\n    new_ucmd!()\n       .args(&[\"-i\", \"1000\", \"-s\", \"x\", \"-n\", \"rz\", \"-w\", \"4\", \"simple.txt\"])\n       .run()\n       .stdout_is(\n            \"0001xL1\\n1001xL2\\n2001xL3\\n3001xL4\\n4001xL5\\n5001xL6\\n6001xL7\\n7001xL8\\n8001xL9\\n\\\n             9001xL10\\n10001xL11\\n11001xL12\\n12001xL13\\n13001xL14\\n14001xL15\\n\",\n        );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_older_than_src", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_arg_update_older_dest_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_older_file1\";\n    let new = \"test_cp_arg_update_dest_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n       .arg(old)\n       .arg(\"--update=older\")\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n\n    assert_eq!(at.read(old), \"new content\\n\");\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::delete_variable_in_strict", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn delete_variable_in_strict() {\n    // Checks as per https://tc39.es/ecma262/#sec-delete-operator-static-semantics-early-errors\n    // that delete on a variable name is an error in strict mode code.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            let x = 10;\n            delete x;\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"cannot delete variables in strict mode at line 3, col 1\",\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_too_large_block_size", "test": ["fn run_command(size: &str) {\n        new_ucmd!()\n           .arg(format!(\"--block-size={size}\"))\n           .fails()\n           .stderr_contains(format!(\"--block-size argument '{size}' too large\"));\n    } [SEP] fn test_too_large_block_size() {\n    fn run_command(size: &str) {\n        new_ucmd!()\n           .arg(format!(\"--block-size={size}\"))\n           .fails()\n           .stderr_contains(format!(\"--block-size argument '{size}' too large\"));\n    }\n\n    let too_large_sizes = vec![\"1Y\", \"1Z\"];\n\n    for size in too_large_sizes {\n        run_command(size);\n    }\n}"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_bytes_ser", "test": ["pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T:?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n} [SEP] fn test_bytes_ser() {\n    let buf = vec![];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[]\".to_string());\n\n    let buf = vec![1, 2, 3];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_effective_suffix_hex_last", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_effective_suffix_hex_last() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"-n\",\n        \"4\",\n        \"--hex-suffixes=7\",\n        \"--numeric-suffixes=4\",\n        \"-x\",\n        \"-d\",\n        \"--hex-suffixes=9\",\n        \"threebytes.txt\",\n    ])\n   .succeeds()\n   .no_stdout()\n   .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_context_underflow", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_up_to_match_context_underflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/5/-10\"])\n       .fails()\n       .stdout_is(\"0\\n141\\n\")\n       .stderr_is(\"csplit: '/5/-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"counting splits\")\n       .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/5/-10\", \"-k\"])\n       .fails()\n       .stdout_is(\"0\\n141\\n\")\n       .stderr_is(\"csplit: '/5/-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"counting splits\")\n       .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), \"\");\n    assert_eq!(at.read(\"xx01\"), generate(1, 51));\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_22", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_22() {\n    let original = r##\"# H1 {.foo}bar}\n\"##;\n    let expected = r##\"<h1>H1 {.foo}bar}</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_flag_a_0", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn unexpand_flag_a_0() {\n    new_ucmd!()\n       .args(&[\"--\"])\n       .pipe_in(\"e     E\\nf      F\\ng       G\\nh        H\\n\")\n       .run()\n       .stdout_is(\"e     E\\nf      F\\ng       G\\nh        H\\n\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::passthrough_wrong_type", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn passthrough_wrong_type() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"a\" (borrow $t)) (result (own $t))))\n\n                (core func $f (canon lower (func $f)))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32) (result i32)))\n                    (func (export \"f2\") (param i32)\n                        (drop (call $f (local.get 0)))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n       .root()\n       .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| Ok((r,)))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    _"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_conflict_options", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_output_conflict_options() {\n    for option in [\"-i\", \"-T\", \"-P\"] {\n        new_ucmd!().arg(\"--output=source\").arg(option).fails();\n    }\n}_"]}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_window_update_on_stream_closed_by_data_frame", "test": ["pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    } [SEP] async fn recv_window_update_on_stream_closed_by_data_frame() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n           .method(Method::POST)\n           .uri(\"https://http2.akamai.com/\")\n           .body(())\n           .unwrap();\n\n        let (response, mut stream) = client.send_request(request, false).unwrap();\n\n        // Wait for the response\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n\n        // Send a data frame, this will also close the connection\n        stream.send_data(\"hello\".into(), true).unwrap();\n\n        // keep `stream` from being dropped in order to prevent\n        // it from sending an RST_STREAM frame.\n        //\n        // i know this is kind of evil, but it's necessary to\n        // ensure that the stream is closed by the EOS frame,\n        // and not by the RST_STREAM.\n        std::mem::forget(stream);\n\n        // Wait for the connection to close\n        h2.await.unwrap();\n    };\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n           .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::ignore_recipe_comments_with_shell_setting", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/large_number.rs::test_large_integer_to_float", "test": ["pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T:?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    } [SEP] fn test_large_integer_to_float() {\n    use ron::value::Float;\n    let test_var = std::i64::MAX as u64 + 1;\n    let expected = test_var as f64; // Is exactly representable by f64\n    let test_ser = ron::ser::to_string(&test_var).unwrap();\n    assert_eq!(test_ser, test_var.to_string());\n    let test_deser = ron::de::from_str::<Value>(&test_ser);\n\n    assert_eq!(\n        test_deser.unwrap(),\n        Value::Number(Number::Float(Float::new(expected))),\n    );\n}\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_server_stale_peer_without_data_left_derive_when_split", "test": ["fn test_stale_peer_without_data<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let region = cluster.get_region(b\"\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.must_split(&region, b\"k2\");\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine3 = cluster.get_engine(3);\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    let new_region = if right_derive {\n        cluster.get_region(b\"k1\")\n    } else {\n        cluster.get_region(b\"k3\")\n    };\n    let new_region_id = new_region.get_id();\n    // Block peer (3, 4) at receiving snapshot, but not the heartbeat\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(new_region_id, 3).msg_type(MessageType::MsgSnapshot),\n    ));\n\n    pd_client.must_add_peer(new_region_id, new_peer(3, 4));\n\n    // Wait for the heartbeat broadcasted from peer (1, 1000) to peer (3, 4).\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_failing_no_such_file", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_install_failing_no_such_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"inexistent_file\";\n    let dir1 = \"target_dir\";\n\n    at.mkdir(dir1);\n    at.touch(file1);\n\n    ucmd.arg(file1)\n       .arg(file2)\n       .arg(dir1)\n       .fails()\n       .code_is(1)\n       .stderr_contains(\"No such file or directory\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_empty", "test": ["pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n           .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    } [SEP] fn test_cp_sparse_always_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 4;\n    let buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=always\", \"src_file1\", \"dst_file_sparse\"])\n       .succeeds();\n\n    assert_eq!(at.read_bytes(\"dst_file_sparse\"), buf);\n    assert_eq!(at.metadata(\"dst_file_sparse\").blocks(), 0);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_enter_joint_state", "test": ["pub fn is_in_joint(&self, region_id: u64) -> bool {\n        let region = block_on(self.get_region_by_id(region_id))\n           .unwrap()\n           .expect(\"region not exist\");\n        region.get_peers().iter().any(|p| {\n            p.get_role() == PeerRole::IncomingVoter || p.get_role() == PeerRole::DemotingVoter\n        })\n    } [SEP] fn test_enter_joint_state() {\n    let mut cluster = new_node_cluster(0, 4);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // normal confchange request will not enter joint state\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    assert!(!pd_client.is_in_joint(region_id));\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    assert!(!pd_client.is_in_joint(region_id));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // confchange_v2 request with one conchange request will not enter joint state\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![(ConfChangeType::RemoveNode, new_peer(3, 3))],\n    );\n    assert!(!pd_client.is_in_joint(region_id));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    pd_client.must_joint_confchange(region_id, vec![(ConfChangeType::AddNode, new_peer(3, 3))]);_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_not_invoke_committed_cb_when_fail_to_commit", "test": ["pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    } [SEP] fn test_not_invoke_committed_cb_when_fail_to_commit() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k\", b\"v\");\n\n    // Partition the leader and followers to let the leader fails to commit the\n    // proposal.\n    cluster.partition(vec![1], vec![2, 3]);\n    let write_req = make_write_req(&mut cluster, b\"k1\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n       .sim\n       .rl()\n       .async_command_on_node(1, write_req, cb)\n       .unwrap();\n    // Check the request is proposed but not committed.\n    cb_receivers\n       .committed\n       .recv_timeout(Duration::from_millis(200))\n       .unwrap_err();\n    cb_receivers.proposed.try_recv().unwrap();\n\n    // The election timeout is 250ms by default.\n    let election_timeout = cluster.cfg.raft_store.raft_base_tick_interval.0\n        * cluster.cfg.raft_store.raft_election_timeout_ticks as u32;\n    std::thread::sleep(2 * election_timeout);\n\n    // Make sure a new leader is elected and will discard the previous proposal when\n    // partition is recovered.\n    cluster.must_put(b\"k2\", b\"v\");\n    cluster.clear_send_filters();\n\n    let resp = cb_receivers\n       .applied\n       .recv_timeout(Duration::from_secs(1))\n       .unwrap();\n    assert!(resp.get_header().has_error(), \"{:?}\", resp);\n    //_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::round_to_f64_test", "test": ["fn check_round_to_f64(mant: u64, exp: i32, r_mant: u64, r_exp: i32) {\n    let mut x = ExtendedFloat { mant, exp };\n    x.round_to_native::<f64, _>(round_nearest_tie_even);\n    assert_eq!(\n        x,\n        ExtendedFloat {\n            mant: r_mant,\n            exp: r_exp\n        }\n    );\n} [SEP] fn round_to_f64_test() {\n    // This is lossy, so some of these values are **slightly** rounded.\n\n    // underflow\n    check_round_to_f64(9223372036854775808, -1138, 0, -1074);\n\n    // min value\n    check_round_to_f64(9223372036854775808, -1137, 1, -1074);\n\n    // 1.0e-250\n    check_round_to_f64(15095849699286165504, -562, 7371020360979573, -551);\n\n    // 1.0e-150\n    check_round_to_f64(15095849699286165504, -562, 7371020360979573, -551);\n\n    // 1.0e-45\n    check_round_to_f64(13164036458569648128, -213, 6427752177035961, -202);\n\n    // 1.0e-40\n    check_round_to_f64(10043362776618688512, -196, 4903985730770844, -185);\n\n    // 1.0e-20\n    check_round_to_f64(13611294676837537792, -130, 6646139978924579, -119);\n\n    // 1.0\n    check_round_to_f64(9223372036854775808, -63, 4503599627370496, -52);\n\n    // 1e20\n    check_round_to_f64(12500000000000000000, 3, 6103515625000000,_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_when_symlink_is_absolute_and_enoent", "test": ["pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    } [SEP] fn test_realpath_when_symlink_is_absolute_and_enoent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"dir2\");\n    at.touch(\"dir2/bar\");\n\n    at.mkdir(\"dir1\");\n    at.symlink_file(\"dir2/bar\", \"dir1/foo1\");\n    at.symlink_file(\"/dir2/bar\", \"dir1/foo2\");\n    at.relative_symlink_file(\"../dir2/baz\", \"dir1/foo3\");\n\n    #[cfg(unix)]\n    ucmd.arg(\"dir1/foo1\")\n       .arg(\"dir1/foo2\")\n       .arg(\"dir1/foo3\")\n       .run()\n       .stdout_contains(\"/dir2/bar\\n\")\n       .stdout_contains(\"/dir2/baz\\n\")\n       .stderr_is(\"realpath: dir1/foo2: No such file or directory\\n\");\n\n    #[cfg(windows)]\n    ucmd.arg(\"dir1/foo1\")\n       .arg(\"dir1/foo2\")\n       .arg(\"dir1/foo3\")\n       .run()\n       .stdout_contains(\"\\\\dir2\\\\bar\\n\")\n       .stdout_contains(\"\\\\dir2\\\\baz\\n\")\n       .stderr_is(\"realpath: dir1/foo2: No such file or directory\\n\");\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::large_keys", "test": ["fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    } [SEP] fn large_keys() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; 1024];\n    let value = vec![0u8; 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..100 {\n            key[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..100 {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_intrinsics", "test": ["pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n           !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    } [SEP] fn mismatch_intrinsics() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                ;; note the mismatch where this is an intrinsic for `u` but\n                ;; we're typing it as `t`\n                (core func $t_ctor (canon resource.new $u))\n\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    assert_eq!(\n        ctor.call(&mut store, (100,)).unwrap_err().to_string(),\n        \"unknown handle index 0\"\n    );\n\n    Ok(())\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_shortcut", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_shortcut() {\n    new_ucmd!()\n       .args(&[\"-2\", \"-5\", \"-7\"])\n       .pipe_in(\"\\ta\\tb\\tc\")\n       .succeeds()\n        //          01234567890\n       .stdout_is(\"  a  b c\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_line_length_words", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_utf8_line_length_words() {\n    new_ucmd!()\n       .arg(\"-Lw\")\n       .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n       .run()\n       .stdout_is(\"     87      48\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_offset_repeat_twice", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_up_to_match_offset_repeat_twice() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/+3\", \"{2}\"])\n       .succeeds()\n       .stdout_only(\"24\\n30\\n30\\n57\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 12));\n    assert_eq!(at.read(\"xx01\"), generate(12, 22));\n    assert_eq!(at.read(\"xx02\"), generate(22, 32));\n    assert_eq!(at.read(\"xx03\"), generate(32, 51));\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_no_hex", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_escape_no_hex() {\n    new_ucmd!()\n       .args(&[\"-e\", \"foo\\\\x bar\"])\n       .succeeds()\n       .stdout_only(\"foo\\\\x bar\\n\");\n}\n"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_new_underscore", "test": ["pub fn new(lifetime: Lifetime) -> Self {\n        LifetimeParam {\n            attrs: Vec::new(),\n            lifetime,\n            colon_token: None,\n            bounds: Punctuated::new(),\n        }\n    } [SEP] fn ident_new_underscore() {\n    new(\"_\");\n}_"]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::ceil_divmod_test", "test": ["fn ceil_divmod(self, y: Self) -> (Self, i32) {\n        let q = self / y;\n        let r = self % y;\n        match r == Self::ZERO {\n            true  => (q, i32::as_cast(r)),\n            false => (q + Self::ONE, i32::as_cast(r) - i32::as_cast(y))\n        }\n    } [SEP] fn ceil_divmod_test() {\n    use lexical_util::num::Integer;\n\n    assert_eq!(5usize.ceil_divmod(7), (1, -2));\n    assert_eq!(0usize.ceil_divmod(7), (0, 0));\n    assert_eq!(35usize.ceil_divmod(7), (5, 0));\n    assert_eq!(36usize.ceil_divmod(7), (6, -6));\n}("]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::sort_by", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn sort_by() {\n    let sort_by = \"SELECT * FROM db.table SORT BY a\";\n    hive().verified_stmt(sort_by);\n}_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_btc_locks_inscriptions", "test": ["fn parse(witnesses: &[Witness]) -> Vec<ParsedEnvelope> {\n    ParsedEnvelope::from_transaction(&Transaction {\n      version: 0,\n      lock_time: LockTime::ZERO,\n      input: witnesses\n       .iter()\n       .map(|witness| TxIn {\n          previous_output: OutPoint::null(),\n          script_sig: ScriptBuf::new(),\n          sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n          witness: witness.clone(),\n        })\n       .collect(),\n      output: Vec::new(),\n    })\n  } [SEP] fn send_btc_locks_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let (_, reveal) = inscribe(&rpc_server);\n\n  let output =\n    CommandBuilder::new(\"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 1btc\")\n     .rpc_server(&rpc_server)\n     .run_and_deserialize_output::<Output>();\n\n  assert_eq!(\n    output.transaction,\n    \"0000000000000000000000000000000000000000000000000000000000000000\"\n     .parse()\n     .unwrap()\n  );\n\n  assert_eq!(\n    rpc_server.sent(),\n    &[Sent {\n      amount: 1.0,\n      address: \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\"\n       .parse::<Address<NetworkUnchecked>>()\n       .unwrap()\n       .assume_checked(),\n      locked: vec![OutPoint {\n        txid: reveal,\n        vout: 0,\n      }]\n    }]\n  )\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_limits_table_only", "test": ["pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    } [SEP] fn test_limits_table_only() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, StoreLimitsBuilder::new().table_elements(5).build());\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    // Test instance exports and host objects *not* hitting the limit\n    for memory in IntoIterator::into_iter([\n        instance.get_memory(&mut store, \"m\").unwrap(),\n        Memory::new(&mut store, MemoryType::new(0, None))?,\n    ]) {\n        memory.grow(&mut store, 3)?;\n        memory.grow(&mut store, 5)?;\n        memory.grow(&mut store, 2)?;\n        memory.grow(&mut store, 1)?;\n    }\n\n    // Test instance exports and host objects hitting the limit\n    for table in IntoIterator::into_iter([\n        instance.get_table(&mut store, \"t\").unwrap(),\n        Table::new(\n            &mut store,\n            TableType::new(ValType::FuncRef, 0, None),\n            Val::FuncRef(None),\n        )?,\n    ]) {\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n\n        assert_eq!(\n            table\n               .grow(&mut store, 1, Val::FuncRef(None))\n               .map_err(|e| e.to_string())\n               .unwrap_err(),\n            \"failed to grow table by `1`\"\n        );\n    }\n\n    _"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_recv_buffer_overflow", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn datagram_recv_buffer_overflow() {\n    let _guard = subscribe();\n    const WINDOW: usize = 100;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: Some(WINDOW),\n           ..TransportConfig::default()\n        }),\n       ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_eq!(\n        pair.client_conn_mut(client_ch).datagrams().max_size(),\n        Some(WINDOW - Datagram::SIZE_B_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/sst.rs::other_external_sst_info", "test": ["fn smallest_key(&self) -> &[u8] {\n        panic!()\n    } [SEP] fn other_external_sst_info() -> Result<()> {\n    let tempdir = tempdir();\n    let sst_path = tempdir\n       .path()\n       .join(\"test-data.sst\")\n       .to_string_lossy()\n       .to_string();\n    let sst_builder = <KvTestEngine as SstExt>::SstWriterBuilder::new();\n    let mut sst_writer = sst_builder.build(&sst_path)?;\n\n    sst_writer.put(b\"k1\", b\"v11\")?;\n    sst_writer.put(b\"k9\", b\"v9\")?;\n\n    let info = sst_writer.finish()?;\n\n    assert_eq!(b\"k1\", info.smallest_key());\n    assert_eq!(b\"k9\", info.largest_key());\n    assert_eq!(2, info.num_entries());\n\n    let size = fs::metadata(&sst_path).unwrap().len();\n\n    assert_eq!(size, info.file_size());\n\n    Ok(())\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_custom_suffix_via_env", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_custom_suffix_via_env() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"-b\")\n       .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}_"]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::cpp_namespace", "test": ["fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n} [SEP] fn cpp_namespace() {\n    let source = r#\"\n    void Test::abcdef::hello() {\n        int size = 1;\n        return;\n    }\n    \"#;\n\n    let needle = \"_ $fn(){\n        size = 1;\n        }\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n\n    let needle = \"_ _::$fn(){\n        size = 1;\n        }\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/code_removal.rs::undefined_return", "test": ["fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    } [SEP] fn undefined_return() {\n    test(\"function f(){return undefined;}\", \"function f(){return}\");\n    test(\"function f(){return void 0;}\", \"function f(){return}\");\n    test(\"function f(){return void foo();}\", \"function f(){return void foo()}\");\n    test(\"function f(){if(a()){return undefined;}}\", \"function f(){if(a())return}\");\n}"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_comment", "test": ["pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    } [SEP] fn test_offset_err_comment() {\n    let mut r = Reader::from_str(\"<a><!--b>\");\n    r.trim_text(true);\n\n    next_eq!(r, Start, b\"a\");\n    assert_eq!(r.buffer_position(), 3);\n\n    match r.read_event() {\n        // error at char 4: no closing --> tag found\n        Err(e) => assert_eq!(\n            r.buffer_position(),\n            4,\n            \"expecting buf_pos = 4, found {}, err {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}_"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::client_stateless_reset", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn client_stateless_reset() {\n    let _guard = subscribe();\n    let mut reset_key = vec![0; 64];\n    let mut rng = rand::thread_rng();\n    rng.fill_bytes(&mut reset_key);\n    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);\n\n    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));\n\n    let mut pair = Pair::new(endpoint_config.clone(), server_config());\n    let (_, server_ch) = pair.connect();\n    pair.client.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);\n    // Send something big enough to allow room for a_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::bad_import_alignment", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn bad_import_alignment() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"unaligned-retptr\" (func $unaligned_retptr (result string)))\n  (type $many_arg (tuple\n    string string string string\n    string string string string\n    string\n  ))\n  (import \"unaligned-argptr\" (func $unaligned_argptr (param \"a\" $many_arg)))\n  (core module $libc_panic\n    (memory (export \"memory\") 1)\n    (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n      unreachable)\n  )\n  (core instance $libc_panic (instantiate $libc_panic))\n\n  (core func $unaligned_retptr_lower\n    (canon lower (func $unaligned_retptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n  (core func $unaligned_argptr_lower\n    (canon lower (func $unaligned_argptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n\n  (core module $m\n    (import \"host\" \"unaligned-retptr\" (func $unaligned_retptr (param i32)))\n    (import \"host\" \"unaligned-argptr\" (func $unaligned_argptr (param i32)))\n\n    (func (export \"unaligned-retptr\")\n     (call $unaligned_retptr (i32.const 1)))\n    (func (export \"unaligned-argptr\")\n     (call $unaligned_argptr (i32.const 1)))\n  )\n  (core_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_integration.rs::test_sync_host_func", "test": ["fn into(self) -> MemArg {\n        match self {\n            StackAMode::FPOffset(off, _ty) => MemArg::InitialSPOffset { off },\n            StackAMode::NominalSPOffset(off, _ty) => MemArg::NominalSPOffset { off },\n            StackAMode::SPOffset(off, _ty) => {\n                MemArg::reg_plus_off(stack_reg(), off, MemFlags::trusted())\n            }\n        }\n    } [SEP] fn test_sync_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    integration::add_atoms_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n       .get_func(&mut store, \"int_float_args_shim\")\n       .unwrap()\n       .call(&mut store, &[0i32.into(), 123.45f32.into()], &mut results)\n       .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"int_float_args errno\"\n    );\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_bootstrap.rs::test_bootstrap_half_way_failure_after_bootstrap_cluster", "test": ["fn test_bootstrap_half_way_failure() {\n    let server = test_pd::Server::new(1);\n    let eps = server.bind_addrs();\n    let pd_client = test_pd::util::new_client(eps, None);\n    let path = TempDir::new().unwrap();\n    let engines = engine_test::new_temp_engine(&path);\n    let bootstrap = || {\n        let logger = slog_global::borrow_global().new(o!());\n        let mut bootstrap = Bootstrap::new(&engines.raft, 0, &pd_client, logger);\n        match bootstrap.bootstrap_store() {\n            Ok(store_id) => {\n                let mut store = Store::default();\n                store.set_id(store_id);\n                bootstrap.bootstrap_first_region(&store, store_id)\n            }\n            Err(e) => Err(e),\n        }\n    };\n\n    // Try to start this node, return after persisted some keys.\n    fail::cfg(\"node_after_bootstrap_store\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_store\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    let ident = engines.raft.get_store_ident().unwrap().unwrap();\n    assert_ne!(ident.get_store_id(), 0);\n\n    // Check whether it can bootstrap cluster successfully.\n    fail::remove(\"node_after_bootstrap_store\");\n    fail::cfg(\"node_after_prepare_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_prepare_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    fail::remove(\"node_after_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_prefix_template_separator", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_prefix_template_separator() {\n    new_ucmd!().args(&[\"-p\", \".\", \"-t\", \"a.XXXX\"]).succeeds();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_to_file_with_ibs_obs", "test": ["pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_to_file_with_ibs_obs() {\n    let tname = \"zero-256k\";\n    let test_fn = format!(\"{tname}.txt\");\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    assert_fixture_exists!(test_fn);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"status=none\",\n        inf!(test_fn),\n        of!(tmp_fn),\n        \"ibs=222\",\n        \"obs=111\",\n    ])\n   .run()\n   .no_stderr()\n   .no_stdout()\n   .success();\n\n    cmp_file!(\n        File::open(fixture_path!(&test_fn)).unwrap(),\n        fix.open(&tmp_fn)\n    );\n}_"]}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic.rs::parens_test", "test": ["fn expr(input: &[u8]) -> IResult<&[u8], i64> {\n  let (input, init) = term(input)?;\n  fold_many0(\n    pair(one_of(\"+-\"), term),\n    move || init,\n    |acc, (op, val)| {\n      if op == '+' {\n        acc + val\n      } else {\n        acc - val\n      }\n    },\n  )(input)\n} [SEP] fn parens_test() {\n  assert_eq!(expr(\" (  2 )\"), Ok((\"\", 2)));\n  assert_eq!(expr(\" 2* (  3 + 4 ) \"), Ok((\"\", 14)));\n  assert_eq!(expr(\"  2*2 / ( 5 - 1) + 3\"), Ok((\"\", 4)));\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_offset_date_and_reference", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_both_offset_date_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_date_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let five_days_later = str_to_filetime(\"%Y%m%d%H%M\", \"201501061234\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-d\", \"+5 days\", \"-r\", ref_file, file])\n       .succeeds()\n       .no_stderr();\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, five_days_later);\n    assert_eq!(mtime, five_days_later);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_resolved_ts_with_learners", "test": ["pub fn get_resolved_ts(&self, region_id: &u64) -> Option<u64> {\n        self.registry\n           .lock()\n           .unwrap()\n           .get(region_id)\n           .map(|rp| rp.resolved_ts())\n    } [SEP] fn test_resolved_ts_with_learners() {\n    let cluster = new_server_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new()\n       .cluster(cluster)\n       .build_with_cluster_runner(|cluster| {\n            let r = cluster.run_conf_change();\n            cluster.pd_client.must_add_peer(r, new_learner_peer(2, 2));\n        });\n\n    let rid = suite.cluster.get_region(&[]).id;\n    let req = suite.new_changedata_request(rid);\n    let (mut req_tx, _, receive_event) = new_event_feed(suite.get_region_cdc_client(rid));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n\n    for _ in 0..10 {\n        let event = receive_event(true);\n        if event.has_resolved_ts() {\n            assert!(event.get_resolved_ts().regions == vec![rid]);\n            drop(receive_event);\n            suite.stop();\n            return;\n        }\n    }\n    panic!(\"resolved timestamp should be advanced correctly\");\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_var_object", "test": ["pub fn concat(&self, items: &[JsValue], context: &mut Context<'_>) -> JsResult<Self> {\n        let object = Array::concat(&self.inner.clone().into(), items, context)?\n           .as_object()\n           .cloned()\n           .expect(\"Array.prototype.filter should always return object\");\n\n        Self::from_object(object)\n    } [SEP] fn for_in_var_object() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let obj = { a: \"a\", b: 2};\n                for (var i in obj) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['a', 'b'])\"),\n    ]);\n}\n"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/aot.rs::bare_bones", "test": ["pub fn precompile_component(&self, bytes: &[u8]) -> Result<Vec<u8>> {\n        #[cfg(feature = \"wat\")]\n        let bytes = wat::parse_bytes(&bytes)?;\n        let (mmap, _) = crate::component::Component::build_artifacts(self, &bytes)?;\n        Ok(mmap.to_vec())\n    } [SEP] fn bare_bones() -> Result<()> {\n    let engine = super::engine();\n    let component = Component::new(&engine, \"(component)\")?.serialize()?;\n    assert_eq!(component, engine.precompile_component(b\"(component)\")?);\n\n    let component = unsafe { Component::deserialize(&engine, &component)? };\n    let mut store = Store::new(&engine, ());\n    Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    Ok(())\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_plus", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_trailing_plus() {\n    new_ucmd!()\n       .arg(\"--tabs=1,+5\")\n       .pipe_in(\"\\ta\\tb\\tc\")\n       .succeeds()\n        //          0         1\n        //          012345678901\n       .stdout_is(\" a    b    c\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_resource_types", "test": ["fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n           .await?;\n\n            proxy\n               .wasi_http_incoming_handler()\n               .call_handle(store, req, out)\n               .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    } [SEP] fn mismatch_resource_types() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                (core func $t_ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n\n                (core func $u_dtor (canon resource._"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_circular", "test": ["pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_symlink_circular() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let link = \"test_symlink_circular\";\n\n    ucmd.args(&[\"-s\", link]).succeeds().no_stderr();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), link);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_node_readd_peer", "test": ["fn test_readd_peer<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    pd_client.must_add_peer(r1, new_peer(2, 4));\n\n    cluster.clear_send_filters();\n    cluster.must_put(b\"k4\", b\"v4\");\n    let engine = cluster.get_engine(2);\n    must_get_equal(&engine, b\"k4\", b\"v"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_output_arg", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_df_output_arg() {\n    new_ucmd!().args(&[\"--output=source\", \"-iPT\"]).fails();\n    new_ucmd!().args(&[\"-iPT\", \"--output=source\"]).fails();\n    new_ucmd!()\n       .args(&[\"--output=source\", \"--output=source\"])\n       .fails();\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_duckdb.rs::parse_div_infix", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_div_infix() {\n    duckdb_and_generic().verified_stmt(r#\"SELECT 5 // 2\"#);\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_single", "test": ["pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    } [SEP] fn test_single() {\n    let mut env = Environment::new();\n    env.add_template(\"simple\", \"Hello {{ name }}!\").unwrap();\n    let tmpl = env.get_template(\"simple\").unwrap();\n    let rv = tmpl.render(context!(name => \"Peter\")).unwrap();\n    assert_eq!(rv, \"Hello Peter!\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_existing", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_existing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"--backup=existing\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}_"]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::get_invalid", "test": ["fn is_none(&self) -> bool {\n        self.index ==!0\n    } [SEP] fn get_invalid() {\n    let mut headers = HeaderMap::new();\n    headers.insert(\"foo\", \"bar\".parse().unwrap());\n    assert!(headers.get(\"Evil\\r\\nKey\").is_none());\n}_"]}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_min_max", "test": ["pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index!= len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10!= 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TOD"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_snapshot_failed", "test": ["pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    } [SEP] fn test_snapshot_failed() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"rockskv_async_snapshot\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"snapshot failed\"));\n}_"]}
{"test_id": "pyfisch-cbor/pyfisch-cbor-347a3f0/tests/ser.rs::test_list", "test": ["fn serialize_and_compare<T: Serialize>(value: T, expected: &[u8]) {\n    let mut slice = [0u8; 64];\n    let writer = SliceWrite::new(&mut slice);\n    let mut serializer = Serializer::new(writer);\n    value.serialize(&mut serializer).unwrap();\n    let writer = serializer.into_inner();\n    let end = writer.bytes_written();\n    let slice = writer.into_inner();\n    assert_eq!(&slice[..end], expected);\n} [SEP] fn test_list() {\n    serialize_and_compare(&[1, 2, 3], b\"\\x83\\x01\\x02\\x03\");\n}"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_timeformat", "test": ["pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    } [SEP] fn test_timeformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"TIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n       .compile_expression(\"1687624642.5|timeformat(format=format)\")\n       .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"18:37:22\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"18:37:22.5\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"unix\")).unwrap().to_string(),\n        \"1687624642\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"iso\")).unwrap().to_string(),\n        \"2023-06-24T18:37:22+02:00\"\n    );\n\n    let expr = env\n       .compile_expression(\"1687624642|timeformat(tz='Europe/Moscow')\")\n       .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"19:37\");\n}_"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-migrated.rs::test_parse_string", "test": ["pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T:?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n} [SEP] fn test_parse_string() {\n    test_parse_ok(&[\n        (\n            \"<bla>This is a String</bla>\",\n            \"This is a String\".to_string(),\n        ),\n        (\"<bla></bla>\", \"\".to_string()),\n        (\"<bla>     </bla>\", \"\".to_string()),\n        (\"<bla>&lt;boom/&gt;</bla>\", \"<boom/>\".to_string()),\n        (\"<bla>&#9835;</bla>\", \"\u266b\".to_string()),\n        (\"<bla>&#x266B;</bla>\", \"\u266b\".to_string()),\n        //(\n        //    \"<bla>\u266b<![CDATA[<cookies/>]]>\u266b</bla>\",\n        //    \"\u266b<cookies/>\u266b\".to_string(),\n        //),\n    ]);\n}\n\n#[test]\n#[("]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_with_table_alias", "test": ["pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    } [SEP] fn parse_select_with_table_alias() {\n    let select = verified_only_select(\"SELECT a, b, c FROM lineitem AS l (A, B, C)\");\n    assert_eq!(\n        select.projection,\n        vec![\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"a\")),),\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"b\")),),\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"c\")),),\n        ]\n    );\n    assert_eq!(\n        select.from,\n        vec![TableWithJoins {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(\"lineitem\")]),\n                alias: Some(TableAlias {\n                    name: Ident::new(\"l\"),\n                    columns: vec![Ident::new(\"A\"), Ident::new(\"B\"), Ident::new(\"C\"),],\n                }),\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            joins: vec![],\n        }]\n    );\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::math", "test": ["fn size(x: u32) -> TextSize {\n    TextSize::from(x)\n} [SEP] fn math() {\n    assert_eq!(size(10) + size(5), size(15));\n    assert_eq!(size(10) - size(5), size(5));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_succeed_and_become_leader", "test": ["pub fn must_transfer_leader(&mut self, region_id: u64, leader: metapb::Peer) {\n        let timer = Instant::now();\n        loop {\n            self.reset_leader_of_region(region_id);\n            let cur_leader = self.leader_of_region(region_id);\n            if let Some(ref cur_leader) = cur_leader {\n                if cur_leader.get_id() == leader.get_id()\n                    && cur_leader.get_store_id() == leader.get_store_id()\n                {\n                    return;\n                }\n            }\n            if timer.saturating_elapsed() > Duration::from_secs(5) {\n                panic!(\n                    \"failed to transfer leader to [{}] {:?}, current leader: {:?}\",\n                    region_id, leader, cur_leader\n                );\n            }\n            self.transfer_leader(region_id, leader.clone());\n        }\n    } [SEP] fn test_when_warmup_succeed_and_become_leader() {\n    let mut cluster = run_cluster_and_warm_up_cache_for_store2();\n\n    // Generally, the cache will be compacted during post_apply.\n    // However, if the cache is warmed up recently, the cache should be kept.\n    let applied_index = cluster.apply_state(1, 2).applied_index;\n    cluster.must_put(b\"kk1\", b\"vv1\");\n    cluster.wait_applied_index(1, 2, applied_index + 1);\n\n    // It should ack the message when cache is already warmed up.\n    // It needs not to fetch raft log anymore.\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.sim.wl().clear_recv_filters(1);\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_multiple_fifos", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_create_multiple_fifos() {\n    new_ucmd!()\n       .arg(\"abcde\")\n       .arg(\"def\")\n       .arg(\"sed\")\n       .arg(\"dum\")\n       .succeeds();\n}_"]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::allow_empty_blocks", "test": ["fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n} [SEP] fn allow_empty_blocks() {\n    let needle = \"{if ($x){}}\";\n    let source = r\"\n    void func(){\n    if (foo) {\n        a = 1;\n        b = 2;\n        c = 3;\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_ecdsa_sig", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_ecdsa_sig() {\n    let s = include_str!(\"data/serde/ecdsa_sig_hex\");\n    let sig = ecdsa::Signature {\n        sig: secp256k1::ecdsa::Signature::from_str(s.trim()).unwrap(),\n        hash_ty: EcdsaSighashType::All,\n    };\n\n    let got = serialize(&sig).unwrap();\n    let want = include_bytes!(\"data/serde/ecdsa_sig_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_drop_partition", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn test_drop_partition() {\n    let drop = \"ALTER TABLE db.table DROP PARTITION (a = 1)\";\n    hive().verified_stmt(drop);\n}_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/msrv.rs::ci_files_are_up_to_date", "test": ["fn ensure_file_contents(path: impl AsRef<Path>, contents: impl AsRef<str>) {\n    let path = path.as_ref();\n    let contents = contents.as_ref();\n\n    if let Ok(old_contents) = std::fs::read_to_string(path) {\n        if contents == old_contents {\n            // File is already up to date\n            return;\n        }\n    }\n\n    let display_path = path.strip_prefix(project_root()).unwrap_or(path);\n\n    eprintln!(\"{} was not up-to-date, updating...\", display_path.display());\n\n    if std::env::var(\"CI\").is_ok() {\n        eprintln!(\"Note: run `cargo test` locally and commit the updated files\");\n    }\n\n    if let Some(parent) = path.parent() {\n        let _ = std::fs::create_dir_all(parent);\n    }\n    std::fs::write(&path, contents).unwrap();\n    panic!(\n        \"\\\"{}\\\" was not up to date and has been updated. Please commit the changes and re-run the tests.\",\n        path.strip_prefix(project_root()).unwrap_or(path).display()\n    );\n} [SEP] fn ci_files_are_up_to_date() {\n    let pattern = Regex::new(r#\"MSRV:\\s*\"\\d+\\.\\d+\"\"#).unwrap();\n    let replacement = format!(\"MSRV: \\\"{}\\\"\", MSRV.as_str());\n    let workflows = project_root().join(\".github\").join(\"workflows\");\n\n    for result in workflows.read_dir().unwrap() {\n        let path = result.unwrap().path();\n\n        let contents = std::fs::read_to_string(&path).unwrap();\n        let expected = pattern.replace_all(&contents, &replacement);\n\n        ensure_file_contents(path, expected);\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_not_add_newline_when_line_less_than_fold", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_should_not_add_newline_when_line_less_than_fold() {\n    new_ucmd!().pipe_in(\"1234\").succeeds().stdout_is(\"1234\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_capitalize", "test": ["fn capitalize(&self) -> String {\n        self.char_indices()\n           .fold(String::with_capacity(self.len()), |mut acc, x| {\n                if x.0 == 0 {\n                    acc.push(x.1.to_ascii_uppercase());\n                } else {\n                    acc.push(x.1);\n                }\n                acc\n            })\n    } [SEP] fn test_capitalize() {\n    assert_eq!(\"Zbnmasd\", \"zbnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"Abnmasd\", \"Abnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"1masd\", \"1masd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"\", \"\".capitalize());\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_none", "test": ["fn assert_engine_error<T>(r: engine_traits::Result<T>) {\n    match r {\n        Err(engine_traits::Error::Engine(_)) => {}\n        Err(e) => panic!(\"expected Error::Engine, got {:?}\", e),\n        Ok(_) => panic!(\"expected Error::Engine, got Ok\"),\n    }\n} [SEP] fn save_point_rollback_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_almost_and_already_full_behavior", "test": ["pub fn has_disk_full(&self) -> bool {\n        self.disk_full.is_some()\n    } [SEP] fn test_almost_and_already_full_behavior() {\n    let mut cluster = new_server_cluster(0, 5);\n    // To ensure the thread has full store disk usage infomation.\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_transfer_leader(region.get_id(), new_peer(1, 1));\n    // To ensure followers have reported disk usages to the leader.\n    for i in [2u64, 3] {\n        fail::cfg(get_fp(DiskUsage::AlmostFull, i), \"return\").unwrap();\n    }\n    for i in [4u64, 5] {\n        fail::cfg(get_fp(DiskUsage::AlreadyFull, i), \"return\").unwrap();\n    }\n    for i in 1..5 {\n        ensure_disk_usage_is_reported(&mut cluster, i + 1, i + 1, &region);\n    }\n\n    let lead_client = PeerClient::new(&cluster, 1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&cluster.pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k2\", b\"v2\")],\n        b\"k2\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    lead_client.must_kv_commit(\n        vec![b\"k2\".to_vec()],\n        prewrite_ts,\n        get_tso(&cluster.pd_client),\n_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_duplicate_files", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_duplicate_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_COPY_TO_FOLDER)\n       .succeeds()\n       .stderr_contains(\"specified more than once\");\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_simple", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_backup_simple() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n       .ucmd()\n       .arg(\"--backup=simple\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::dont_see_stale_stack_walking_registers", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn dont_see_stale_stack_walking_registers() -> Result<()> {\n    let engine = Engine::default();\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"host_start\" (func $host_start))\n                (import \"\" \"host_get_trap\" (func $host_get_trap))\n                (export \"get_trap\" (func $host_get_trap))\n\n                ;; We enter and exit Wasm, which saves registers in the\n                ;; `VMRuntimeLimits`. Later, when we call a re-exported host\n                ;; function, we should not accidentally reuse those saved\n                ;; registers.\n                (start $start)\n                (func $start\n                    (call $host_start)\n                )\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n\n    let host_start = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Ok(()),\n    );\n    linker.define(&store, \"\", \"host_start\", host_start)?;\n\n    let host_get_trap = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Err(anyhow::anyhow!(\"trap!!!\")),\n    );\n    linker.define(&store, \"\", \"host_get_trap\", host_get_trap)?;\n\n    let instance = linker.instantiate(&mut store, &module)?;\n    let get_trap = instance.get_func(&mut store, \"get_trap\").unwrap();\n\n    _"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber_inferred_arg", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_arg_no_clobber_inferred_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .arg(\"--no-clob\")\n       .fails();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_args_dir_symlinks", "test": ["pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    } [SEP] fn valid_context_directory_recursive_follow_args_dir_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    /*\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(\"c\", lc_path.to_str().unwrap());\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap(),\n        None\n    );\n    */\n\n    // -H: if a command line argument is a symbolic link to a directory, traverse it.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-H\", new_la_context])\n       .arg(dir.plus(\"la\"))\n       .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n           .unwrap()\n           .as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    /*\n    assert_eq!(\n        get_file_context(dir.plus_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_empty_file", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_line_bytes_no_empty_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"1\"])\n       .pipe_in(\"1\\n2222\\n3\\n4\")\n       .succeeds()\n       .no_stdout()\n       .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\");\n    assert_eq!(at.read(\"xab\"), \"\\n\");\n    assert_eq!(at.read(\"xac\"), \"2\");\n    assert_eq!(at.read(\"xad\"), \"2\");\n    assert_eq!(at.read(\"xae\"), \"2\");\n    assert_eq!(at.read(\"xaf\"), \"2\");\n    assert_eq!(at.read(\"xag\"), \"\\n\");\n    assert_eq!(at.read(\"xah\"), \"3\");\n    assert_eq!(at.read(\"xai\"), \"\\n\");\n    assert_eq!(at.read(\"xaj\"), \"4\");\n    assert!(!at.plus(\"xak\").exists());\n}\ufffd"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_fail_and_its_timeout_is_too_long", "test": ["pub fn get_id(&self) -> DownstreamId {\n        self.id\n    } [SEP] fn test_when_warmup_fail_and_its_timeout_is_too_long() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.max_entry_cache_warmup_duration = ReadableDuration::secs(1000);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.transfer_leader(1, new_peer(2, 2));\n    // Theoretically, the leader transfer can't succeed unless it sleeps\n    // max_entry_cache_warmup_duration.\n    sleep_ms(50);\n    let leader = cluster.leader_of_region(1).unwrap();\n    assert_eq!(leader.get_id(), 1);\n}_"]}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/cjk_compat_variants.rs::test_cjk_compat_variants", "test": ["fn next (& mut self) -> Option < char > { let next = self. iter. next () ; if let Some (c) = next { if canonical_combining_class (c)!= 0 { * self. value. borrow_mut () += 1 ; } } next } [SEP] fn test_cjk_compat_variants() {\n    // These codepoints have singleton decompositions in the canonical\n    // decomposition, and can use standardized variations.\n    let s = \"\\u{2f999}\\u{2f8a6}\";\n\n    // These codepoints have canonical decompositions.\n    let mut nfd_iter = s.chars().nfd();\n    assert_eq!(nfd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfd_iter.next(), None);\n\n    let mut nfkd_iter = s.chars().nfkd();\n    assert_eq!(nfkd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfkd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfkd_iter.next(), None);\n\n    let mut nfc_iter = s.chars().nfc();\n    assert_eq!(nfc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfc_iter.next(), None);\n\n    let mut nfkc_iter = s.chars().nfkc();\n    assert_eq!(nfkc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfkc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfkc_iter.next(), None);\n\n    // However they also have standardized variants.\n    let mut var_iter = s.chars_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_macros", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn can_remove_whitespace_macros() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\" {%- import \"macros\" as macros -%} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {% import \"macros\" as macros %} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {%- import \"macros\" as macros %} {%- set hey = macros::hey() -%} {{hey}}\"#, \"Hey!\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"macros\", \"{% macro hey() -%} Hey! {%- endmacro %}\"),\n            (\"tpl\", input),\n        ])\n       .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::specify_env", "test": ["fn success() -> Self {\n        Self::Success\n    } [SEP] fn specify_env() -> Result<()> {\n    // By default no env is inherited\n    let output = get_wasmtime_command()?\n       .args(&[\"run\", \"tests/all/cli_tests/print_env.wat\"])\n       .env(\"THIS_WILL_NOT\", \"show up in the output\")\n       .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n\n    // Specify a single env var\n    let output = get_wasmtime_command()?\n       .args(&[\n            \"run\",\n            \"--env\",\n            \"FOO=bar\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n       .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a single env var\n    let output = get_wasmtime_command()?\n       .args(&[\"run\", \"--env\", \"FOO\", \"tests/all/cli_tests/print_env.wat\"])\n       .env(\"FOO\", \"bar\")\n       .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a nonexistent env var\n    let output = get_wasmtime_command()?\n       .args(&[\n            \"run\",\n            \"--env\",\n            \"SURELY_THIS_ENV_VAR_DOES_NOT_EXIST_ANYWHERE_RIGHT\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n       .output()?;\n    assert!(!output.status.success());\n\n    Ok(())\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_restart_after_apply_premerge_before_apply_compact_log", "test": ["pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    } [SEP] fn test_node_merge_restart_after_apply_premerge_before_apply_compact_log() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(11);\n    // Rely on this config to trigger a compact log\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize(1));\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(10);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    // Prevent gc_log_tick to propose a compact log\n    let raft_gc_log_tick_fp = \"on_raft_gc_log_tick\";\n    fail::cfg(raft_gc_log_tick_fp, \"return()\").unwrap();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n    let left_peer_1 = find_peer(&left, 1).cloned().unwrap();\n    cluster_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::instanceofoperator_rhs_not_callable", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn instanceofoperator_rhs_not_callable() {\n    run_test_actions([TestAction::assert_native_error(\n        \"let s = new String(); s instanceof {}\",\n        JsNativeErrorKind::Type,\n        \"right-hand side of 'instanceof' is not callable\",\n    )]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_sst_recovery.rs::test_sst_recovery_basic", "test": ["fn lock(primary: &[u8]) -> PessimisticLock {\n        PessimisticLock {\n            primary: primary.to_vec().into_boxed_slice(),\n            start_ts: 100.into(),\n            ttl: 3000,\n            for_update_ts: 110.into(),\n            min_commit_ts: 110.into(),\n            last_change_ts: 105.into(),\n            versions_to_last_change: 2,\n        }\n    } [SEP] fn test_sst_recovery_basic() {\n    let (mut cluster, pd_client, engine1) = create_tikv_cluster_with_one_node_damaged();\n\n    // Test that only sst recovery can delete the sst file, remove peer don't delete\n    // it.\n    fail::cfg(\"sst_recovery_before_delete_files\", \"pause\").unwrap();\n\n    let store_meta = cluster.store_metas.get(&1).unwrap().clone();\n    std::thread::sleep(CHECK_DURATION);\n    assert_eq!(\n        store_meta\n           .lock()\n           .unwrap()\n           .get_all_damaged_region_ids()\n           .len(),\n        2\n    );\n\n    // Remove peers for safe deletion of files in sst recovery.\n    let region = cluster.get_region(b\"2\");\n    let peer = find_peer(&region, 1).unwrap();\n    pd_client.must_remove_peer(region.id, peer.clone());\n    let region = cluster.get_region(b\"4\");\n    let peer = find_peer(&region, 1).unwrap();\n    pd_client.must_remove_peer(region.id, peer.clone());\n\n    // Read from other store must success.\n    assert_eq!(cluster.must_get(b\"4\").unwrap(), b\"val\");\n\n    std::thread::sleep(CHECK_DURATION);\n\n    must_get_equal(&engine1, b\"1\", b\"val\");\n    must_get_equal(&engine1, b\"7\", b\"val\");\n    assert_corruption(engine1.get_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_fail_id", "test": ["pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    } [SEP] fn test_chown_fail_id() {\n    // test chown 1111. file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n       .ucmd()\n       .arg(format!(\"{user_id}:\"))\n       .arg(file1)\n       .fails()\n       .stderr_contains(\"invalid spec\");\n\n    scene\n       .ucmd()\n       .arg(format!(\"{user_id}.\"))\n       .arg(file1)\n       .fails()\n       .stderr_contains(\"invalid spec\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_backspaced_char_should_be_preserved", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_bytewise_backspaced_char_should_be_preserved() {\n    new_ucmd!()\n       .arg(\"-b\")\n       .pipe_in(\"x\\x08\")\n       .succeeds()\n       .stdout_is(\"x\\x08\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::integers", "test": ["fn call_and_post_return(&self, mut store: impl AsContextMut, params: P) -> Result<R> {\n        let result = self.call(&mut store, params)?;\n        self.post_return(&mut store)?;\n        Ok(result)\n    } [SEP] fn integers() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"take-i32-100\") (param i32)\n                    local.get 0\n                    i32.const 100\n                    i32.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"take-i64-100\") (param i64)\n                    local.get 0\n                    i64.const 100\n                    i64.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"ret-i32-0\") (result i32) i32.const 0)\n                (func (export \"ret-i64-0\") (result i64) i64.const 0)\n                (func (export \"ret-i32-minus-1\") (result i32) i32.const -1)\n                (func (export \"ret-i64-minus-1\") (result i64) i64.const -1)\n                (func (export \"ret-i32-100000\") (result i32) i32.const 100000)\n            )\n            (core instance $i (instantiate (module $m)))\n            (func (export \"take-u8\") (param \"a\" u8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s8\") (param \"a\" s8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u16\") (param \"a\" u16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s16\") (param \"a\" s16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u32_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_quiet_n_verbose_used_multiple_times", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_quiet_n_verbose_used_multiple_times() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n    scene\n       .ucmd()\n       .arg(\"u+x\")\n       .arg(\"--verbose\")\n       .arg(\"--verbose\")\n       .arg(\"file\")\n       .succeeds();\n    scene\n       .ucmd()\n       .arg(\"u+x\")\n       .arg(\"--quiet\")\n       .arg(\"--quiet\")\n       .arg(\"file\")\n       .succeeds();\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/table.rs::table_test_4", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn table_test_4() {\n    let original = r##\" 1. First entry\n 2. Second entry\n\n    Col 1|Col 2\n    -|-\n    Row 1|Part 2\n    Row 2|Part 2\n\"##;\n    let expected = r##\"<ol>\n<li>\n<p>First entry</p>\n</li>\n<li>\n<p>Second entry</p>\n<table><thead><tr><th>Col 1</th><th>Col 2</th></tr></thead>\n<tr><td>Row 1</td><td>Part 2</td></tr>\n<tr><td>Row 2</td><td>Part 2</td></tr>\n</table>\n</li>\n</ol>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}v"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_37", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_37() {\n    let original = r##\"{}\n==\n\n\\{}\n--\n\n\\\n--\n\n{\\}\n==\n\n{}{}\n--\n\"##;\n    let expected = r##\"<h1></h1>\n<h2>\\</h2>\n<h2>\\</h2>\n<h1>{}</h1>\n<h2>{}</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}("]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_server_data_sent", "test": ["fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    } [SEP] fn buffered_server_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, server.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n\n        check_read(&mut client.reader(), b\"hello\");\n    }\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_15", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_15() {\n    let original = r##\"# *H1* { #id1 }\n## **H2** {#id2}\n### _H3_ {#id3}\n#### ~~H4~~ {#id4}\n##### [text](uri) {#id5}\n\"##;\n    let expected = r##\"<h1 id=\"id1\"><em>H1</em></h1>\n<h2 id=\"id2\"><strong>H2</strong></h2>\n<h3 id=\"id3\"><em>H3</em></h3>\n<h4 id=\"id4\"><del>H4</del></h4>\n<h5 id=\"id5\"><a href=\"uri\">text</a></h5>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_host", "test": ["pub fn i32_exit_status(&self) -> Option<i32> {\n        if let Self::I32Exit(status) = self {\n            return Some(*status);\n        }\n        None\n    } [SEP] fn resumable_call_host() {\n    let (mut store, _linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, || -> Result<(), Trap> {\n        Err(Trap::i32_exit(100))\n    });\n    // Even though the called host function traps we expect a normal error\n    // since the host function is the root function of the call and therefore\n    // it would not make sense to resume it.\n    let error = host_fn\n       .call_resumable(&mut store, &[], &mut [])\n       .unwrap_err();\n    match error {\n        Error::Trap(trap) => {\n            assert_eq!(trap.i32_exit_status(), Some(100));\n        }\n        _ => panic!(\"expected Wasm trap\"),\n    }\n    // The same test for `TypedFunc`:\n    let trap = host_fn\n       .typed::<(), ()>(&store)\n       .unwrap()\n       .call_resumable(&mut store, ())\n       .unwrap_err();\n    assert_eq!(trap.i32_exit_status(), Some(100));\n}_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/find.rs::no_satoshi_index", "test": ["pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  } [SEP] fn no_satoshi_index() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  CommandBuilder::new(\"find 0\")\n   .rpc_server(&rpc_server)\n   .expected_stderr(\"error: find requires index created with `--index-sats` flag\\n\")\n   .expected_exit_code(1)\n   .run_and_extract_stdout();\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_base_not_prefix_of_relative_to", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_relative_base_not_prefix_of_relative_to() {\n    let result = new_ucmd!()\n       .args(&[\n            \"-sm\",\n            \"--relative-base=/usr/local\",\n            \"--relative-to=/usr\",\n            \"/usr\",\n            \"/usr/local\",\n        ])\n       .succeeds();\n\n    #[cfg(windows)]\n    result.stdout_matches(&Regex::new(r\"^.*:\\\\usr\\n.*:\\\\usr\\\\local\\n$\").unwrap());\n\n    #[cfg(not(windows))]\n    result.stdout_is(\"/usr\\n/usr/local\\n\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_negative_duration", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_sleep_negative_duration() {\n    new_ucmd!().args(&[\"-1\"]).fails();\n    new_ucmd!().args(&[\"-1s\"]).fails();\n    new_ucmd!().args(&[\"-1m\"]).fails();\n    new_ucmd!().args(&[\"-1h\"]).fails();\n    new_ucmd!().args(&[\"-1d\"]).fails();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_floats", "test": ["fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-c\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-b\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n} [SEP] fn test_numeric_floats() {\n    test_helper(\n        \"numeric_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_shortcut_combined_with_all_arg", "test": ["fn run_cmd(arg: &str, expected_prefix: &str, expected_suffix: &str) {\n        let expected_msg = format!(\n            \"{} specifier not at start of number: {}\",\n            expected_prefix.quote(),\n            expected_suffix.quote()\n        );\n        new_ucmd!().arg(arg).fails().stderr_contains(expected_msg);\n    } [SEP] fn test_tabs_shortcut_combined_with_all_arg() {\n    fn run_cmd(all_arg: &str) {\n        new_ucmd!()\n           .args(&[all_arg, \"-3\"])\n           .pipe_in(\"a  b  c\")\n           .run()\n           .stdout_is(\"a\\tb\\tc\");\n    }\n\n    let all_args = vec![\"-a\", \"--all\"];\n\n    for arg in all_args {\n        run_cmd(arg);\n    }\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_repeat", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_too_small_line_num_repeat() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"10\", \"{*}\"])\n       .fails()\n       .stderr_is(\"csplit: '10': line number out of range on repetition 5\\n\")\n       .stdout_is(\"48\\n0\\n0\\n30\\n30\\n30\\n3\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"10\", \"{*}\", \"-k\"])\n       .fails()\n       .stderr_is(\"csplit: '10': line number out of range on repetition 5\\n\")\n       .stdout_is(\"48\\n0\\n0\\n30\\n30\\n30\\n3\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 7);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), \"\");\n    assert_eq!(at.read(\"xx03\"), generate(20, 30));\n    assert_eq!(at.read(\"xx04\"), generate(30, 40));\n    assert_eq!(at.read(\"xx05\"), generate(40, 50));\n    assert_eq!(at.read(\"xx06\"), \"50\\n\");\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::r#try", "test": ["fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    } [SEP] fn r#try() {\n    test_formatting(\n        r#\"\n        try {\n            throw \"hello\";\n        } catch(e) {\n            console.log(e);\n        } finally {\n            console.log(\"things\");\n        }\n        try {\n            throw \"hello\";\n        } catch {\n            console.log(\"something went wrong\");\n        }\n        \"#,\n    );\n}_"]}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encode_all_ascii", "test": ["fn compare_encode(expected: &str, target: &[u8]) {\n    assert_eq!(expected, STANDARD.encode(target));\n} [SEP] fn encode_all_ascii() {\n    let ascii: Vec<u8> = (0..=127).collect();\n\n    compare_encode(\n        \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7P\\\n         D0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn8\\\n         =\",\n        &ascii,\n    );\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_final_newline", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_line_bytes_no_final_newline() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"2\"])\n       .pipe_in(\"1\\n2222\\n3\\n4\")\n       .succeeds()\n       .no_stdout()\n       .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n\");\n    assert_eq!(at.read(\"xab\"), \"22\");\n    assert_eq!(at.read(\"xac\"), \"22\");\n    assert_eq!(at.read(\"xad\"), \"\\n\");\n    assert_eq!(at.read(\"xae\"), \"3\\n\");\n    assert_eq!(at.read(\"xaf\"), \"4\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_hex_suffix_with_value_spaced", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_short_hex_suffix_with_value_spaced() {\n    new_ucmd!()\n       .args(&[\"-n\", \"4\", \"-x\", \"9\", \"threebytes.txt\"])\n       .fails()\n       .stderr_contains(\"split: cannot open '9' for reading: No such file or directory\");\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::test_unknown_import_error", "test": ["pub(crate) fn module(&self) -> &Arc<Module> {\n        self.runtime_info.module()\n    } [SEP] fn test_unknown_import_error() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"unknown-module\" \"unknown-name\" (func)))\"#,\n    )?;\n    let err = linker\n       .instantiate(&mut store, &module)\n       .expect_err(\"should fail\");\n    let unknown_import: UnknownImportError = err.downcast()?;\n    assert_eq!(unknown_import.module(), \"unknown-module\");\n    assert_eq!(unknown_import.name(), \"unknown-name\");\n    unknown_import.ty().unwrap_func();\n    Ok(())\n}_"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/issues.rs::issue94", "test": ["pub fn read_event(&mut self) -> Result<Event<'i>> {\n        self.read_event_impl(())\n    } [SEP] fn issue94() {\n    let data = br#\"<Run>\n<!B>\n</Run>\"#;\n    let mut reader = Reader::from_reader(&data[..]);\n    reader.trim_text(true);\n    loop {\n        match reader.read_event() {\n            Ok(Event::Eof) | Err(..) => break,\n            _ => (),\n        }\n    }\n}    "]}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_iteration", "test": ["fn next(&mut self) -> Option<Self::Item> {\n    self.iter.next().map(take)\n  } [SEP] fn ArrayVec_iteration() {\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut i = av.into_iter();\n  assert_eq!(i.next(), Some(10));\n  assert_eq!(i.next(), Some(11));\n  assert_eq!(i.next(), Some(12));\n  assert_eq!(i.next(), Some(13));\n  assert_eq!(i.next(), None);\n\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut av2: ArrayVec<[i32; 4]> = av.clone().into_iter().collect();\n  assert_eq!(av, av2);\n\n  // IntoIterator for &mut ArrayVec\n  for x in &mut av2 {\n    *x = -*x;\n  }\n\n  // IntoIterator for &ArrayVec\n  assert!(av.iter().zip(&av2).all(|(&a, &b)| a == -b));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_backspace", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_escape_backspace() {\n    new_ucmd!()\n       .args(&[\"-e\", \"\\\\b\"])\n       .succeeds()\n       .stdout_only(\"\\x08\\n\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_bytes", "test": ["pub fn stdout_contains_line<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().lines().any(|line| line == cmp.as_ref()),\n            \"'{}' does not contain line '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_du_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(\"a/b\");\n\n    at.write(\"a/b/file1\", \"foo\");\n    at.write(\"a/b/file2\", \"foobar\");\n\n    let result = ucmd.args(&[\"--bytes\", \"--all\", \"a\"]).succeeds();\n\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        result.stdout_contains_line(\"6\\ta/b/file2\");\n        result.stdout_contains_line(\"3\\ta/b/file1\");\n        result.stdout_contains_line(\"9\\ta/b\");\n        result.stdout_contains_line(\"9\\ta\");\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        result.stdout_contains_line(\"6\\ta\\\\b\\\\file2\");\n        result.stdout_contains_line(\"3\\ta\\\\b\\\\file1\");\n        result.stdout_contains_line(\"9\\ta\\\\b\");\n        result.stdout_contains_line(\"9\\ta\");\n    }\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_calling_export.rs::test_import_calling_export", "test": ["pub fn expect(self, msg: &str) -> T {\n        self.expand().expect(msg)\n    } [SEP] fn test_import_calling_export() {\n    const WAT: &str = r#\"\n    (module\n      (type $t0 (func))\n      (import \"\" \"imp\" (func $.imp (type $t0)))\n      (func $run call $.imp)\n      (func $other)\n      (export \"run\" (func $run))\n      (export \"other\" (func $other))\n    )\n    \"#;\n\n    let mut store = Store::<Option<Func>>::default();\n    let module = Module::new(store.engine(), WAT).expect(\"failed to create module\");\n\n    let callback_func = Func::new(\n        &mut store,\n        FuncType::new(None, None),\n        move |mut caller, _, _| {\n            caller\n               .data()\n               .unwrap()\n               .call(&mut caller, &[], &mut [])\n               .expect(\"expected function not to trap\");\n            Ok(())\n        },\n    );\n\n    let imports = vec![callback_func.into()];\n    let instance = Instance::new(&mut store, &module, imports.as_slice())\n       .expect(\"failed to instantiate module\");\n\n    let run_func = instance\n       .get_func(&mut store, \"run\")\n       .expect(\"expected a run func in the module\");\n\n    let other_func = instance\n       .get_func(&mut store, \"other\")\n       .expect(\"expected an other func in the module\");\n    *store.data_mut() = Some(other_func);\n\n    run_func\n       .call(&mut store, &[], &mut [])\n       .expect(\"expected function not to trap\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_custom_backup_suffix", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_symlink_custom_backup_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_custom_backup_suffix\";\n    let link = \"test_symlink_custom_backup_suffix_link\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let arg = &format!(\"--suffix={suffix}\");\n    ucmd.args(&[\"-b\", arg, \"-s\", file, link])\n       .succeeds()\n       .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}{suffix}\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}_"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_work", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_work() {\n    let work = Work::from_le_bytes(le_bytes());\n    let got = serialize(&work).unwrap();\n    let want = include_bytes!(\"data/serde/u256_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_log.rs::test_node_compact_log", "test": ["fn test_compact_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let mut before_states = HashMap::default();\n\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        before_states.insert(id, state.take_truncated_state());\n    }\n\n    for i in 1..1000 {\n        let (k, v) = (format!(\"key{}\", i), format!(\"value{}\", i));\n        let key = k.as_bytes();\n        let value = v.as_bytes();\n        cluster.must_put(key, value);\n\n        if i > 100\n            && check_compacted(\n                &cluster.engines,\n                &before_states,\n                1,\n                false, // must_compacted\n            )\n        {\n            return;\n        }\n    }\n\n    check_compacted(\n        &cluster.engines,\n        &before_states,\n        1,\n        true, // must_compacted\n    );\n} [SEP] fn test_node_compact_log() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_compact_log(&mut cluster);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_pr_core_utils_tests", "test": ["pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    } [SEP] fn test_with_pr_core_utils_tests() {\n    let test_cases = vec![\n        (\"\", vec![\"0Ft\"], vec![\"0F\"], 0),\n        (\"\", vec![\"0Fnt\"], vec![\"0F\"], 0),\n        (\"+3\", vec![\"0Ft\"], vec![\"3-0F\"], 0),\n        (\"+3 -f\", vec![\"0Ft\"], vec![\"3f-0F\"], 0),\n        (\"-a -3\", vec![\"0Ft\"], vec![\"a3-0F\"], 0),\n        (\"-a -3 -f\", vec![\"0Ft\"], vec![\"a3f-0F\"], 0),\n        (\"-a -3 -f\", vec![\"0Fnt\"], vec![\"a3f-0F\"], 0),\n        (\"+3 -a -3 -f\", vec![\"0Ft\"], vec![\"3a3f-0F\"], 0),\n        (\"-l 24\", vec![\"FnFn\"], vec![\"l24-FF\"], 0),\n        (\"-W 20 -l24 -f\", vec![\"tFFt-ll\"], vec![\"W20l24f-ll\"], 0),\n    ];\n\n    for test_case in test_cases {\n        let (flags, input_file, expected_file, return_code) = test_case;\n        let mut scenario = new_ucmd!();\n        let input_file_path = input_file.first().unwrap();\n        let test_file_path ="]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/errors.rs::test_fuzzer_input_3", "test": ["fn parse_all_options(md: &str) {\n    let parser = Parser::new_ext(md, Options::all());\n\n    for _ in parser {}\n} [SEP] fn test_fuzzer_input_3() {\n    parse_all_options(\"\\n # #\\r\\u{1c} \");\n} a"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_target", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_target() {\n    let target = Target::from_le_bytes(le_bytes());\n    let got = serialize(&target).unwrap();\n    let want = include_bytes!(\"data/serde/u256_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_long_redirection_to_root", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_realpath_long_redirection_to_root() {\n    // Create a 255-character path to root\n    let dir = path_concat!(\"..\",..85);\n    let expect = get_root_path().to_owned() + \"\\n\";\n    new_ucmd!().arg(dir).succeeds().stdout_is(expect);\n}\n"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_can_get_server_cert", "test": ["fn get_chain(&self) -> Vec<rustls::Certificate> {\n        rustls_pemfile::certs(&mut io::BufReader::new(\n            fs::File::open(self.path_for(\"end.fullchain\")).unwrap(),\n        ))\n       .unwrap()\n       .iter()\n       .map(|v| rustls::Certificate(v.clone()))\n       .collect()\n    } [SEP] fn client_can_get_server_cert() {\n    for kt in ALL_KEY_TYPES.iter() {\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_configs(client_config, make_server_config(*kt));\n            do_handshake(&mut client, &mut server);\n\n            let certs = client.peer_certificates();\n            assert_eq!(certs, Some(kt.get_chain().as_slice()));\n        }\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_invalid_buffer_size", "test": ["pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    } [SEP] fn test_invalid_buffer_size() {\n    new_ucmd!()\n       .arg(\"-S\")\n       .arg(\"asd\")\n       .fails()\n       .code_is(2)\n       .stderr_only(\"sort: invalid --buffer-size argument 'asd'\\n\");\n\n    new_ucmd!()\n       .arg(\"-S\")\n       .arg(\"100f\")\n       .fails()\n       .code_is(2)\n       .stderr_only(\"sort: invalid suffix in --buffer-size argument '100f'\\n\");\n\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n       .arg(\"-n\")\n       .arg(\"-S\")\n       .arg(\"1Y\")\n       .arg(\"ext_sort.txt\")\n       .fails()\n       .code_is(2)\n       .stderr_only(\"sort: --buffer-size argument '1Y' too large\\n\");\n\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let buffer_sizes = [\"1000G\", \"10T\"];\n        for buffer_size in &buffer_sizes {\n            new_ucmd!()\n               .arg(\"-n\")\n               .arg(\"-S\")\n               .arg(buffer_size)\n               .arg(\"ext_sort.txt\")\n               .fails()\n               .code_is(2)\n               .stderr_only(format!(\n                    \"sort: --buffer-size argument '{}' too large\\n\",\n                    buffer_size\n                ));\n        }\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_directory_and_file", "test": ["pub fn stdout_is_fixture<T: AsRef<OsStr>>(&self, file_rel_path: T) -> &Self {\n        let contents = read_scenario_fixture(&self.tmpd, file_rel_path);\n        self.stdout_is(String::from_utf8(contents).unwrap())\n    } [SEP] fn test_directory_and_file() {\n    let s = TestScenario::new(util_name!());\n    s.fixtures.mkdir(\"test_directory2\");\n    // spell-checker:disable-next-line\n    for fixture in [\"empty.txt\", \"alpha.txt\", \"nonewline.txt\"] {\n        s.ucmd()\n           .args(&[\"test_directory2\", fixture])\n           .fails()\n           .stderr_is(\"cat: test_directory2: Is a directory\\n\")\n           .stdout_is_fixture(fixture);\n    }\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_partial", "test": ["pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    } [SEP] fn save_point_rollback_partial() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n    let a = db.engine.get_value(b\"a\").unwrap();\n    assert!(a.is_some());\n    let b = db.engine.get_value(b\"b\").unwrap();\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in max_keys..2 * max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n    let a = db.engine.get_value(b\"a\").unwrap();\n    assert!(a.is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n    let b = db.engine.get_value(b\"b\").unwrap();\n    assert!(b.is_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_cname_additionals", "test": ["pub fn message_type(&self) -> MessageType {\n        self.message_type\n    } [SEP] async fn test_cname_additionals() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::from_str(\"alias.example.com.\").unwrap());\n    query.set_query_type(RecordType::A);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n       .lookup(&question_req, None, response_handler.clone())\n       .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let answers: &[Record] = result.answers();\n    assert_eq!(answers.len(), 1);\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::CNAME);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"www.example.com.\").unwrap()))\n    );\n\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(additionals.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        add_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::forward_call_works", "test": ["fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n           .await?;\n\n            proxy\n               .wasi_http_incoming_handler()\n               .call_handle(store, req, out)\n               .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    } [SEP] fn forward_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (export \"foo\") (result i32)\n                    call 1)\n                (func (result i32)\n                    i32.const 4)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_no_value", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--hex-suffixes\", \"onehundredlines.txt\"])\n       .succeeds()\n       .no_stdout()\n       .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08_"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::with_reinscribe_flag_but_not_actually_a_reinscription", "test": ["pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  } [SEP] fn with_reinscribe_flag_but_not_actually_a_reinscription() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(\"wallet inscribe --file tulip.png --fee-rate 5.0 \")\n   .write(\"tulip.png\", [1; 520])\n   .rpc_server(&rpc_server)\n   .run_and_deserialize_output::<Inscribe>();\n\n  let coinbase = rpc_server.mine_blocks(1)[0].txdata[0].txid();\n\n  CommandBuilder::new(format!(\n    \"wallet inscribe --file orchid.png --fee-rate 1.1 --reinscribe --satpoint {coinbase}:0:0\"\n  ))\n .write(\"orchid.png\", [1; 520])\n .rpc_server(&rpc_server)\n .expected_exit_code(1)\n .stderr_regex(\"error: reinscribe flag set but this would not be a reinscription.*\")\n .run_and_extract_stdout();\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::instanceofoperator_rhs_not_object", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn instanceofoperator_rhs_not_object() {\n    run_test_actions([TestAction::assert_native_error(\n        \"let s = new String(); s instanceof 1\",\n        JsNativeErrorKind::Type,\n        \"right-hand side of 'instanceof' should be an object, got `number`\",\n    )]);\n}"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression19", "test": ["fn open_table<'txn, K: RedbKey +'static, V: RedbValue +'static>(\n        &'txn mut self,\n        table: TableDefinition<K, V>,\n    ) -> SpecialValuesTable<'db, 'txn, K, V> {\n        let def: TableDefinition<K, (u64, u64)> = TableDefinition::new(table.name());\n        SpecialValuesTable {\n            inner: self.inner.open_table(def).unwrap(),\n            file: self.file,\n            _value_type: Default::default(),\n        }\n    } [SEP] fn regression19() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 100];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    let savepoint0 = tx.ephemeral_savepoint().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 101];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 102];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.restore_savepoint(&savepoint0).unwrap();\n    tx.commit().unwrap();\n\n    "]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/encodings.rs::test_koi8_r_encoding", "test": ["pub fn unescape(raw: &str) -> Result<Cow<str>, EscapeError> {\n    unescape_with(raw, |_| None)\n} [SEP] fn test_koi8_r_encoding() {\n    let src = include_bytes!(\"documents/opennews_all.rss\").as_ref();\n    let mut buf = vec![];\n    let mut r = Reader::from_reader(src);\n    r.trim_text(true);\n    loop {\n        match r.read_event_into(&mut buf) {\n            Ok(Event::Text(e)) => {\n                e.unescape().unwrap();\n            }\n            Ok(Event::Eof) => break,\n            _ => (),\n        }\n    }\n}_"]}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::regex_string", "test": ["pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    } [SEP] fn regex_string() {\n    assert_eq!(r\"[a-zA-Z0-9]+\", regex!(r\"[a-zA-Z0-9]+\").as_str());\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{}\", regex!(r\"[a-zA-Z0-9]+\")));\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{:?}\", regex!(r\"[a-zA-Z0-9]+\")));\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_nano_seconds", "test": ["pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_date_nano_seconds() {\n    // %N     nanoseconds (000000000..999999999)\n    let re = Regex::new(r\"^\\d{1,9}\\n$\").unwrap();\n    new_ucmd!().arg(\"+%N\").succeeds().stdout_matches(&re);\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pd_client.rs::test_slow_periodical_update", "test": ["pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    } [SEP] fn test_slow_periodical_update() {\n    let pd_client_reconnect_fp = \"pd_client_reconnect\";\n    let server = MockServer::new(1);\n    let eps = server.bind_addrs();\n\n    let mut cfg = new_config(eps);\n    let env = Arc::new(EnvBuilder::new().cq_count(1).build());\n    let mgr = Arc::new(SecurityManager::new(&SecurityConfig::default()).unwrap());\n\n    // client1 updates leader frequently (100ms).\n    cfg.update_interval = ReadableDuration(Duration::from_millis(100));\n    let _client1 = RpcClientV2::new(&cfg, Some(env.clone()), mgr.clone()).unwrap();\n\n    // client2 never updates leader in the test.\n    cfg.update_interval = ReadableDuration(Duration::from_secs(100));\n    let mut client2 = RpcClientV2::new(&cfg, Some(env), mgr).unwrap();\n\n    fail::cfg(pd_client_reconnect_fp, \"pause\").unwrap();\n    // Wait for the PD client thread blocking on the fail point.\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let (tx, rx) = mpsc::channel();\n    let handle = thread::spawn(move || {\n        client2.alloc_id().unwrap();\n        tx.send(()).unwrap();\n    });\n\n    let timeout = Duration::from_millis(500);\n    if rx.recv_timeout(timeout).is_err() {\n        panic!(\"pd client2 is blocked\");\n    }\n\n    // Clean up the fail point.\n    fail::remove(pd_client_reconnect__"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_missing_arguments", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_missing_arguments() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let no_target_dir = \"no-target_dir\";\n\n    scene\n       .ucmd()\n       .fails()\n       .code_is(1)\n       .usage_error(\"missing file operand\");\n\n    scene\n       .ucmd()\n       .arg(\"-D\")\n       .arg(format!(\"-t {no_target_dir}\"))\n       .fails()\n       .usage_error(\"missing file operand\");\n    assert!(!at.dir_exists(no_target_dir));\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_guest_twice", "test": ["fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n           .await?;\n\n            proxy\n               .wasi_http_incoming_handler()\n               .call_handle(store, req, out)\n               .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    } [SEP] fn drop_guest_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n\n                (core func $ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $ctor)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_variable_name_in_set", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn missing_variable_name_in_set() {\n    assert_err_msg(\"{% set = 1 %}\", &[\"1:8\", \"expected an identifier (must start with a-z)\"]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_fullblock", "test": ["pub fn stderr(&self) -> &[u8] {\n        &self.stderr\n    } [SEP] fn test_fullblock() {\n    let tname = \"fullblock-from-urand\";\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    let exp_stats = vec![\n        \"1+0 records in\\n\",\n        \"1+0 records out\\n\",\n        \"134217728 bytes (134 MB, 128 MiB) copied,\",\n    ];\n    let exp_stats = exp_stats.into_iter().fold(Vec::new(), |mut acc, s| {\n        acc.extend(s.bytes());\n        acc\n    });\n\n    let ucmd = new_ucmd!()\n       .args(&[\n            \"if=/dev/urandom\",\n            of!(&tmp_fn),\n            \"bs=128M\",\n            // Note: In order for this test to actually test iflag=fullblock, the bs=VALUE\n            // must be big enough to 'overwhelm' the urandom store of bytes.\n            // Try executing 'dd if=/dev/urandom bs=128M count=1' (i.e without iflag=fullblock).\n            // The stats should contain the line: '0+1 records in' indicating a partial read.\n            // Since my system only copies 32 MiB without fullblock, I expect 128 MiB to be\n            // a reasonable value for testing most systems.\n            \"count=1\",\n            \"iflag=fullblock\",\n        ])\n       .run();\n    ucmd.success();\n\n    let run_stats = &ucmd.stderr()[..exp_stats.len()];\n    assert_eq!(exp_stats, run_stats);\n}_"]}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::storage1d", "test": ["fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n} [SEP] fn storage1d() {\n    require(\n        &[Ca::Image1D],\n        r#\"\n        @group(0) @binding(0)\n        var image_1d: texture_storage_1d<rgba8unorm,write>;\n    \"#,\n    );\n}\","]}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::setting_accepts_value", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_deadline", "test": ["pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    } [SEP] fn test_deadline() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"deadline_check_fail\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"exceeding the deadline\"));\n}_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_a_wasi_executable", "test": ["pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    } [SEP] fn run_a_wasi_executable() {\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"run\")\n       .arg(fixtures::qjs())\n       .arg(\"--\")\n       .arg(\"--eval\")\n       .arg(\"console.log('Hello, World!')\")\n       .env(\"RUST_LOG\", &*RUST_LOG)\n       .assert();\n\n    assert.success().stdout(contains(\"Hello, World!\"));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::basic_async_hook", "test": ["pub fn data(&self) -> &T {\n        self.inner.data()\n    } [SEP] async fn basic_async_hook() -> Result<(), Error> {\n    struct HandlerR;\n\n    #[async_trait::async_trait]\n    impl CallHookHandler<State> for HandlerR {\n        async fn handle_call_event(&self, obj: &mut State, ch: CallHook) -> Result<()> {\n            State::call_hook(obj, ch)\n        }\n    }\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook_async(HandlerR {});\n\n    assert_eq!(store.data().calls_into_host, 0);\n    assert_eq!(store.data().returns_from_host, 0);\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_zero_terminated_syntax", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_zero_terminated_syntax() {\n    new_ucmd!()\n       .args(&[\"-z\", \"-n\", \"1\"])\n       .pipe_in(\"x\\0y\")\n       .run()\n       .stdout_is(\"x\\0\");\n}    "]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_when_using_variable_set_in_included_templates_outside", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn error_when_using_variable_set_in_included_templates_outside() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"included\", r#\"{{a}}{% set b = \"hi\" %}-{{b}}\"#),\n        (\"base\", r#\"{{a}}{% include \"included\" %}{{b}}\"#),\n    ])\n   .unwrap();\n    let mut context = Context::new();\n    context.insert(\"a\", &10);\n    let result = tera.render(\"base\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `b` not found in context while rendering \\'base\\'\"\n    );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_chars_words", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_utf8_chars_words() {\n    new_ucmd!()\n       .arg(\"-mw\")\n       .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n       .run()\n       .stdout_is(\"     87     442\\n\");\n}    "]}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/conversions.rs::test_rgbu8_to_rgbu16", "test": ["fn convert(&self) -> ImageBuffer<ToType, Vec<ToType::Subpixel>> {\n        let mut buffer: ImageBuffer<ToType, Vec<ToType::Subpixel>> =\n            ImageBuffer::new(self.width, self.height);\n        for (to, from) in buffer.pixels_mut().zip(self.pixels()) {\n            to.from_color(from)\n        }\n        buffer\n    } [SEP] fn test_rgbu8_to_rgbu16() {\n    // Create an all white image using Rgb<u16>s for pixel values\n    let image_u16 =\n        ImageBuffer::from_pixel(2, 2, image::Rgb::<u16>([u16::MAX, u16::MAX, u16::MAX]));\n\n    // Create an all white image using Rgb<u8>s for pixel values and convert it\n    // to Rgb<u16>s.\n    let image_u8 = ImageBuffer::from_pixel(2, 2, image::Rgb::<u8>([u8::MAX, u8::MAX, u8::MAX]));\n    let image_converted: ImageBuffer<Rgb<u16>, _> = image_u8.convert();\n\n    assert_eq!(image_u16, image_converted);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_invalid_combined_shorts", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_split_obs_lines_within_invalid_combined_shorts() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n       .ucmd()\n       .args(&[\"-2fb\", \"file\"])\n       .fails()\n       .code_is(1)\n       .stderr_contains(\"error: unexpected argument '-f' found\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_arch.rs::test_arch", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_arch() {\n    new_ucmd!().succeeds();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_env_help", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_env_help() {\n    new_ucmd!()\n       .arg(\"--help\")\n       .succeeds()\n       .no_stderr()\n       .stdout_contains(\"Options:\");\n}    "]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_raw_pair", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_raw_pair() {\n    let pair = Pair {\n        key: Key { type_value: 1u8, key: vec![0u8, 1u8, 2u8, 3u8] },\n        value: vec![0u8, 1u8, 2u8, 3u8],\n    };\n    let got = serialize(&pair).unwrap();\n    let want = include_bytes!(\"data/serde/raw_pair_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::include_fails_without_unstable", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_already_in_joint_state", "test": ["pub fn sleep_ms(ms: u64) {\n    std::thread::sleep(Duration::from_millis(ms));\n} [SEP] fn test_unsafe_recovery_already_in_joint_state() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n    let peer_on_store0 = find_peer(&region, nodes[0]).unwrap();\n    let peer_on_store2 = find_peer(&region, nodes[2]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store2.clone());\n    cluster\n       .pd_client\n       .must_remove_peer(region.get_id(), peer_on_store2.clone());\n    cluster.pd_client.must_add_peer(\n        region.get_id(),\n        new_learner_peer(nodes[2], peer_on_store2.get_id()),\n    );\n    // Wait the new learner to be initialized.\n    sleep_ms(100);\n    pd_client.must_joint_confchange(\n        region.get_id(),\n        vec![\n            (\n                ConfChangeType::AddLearnerNode,\n                new_learner_peer(nodes[0], peer_on_store0.get_id()),\n            ),\n            (\n                ConfChangeType::AddNode,\n                new_peer(nodes[2], peer_on_store2.get_id()),\n            ),\n        ],\n    );\n    cluster.stop_node(nodes[1]);\n    cluster.stop_node(nodes[2]);\n    cluster.must_wait_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_start", "test": ["fn success() -> Self {\n        Self::Success\n    } [SEP] fn timeout_in_start() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-start.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}    "]}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_value.rs::test_nan", "test": ["pub fn is_f64(&self) -> bool {\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n    } [SEP] fn test_nan() {\n    let pos_nan = serde_yaml::from_str::<Value>(\".nan\").unwrap();\n    assert!(pos_nan.is_f64());\n    assert_eq!(pos_nan, pos_nan);\n\n    let neg_fake_nan = serde_yaml::from_str::<Value>(\"-.nan\").unwrap();\n    assert!(neg_fake_nan.is_string());\n\n    let significand_mask = 0xF_FFFF_FFFF_FFFF;\n    let bits = (f64::NAN.copysign(1.0).to_bits() ^ significand_mask) | 1;\n    let different_pos_nan = Value::Number(Number::from(f64::from_bits(bits)));\n    assert_eq!(pos_nan, different_pos_nan);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_no_op", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_no_op() {\n    new_ucmd!()\n       .pipe_in(\"1024\\n1234567\")\n       .run()\n       .stdout_is(\"1024\\n1234567\\n\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_after_delete.rs::test_node_compact_after_update_v2", "test": ["pub fn get(&self, idx: usize) -> Option<BytesRef<'_>> {\n        assert!(idx < self.len());\n        if self.bitmap.get(idx) {\n            Some(&self.data[self.var_offset[idx]..self.var_offset[idx + 1]])\n        } else {\n            None\n        }\n    } [SEP] fn test_node_compact_after_update_v2() {\n    let count = 1;\n    let mut cluster = test_raftstore_v2::new_node_cluster(0, count);\n\n    cluster.cfg.raft_store.region_compact_check_interval = ReadableDuration::millis(100);\n    // disable it\n    cluster.cfg.raft_store.region_compact_min_tombstones = 1000000;\n    cluster.cfg.raft_store.region_compact_redundant_rows_percent = 40;\n    cluster.cfg.raft_store.region_compact_min_redundant_rows = 50;\n    cluster.cfg.raft_store.region_compact_check_step = Some(2);\n    cluster.cfg.rocksdb.titan.enabled = true;\n    cluster.run();\n\n    let region = cluster.get_region(b\"\");\n    let (split_key, _) = gen_mvcc_put_kv(b\"k100\", b\"\", 1.into(), 2.into());\n    cluster.must_split(&region, &split_key);\n\n    for i in 0..200 {\n        let (k, v) = (format!(\"k{:03}\", i), format!(\"value{}\", i));\n        let (k, v) = gen_mvcc_put_kv(k.as_bytes(), v.as_bytes(), 1.into(), 2.into());\n        cluster.must_put_cf(CF_WRITE, &k, &v);\n\n        let (k, v) = (format!(\"k{:03}\", i), format!(\"value{}\", i));\n        let (k, v)_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::add_set_values_in_context", "test": ["fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n} [SEP] fn add_set_values_in_context() {\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"hey\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"admin\", &true);\n    context.insert(\"num\", &1);\n\n    let inputs = vec![\n        (\"{% set i = 1 %}{{ i }}\", \"1\"),\n        (\"{% set i = 1 + 2 %}{{ i }}\", \"3\"),\n        (r#\"{% set i = \"hey\" %}{{ i }}\"#, \"hey\"),\n        (r#\"{% set i = \"<html>\" %}{{ i | safe }}\"#, \"<html>\"),\n        (r#\"{% set i = \"<html>\" %}{{ i }}\"#, \"&lt;html&gt;\"),\n        (\"{% set i = my_var %}{{ i }}\", \"hey\"),\n        (\"{% set i = malicious %}{{ i | safe }}\", \"<html>\"),\n        (\"{% set i = malicious %}{{ i }}\", \"&lt;html&gt;\"),\n        (\"{% set i = my_var | upper %}{{ i }}\", \"HEY\"),\n        (\"{% set i = range(end=3) %}{{ i }}\", \"[0, 1, 2]\"),\n        (\"{% set i = admin or_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_version", "test": ["fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-c\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n       .env(\"TERM\", term)\n       .arg(\"-b\")\n       .arg(format!(\"{file_name}.txt\"))\n       .run()\n       .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n} [SEP] fn test_version() {\n    test_helper(\"version\", &[\"-V\"]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_batch_get_command", "test": ["pub fn batch_get_command_ok(&self, keys: &[&[u8]], ts: u64, expect: Vec<&[u8]>) {\n        let result: Vec<Option<Vec<u8>>> = self\n           .store\n           .batch_get_command(self.ctx.clone(), keys, ts)\n           .unwrap()\n           .into_iter()\n           .collect();\n        let expect: Vec<Option<Vec<u8>>> = expect\n           .into_iter()\n           .map(|x| if x.is_empty() { None } else { Some(x.to_vec()) })\n           .collect();\n        assert_eq!(result, expect);\n    } [SEP] fn test_txn_store_batch_get_command() {\n    let store = AssertionStorage::default();\n    // not exist\n    store.get_none(b\"a\", 10);\n    store.get_none(b\"b\", 10);\n    // after put\n    store.put_ok(b\"a\", b\"x\", 5, 10);\n    store.put_ok(b\"b\", b\"x\", 5, 10);\n    store.batch_get_command_ok(&[b\"a\", b\"b\", b\"c\"], 10, vec![b\"x\", b\"x\", b\"\"]);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_tombstone", "test": ["fn test_tombstone<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, b\"k1\");\n    must_get_none(&engine_2, b\"k3\");\n    let mut existing_kvs = vec![];\n    for cf in engine_2.cf_names() {\n        engine_2\n           .scan(cf, b\"\", &[0xFF], false, |k, v| {\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_when_multiple_inputs_exceed_max_duration_then_no_error", "test": ["pub fn no_output(&self) -> &Self {\n        self.no_stdout().no_stderr()\n    } [SEP] fn test_sleep_when_multiple_inputs_exceed_max_duration_then_no_error() {\n    let mut child = new_ucmd!()\n       .arg(format!(\"{}\", u64::MAX))\n       .arg(\"1\")\n       .timeout(Duration::from_secs(10))\n       .run_no_wait();\n\n    #[cfg(unix)]\n    child\n       .delay(100)\n       .kill()\n       .make_assertion()\n       .with_current_output()\n       .signal_is(9) // make sure it was us who terminated the process\n       .no_output();\n    #[cfg(windows)]\n    child\n       .delay(100)\n       .kill()\n       .make_assertion()\n       .with_current_output()\n       .failure()\n       .no_output();\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::read_write_memory_via_api", "test": ["pub fn write(&mut self, addr: usize, len: usize) -> Result<(), AccessError> {\n        if!self.flag {\n            return Ok(());\n        }\n        if!(self.is_in_bounds_stack(addr, len) || self.is_in_bounds_heap(addr, len)) {\n            return Err(AccessError::OutOfBounds {\n                addr: addr,\n                len: len,\n            });\n        }\n        for i in addr..addr + len {\n            if let MemState::Unallocated = self.metadata[i] {\n                return Err(AccessError::InvalidWrite {\n                    addr: addr,\n                    len: len,\n                });\n            }\n        }\n        for i in addr..addr + len {\n            self.metadata[i] = MemState::ValidToReadWrite;\n        }\n        Ok(())\n    } [SEP] fn read_write_memory_via_api() {\n    let cfg = Config::new();\n    let mut store = Store::new(&Engine::new(&cfg).unwrap(), ());\n    let ty = MemoryType::new(1, None);\n    let mem = Memory::new(&mut store, ty).unwrap();\n    mem.grow(&mut store, 1).unwrap();\n\n    let value = b\"hello wasm\";\n    let size = mem.data_size(&store);\n    mem.write(&mut store, size - value.len(), value).unwrap();\n\n    let mut buffer = [0u8; 10];\n    mem.read(&store, mem.data_size(&store) - buffer.len(), &mut buffer)\n       .unwrap();\n    assert_eq!(value, &buffer);\n\n    // Error conditions.\n\n    // Out of bounds write.\n\n    let size = mem.data_size(&store);\n    let res = mem.write(&mut store, size - value.len() + 1, value);\n    assert!(res.is_err());\n    assert_ne!(\n        mem.data(&store)[mem.data_size(&store) - value.len() + 1],\n        value[0],\n        \"no data is written\",\n    );\n\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_ingest_key_manager_delete_file_failed", "test": ["pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    } [SEP] fn test_ingest_key_manager_delete_file_failed() {\n    // test with tde\n    let (_tmp_key_dir, cluster, ctx, _tikv, import) = new_cluster_and_tikv_import_client_tde();\n\n    let temp_dir = Builder::new()\n       .prefix(\"test_download_sst_blocking_sst_writer\")\n       .tempdir()\n       .unwrap();\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    upload_sst(&import, &meta, &data).unwrap();\n\n    let deregister_fp = \"key_manager_fails_before_delete_file\";\n    // the first delete is in check before ingest, the second is in ingest cleanup\n    // set the ingest clean up failed to trigger remove file but not remove key\n    // condition\n    fail::cfg(deregister_fp, \"1*off->1*return->off\").unwrap();\n\n    // Do an ingest and verify the result is correct. Though the ingest succeeded,\n    // the clone file is still in the key manager\n    // TODO: how to check the key manager contains the clone key\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta.clone());\n    let resp = import.ingest(&ingest).unwrap();\n\n    assert!(!resp.has_error());\n\n    fail::remove(deregister_fp);\n\n    let node_id = *cluster.sim.rl().get_node_ids().iter().next().unwrap();\n    let save_path = cluster\n       .sim\n       .rl_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_symlink_to_missing", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_trailing_slash_symlink_to_missing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"subdir\");\n    at.relative_symlink_file(\"missing\", \"link\");\n    at.relative_symlink_file(\"subdir/missing\", \"link2\");\n    for query in [\n        \"missing\",\n        \"./missing/\",\n        \"link\",\n        \"./link/\",\n        \"link/more\",\n        \"link2\",\n        \"./link2/\",\n        \"link2/more\",\n    ] {\n        scene\n           .ucmd()\n           .args(&[\"-ev\", query])\n           .fails()\n           .code_is(1)\n           .stderr_contains(\"No such file or directory\")\n           .no_stdout();\n    }\n}_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_test_caching_works_for_packages", "test": ["pub(crate) fn stderr(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDERR_FILENO)\n    } [SEP] fn run_test_caching_works_for_packages() {\n    // we're testing the cache, so we don't want to reuse the current user's\n    // $WASMER_DIR\n    let wasmer_dir = TempDir::new().unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"python/python@0.1.0\")\n       .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n       .arg(\"--registry=wasmer.io\")\n       .arg(\"/app/test.py\")\n       .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n       .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n       .assert();\n\n    assert\n       .success()\n       .stderr(contains(\"wapm_source: Querying the GraphQL API\"))\n       .stderr(contains(\"builtin_loader: Downloading a webc file\"))\n       .stderr(contains(\"module_cache::filesystem: Saved to disk\"));\n\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"python/python@0.1.0\")\n       .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n       .arg(\"--registry=wasmer.io\")\n       .arg(\"/app/test.py\")\n       .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n       .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n       .assert()\n       .success();\n\n    assert\n       .stderr(contains(\"wapm_source: Cache hit!\"))\n       .stderr(contains"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601_default", "test": ["pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_date_rfc_8601_default() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!().arg(param).succeeds().stdout_matches(&re);\n    }\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_df_compatible() {\n    new_ucmd!().arg(\"-ah\").succeeds();\n}_"]}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::xlsb", "test": ["fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    } [SEP] fn xlsb() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xlsb\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsb<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"issue2\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.), String(\"a\".to_string())],\n            [Float(2.), String(\"b\".to_string())],\n            [Float(3.), String(\"c\".to_string())]\n        ]\n    );\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_anyhow_error_return", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn test_anyhow_error_return() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::msg(\"test 1234\"))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n    assert!(!e.to_string().contains(\"test 1234\"));\n    assert!(format!(\"{:?}\", e).contains(\"Caused by:\\n    test 1234\"));\n\n    assert!(e.downcast_ref::<Trap>().is_none());\n    assert!(e.downcast_ref::<WasmBacktrace>().is_some());\n\n    Ok(())\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::bad_text_syntax", "test": ["fn success() -> Self {\n        Self::Success\n    } [SEP] fn bad_text_syntax() -> Result<()> {\n    let output = get_wasmtime_command()?\n       .arg(\"-Ccache=n\")\n       .arg(\"tests/all/cli_tests/bad-syntax.wat\")\n       .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"--> tests/all/cli_tests/bad-syntax.wat\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}    "]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_invalid_type_index_variable", "test": ["pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    } [SEP] fn error_invalid_type_index_variable() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[a] }}\")]).unwrap();\n\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n    context.insert(\"a\", &true);\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Only variables evaluating to String or Number can be used as index (`a` of `arr[a]`)\"\n    );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_vertical_tab", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_escape_vertical_tab() {\n    new_ucmd!()\n       .args(&[\"-e\", \"\\\\v\"])\n       .succeeds()\n       .stdout_only(\"\\x0B\\n\");\n}    "]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::mainnet_has_no_content_size_limit", "test": ["pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  } [SEP] fn mainnet_has_no_content_size_limit() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n   .network(Network::Bitcoin)\n   .build();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"wallet inscribe --file degenerate.png --fee-rate 1\")\n   .write(\"degenerate.png\", [1; 1025])\n   .rpc_server(&rpc_server)\n   .stdout_regex(\".*\")\n   .run_and_extract_stdout();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_help", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_help() {\n    for help_flg in [\"-h\", \"--help\"] {\n        new_ucmd!()\n           .arg(help_flg)\n           .succeeds()\n           .no_stderr()\n           .stdout_contains(\"Usage:\");\n    }\n}    "]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_no_imports_wasm_works", "test": ["fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        } [SEP] fn run_no_imports_wasm_works() {\n    Command::new(get_wasmer_path())\n       .arg(\"run\")\n       .arg(fixtures::fib())\n       .assert()\n       .success();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_symlink_to_itself_verbose", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_symlink_to_itself_verbose() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.relative_symlink_file(\"a\", \"a\");\n    ucmd.args(&[\"-ev\", \"a\"])\n       .fails()\n       .code_is(1)\n       .stderr_contains(\"Too many levels of symbolic links\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_dynamic_config.rs::test_enable", "test": ["pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    } [SEP] pub fn test_enable() {\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        receiver_address: \"\".to_string(),\n        report_receiver_interval: ReadableDuration::millis(2500),\n        max_resource_groups: 5000,\n        precision: ReadableDuration::secs(1),\n    });\n\n    let port = alloc_port();\n    test_suite.start_receiver_at(port);\n\n    // Workload\n    // [req-1, req-2]\n    test_suite.setup_workload(vec![\"req-1\", \"req-2\"]);\n\n    // | Address |\n    // |   x     |\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n\n    // | Address |\n    // |   x     |\n    test_suite.cfg_receiver_address(\"\");\n    test_suite.flush_receiver();\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_nc_0_wo_follow", "test": ["pub fn succeeded(&self) -> bool {\n        self.exit_status.map_or(true, |e| e.success())\n    } [SEP] fn test_nc_0_wo_follow() {\n    // verify that -[nc]0 without -f, exit without reading\n\n    let ts = TestScenario::new(util_name!());\n    ts.ucmd()\n       .args(&[\"-n0\", \"missing\"])\n       .run()\n       .no_stderr()\n       .no_stdout()\n       .succeeded();\n    ts.ucmd()\n       .args(&[\"-c0\", \"missing\"])\n       .run()\n       .no_stderr()\n       .no_stdout()\n       .succeeded();\n}_"]}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::shl_limbs_test", "test": ["pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n} [SEP] fn shl_limbs_test() {\n    let mut x = VecType::from_u64(0xD2210408);\n    bigint::shl_limbs(&mut x, 2);\n    let expected: VecType = if bigint::LIMB_BITS == 32 {\n        vec_from_u32(&[0, 0, 0xD2210408])\n    } else {\n        vec_from_u32(&[0, 0, 0, 0, 0xD2210408])\n    };\n    assert_eq!(&*x, &*expected);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_rename_compatibility", "test": ["pub fn assert_eq_debug<C: PartialEq + Debug>(lhs: &C, rhs: &C) {\n    if lhs == rhs {\n        return;\n    }\n    let lhs_str = format!(\"{:?}\", lhs);\n    let rhs_str = format!(\"{:?}\", rhs);\n\n    fn find_index(l: impl Iterator<Item = (u8, u8)>) -> usize {\n        let it = l\n           .enumerate()\n           .take_while(|(_, (l, r))| l == r)\n           .filter(|(_, (l, _))| *l == b' ');\n        let mut last = None;\n        let mut second = None;\n        for a in it {\n            second = last;\n            last = Some(a);\n        }\n        second.map_or(0, |(i, _)| i)\n    }\n    let cpl = find_index(lhs_str.bytes().zip(rhs_str.bytes()));\n    let csl = find_index(lhs_str.bytes().rev().zip(rhs_str.bytes().rev()));\n    if cpl + csl > lhs_str.len() || cpl + csl > rhs_str.len() {\n        assert_eq!(lhs, rhs);\n    }\n    let lhs_diff = String::from_utf8_lossy(&lhs_str.as_bytes()[cpl..lhs_str.len() - csl]);\n    let rhs_diff = String::from_utf8_lossy(&rhs_str.as_bytes()[cpl..rhs_str.len() - csl]);\n    panic!(\n        \"config not matched:\\nlhs:...{}...,\\nrhs:...{}...\",\n        lhs_diff, rhs_diff\n    );\n} [SEP] fn test_rename_compatibility() {\n    let old_content = r#\"\n[server]\nsnap-max-write-bytes-per-sec = \"10MiB\"\n\n[storage]\nengine"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_wrap", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_wrap() {\n    for wrap_param in [\"-w\", \"--wrap\", \"--wr\"] {\n        let input = \"The quick brown fox jumps over the lazy dog.\";\n        new_ucmd!()\n           .arg(wrap_param)\n           .arg(\"20\")\n           .pipe_in(input)\n           .succeeds()\n            // spell-checker:disable-next-line\n           .stdout_only(\"VGhlIHF1aWNrIGJyb3du\\nIGZveCBqdW1wcyBvdmVy\\nIHRoZSBsYXp5IGRvZy4=\\n\");\n    }\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_decrease_pool", "test": ["pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    } [SEP] fn test_decrease_pool() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let _ = cluster.run_conf_change();\n\n    // Save current poller tids before shrinking\n    let original_poller_tids = get_poller_thread_ids();\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store_pool_size\".to_owned(), \"1\".to_owned());\n            change.insert(\"raftstore.apply-pool-size\".to_owned(), \"1\".to_owned());\n            change\n        };\n\n        // Update config, shrink from 2 to 1\n        cfg_controller.update(change).unwrap();\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        assert_eq!(\n            cfg_controller\n               .get_current()\n               .raft_store\n               .apply_batch_system\n               .pool_size,\n            1\n        );\n        assert_eq!(\n            cfg_controller\n               .get_current()\n               .raft_store\n               .store_batch_system\n               .pool_size,\n            1\n        );\n    }\n\n    // Save current poller tids after scaling down\n    let current_poller_tids = get_poller_thread_ids();\n    // Compared with before shrinking, the thread_"]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/comments.rs::test_simple", "test": ["pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    } [SEP] fn test_simple() {\n    assert_eq!(\n        from_str(\n            \"/*\n * We got a hexadecimal number here!\n *\n */0x507\"\n        ),\n        Ok(0x507)\n    );\n}\n"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_char", "test": ["fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if!json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_hyphen_values_between", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_hyphen_values_between() {\n    new_ucmd!()\n       .arg(\"test\")\n       .arg(\"-E\")\n       .arg(\"araba\")\n       .run()\n       .success()\n       .stdout_is(\"test -E araba\\n\");\n\n    new_ucmd!()\n       .arg(\"dumdum \")\n       .arg(\"dum dum dum\")\n       .arg(\"-e\")\n       .arg(\"dum\")\n       .run()\n       .success()\n       .stdout_is(\"dumdum  dum dum dum -e dum\\n\");\n}    "]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::large_initial", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn large_initial() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![vec![0, 0, 0, 42]];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    let protocols = (0..1000u32)\n       .map(|x| x.to_be_bytes().to_vec())\n       .collect::<Vec<_>>();\n    client_crypto.alpn_protocols = protocols;\n    let cfg = ClientConfig::new(Arc::_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_reference_with_size_file_not_found", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_reference_with_size_file_not_found() {\n    new_ucmd!()\n       .args(&[\"-r\", \"a\", \"-s\", \"+1\", \"b\"])\n       .fails()\n       .stderr_contains(\"cannot stat 'a': No such file or directory\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_leader_change_with_uncommitted_log", "test": ["fn test_leader_change_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // So peer 3 won't replicate any message of the region but still can vote.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // peer 1 and peer 2 must have k2, but peer 3 must not.\n    for i in 1..3 {\n        let engine = cluster.get_engine(i);\n        must_get_equal(&engine, b\"k1\", b\"v1\");\n    }\n\n    let engine3 = cluster.get_engine(3);\n    must_get_none(&engine3, b\"k1\");\n\n    // now only peer 1 and peer 2 can step to leader.\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n           .msg_type(MessageType::MsgAppend)\n           .direction(Direction::Recv)\n           .allow(1),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it becomes leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n           .msg_type(MessageType"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_write_data_to_source_region_after_merging", "test": ["pub fn get_id(&self) -> DownstreamId {\n        self.id\n    } [SEP] fn test_node_merge_write_data_to_source_region_after_merging() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(100);\n    // For snapshot after merging\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(12);\n    cluster.cfg.raft_store.apply_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    let mut region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let right_peer_2 = find_peer(&right, 2).cloned().unwrap();\n    assert_eq!(right_peer_2.get_id(), 2);\n\n    // Make sure peer 2 finish split before pause\n    cluster.must_put(b\"k2pause\", b\"vpause\");\n    must_get_equal(&cluster.get_engine(2), b\"k2pause\", b\"vpause\");\n\n    let on_handle_apply_2_fp = \"on_handle_apply_2\";\n    fail::cfg(on_handle_apply_2_fp, \"pause\").unwrap();\n\n    let right_peer_1_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_accepts_option_argument_directly", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_accepts_option_argument_directly() {\n    new_ucmd!()\n       .arg(\"-s,\")\n       .arg(\"2\")\n       .succeeds()\n       .stdout_is(\"1,2\\n\");\n}    "]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    } [SEP] fn test_compare_and_swap() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let result = io_loop\n       .block_on(client.create(record.clone(), origin.clone()))\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let new = new;\n\n    let result = io_loop\n       .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n       .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n       .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n       .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == new));\n    assert!(!result.answers().iter().any(|rr| *rr == current));\n\n    _"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_finalizer", "test": ["pub fn has_value(&self) -> bool {\n        // SAFETY: this is safe because `Ephemeron` is tracked to always point to a valid pointer\n        // `inner_ptr`.\n        unsafe { self.inner_ptr.get().as_ref().value().is_some() }\n    } [SEP] fn eph_finalizer() {\n    #[derive(Clone, Trace)]\n    struct S {\n        #[unsafe_ignore_trace]\n        inner: Rc<Cell<bool>>,\n    }\n\n    impl Finalize for S {\n        fn finalize(&self) {\n            self.inner.set(true);\n        }\n    }\n\n    run_test(|| {\n        let val = S {\n            inner: Rc::new(Cell::new(false)),\n        };\n\n        let key = Gc::new(50u32);\n        let eph = Ephemeron::new(&key, Gc::new(val.clone()));\n        assert!(eph.has_value());\n        // finalize hasn't been run\n        assert!(!val.inner.get());\n\n        drop(key);\n        force_collect();\n        assert!(!eph.has_value());\n        // finalize ran when collecting\n        assert!(val.inner.get());\n    });\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_21", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_21() {\n    let original = r##\"# H1 {.foo{unknown}\n## H2 {.foo{.bar}\n\"##;\n    let expected = r##\"<h1>H1 {.foo</h1>\n<h2 class=\"bar\">H2 {.foo</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}("]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::test_create_view_with_no_schema_binding", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn test_create_view_with_no_schema_binding() {\n    redshift_and_generic()\n       .verified_stmt(\"CREATE VIEW myevent AS SELECT eventname FROM event WITH NO SCHEMA BINDING\");\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::strict_mode_dup_func_parameters", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn strict_mode_dup_func_parameters() {\n    // Checks that a function cannot contain duplicate parameter\n    // names in strict mode code as per https://tc39.es/ecma262/#sec-function-definitions-static-semantics-early-errors.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            function f(a, b, b) {}\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"Duplicate parameter name not allowed in this context at line 2, col 12\",\n    )]);\n}"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_lint_error", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn ci_lint_error() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::wasm_fault_address_reported_by_default", "test": ["pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n           .expand()\n           .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n           .is_some()\n    } [SEP] fn wasm_fault_address_reported_by_default() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (func $start\n                    i32.const 0xdeadbeef\n                    i32.load\n                    drop)\n                (start $start)\n            )\n        \"#,\n    )?;\n    let err = Instance::new(&mut store, &module, &[]).unwrap_err();\n\n    // NB: at this time there's no programmatic access to the fault address\n    // because it's not always available for load/store traps. Only static\n    // memories on 32-bit have this information, but bounds-checked memories\n    // use manual trapping instructions and otherwise don't have a means of\n    // communicating the faulting address at this time.\n    //\n    // It looks like the exact reported fault address may not be deterministic,\n    // so assert that we have the right error message, but not the exact address.\n    let err = format!(\"{err:?}\");\n    assert!(\n        err.contains(\"memory fault at wasm address \")\n            && err.contains(\" in linear memory of size 0x10000\"),\n        \"bad error: {err}\"\n    );\n    Ok(())\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_mix", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_mix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"13\", \"%25%\", \"/0$/\"])\n       .succeeds()\n       .stdout_only(\"27\\n15\\n63\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 13));\n    assert_eq!(at.read(\"xx01\"), generate(25, 30));\n    assert_eq!(at.read(\"xx02\"), generate(30, 51));\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_multiple_snapshots_together", "test": ["fn test_node_merge_multiple_snapshots(together: bool) {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    ignore_merge_target_integrity(&mut cluster.cfg, &cluster.pd_client);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    // make it gc quickly to trigger snapshot easily\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(10);\n    cluster.cfg.raft_store.merge_max_log_gap = 9;\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n\n    let target_leader = right\n       .get_peers()\n       .iter()\n       .find(|p| p.get_store_id() == 1)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(right.get_id(), target_leader);\n    let target_leader = left\n       .get_peers()\n       .iter()\n       .find(|p| p.get_store_id() == 2)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(left.get_id(), target_leader);\n    must_get_equal(&cluster.get_engine(1"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pathchk.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_range_start_is_larger_than_last_index", "test": ["pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n} [SEP] fn test_when_warmup_range_start_is_larger_than_last_index() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_entry_cache_life_time = ReadableDuration::secs(1000);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n    cluster.pd_client.disable_default_operator();\n\n    let s4 = cluster.add_new_engine();\n\n    // Prevent peer 4 from appending logs, so it's last index should\n    // be really small.\n    let recv_filter_s4 = Box::new(\n        RegionPacketFilter::new(1, s4)\n           .direction(Direction::Recv)\n           .msg_type(MessageType::MsgAppend),\n    );\n    cluster.sim.wl().add_recv_filter(s4, recv_filter_s4);\n\n    let (sx, rx) = channel::unbounded();\n    let recv_filter_1 = Box::new(\n        RegionPacketFilter::new(1, 1)\n           .direction(Direction::Recv)\n           .msg_type(MessageType::MsgTransferLeader)\n           .set_msg_callback(Arc::new(move |m| {\n                sx.send(m.get_message().get_from()).unwrap();\n            })),\n    );\n    cluster.sim.wl().add_recv_filter(1, recv_filter_1);\n\n    cluster.pd_client.must_add_peer(1, new_peer(s4, s4));\n    cluster.transfer_leader(1, new_peer(s4, s4));\n    // Store(s4)_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_values_scientific_notation", "test": ["pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    } [SEP] fn test_values_scientific_notation() {\n    let mut env = Environment::new();\n    env.add_template(\"sci1\", \"VALUE = {{ value or -12.4E-4 }}\")\n       .unwrap();\n    let tmpl = env.get_template(\"sci1\").unwrap();\n    let rv = tmpl.render(context!(value => -12.4E-3)).unwrap();\n    assert_eq!(rv, \"VALUE = -0.0124\");\n    let rv = tmpl.render(context!());\n    // assert_eq!(rv, \"VALUE = -0.00124\");\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci2\", \"VALUE = {{ value or 1.4E4 }}\")\n       .unwrap();\n    let tmpl = env.get_template(\"sci2\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci3\", \"VALUE = {{ value or 1.4e+4}}\")\n       .unwrap();\n    let tmpl = env.get_template(\"sci3\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci4\", \"VALUE = {{ 1.4+4}}\").unwrap();\n    let tmpl = env.get_template(\"sci4\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci5\", \"VALUE = {{ 1.4+1E-1}}\").unwrap();\n    let tmpl = env.get_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_on_array_literal_works", "test": ["fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n} [SEP] fn filter_on_array_literal_works() {\n    let mut context = Context::new();\n    let i: Option<usize> = None;\n    context.insert(\"existing\", \"hello\");\n    context.insert(\"null\", &i);\n\n    let inputs = vec![\n        (r#\"{{ [1, 2, 3] | length }}\"#, \"3\"),\n        (r#\"{% set a = [1, 2, 3] | length %}{{ a }}\"#, \"3\"),\n        (r#\"{% for a in [1, 2, 3] | slice(start=1) %}{{ a }}{% endfor %}\"#, \"23\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}_"]}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_eq", "test": ["pub(super) fn prerelease(text: &str) -> Prerelease {\n    Prerelease::new(text).unwrap()\n} [SEP] fn test_eq() {\n    assert_eq!(prerelease(\"-\"), prerelease(\"-\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aa\"));\n    assert_ne!(prerelease(\"aa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aaaaaaaaa\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"bbbbbbbbb\"));\n    assert_ne!(build_metadata(\"1\"), build_metadata(\"001\"));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_cli_args", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_cli_args() {\n    // Make sure that factor works with CLI arguments as well.\n    new_ucmd!().args(&[\"3\"]).succeeds().stdout_contains(\"3: 3\");\n\n    new_ucmd!()\n       .args(&[\"3\", \"6\", \" +9\"])\n       .succeeds()\n       .stdout_contains(\"3: 3\")\n       .stdout_contains(\"9: 3 3\");\n}\n"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_window_rank_function", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_window_rank_function() {\n    let supported_dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(HiveDialect {}),\n            Box::new(SnowflakeDialect {}),\n        ],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT column1, column2, FIRST_VALUE(column2) OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT column1, column2, FIRST_VALUE(column2) OVER (ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT col_1, col_2, LAG(col_2) OVER (ORDER BY col_1) FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) OVER (ORDER BY col_1) FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) OVER (PARTITION BY col_3 ORDER BY col_1)\",\n    ] {\n        supported_dialects.verified_stmt(sql);\n    }\n\n    let supported_dialects_nulls = TestedDialects {\n        dialects: vec![Box::new(MsSqlDialect {}), Box::new(SnowflakeDialect {})],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT column1, column2, FIRST_VALUE(column2) IGNORE NULLS OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT column1, column2, FIRST_VALUE(column2) RESPECT NULLS OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_interactive_error", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_cp_arg_update_interactive_error() {\n    new_ucmd!()\n       .arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .arg(\"-i\")\n       .fails()\n       .no_stdout();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::plain_context", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn plain_context() {\n    let ctx = \"unconfined_u:unconfined_r:unconfined_t:s0-s0\";\n    new_ucmd!().args(&[ctx, \"/bin/true\"]).succeeds();\n    new_ucmd!().args(&[ctx, \"/bin/false\"]).fails().code_is(1);\n\n    let output = new_ucmd!().args(&[ctx, \"sestatus\", \"-v\"]).succeeds();\n    let r = get_sestatus_context(output.stdout());\n    assert_eq!(r, \"unconfined_u:unconfined_r:unconfined_t:s0\");\n\n    let ctx = \"system_u:unconfined_r:unconfined_t:s0-s0\";\n    new_ucmd!().args(&[ctx, \"/bin/true\"]).succeeds();\n\n    let ctx = \"system_u:system_r:unconfined_t:s0\";\n    let output = new_ucmd!().args(&[ctx, \"sestatus\", \"-v\"]).succeeds();\n    assert_eq!(get_sestatus_context(output.stdout()), ctx);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_server.rs::test_serving_status", "test": ["fn check(&mut self, ctx: &RpcContext<'_>) -> CheckResult {\n        match check_common_name(&self.allowed_cn, ctx) {\n            Ok(()) => CheckResult::Continue,\n            Err(reason) => CheckResult::Abort(RpcStatus::with_message(\n                RpcStatusCode::UNAUTHENTICATED,\n                format!(\n                    \"Common name check fail, reason: {}, cert_allowed_cn: {:?}\",\n                    reason, self.allowed_cn\n                ),\n            )),\n        }\n    } [SEP] fn test_serving_status() {\n    let mut cluster = new_server_cluster(0, 3);\n    // A round is 30 ticks, set inspect interval to 20ms, so one round is 0.3s.\n    cluster.cfg.raft_store.inspect_interval = ReadableDuration::millis(10);\n    cluster.run();\n\n    let service = cluster.sim.rl().health_services.get(&1).unwrap().clone();\n    let builder =\n        ServerBuilder::new(Arc::new(Environment::new(1))).register_service(create_health(service));\n    let mut server = builder.bind(\"127.0.0.1\", 0).build().unwrap();\n    server.start();\n\n    let (addr, port) = server.bind_addrs().next().unwrap();\n    let ch =\n        ChannelBuilder::new(Arc::new(Environment::new(1))).connect(&format!(\"{}:{}\", addr, port));\n    let client = HealthClient::new(ch);\n\n    let check = || {\n        let req = HealthCheckRequest {\n            service: \"\".to_string(),\n           ..Default::default()\n        };\n        let resp = client.check(&req).unwrap();\n        resp.status\n    };\n\n    thread::sleep(Duration::from_millis(500));\n    assert_eq!(check(), ServingStatus::Serving);\n\n    fail::cfg(\"pause_on_peer_collect_message\", \"pause\").unwrap();\n\n    thread::sleep(Duration::from_secs(1));\n    assert_eq!(\n"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_inscribe_with_multiple_inscriptions_with_parent", "test": ["pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  } [SEP] fn batch_inscribe_with_multiple_inscriptions_with_parent() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let parent_output = CommandBuilder::new(\"wallet inscribe --fee-rate 5.0 --file parent.png\")\n   .write(\"parent.png\", [1; 520])\n   .rpc_server(&rpc_server)\n   .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let parent_id = parent_output.inscriptions[0].id;\n\n  let output = CommandBuilder::new(\"wallet inscribe --fee-rate 1 --batch batch.yaml\")\n   .write(\"inscription.txt\", \"Hello World\")\n   .write(\"tulip.png\", [0; 555])\n   .write(\"meow.wav\", [0; 2048])\n   .write(\n      \"batch.yaml\",\n      format!(\"parent: {parent_id}\\nmode: shared-output\\ninscriptions:\\n- file: inscription.txt\\n- file: tulip.png\\n- file: meow.wav\\n\")\n    )\n   .rpc_server(&rpc_server)\n   .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[]);\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[0].id),\n    r\".*<dt>parent</dt>\\s*<dd>.*</dd>.*\",\n  );\n\n  ord_server_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_transport.rs::test_node_partition_write", "test": ["fn test_partition_write<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    must_get_equal(&cluster.get_engine(1), key, value);\n\n    let region_id = cluster.get_region_id(key);\n\n    // transfer leader to (1, 1)\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n\n    // leader in majority, partition doesn't affect write/read\n    cluster.partition(vec![1, 2, 3], vec![4, 5]);\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n    cluster.clear_send_filters();\n\n    // leader in minority, new leader should be elected\n    cluster.partition(vec![1, 2], vec![3, 4, 5]);\n    assert_eq!(cluster.must_get(key), Some(value.to_vec()));\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 1);\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 2);\n    cluster.must_put(key, b\"changed\");\n    cluster.clear_send_filters();\n\n    // when network recover, old leader should sync data\n    cluster.reset_leader_of_region(region_id);\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), key, b\"changed\");\n} [SEP] fn test_node_partition_write() {\n    let mut cluster = new_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::requires_setting", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_help_ref", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_help_ref() {\n    new_ucmd!()\n       .arg(\"--help\")\n       .arg(\"--reference=ref_file\")\n       .succeeds()\n       .stdout_contains(\"Arguments:\");\n}    "]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_b_de", "test": ["fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n} [SEP] fn test_internally_b_de() {\n    let s = \"(type:\\\"VariantB\\\",foo:1,bar:2)\";\n    let e = EnumStructInternally::VariantB { foo: 1, bar: 2 };\n    test_de(s, e);\n}"]}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_int_max_i64", "test": ["fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n} [SEP] fn test_int_max_i64() {\n    let thing = i64::MAX;\n    let yaml = indoc! {\"\n        9223372036854775807\n    \"};\n    test_serde(&thing, yaml);\n}"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/regression.rs::regression_test_2", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn regression_test_2() {\n    let original = r##\"see the [many] [articles] [on] [QuickCheck].\n\n[many]: https://medium.com/@jlouis666/quickcheck-advice-c357efb4e7e6\n[articles]: http://www.quviq.com/products/erlang-quickcheck/\n[on]: https://wiki.haskell.org/Introduction_to_QuickCheck1\n[QuickCheck]: https://hackage.haskell.org/package/QuickCheck\n\"##;\n    let expected = r##\"<p>see the \n  <a href=\"https://medium.com/@jlouis666/quickcheck-advice-c357efb4e7e6\">many</a> \n  <a href=\"http://www.quviq.com/products/erlang-quickcheck/\">articles</a> \n  <a href=\"https://wiki.haskell.org/Introduction_to_QuickCheck1\">on</a> \n  <a href=\"https://hackage.haskell.org/package/QuickCheck\">QuickCheck</a>.\n</p>\n\"##;\n\n    test_"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::arrow", "test": ["fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    } [SEP] fn arrow() {\n    test(\"x => a, b\", \"x=>a,b;\");\n    test(\"x => (a, b)\", \"x=>(a,b);\");\n    test(\"x => (a => b)\", \"x=>a=>b;\");\n    test(\"x => y => a, b\", \"x=>y=>a,b;\");\n    test(\"x => y => (a = b)\", \"x=>y=>a=b;\");\n    test(\"x => y => z => a = b, c\", \"x=>y=>z=>a=b,c;\");\n    test(\"x => y => z => a = (b, c)\", \"x=>y=>z=>a=(b,c);\");\n    test(\"x => ({} + 0)\", \"x=>({})+0;\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_trailing_slash_subdir", "test": ["pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_canonicalize_trailing_slash_subdir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"subdir\");\n    at.relative_symlink_dir(\"subdir\", \"link2\");\n    for name in [\"subdir\", \"link2\"] {\n        scene\n           .ucmd()\n           .args(&[\"-f\", name])\n           .succeeds()\n           .stdout_contains(\"subdir\");\n        scene\n           .ucmd()\n           .args(&[\"-f\", &format!(\"./{name}/\")])\n           .succeeds()\n           .stdout_contains(\"subdir\");\n        scene\n           .ucmd()\n           .args(&[\"-f\", &format!(\"{name}/more\")])\n           .succeeds()\n           .stdout_contains(path_concat!(\"subdir\", \"more\"));\n        scene\n           .ucmd()\n           .args(&[\"-f\", &format!(\"./{name}/more/\")])\n           .succeeds()\n           .stdout_contains(path_concat!(\"subdir\", \"more\"));\n        scene\n           .ucmd()\n           .args(&[\"-f\", &format!(\"{name}/more/more2\")])\n           .fails()\n           .code_is(1)\n           .no_stdout();\n        scene\n           .ucmd()\n           .args(&[\"-f\", &format!(\"./{name}/more/more2/\")])\n           .fails()\n           .code_is(1)\n           .no_stdout();\n    }\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::function_type_parameters", "test": ["fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n} [SEP] fn function_type_parameters() {\n    let source = r#\"def X[T: str, U, *Ts, **P]():...\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_verbose", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_mv_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_verbose_dir\";\n    let file_a = \"test_mv_verbose_file_a\";\n    let file_b = \"test_mv_verbose_file_b\";\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n       .ucmd()\n       .arg(\"-v\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .stdout_only(format!(\"renamed '{file_a}' -> '{file_b}'\\n\"));\n\n    at.touch(file_a);\n    scene\n       .ucmd()\n       .arg(\"-vb\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .stdout_only(format!(\n            \"renamed '{file_a}' -> '{file_b}' (backup: '{file_b}~')\\n\"\n        ));\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_config_is_clone", "test": ["fn make_client_config(\n    params: &BenchmarkParam,\n    clientauth: ClientAuth,\n    resume: ResumptionParam,\n) -> ClientConfig {\n    let mut root_store = RootCertStore::empty();\n    let mut rootbuf =\n        io::BufReader::new(fs::File::open(params.key_type.path_for(\"ca.cert\")).unwrap());\n    root_store.add_parsable_certificates(&rustls_pemfile::certs(&mut rootbuf).unwrap());\n\n    let cfg = ClientConfig::builder()\n       .with_cipher_suites(&[params.ciphersuite])\n       .with_safe_default_kx_groups()\n       .with_protocol_versions(&[params.version])\n       .unwrap()\n       .with_root_certificates(root_store);\n\n    let mut cfg = if clientauth == ClientAuth::Yes {\n        cfg.with_client_auth_cert(\n            params.key_type.get_client_chain(),\n            params.key_type.get_client_key(),\n        )\n       .unwrap()\n    } else {\n        cfg.with_no_client_auth()\n    };\n\n    if resume!= ResumptionParam::No {\n        cfg.resumption = Resumption::in_memory_sessions(128);\n    } else {\n        cfg.resumption = Resumption::disabled();\n    }\n\n    cfg\n} [SEP] fn client_config_is_clone() {\n    let _ = make_client_config(KeyType::Rsa);\n}_"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_end_element", "test": ["pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    } [SEP] fn test_offset_err_end_element() {\n    let mut r = Reader::from_str(\"</a>\");\n    r.trim_text(true);\n\n    match r.read_event() {\n        Err(_) if r.buffer_position() == 2 => (), // error at char 2: no opening tag\n        Err(e) => panic!(\n            \"expecting buf_pos = 2, found {}, err: {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_all_symlinks", "test": ["pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    } [SEP] fn valid_context_directory_recursive_follow_all_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let c_path = Path::new(\"a\").join(\"c\");\n    dir.touch(c_path.to_str().unwrap());\n\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(c_path.to_str().unwrap(), lc_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let lc_context = get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    // -L: traverse every symbolic link to a directory encountered.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-L\", new_la_context])\n       .arg(dir.plus(\"la\"))\n       .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n           .unwrap()\n           .as_deref(),\n        Some(new_la_context)\n    );"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_transport.rs::test_server_partition_write", "test": ["fn test_partition_write<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    must_get_equal(&cluster.get_engine(1), key, value);\n\n    let region_id = cluster.get_region_id(key);\n\n    // transfer leader to (1, 1)\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n\n    // leader in majority, partition doesn't affect write/read\n    cluster.partition(vec![1, 2, 3], vec![4, 5]);\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n    cluster.clear_send_filters();\n\n    // leader in minority, new leader should be elected\n    cluster.partition(vec![1, 2], vec![3, 4, 5]);\n    assert_eq!(cluster.must_get(key), Some(value.to_vec()));\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 1);\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 2);\n    cluster.must_put(key, b\"changed\");\n    cluster.clear_send_filters();\n\n    // when network recover, old leader should sync data\n    cluster.reset_leader_of_region(region_id);\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), key, b\"changed\");\n} [SEP] fn test_server_partition_write() {\n    let mut cluster = new_"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_txout", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_txout() {\n    let txout = TxOut {\n        value: Amount::from_sat(0xDEADBEEFCAFEBABE),\n        script_pubkey: ScriptBuf::from(vec![0u8, 1u8, 2u8]),\n    };\n    let got = serialize(&txout).unwrap();\n    let want = include_bytes!(\"data/serde/txout_bincode\") as &[_];\n    assert_eq!(got, want)\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_destroy_clean_up_logs_with_log_gc", "test": ["pub fn is_empty(&self) -> bool {\n        self.entries.len() == 0\n    } [SEP] fn test_destroy_clean_up_logs_with_log_gc() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(50);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 50;\n    let pd_client = cluster.pd_client.clone();\n\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    let raft_engine = cluster.engines[&3].raft.clone();\n    let mut dest = vec![];\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(!dest.is_empty());\n\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    dest.clear();\n    // Normally destroy peer should cleanup all logs.\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(dest.is_empty(), \"{:?}\", dest);\n\n    pd_client.must_add_peer(1, new_peer(3, 4));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(3), b\"k3\", b\"v3\");\n    dest.clear();\n    raft_engine.get_all_entries_to(1, &mut dest)._"]}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::test_absolute_path_resolves_parent", "test": ["pub(crate) fn parent(&self) -> Option<&'run Scope<'src, 'run>> {\n    self.parent\n  } [SEP] fn test_absolute_path_resolves_parent() {\n  let test_object = Test::new()\n   .justfile(\"path := absolute_path('../test_file')\")\n   .args([\"--evaluate\", \"path\"]);\n\n  let mut tempdir = test_object.tempdir.path().to_owned();\n\n  // Just retrieves the current directory via env::current_dir(), which\n  // does the moral equivalent of canonicalize, which will remove symlinks.\n  // So, we have to canonicalize here, so that we can match it.\n  if cfg!(unix) {\n    tempdir = tempdir.canonicalize().unwrap();\n  }\n\n  test_object\n   .stdout(\n      tempdir\n       .parent()\n       .unwrap()\n       .join(\"test_file\")\n       .to_str()\n       .unwrap()\n       .to_owned(),\n    )\n   .run();\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_valid_page_ranges", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_with_valid_page_ranges() {\n    let test_file_path = \"test_num_page.log\";\n    let mut scenario = new_ucmd!();\n    scenario\n       .args(&[\"--pages=20:5\", test_file_path])\n       .fails()\n       .stderr_is(\"pr: invalid --pages argument '20:5'\\n\")\n       .stdout_is(\"\");\n    new_ucmd!()\n       .args(&[\"--pages=1:5\", test_file_path])\n       .succeeds();\n    new_ucmd!().args(&[\"--pages=1\", test_file_path]).succeeds();\n    new_ucmd!()\n       .args(&[\"--pages=-1:5\", test_file_path])\n       .fails()\n       .stderr_is(\"pr: invalid --pages argument '-1:5'\\n\")\n       .stdout_is(\"\");\n    new_ucmd!()\n       .args(&[\"--pages=1:-5\", test_file_path])\n       .fails()\n       .stderr_is(\"pr: invalid --pages argument '1:-5'\\n\")\n       .stdout_is(\"\");\n    new_ucmd!()\n       .args(&[\"--pages=5:1\", test_file_path])\n       .fails()\n       .stderr_is(\"pr: invalid --pages argument '5:1'\\n\")\n       .stdout_is(\"\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_snap.rs::test_server_snapshot_on_resolve_failure", "test": ["pub fn recv_timeout(&mut self, dur: Duration) -> Result<T, RecvTimeoutError> {\n        let fut = self.next();\n        match block_on_timeout(fut, dur) {\n            Ok(Some(v)) => Ok(v),\n            Ok(None) => Err(RecvTimeoutError::Disconnected),\n            Err(_) => Err(RecvTimeoutError::Timeout),\n        }\n    } [SEP] fn test_server_snapshot_on_resolve_failure() {\n    let mut cluster = new_server_cluster(1, 2);\n    configure_for_snapshot(&mut cluster.cfg);\n\n    let on_send_store_fp = \"transport_on_send_snapshot\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n    cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let ready_notify = Arc::default();\n    let (notify_tx, notify_rx) = mpsc::channel();\n    cluster.sim.write().unwrap().add_send_filter(\n        1,\n        Box::new(MessageTypeNotifier::new(\n            MessageType::MsgSnapshot,\n            notify_tx,\n            Arc::clone(&ready_notify),\n        )),\n    );\n\n    // \"return(2)\" those failure occurs if TiKV resolves or sends to store 2.\n    fail::cfg(on_send_store_fp, \"return(2)\").unwrap();\n    pd_client.add_peer(1, new_learner_peer(2, 2));\n\n    // We are ready to recv notify.\n    ready_notify.store(true, Ordering::SeqCst);\n    notify_rx.recv_timeout(Duration::from_secs(3)).unwrap();\n\n    let engine2 = cluster.get_engine(2);\n    must_get_none(&engine2, b\"k1\");\n\n    // If snapshot status is reported correctly, sending snapshot should be_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/gen_c_header.rs::gen_c_header_works", "test": ["pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    } [SEP] fn gen_c_header_works() -> anyhow::Result<()> {\n    let temp_dir = tempfile::tempdir()?;\n    let operating_dir: PathBuf = temp_dir.path().to_owned();\n\n    let wasm_path = operating_dir.join(fixtures::qjs());\n    let out_path = temp_dir.path().join(\"header.h\");\n\n    let _ = Command::new(get_wasmer_path())\n       .arg(\"gen-c-header\")\n       .arg(&wasm_path)\n       .arg(\"-o\")\n       .arg(&out_path)\n       .output()\n       .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(file.contains(\"wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0\"), \"no wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0 in file\");\n\n    let _ = Command::new(get_wasmer_path())\n       .arg(\"gen-c-header\")\n       .arg(&wasm_path)\n       .arg(\"-o\")\n       .arg(&out_path)\n       .arg(\"--prefix\")\n       .arg(\"abc123\")\n       .output()\n       .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(\n        file.contains(\"wasmer_function_abc123_0\"),\n        \"no wasmer_function_abc123_0 in file\"\n    );\n\n"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_node_split_epoch_not_match_left_derive", "test": ["fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n       .iter()\n       .map(|&k| pd_client.get_region(k).unwrap())\n       .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec!"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none_then_all", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_mv_arg_update_none_then_all() {\n    // take last if multiple update args are supplied,\n    // update=all wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_then_all_file1\";\n    let new = \"test_mv_arg_update_none_then_all_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n       .arg(new)\n       .arg(\"--update=none\")\n       .arg(\"--update=all\")\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n\n    assert_eq!(at.read(new), \"old content\\n\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_server_down_peers_without_hibernate_regions", "test": ["fn test_down_peers<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.max_peer_down_duration = ReadableDuration::secs(1);\n    cluster.run();\n\n    // Kill 1, 2\n    for len in 1..3 {\n        let id = len;\n        cluster.stop_node(id);\n        wait_down_peers(cluster, len, Some(id));\n    }\n\n    // Restart 1, 2\n    cluster.run_node(1).unwrap();\n    cluster.run_node(2).unwrap();\n    wait_down_peers(cluster, 0, None);\n\n    cluster.stop_node(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    // max peer down duration is 500 millis, but we only report down time in\n    // seconds, so sleep 1 second to make the old down second is always larger\n    // than new down second by at lease 1 second.\n    sleep_ms(1000);\n\n    wait_down_peers(cluster, 1, Some(1));\n    let down_secs = cluster.get_down_peers()[&1].get_down_seconds();\n    let timer = Instant::now();\n    let leader = cluster.leader_of_region(1).unwrap();\n    let new_leader = if leader.get_id() == 2 {\n        new_peer(3, 3)\n    } else {\n        new_peer(2, 2)\n    };\n\n    cluster.must_transfer_leader(1, new_leader);\n    // new leader should reset all down peer list.\n    wait_down_peers(cluster, 0, None);\n    wait_down_peers(cluster, 1, Some(1));\n    assert!(\n        cluster.get_down_peers()[&1].get_down_seconds()\n            < down_secs + timer.saturating_elapsed().as_secs()\n    );\n\n    // Ensure that node will not reuse the previous peer heartbeats.\n    cluster.must_transfer_leader(1"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_day", "test": ["pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_date_format_day() {\n    let scene = TestScenario::new(util_name!());\n\n    let mut re = Regex::new(r\"\\S+\").unwrap();\n    scene.ucmd().arg(\"+%a\").succeeds().stdout_matches(&re);\n\n    re = Regex::new(r\"\\S+\").unwrap();\n    scene.ucmd().arg(\"+%A\").succeeds().stdout_matches(&re);\n\n    re = Regex::new(r\"^\\d{1}\\n$\").unwrap();\n    scene.ucmd().arg(\"+%u\").succeeds().stdout_matches(&re);\n}_"]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::into_header_name", "test": ["pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri> {\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3]!= b\"//\" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invald scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    } [SEP] fn into_header_name() {\n    let mut m = HeaderMap::new();\n    m.insert(HOST, \"localhost\".parse().unwrap());\n    m.insert(&ACCEPT, \"*/*\".parse().unwrap());\n    m.insert(\"connection\", \"keep-alive\".parse().unwrap());\n\n    m.append(LOCATION, \"/\".parse().unwrap());\n    m.append(&VIA, \"bob\".parse().unwrap());\n    m.append(\"transfer-encoding\", \"chunked\".parse().unwrap());\n\n    assert_eq!(m.len(), 6);\n}"]}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/reftest/mod.rs::reftest", "test": ["fn reftest_file(path: &Path) {\n    let file = File::open(path).unwrap();\n    let decoder = jpeg::Decoder::new(file);\n    reftest_decoder(decoder, path, &path.with_extension(\"png\"));\n} [SEP] fn reftest() {\n    let files = common::test_files(&Path::new(\"tests\").join(\"reftest\").join(\"images\"));\n\n    for path in &files {\n        reftest_file(path);\n    }\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_no_args", "test": ["fn expect_error(input: &[&str]) {\n    assert!(!new_ucmd!()\n       .args(input)\n       .fails()\n       .no_stdout()\n       .stderr_str()\n       .is_empty());\n} [SEP] fn test_no_args() {\n    expect_error(&[]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_multiple_of_input_chunk", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_multiple_of_input_chunk() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"multiple_of_input_chunk\";\n    RandomFile::new(&at, name).add_bytes(16 * 1024);\n    ucmd.args(&[\"-b\", \"8K\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 8 * 1024);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::lower_n_halfway_test", "test": ["pub(crate) fn lower_n_halfway(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n <= bits, \"lower_n_halfway() overflow in shl.\");\n\n    if n == 0 {\n        0\n    } else {\n        nth_bit(n - 1)\n    }\n} [SEP] fn lower_n_halfway_test() {\n    assert_eq!(lower_n_halfway(0u64), 0b0);\n    assert_eq!(lower_n_halfway(1u64), 0b1);\n    assert_eq!(lower_n_halfway(2u64), 0b10);\n    assert_eq!(lower_n_halfway(10u64), 0b1000000000);\n    assert_eq!(lower_n_halfway(32u64), 0b10000000000000000000000000000000);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::s_iseek_skip_not_additive() {\n    ", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] ytes_iseek_skip_not_additive() {\n    new_ucmd!()\n       .args(&[\"iseek=4\", \"skip=4\", \"iflag=skip_bytes\", \"bs=2\"])\n       .pipe_in(\"0123456789abcdefghijklm\")\n       .succeeds()\n       .stdout_is(\"456789abcdefghijklm\");\n}\n\n#[test]    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_files0_progressive_stream", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_files0_progressive_stream() {\n    use std::process::Stdio;\n    // You should be able to run wc and have a back-and-forth exchange with wc...\n    let mut child = new_ucmd!()\n       .args(&[\"--files0-from=-\"])\n       .set_stdin(Stdio::piped())\n       .set_stdout(Stdio::piped())\n       .set_stderr(Stdio::piped())\n       .run_no_wait();\n\n    macro_rules! chk {\n        ($fn:ident, $exp:literal) => {\n            assert_eq!(child.$fn($exp.len()), $exp.as_bytes());\n        };\n    }\n\n    // File in, count out...\n    child.write_in(\"moby_dick.txt\\0\");\n    chk!(stdout_exact_bytes, \"18 204 1115 moby_dick.txt\\n\");\n    child.write_in(\"lorem_ipsum.txt\\0\");\n    chk!(stdout_exact_bytes, \"13 109 772 lorem_ipsum.txt\\n\");\n\n    // Introduce an error!\n    child.write_in(\"\\0\");\n    chk!(\n        stderr_exact_bytes,\n        \"wc: -:3: invalid zero-length file name\\n\"\n    );\n\n    // wc is quick to forgive, let's move on...\n    child.write_in(\"alice_in_wonderland.txt\\0\");\n    chk!(stdout_exact_bytes, \"5 57 302 alice_in_wonderland.txt\\n\");\n\n    // Fin.\n    child\n       .wait()\n       .expect(\"wc should finish\")\n       .failure()\n       .stdout_only(\"36 370 2189 total\\n\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_cymdhms_time", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_cymdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_cymdhms_time\";\n\n    ucmd.args(&[\"-t\", \"201501011234.56\", file])\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M.%S\", \"201501010000.00\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_ipv4_like_fall_through", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    } [SEP] fn test_lookup_ipv4_like_fall_through() {\n    let authority = create_ip_like_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"198.51.100.35.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(Hosts::default())),\n        Some(RData::A(A::new(198, 51, 100, 35))),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        lookup.iter().next().unwrap(),\n        Ipv4Addr::new(198, 51, 100, 35)\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_multiple_files_into_file", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_move_multiple_files_into_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_multiple_files_into_file1\";\n    let file2 = \"test_mv_move_multiple_files_into_file2\";\n    let file3 = \"test_mv_move_multiple_files_into_file3\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n\n    ucmd.arg(file1)\n       .arg(file2)\n       .arg(file3)\n       .fails()\n       .stderr_is(format!(\"mv: target '{file3}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_stale_meta", "test": ["pub fn must_get_equal<EK: KvEngine>(engine: &impl RawEngine<EK>, key: &[u8], value: &[u8]) {\n    must_get(engine, \"default\", key, Some(value));\n} [SEP] fn test_server_stale_meta() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n    pd_client.must_add_peer(1, new_peer(3, 4));\n    cluster.shutdown();\n\n    let engine_3 = cluster.get_engine(3);\n    let mut state: RegionLocalState = engine_3\n       .get_msg_cf(CF_RAFT, &keys::region_state_key(1))\n       .unwrap()\n       .unwrap();\n    state.set_state(PeerState::Tombstone);\n\n    engine_3\n       .put_msg_cf(CF_RAFT, &keys::region_state_key(1), &state)\n       .unwrap();\n    cluster.clear_send_filters();\n\n    // avoid TIMEWAIT\n    sleep_ms(500);\n    cluster.start().unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_reboot", "test": ["fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n           .is_cluster_bootstrapped\n           .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    } [SEP] fn test_reboot() {\n    let eps_count = 1;\n    let server = MockServer::with_case(eps_count, Arc::new(AlreadyBootstrapped));\n    let eps = server.bind_addrs();\n    let mut client = new_client_v2(eps, None);\n\n    assert!(!client.is_cluster_bootstrapped().unwrap());\n\n    match client.bootstrap_cluster(metapb::Store::default(), metapb::Region::default()) {\n        Err(PdError::ClusterBootstrapped(_)) => (),\n        _ => {\n            panic!(\"failed, should return ClusterBootstrapped\");\n        }\n    }\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_basic", "test": ["pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    } [SEP] fn test_basic() {\n    let mut env = Environment::new();\n    env.add_template(\"test\", \"{% for x in seq %}[{{ x }}]{% endfor %}\")\n       .unwrap();\n    let t = env.get_template(\"test\").unwrap();\n    let mut ctx = BTreeMap::new();\n    ctx.insert(\"seq\", Value::from((0..3).collect::<Vec<_>>()));\n    let rv = t.render(ctx).unwrap();\n    assert_eq!(rv, \"[0][1][2]\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_no_renumber", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_no_renumber() {\n    for arg in [\"-p\", \"--no-renumber\"] {\n        new_ucmd!()\n           .arg(arg)\n           .pipe_in(\"a\\n\\\\:\\\\:\\nb\")\n           .succeeds()\n           .stdout_is(\"     1\\ta\\n\\n     2\\tb\\n\");\n    }\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_drop_sequence", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_drop_sequence() {\n    // SimpleLogger::new().init().unwrap();\n    let sql1 = \"DROP SEQUENCE IF EXISTS  name0 CASCADE\";\n    pg().one_statement_parses_to(sql1, \"DROP SEQUENCE IF EXISTS name0 CASCADE\");\n    let sql2 = \"DROP SEQUENCE IF EXISTS  name1 RESTRICT\";\n    pg().one_statement_parses_to(sql2, \"DROP SEQUENCE IF EXISTS name1 RESTRICT\");\n    let sql3 = \"DROP SEQUENCE  name2 CASCADE\";\n    pg().one_statement_parses_to(sql3, \"DROP SEQUENCE name2 CASCADE\");\n    let sql4 = \"DROP SEQUENCE  name2\";\n    pg().one_statement_parses_to(sql4, \"DROP SEQUENCE name2\");\n    let sql5 = \"DROP SEQUENCE  name0 CASCADE\";\n    pg().one_statement_parses_to(sql5, \"DROP SEQUENCE name0 CASCADE\");\n    let sql6 = \"DROP SEQUENCE  name1 RESTRICT\";\n    pg().one_statement_parses_to(sql6, \"DROP SEQUENCE name1 RESTRICT\");\n    let sql7 = \"DROP SEQUENCE  name1, name2, name3\";\n    pg().one"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_zero_terminated_syntax_2", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_zero_terminated_syntax_2() {\n    new_ucmd!()\n       .args(&[\"-z\", \"-n\", \"2\"])\n       .pipe_in(\"x\\0y\")\n       .run()\n       .stdout_is(\"x\\0y\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_read_from_two_file", "test": ["pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn unexpand_read_from_two_file() {\n    new_ucmd!()\n       .arg(\"with_spaces.txt\")\n       .arg(\"with_spaces.txt\")\n       .arg(\"-t4\")\n       .run()\n       .success();\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601", "test": ["pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_date_rfc_8601() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2},\\d{9}[+-]\\d{2}:\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!()\n           .arg(format!(\"{param}=ns\"))\n           .succeeds()\n           .stdout_matches(&re);\n    }\n}    "]}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_bmp", "test": ["fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n} [SEP] fn truncate_bmp() {\n    truncate_images(\"bmp\")\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_a = \"test_mv_interactive_file_a\";\n    let file_b = \"test_mv_interactive_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n       .ucmd()\n       .arg(\"-i\")\n       .arg(file_a)\n       .arg(file_b)\n       .pipe_in(\"n\")\n       .fails()\n       .no_stdout();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n       .ucmd()\n       .arg(\"-i\")\n       .arg(file_a)\n       .arg(file_b)\n       .pipe_in(\"Yesh\") // spell-checker:disable-line\n       .succeeds()\n       .no_stdout();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_no_change", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_no_change() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"file\");\n    ucmd.arg(\"\").arg(at.plus(\"file\")).succeeds();\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/mod.rs::function", "test": ["fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    } [SEP] fn function() {\n    test_formatting(\n        r#\"\n        function func(a, b) {\n            console.log(a);\n        }\n        function func_2(a, b) {}\n        pass_func(function(a, b) {\n            console.log(\"in callback\", a);\n        });\n        pass_func(function(a, b) {});\n        \"#,\n    );\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_scale_scheduler_pool", "test": ["fn get_pool_size(&self, priority_level: CommandPri) -> usize {\n        if priority_level == CommandPri::High {\n            self.high_worker_pool.get_pool_size()\n        } else {\n            self.worker_pool.get_pool_size()\n        }\n    } [SEP] fn test_scale_scheduler_pool() {\n    let snapshot_fp = \"scheduler_start_execute\";\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    let origin_pool_size = cluster.cfg.storage.scheduler_worker_pool_size;\n\n    let engine = cluster\n       .sim\n       .read()\n       .unwrap()\n       .storages\n       .get(&1)\n       .unwrap()\n       .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n       .config(cluster.cfg.tikv.storage.clone())\n       .build()\n       .unwrap();\n\n    let cfg = new_tikv_config(1);\n    let kv_engine = storage.get_engine().kv_engine().unwrap();\n    let (_tx, rx) = std::sync::mpsc::channel();\n    let flow_controller = Arc::new(FlowController::Singleton(EngineFlowController::new(\n        &cfg.storage.flow_control,\n        kv_engine.clone(),\n        rx,\n    )));\n\n    let cfg_controller = ConfigController::new(cfg);\n    let (scheduler, _receiver) = dummy_scheduler();\n    cfg_controller.register(\n        Module::Storage,\n        Box::new(StorageConfigManger::new(\n            kv_engine,\n            scheduler,\n            flow_controller,\n            storage.get_scheduler(),\n        )),\n    );\n    let scheduler = storage.get_scheduler();\n\n    let region = cluster.get_region(b\"k1\");\n    let mut ctx = Context::default();\n    ctx.set_region_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::i128_type", "test": ["fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    } [SEP] fn i128_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n\n    let definition: TableDefinition<i128, i128> = TableDefinition::new(\"x\");\n\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in -10..=10 {\n            table.insert(&i, &(i - 1)).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(-2, table.get(&-1).unwrap().unwrap().value());\n    let mut iter: Range<i128, i128> = table.range::<i128>(..).unwrap();\n    for i in -11..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i);\n    }\n    assert!(iter.next().is_none());\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_read.rs::test_read_after_cleanup_range_for_snap", "test": ["pub fn get_id(&self) -> ConnId {\n        self.id\n    } [SEP] fn test_read_after_cleanup_range_for_snap() {\n    let mut cluster = new_server_cluster(1, 3);\n    configure_for_snapshot(&mut cluster.cfg);\n    configure_for_lease_read(&mut cluster.cfg, Some(100), Some(10));\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    // Set region and peers\n    let r1 = cluster.run_conf_change();\n    let p1 = new_peer(1, 1);\n    let p2 = new_peer(2, 2);\n    cluster.pd_client.must_add_peer(r1, p2.clone());\n    let p3 = new_peer(3, 3);\n    cluster.pd_client.must_add_peer(r1, p3.clone());\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_none_pending_peer(p2);\n    cluster.pd_client.must_none_pending_peer(p3.clone());\n    let region = cluster.get_region(b\"k0\");\n    assert_eq!(cluster.leader_of_region(region.get_id()).unwrap(), p1);\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n    cluster.stop_node(3);\n    let last_index = cluster.raft_local_state(r1, 1).last_index;\n    (0..10).for_each(|_| cluster.must_put(b\"k1\", b\"v1\"));\n    // Ensure logs are compacted, then node 1 will send a snapshot to node 3 later\n    cluster.wait_log_truncated(r1, 1, last_index + 1);\n\n    fail::cfg(\"send_snapshot\", \"pause\").unwrap();\n    cluster.run_node(3).unwrap_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_big_numbers", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_big_numbers() {\n    new_ucmd!()\n       .args(&[\n            \"1000000000000000000000000000\",\n            \"1000000000000000000000000001\",\n        ])\n       .succeeds()\n       .stdout_only(\"1000000000000000000000000000\\n1000000000000000000000000001\\n\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_nonempty_directory_with_parents", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_rmdir_nonempty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(NESTED_DIR_FILE);\n\n    ucmd.arg(\"-p\").arg(NESTED_DIR).fails().stderr_is(format!(\n        \"rmdir: failed to remove 'dir/ect/ory': {NOT_EMPTY}\\n\"\n    ));\n\n    assert!(at.dir_exists(NESTED_DIR));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/resolved_ts/tests/integrations/mod.rs::test_store_partitioned", "test": ["pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    } [SEP] fn test_store_partitioned() {\n    let mut suite = TestSuite::new(3);\n    let r = suite.cluster.get_region(&[]);\n    suite.cluster.must_transfer_leader(r.id, new_peer(1, 1));\n    suite.must_get_rts_ge(r.id, block_on(suite.cluster.pd_client.get_tso()).unwrap());\n\n    suite\n       .cluster\n       .add_send_filter(IsolationFilterFactory::new(3));\n    let tso = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    for _ in 0..50 {\n        let rts = suite.region_resolved_ts(r.id).unwrap();\n        if rts > tso {\n            if rts.physical() - tso.physical() < 3000 {\n                break;\n            } else {\n                panic!(\"resolved ts doesn't advance in time\")\n            }\n        }\n        sleep_ms(100);\n    }\n\n    suite.stop();\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::empty_type", "test": ["fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    } [SEP] fn empty_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, ()> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(&0, &()).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert!(!table.is_empty().unwrap());\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_node_stale_read_during_splitting_left_derive", "test": ["fn stale_read_during_splitting(right_derive: bool) {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, None, None);\n    cluster.run();\n\n    // Write the initial values.\n    let key1 = b\"k1\";\n    let v1 = b\"v1\";\n    cluster.must_put(key1, v1);\n    let key2 = b\"k2\";\n    let v2 = b\"v2\";\n    cluster.must_put(key2, v2);\n\n    // Get the first region.\n    let region_left = cluster.get_region(key1);\n    let region_right = cluster.get_region(key2);\n    assert_eq!(region_left, region_right);\n    let region1 = region_left;\n    assert_eq!(region1.get_id(), 1);\n    let peer3 = region1\n       .get_peers()\n       .iter()\n       .find(|p| p.get_id() == 3)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(region1.get_id(), peer3.clone());\n\n    // Get the current leader.\n    let leader1 = peer3;\n\n    // Pause the apply worker of peer 3.\n    let apply_split = \"apply_before_split_1_3\";\n    fail::cfg(apply_split, \"pause\").unwrap();\n\n    // Split the first region.\n    cluster.split_region(&region1, key2, Callback::write(Box::new(move |_| {})));\n\n    // Sleep for a while.\n    // The TiKVs that have followers of the old region will elected a leader\n    // of the new region.\n    //           TiKV A  TiKV B  TiKV C\n    // Region 1    L       F       F\n    // Region 2    X       L       F\n    //"]}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_addresses_must_be_valid_for_network", "test": ["pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  } [SEP] fn send_addresses_must_be_valid_for_network() {\n  let rpc_server = test_bitcoincore_rpc::builder().build();\n  let txid = rpc_server.mine_blocks_with_subsidy(1, 1_000)[0].txdata[0].txid();\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 tb1q6en7qjxgw4ev8xwx94pzdry6a6ky7wlfeqzunz {txid}:0:0\"\n  ))\n .rpc_server(&rpc_server)\n .expected_stderr(\n    \"error: address tb1q6en7qjxgw4ev8xwx94pzdry6a6ky7wlfeqzunz belongs to network testnet which is different from required bitcoin\\n\",\n  )\n .expected_exit_code(1)\n .run_and_extract_stdout();\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::three_case_partial_fallthrough", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn three_case_partial_fallthrough() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            let b = 10;\n\n            switch (a) {\n                case 10:\n                    a = 150;\n                case 20:\n                    b = 150;\n                    break;\n                case 15:\n                    b = 1000;\n                    break;\n            }\n\n            a + b;\n        \"#},\n        300,\n    )]);\n}"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::internal_n_mask_test", "test": ["pub(crate) fn internal_n_mask(bit: u64, n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(bit <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(n <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(bit >= n, \"internal_n_halfway() overflow in sub.\");\n\n    lower_n_mask(bit) ^ lower_n_mask(bit - n)\n} [SEP] fn internal_n_mask_test() {\n    assert_eq!(internal_n_mask(1u64, 0u64), 0b0);\n    assert_eq!(internal_n_mask(1u64, 1u64), 0b1);\n    assert_eq!(internal_n_mask(2u64, 1u64), 0b10);\n    assert_eq!(internal_n_mask(4u64, 2u64), 0b1100);\n    assert_eq!(internal_n_mask(10u64, 2u64), 0b1100000000);\n    assert_eq!(internal_n_mask(10u64, 4u64), 0b1111000000);\n    assert_eq!(\n        internal_n_mask(32u64, 4u64),\n        0b11110000000000000000000000000000\n    );\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::compare", "test": ["fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n} [SEP] fn compare() {\n    let source = r#\"4 < x < 5\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_empty", "test": ["pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n       .items\n       .values()\n       .map(|item| introspect_item(item, &lookup))\n       .collect();\n\n    let tokens = lookup\n       .tokens\n       .into_iter()\n       .map(|(name, ty)| (ty, name))\n       .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n} [SEP] fn ident_parse_empty() {\n    parse(\"\").unwrap_err();\n}    "]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::write_digits_f32_test", "test": ["fn write_digits_f32(buffer: &mut [u8], value: u64, expected: &str) {\n    let count = unsafe { f32::write_digits(buffer, value) };\n    let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n    assert_eq!(actual, expected);\n} [SEP] fn write_digits_f32_test() {\n    let mut buffer = [b'\\x00'; 32];\n    write_digits_f32(&mut buffer, 0, \"0\");\n    write_digits_f32(&mut buffer, 1, \"1\");\n    write_digits_f32(&mut buffer, 11, \"11\");\n    write_digits_f32(&mut buffer, 23, \"23\");\n    write_digits_f32(&mut buffer, 23786281, \"23786281\");\n    write_digits_f32(&mut buffer, 4294967295, \"4294967295\");\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_check_zero_terminated_success", "test": ["pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    } [SEP] fn test_check_zero_terminated_success() {\n    new_ucmd!()\n       .arg(\"-z\")\n       .arg(\"-c\")\n       .arg(\"zero-terminated.expected\")\n       .succeeds();\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_with_table_alias_as", "test": ["pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if!canonical.is_empty() && sql!= canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if!canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    } [SEP] fn parse_select_with_table_alias_as() {\n    // AS is optional\n    one_statement_parses_to(\n        \"SELECT a, b, c FROM lineitem l (A, B, C)\",\n        \"SELECT a, b, c FROM lineitem AS l (A, B, C)\",\n    );\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_backspace_should_be_preserved", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_backspace_should_be_preserved() {\n    new_ucmd!().pipe_in(\"\\x08\").succeeds().stdout_is(\"\\x08\");\n}\n"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_const", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn for_of_loop_const() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (let i of [1, 2, 3]) {\n                    result = i;\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 3),\n        TestAction::assert_native_error(\"i\", JsNativeErrorKind::Reference, \"i is not defined\"),\n    ]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_comma_with_plus_1", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_comma_with_plus_1() {\n    new_ucmd!()\n       .args(&[\"--tabs=3,+6\"])\n       .pipe_in(\"\\t111\\t222\\t333\")\n       .succeeds()\n        //          01234567890\n       .stdout_is(\"   111   222   333\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_cdc_observed_before_incremental_scan_snapshot", "test": ["pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    } [SEP] fn test_cdc_observed_before_incremental_scan_snapshot() {\n    let cluster = new_server_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let region = suite.cluster.get_region(b\"\");\n    let lead_client = PeerClient::new(&suite.cluster, region.id, new_peer(1, 1));\n\n    // So that the second changefeed can get some delta changes elder than its\n    // snapshot.\n    let (mut req_tx_0, event_feed_0, _) = new_event_feed(suite.get_region_cdc_client(region.id));\n    let req_0 = suite.new_changedata_request(region.id);\n    block_on(req_tx_0.send((req_0, WriteFlags::default()))).unwrap();\n\n    fail::cfg(\"cdc_before_handle_multi_batch\", \"pause\").unwrap();\n    fail::cfg(\"cdc_sleep_before_drain_change_event\", \"return\").unwrap();\n    let (mut req_tx, event_feed, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.id));\n    let req = suite.new_changedata_request(region.id);\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    thread::sleep(Duration::from_secs(1));\n\n    for version in 0..10 {\n        let key = format!(\"key-{:0>6}\", version);\n        let start_ts = get_tso(&suite.cluster.pd_client);\n        lead_client.must_kv_prewrite(\n            vec![new_mutation(Op::Put, key.as_bytes(), b\"_"]}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_push_promise", "test": ["pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    } [SEP] async fn read_push_promise() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0x5,\n            0x5, 0x4,\n            0, 0, 0, 0x1, // stream id\n            0, 0, 0, 0x2, // promised id\n            0x82, // HPACK :method=\"GET\"\n        ];\n    };\n\n    let pp = poll_frame!(PushPromise, codec);\n    assert_eq!(pp.stream_id(), 1);\n    assert_eq!(pp.promised_id(), 2);\n    assert_eq!(pp.into_parts().0.method, Some(Method::GET));\n\n    assert_closed!(codec);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_readpool_full", "test": ["pub fn has_server_is_busy(&self) -> bool {\n        self.server_is_busy.is_some()\n    } [SEP] fn test_readpool_full() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"future_pool_spawn_full\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_region_error().has_server_is_busy());\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::break_labelled_if_statement", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn break_labelled_if_statement() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let result = \"\";\n            bar: if(true) {\n                result = \"foo\";\n                break bar;\n                result = 'this will not be executed';\n            }\n            result\n        \"#},\n        \"foo\",\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_init_list_1", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn unexpand_init_list_1() {\n    // Once the list is exhausted, spaces are not converted anymore\n    new_ucmd!()\n       .args(&[\"-t2,4\"])\n       .pipe_in(\"     5\\n      6\\n       7\\n        8\\n\")\n       .run()\n       .stdout_is(\"\\t\\t 5\\n\\t\\t  6\\n\\t\\t   7\\n\\t\\t    8\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_shell_syntax", "test": ["pub fn guess_syntax() -> OutputFmt {\n    match env::var(\"SHELL\") {\n        Ok(ref s) if!s.is_empty() => {\n            let shell_path: &Path = s.as_ref();\n            if let Some(name) = shell_path.file_name() {\n                if name == \"csh\" || name == \"tcsh\" {\n                    OutputFmt::CShell\n                } else {\n                    OutputFmt::Shell\n                }\n            } else {\n                OutputFmt::Shell\n            }\n        }\n        _ => OutputFmt::Unknown,\n    }\n} [SEP] fn test_shell_syntax() {\n    use std::env;\n    let last = env::var(\"SHELL\");\n    env::set_var(\"SHELL\", \"/path/csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"/path/bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"/asd/bar\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"foo\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n    env::remove_var(\"SHELL\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n\n    if let Ok(s) = last {\n        env::set_var(\"SHELL\", s);\n    }\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter", "test": ["fn abort() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"aborted\").unwrap();\n        assert_eq!(\"aborted\", table.get(\"hello\").unwrap().unwrap().value());\n    }\n    write_txn.abort().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE);\n    assert!(table.is_err());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 1);\n} [SEP] fn drain_filter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n        // Test draining uncommitted data\n        drop(table.drain_filter(0..10, |k, _| k < 5).unwrap());\n        for i in 0..5 {\n            table.insert(&i, &i).unwrap();\n        }\n        assert_eq!(table.len().unwrap(), 10);\n\n"]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_qualified_identifier", "test": ["fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n} [SEP] fn test_qualified_identifier() {\n    let needle = r#\"_::var = 10\"#;\n\n    let source = r#\"\n    void foo::bar(foo *this){\n        foo::var = 10;\n    }\"#;\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::multiline_str_concat", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn multiline_str_concat() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 'hello'+\n                    'world';\n            a\n        \"#},\n        \"hello world\",\n    )]);\n}"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_all", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    } [SEP] fn test_delete_all() {\n    use hickory_proto::rr::rdata::AAAA;\n\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n       .delete_all(record.name().clone(), origin.clone(), DNSClass::IN)\n       .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n       .create(record.clone(), origin.clone())\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_rr_type(RecordType::AAAA);\n    record.set_data(Some(RData::AAAA(AAAA::new(1, 2, 3, 4, 5, 6, 7, 8))));\n    let result = client\n       .create(record.clone(), origin.clone())\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n       .delete_all(record.name().clone(), origin, DNSClass::IN)\n       .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n       .query(record.name(), record.dns_class(), RecordType::A)\n       .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    _"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge_custom", "test": ["pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n       .unwrap_or(Value::UNDEFINED))\n    } [SEP] fn test_context_merge_custom() {\n    struct X;\n    impl StructObject for X {\n        fn get_field(&self, name: &str) -> Option<Value> {\n            match name {\n                \"a\" => Some(Value::from(1)),\n                \"b\" => Some(Value::from(2)),\n                _ => None,\n            }\n        }\n    }\n\n    let x = Value::from_struct_object(X);\n    let ctx = context! { a => 42,..x };\n\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(42));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_char", "test": ["pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q:?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    } [SEP] fn test_serialize_char() {\n    let value = json!(\n        ({\n            let mut map = BTreeMap::new();\n            map.insert('c', ());\n            map\n        })\n    );\n    assert_eq!(&Value::Null, value.get(\"c\").unwrap());\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_cert_resolve_reduces_sigalgs_for_rsa_ciphersuite", "test": ["fn check_sigalgs_reduced_by_ciphersuite(\n    kt: KeyType,\n    suite: CipherSuite,\n    expected_sigalgs: Vec<SignatureScheme>,\n) {\n    let client_config = finish_client_config(\n        kt,\n        ClientConfig::builder()\n           .with_cipher_suites(&[find_suite(suite)])\n           .with_safe_default_kx_groups()\n           .with_safe_default_protocol_versions()\n           .unwrap(),\n    );\n\n    let mut server_config = make_server_config(kt);\n\n    server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n        expected_sigalgs: Some(expected_sigalgs),\n        expected_cipher_suites: Some(vec![suite, CipherSuite::TLS_EMPTY_RENEGOTIATION_INFO_SCSV]),\n       ..Default::default()\n    });\n\n    let mut client = ClientConnection::new(Arc::new(client_config), dns_name(\"localhost\")).unwrap();\n    let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n    let err = do_handshake_until_error(&mut client, &mut server);\n    assert!(err.is_err());\n} [SEP] fn server_cert_resolve_reduces_sigalgs_for_rsa_ciphersuite() {\n    check_sigalgs_reduced_by_ciphersuite(\n        KeyType::Rsa,\n        CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        vec![\n            SignatureScheme::RSA_PSS_SHA512,\n            SignatureScheme::RSA_PSS_SHA384,\n            SignatureScheme::RSA_PSS_SHA256,\n            SignatureScheme::RSA_PKCS1_SHA512,\n            SignatureScheme::RSA_PKCS1_SHA384,\n            SignatureScheme::R_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_node_stale_read_during_splitting_right_derive", "test": ["fn stale_read_during_splitting(right_derive: bool) {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, None, None);\n    cluster.run();\n\n    // Write the initial values.\n    let key1 = b\"k1\";\n    let v1 = b\"v1\";\n    cluster.must_put(key1, v1);\n    let key2 = b\"k2\";\n    let v2 = b\"v2\";\n    cluster.must_put(key2, v2);\n\n    // Get the first region.\n    let region_left = cluster.get_region(key1);\n    let region_right = cluster.get_region(key2);\n    assert_eq!(region_left, region_right);\n    let region1 = region_left;\n    assert_eq!(region1.get_id(), 1);\n    let peer3 = region1\n       .get_peers()\n       .iter()\n       .find(|p| p.get_id() == 3)\n       .unwrap()\n       .clone();\n    cluster.must_transfer_leader(region1.get_id(), peer3.clone());\n\n    // Get the current leader.\n    let leader1 = peer3;\n\n    // Pause the apply worker of peer 3.\n    let apply_split = \"apply_before_split_1_3\";\n    fail::cfg(apply_split, \"pause\").unwrap();\n\n    // Split the first region.\n    cluster.split_region(&region1, key2, Callback::write(Box::new(move |_| {})));\n\n    // Sleep for a while.\n    // The TiKVs that have followers of the old region will elected a leader\n    // of the new region.\n    //           TiKV A  TiKV B  TiKV C\n    // Region 1    L       F       F\n    // Region 2    X       L       F\n    //"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_stdin_default", "test": ["pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    } [SEP] fn test_stdin_default() {\n    new_ucmd!()\n       .pipe_in_fixture(FOOBAR_TXT)\n       .run()\n       .stdout_is_fixture(\"foobar_stdin_default.expected\")\n       .no_stderr();\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_args", "test": ["fn clone(&self) -> Self {\n        *self\n    } [SEP] fn test_args() {\n    fn type_name_of_val<T:?Sized>(_val: &T) -> &str {\n        std::any::type_name::<T>()\n    }\n\n    let args = args!();\n    assert_eq!(args.len(), 0);\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n\n    let args = args!(1, 2, foo => 42, bar => 23);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n\n    let args = args!(1, 2, foo => 42, bar => 23,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n    assert_eq!(type_name_of_val(args), \"[minij."]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_batch_size_edge_limit", "test": ["pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if!create &&!self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    } [SEP] fn test_batch_size_edge_limit() {\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), true);\n    let (mock_server, port) = create_mock_server(service, 60200, 60300).unwrap();\n\n    let mut raft_client = get_raft_client_by_port(port);\n\n    // Put them in buffer so sibling messages will be likely be batched during\n    // sending.\n    let mut msgs = Vec::with_capacity(5);\n    for _ in 0..5 {\n        let mut raft_m = RaftMessage::default();\n        // Magic number, this can make estimated size about 4940000, hence two messages\n        // will be batched together, but the total size will be way larger than\n        // 10MiB as there are many indexes and terms.\n        for _ in 0..38000 {\n            let mut e = Entry::default();\n            e.set_term(1);\n_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_mock_lookup", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    } [SEP] fn test_mock_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let v4_record = v4_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(resp_query, vec![v4_record], vec![], vec![]);\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::delete", "test": ["fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    } [SEP] fn delete() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello2\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 2);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert_eq!(\"world\", table.remove(\"hello\").unwrap().unwrap().value());\n        assert!(table.remove(\"hello\").unwrap().is_none());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert!(table.get(\"hello\").unwrap().is_none());\n    assert_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_valid_arg_exponents", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_valid_arg_exponents() {\n    new_ucmd!().arg(\"-h\").succeeds().code_is(0);\n    new_ucmd!().arg(\"--exponents\").succeeds().code_is(0);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_mv_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_mv_arg_update_none_file1\";\n    let file2 = \"test_mv_arg_update_none_file2\";\n    let file1_content = \"file1 content\\n\";\n    let file2_content = \"file2 content\\n\";\n\n    at.write(file1, file1_content);\n    at.write(file2, file2_content);\n\n    ucmd.arg(file1)\n       .arg(file2)\n       .arg(\"--update=none\")\n       .succeeds()\n       .no_stderr()\n       .no_stdout();\n\n    assert_eq!(at.read(file2), file2_content);\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_write", "test": ["pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    } [SEP] fn client_complete_io_for_write() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        client\n           .writer()\n           .write_all(b\"01234567890123456789\")\n           .unwrap();\n        client\n           .writer()\n           .write_all(b\"01234567890123456789\")\n           .unwrap();\n        {\n            let mut pipe = OtherSession::new(&mut server);\n            let (rdlen, wrlen) = client.complete_io(&mut pipe).unwrap();\n            assert!(rdlen == 0 && wrlen > 0);\n            println!(\"{:?}\", pipe.writevs);\n            assert_eq!(pipe.writevs, vec![vec![42, 42]]);\n        }\n        check_read(\n            &mut server.reader(),\n            b\"0123456789012345678901234567890123456789\",\n        );\n    }\n}_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/regexes.rs::match_fails_evaluates_to_second_branch", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_fold_void", "test": ["pub(crate) fn test_same(source_text: &str) {\n    test(source_text, source_text);\n} [SEP] fn test_fold_void() {\n    test_same(\"void 0;\");\n    test(\"void 1\", \"void 0;\");\n    test(\"void x\", \"void 0;\");\n    test_same(\"void x();\");\n}"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_4", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn gfm_table_test_4() {\n    let original = r##\"| abc | def |\n| --- | --- |\n| bar | baz |\n> bar\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bar</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>bar</p>\n</blockquote>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_mode_directories_with_file", "test": ["pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_ancestors_mode_directories_with_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_file = \"ancestor1/ancestor2/target_file\";\n    let directories_arg = \"-D\";\n    let mode_arg = \"--mode=200\";\n    let file = \"file\";\n    let probe = \"probe\";\n\n    at.mkdir(probe);\n    let default_perms = at.metadata(probe).permissions().mode();\n\n    at.touch(file);\n\n    ucmd.args(&[mode_arg, directories_arg, file, target_file])\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.file_exists(target_file));\n\n    assert_eq!(default_perms, at.metadata(ancestor1).permissions().mode());\n    assert_eq!(default_perms, at.metadata(ancestor2).permissions().mode());\n\n    // Expected mode only on the target_file.\n    assert_eq!(0o100_200_u32, at.metadata(target_file).permissions().mode());\n}_"]}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_rrset", "test": ["pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    } [SEP] fn test_delete_rrset() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n       .block_on(client.delete_rrset(record.clone(), origin.clone()))\n       .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n       .block_on(client.create(record.clone(), origin.clone()))\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = io_loop\n       .block_on(client.append(record.clone(), origin.clone(), true))\n       .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n       .block_on(client.delete_rrset(record.clone(), origin))\n       .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n       .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_import_macros_missing_namespace", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn invalid_import_macros_missing_namespace() {\n    assert_err_msg(\n        r#\"{% import \"hello\" as %}\"#,\n        &[\"1:22\", \"expected an identifier (must start with a-z)\"],\n    );\n}"]}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::special_chrs_xlsx", "test": ["fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    } [SEP] fn special_chrs_xlsx() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"spc_chrs\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [String(\"&\".to_string())],\n            [String(\"<\".to_string())],\n            [String(\">\".to_string())],\n            [String(\"aaa'aaa\".to_string())],\n            [String(\"\\\"\".to_string())],\n            [String(\"\u263a\".to_string())],\n            [String(\"\u058d\".to_string())],\n            [String(\"\u00e0\u00e2\u00e9\u00ea\u00e8\u00e7\u00f6\u00ef\u00ee\u00ab\u00bb\".to_string())]\n        ]\n    );\n}\n\n#[test]\nfn s_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_exclude_all_types", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_exclude_all_types() {\n    let fs_types = new_ucmd!()\n       .arg(\"--output=fstype\")\n       .succeeds()\n       .stdout_move_str();\n    let fs_types: HashSet<_> = fs_types.lines().skip(1).collect();\n\n    let mut args = Vec::new();\n\n    for fs_type in fs_types {\n        args.push(\"-x\");\n        args.push(fs_type.trim_end());\n    }\n\n    new_ucmd!()\n       .args(&args)\n       .fails()\n       .stderr_contains(\"no file systems processed\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_nonexistent_file", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_link_nonexistent_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_nonexistent_file\";\n    let link = \"test_link_nonexistent_file_link\";\n\n    ucmd.args(&[file, link])\n       .fails()\n       .stderr_only(\"link: cannot create link 'test_link_nonexistent_file_link' to 'test_link_nonexistent_file': No such file or directory\\n\");\n    assert!(!at.file_exists(file));\n    assert!(!at.file_exists(link));\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_var_width_value_type", "test": ["fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    } [SEP] fn vec_var_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<&str>> = TableDefinition::new(\"x\");\n\n    let value = vec![\"hello\", \"world\"];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_numbered", "test": ["pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    } [SEP] fn test_cp_backup_numbered() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=numbered\")\n       .arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(TEST_HOW_ARE_YOU_SOURCE)\n       .succeeds()\n       .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\")),\n        \"How are you?\\n\"\n    );\n}_"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::lifecycle", "test": ["fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if!endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    } [SEP] fn lifecycle() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair."]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_cpu.rs::test_reschedule_coprocessor", "test": ["fn is_empty(&self) -> bool {\n        self.heap.is_empty()\n    } [SEP] pub fn test_reschedule_coprocessor() {\n    let tag = \"tag_coprocessor\";\n\n    let (test_suite, mut store, endpoint) = setup_test_suite();\n    fail::cfg(\"copr_reschedule\", \"return\").unwrap();\n    fail::cfg_callback(\"scanner_next\", || cpu_load(Duration::from_millis(100))).unwrap();\n    defer!({\n        fail::remove(\"scanner_next\");\n        fail::remove(\"copr_reschedule\");\n    });\n\n    let jh = test_suite\n       .rt\n       .spawn(require_cpu_time_not_zero(&test_suite, tag));\n\n    let table = ProductTable::new();\n    let insert = prepare_insert(&mut store, &table);\n    insert.execute();\n    store.commit();\n\n    let mut req = DagSelect::from(&table).build();\n    let mut ctx = Context::default();\n    ctx.set_resource_group_tag(tag.as_bytes().to_vec());\n    req.set_context(ctx);\n    assert!(\n       !block_on(endpoint.parse_and_handle_unary_request(req, None))\n           .consume()\n           .get_data()\n           .is_empty()\n    );\n\n    assert!(block_on(jh).unwrap());\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::function_declaration_returns_undefined", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn function_declaration_returns_undefined() {\n    run_test_actions([TestAction::assert_eq(\n        \"function abc() {}\",\n        JsValue::undefined(),\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_target_directory", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_cp_arg_no_target_directory() {\n    new_ucmd!()\n       .arg(TEST_HELLO_WORLD_SOURCE)\n       .arg(\"-v\")\n       .arg(\"-T\")\n       .arg(TEST_COPY_TO_FOLDER)\n       .fails()\n       .stderr_contains(\"cannot overwrite directory\");\n}    "]}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow10_test", "test": ["pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if!is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n} [SEP] fn u64_pow10_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        1_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_lines_file", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_positive_lines_file() {\n    new_ucmd!()\n       .args(&[\"-n\", \"+7\", \"foobar.txt\"])\n       .succeeds()\n       .stdout_is(\n            \"siette\nocho\nnueve\ndiez\nonce\n\",\n        );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_bytes_file", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_positive_bytes_file() {\n    new_ucmd!()\n       .args(&[\"-c\", \"+42\", \"foobar.txt\"])\n       .succeeds()\n       .stdout_is(\n            \"ho\nnueve\ndiez\nonce\n\",\n        );\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix_hyphen_value", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_custom_backup_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n       .arg(format!(\"--suffix={suffix}\"))\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}_"]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_commutative", "test": ["fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n} [SEP] fn test_commutative() {\n    let needle = \"{if ($x + size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size + offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n\n    let needle = \"{while (_(C_INUSE & _($psize))){k == $psize;}}\";\n    let source = r\"\n    static int alloc_rev(struct chunk *c)\n    {\n    int i;\n    size_t k;\n    while (!((k=c->psize) & C_INUSE)) {\n        i = bin_index(k);\n        lock_bin(i);\n        if (c->psize == k) {\n            unbin(PREV_CHUNK(c), i);\n            unlock_bin(i);\n            return 1;\n        }\n        unlock_bin(i);\n    }\n    return 0;\n    }\n    \";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n\n    let needle = \"{if ($x - size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size - offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 0);\n\n    let needle = \"{if ($x / size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size / offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 0);\n}_"]}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter_all_elements_next_back", "test": ["fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    } [SEP] fn drain_filter_all_elements_next_back() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let mut table = write_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.drain_filter(0..10, |_, _| true).unwrap();\n    for i in (0..10).rev() {\n        let (k, v) = iter.next_back().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_return", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn for_of_loop_return() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                function foo() {\n                    for (i of [1, 2, 3]) {\n                        if (i > 1)\n                            return i;\n                    }\n                }\n            \"#}),\n        TestAction::assert_eq(\"foo()\", 2),\n    ]);\n}"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_host_twice", "test": ["fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n           .await?;\n\n            proxy\n               .wasi_http_incoming_handler()\n               .call_handle(store, req, out)\n               .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    } [SEP] fn drop_host_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_number_with_io_blksize", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_split_number_with_io_blksize() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n    ucmd.args(&[\"-n\", \"5\", \"asciilowercase.txt\", \"---io-blksize\", \"1024\"])\n       .succeeds();\n    assert_eq!(file_read(\"xaa\"), \"abcde\");\n    assert_eq!(file_read(\"xab\"), \"fghij\");\n    assert_eq!(file_read(\"xac\"), \"klmno\");\n    assert_eq!(file_read(\"xad\"), \"pqrst\");\n    assert_eq!(file_read(\"xae\"), \"uvwxyz\\n\");\n}"]}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_iterators.rs::may_dangle", "test": ["fn drop(&mut self) {} [SEP] fn may_dangle() {\n    let p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n    for element in &p {\n        if *element == 2 {\n            drop(p);\n            break;\n        }\n    }\n\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n    for element in &mut p {\n        if *element == 2 {\n            drop(p);\n            break;\n        }\n    }\n}_"]}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_runs_linter_not_formatter_issue_3495", "test": ["pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    } [SEP] fn ci_runs_linter_not_formatter_issue_3495() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_DISABLED_FORMATTER.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), INCORRECT_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n       .open(file_path)\n       .expect(\"ci target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n       .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_runs_linter_not_formatter_issue_3495\",\n        fs,\n        console,\n        result,\n    ));\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni", "test": ["pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n           .as_ref()\n           .map(<DnsName as AsRef<str>>::as_ref)\n    } [SEP] fn server_exposes_offered_sni() {\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"second.testserver.com\"))\n               .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_true.rs::test_short_options", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_short_options() {\n    for option in [\"-h\", \"-V\"] {\n        new_ucmd!().arg(option).succeeds().stdout_is(\"\");\n    }\n}\n"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::assign", "test": ["fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n       .lines()\n       .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n       .collect::<Vec<&'static str>>()\n       .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n       .parse_script(interner)\n       .expect(\"parsing failed\")\n       .to_interned_string(interner);\n    if scenario!= result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n} [SEP] fn assign() {\n    test_formatting(\n        r#\"\n        let a = 20;\n        a += 10;\n        a -= 10;\n        a *= 10;\n        a **= 10;\n        a /= 10;\n        a %= 10;\n        a &= 10;\n        a |= 10;\n        a ^= 10;\n        a <<= 10;\n        a >>= 10;\n        a >>>= 10;\n        a &&= 10;\n        a ||= 10;\n        a??= 10;\n        "]}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i32_min", "test": ["pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T:?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    } [SEP] fn test_i32_min() {\n    assert_eq!(\n        std::i32::MIN,\n        from_str(&to_string(&std::i32::MIN).unwrap()).unwrap()\n    );\n}    "]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_coredump_smoketest", "test": ["pub fn display<'a>(&'a self, params: Option<&'a FunctionParameters>) -> String {\n        match self {\n            FinalizedRelocTarget::ExternalName(name) => format!(\"{}\", name.display(params)),\n            FinalizedRelocTarget::Func(offset) => format!(\"func+{offset}\"),\n        }\n    } [SEP] fn run_coredump_smoketest() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/coredump_smoketest.wat\")?;\n    let coredump_file = NamedTempFile::new()?;\n    let coredump_arg = format!(\"-Dcoredump={}\", coredump_file.path().display());\n    let err = run_wasmtime(&[\n        \"run\",\n        \"--invoke\",\n        \"a\",\n        \"-Ccache=n\",\n        &coredump_arg,\n        wasm.path().to_str().unwrap(),\n    ])\n   .unwrap_err();\n    assert!(err.to_string().contains(&format!(\n        \"core dumped at {}\",\n        coredump_file.path().display()\n    )));\n    Ok(())\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_loop_break", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn for_loop_break() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 1;\n            for (; a < 5; a++) {\n                if (a == 3) {\n                    break;\n                }\n            }\n            a;\n        \"#},\n        3,\n    )]);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_index", "test": ["fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    } [SEP] fn test_analyze_index() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n        (6, Some(\"name:1\"), 1),\n        (7, Some(\"name:1\"), 1),\n        (8, Some(\"name:1\"), 1),\n        (9, Some(\"name:2\"), 1),\n        (10, Some(\"name:2\"), 1),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    let req = new_analyze_index_req(&product, 3, product[\"name\"].index, 4, 32, 2, 2);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeIndexResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let hist = analyze_resp.get_hist();\n    assert_eq!(hist.get_ndv(), 6);\n    assert_eq!(hist.get_buckets().len(), 2);\n    assert_eq!(hist.get_buckets()[0].get_count(), 5);\n    assert_eq!(hist.get_buckets()[0].get_ndv(), 3);\n    assert_eq!(hist.get_buckets()[1].get_count(), 9);\n    assert_eq!(hist.get_buckets()[1].get_ndv(), 3);\n    let rows = analyze_resp.get_cms().get_rows();\n    assert_eq!(rows.len(), 4);\n    let sum: u32 = rows.first().unwrap().get_counters().iter().sum();\n    assert_eq!(_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_test", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn unterminated_test() {\n    assert_err_msg(\n        r#\"{% if a is odd( %}\"#,\n        &[\"1:17\", \"a test argument (any expressions including arrays)\"],\n    );\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_first_only_0", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn unexpand_first_only_0() {\n    new_ucmd!()\n       .args(&[\"-t3\"])\n       .pipe_in(\"        A     B\")\n       .run()\n       .stdout_is(\"\\t\\t  A\\t  B\");\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_join.rs::empty_intersection", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn empty_intersection() {\n    new_ucmd!()\n       .arg(\"fields_1.txt\")\n       .arg(\"fields_2.txt\")\n       .arg(\"-2\")\n       .arg(\"2\")\n       .succeeds()\n       .stdout_only(\"\");\n}_"]}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_matching_hostnames", "test": ["pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    } [SEP] fn check_matching_hostnames() {\n    // Makes sure that reuqests are handled with the same result whether parsed form full url or from pre-parsed hostname\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    let engine = get_blocker_engine();\n\n    for req in requests {\n        let url_host = adblock::url_parser::parse_url(&req.url).unwrap();\n        let source_host = adblock::url_parser::parse_url(&req.sourceUrl).unwrap();\n        let domain = url_host.domain();\n        let source_domain = source_host.domain();\n        let third_party = source_domain!= domain;\n\n        let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n        let preparsed_request = Request::preparsed(&req.url, url_host.hostname(), source_host.hostname(), &req.r#type, third_party);\n\n        let checked = engine.check_network_request(&request);\n        let checked_hostnames = engine.check_network_request(&preparsed_request);\n\n        assert_eq!(checked.matched, checked_hostnames.matched);\n        assert_eq!(checked.filter, checked_hostnames.filter);\n        assert_eq!(checked.exception, checked_hostnames.exception);\n        assert_eq!(checked.redirect, checked_hostnames.redirect);\n    }\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_v1_v2_mixed.rs::test_v1_simple_write", "test": ["pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    } [SEP] fn test_v1_simple_write() {\n    let mut cluster_v2 = test_raftstore_v2::new_node_cluster(1, 2);\n    let mut cluster_v1 = test_raftstore::new_node_cluster(1, 2);\n    cluster_v1.cfg.tikv.raft_store.enable_v2_compatible_learner = true;\n    cluster_v1.pd_client.disable_default_operator();\n    cluster_v2.pd_client.disable_default_operator();\n    let r11 = cluster_v1.run_conf_change();\n    let r21 = cluster_v2.run_conf_change();\n\n    cluster_v1.must_put(b\"k0\", b\"v0\");\n    cluster_v2.must_put(b\"k0\", b\"v0\");\n    cluster_v1\n       .pd_client\n       .must_add_peer(r11, new_learner_peer(2, 10));\n    cluster_v2\n       .pd_client\n       .must_add_peer(r21, new_learner_peer(2, 10));\n    check_key_in_engine(&cluster_v1.get_engine(2), b\"zk0\", b\"v0\");\n    check_key_in_engine(&cluster_v2.get_engine(2), b\"zk0\", b\"v0\");\n    let trans1 = Mutex::new(cluster_v1.sim.read().unwrap().get_router(2).unwrap());\n    let trans2 = Mutex::new(cluster_v2.sim.read().unwrap().get_router(1).unwrap());\n\n    let factory1 = ForwardFactory {\n        node_id: 1,\n        chain_send: Arc::new(move |m| {\n            info!(\"send to trans2\"; \"msg\" =>?m_"]}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::sample_rate_shading", "test": ["fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n} [SEP] fn sample_rate_shading() {\n    require(\n        &[Ca::SampleRateShading],\n        r#\"\n        @fragment\n        fn f(@location(0) @interpolate(perspective, sample) x: f32) { }\n    \"#,\n    );\n\n    require(\n        &[Ca::SampleRateShading],\n        r#\"\n        @fragment\n        fn f(@builtin(sample_index) x: u32) { }\n    \"#,\n    );\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_transfer_leader_delay", "test": ["pub async fn lock(self: Arc<Self>) -> KeyHandleGuard {\n        // Safety: `_mutex_guard` is declared before `handle_ref` in `KeyHandleGuard`.\n        // So the mutex guard will be released earlier than the `Arc<KeyHandle>`.\n        // Then we can make sure the mutex guard doesn't point to released memory.\n        let mutex_guard = unsafe { mem::transmute(self.mutex.lock().await) };\n        KeyHandleGuard {\n            _mutex_guard: mutex_guard,\n            handle: self,\n        }\n    } [SEP] fn test_transfer_leader_delay() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    let messages = Arc::new(Mutex::new(vec![]));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3)\n           .direction(Direction::Send)\n           .msg_type(MessageType::MsgTransferLeader)\n           .reserve_dropped(messages.clone()),\n    ));\n\n    cluster.transfer_leader(1, new_peer(3, 3));\n    let timer = Instant::now();\n    while timer.saturating_elapsed() < Duration::from_secs(3) && messages.lock().unwrap().is_empty()\n    {\n        thread::sleep(Duration::from_millis(10));\n    }\n    assert_eq!(messages.lock().unwrap().len(), 1);\n\n    // Wait till leader peer goes to sleep again.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_file_with_target_arg", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_move_file_into_file_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_file_into_file_with_target_arg_file1\";\n    let file2 = \"test_mv_move_file_into_file_with_target_arg_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--target\")\n       .arg(file1)\n       .arg(file2)\n       .fails()\n       .stderr_is(format!(\"mv: target directory '{file1}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n}_"]}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_custom_filter", "test": ["pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    } [SEP] fn test_custom_filter() {\n    fn test_filter(_: &State, value: String) -> Result<String, Error> {\n        Ok(format!(\"[{value}]\"))\n    }\n\n    let mut ctx = BTreeMap::new();\n    ctx.insert(\"var\", 42);\n\n    let mut env = Environment::new();\n    env.add_filter(\"test\", test_filter);\n    env.add_template(\"test\", \"{{ var|test }}\").unwrap();\n    let tmpl = env.get_template(\"test\").unwrap();\n    let rv = tmpl.render(&ctx).unwrap();\n    assert_eq!(rv, \"[42]\");\n}    "]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/spec.rs::spec_test_2", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn spec_test_2() {\n    let original = r##\"      foo    baz        bim\n\"##;\n    let expected = r##\"<pre><code>foo    baz        bim\n</code></pre>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_create_procedure", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_mssql_create_procedure() {\n    let _ = ms_and_generic().verified_stmt(\"CREATE OR ALTER PROCEDURE foo AS BEGIN SELECT 1 END\");\n    let _ = ms_and_generic().verified_stmt(\"CREATE PROCEDURE foo AS BEGIN SELECT 1 END\");\n    let _ = ms().verified_stmt(\n        \"CREATE PROCEDURE foo AS BEGIN SELECT [myColumn] FROM [myschema].[mytable] END\",\n    );\n    let _ = ms_and_generic().verified_stmt(\n        \"CREATE PROCEDURE foo (@CustomerName NVARCHAR(50)) AS BEGIN SELECT * FROM DEV END\",\n    );\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN UPDATE bar SET col = 'test' END\");\n    // Test a statement with END in it\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN SELECT [foo], CASE WHEN [foo] IS NULL THEN 'empty' ELSE 'notempty' END AS [foo] END\");\n    // Multiple statements\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN UPDATE bar SET col = 'test'; SELECT [foo] FROM BAR WHERE [FOO] > 10 END\");\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::type_aliases", "test": ["fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n} [SEP] fn type_aliases() {\n    let source = r#\"type X[T: str, U, *Ts, **P] = list[T]\"#;\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::export_keying_material", "test": ["fn export_keying_material(\n        &self,\n        output: &mut [u8],\n        label: &[u8],\n        context: &[u8],\n    ) -> Result<(), crypto::ExportKeyingMaterialError> {\n        self.inner.export_keying_material(output, label, context)\n    } [SEP] fn export_keying_material() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    const LABEL: &[u8] = b\"test_label\";\n    const CONTEXT: &[u8] = b\"test_context\";\n\n    // client keying material\n    let mut client_buf = [0u8; 64];\n    pair.client_conn_mut(client_ch)\n       .crypto_session()\n       .export_keying_material(&mut client_buf, LABEL, CONTEXT)\n       .unwrap();\n\n    // server keying material\n    let mut server_buf = [0u8; 64];\n    pair.server_conn_mut(server_ch)\n       .crypto_session()\n       .export_keying_material(&mut server_buf, LABEL, CONTEXT)\n       .unwrap();\n\n    assert_eq!(&client_buf[..], &server_buf[..]);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_kth_l", "test": ["pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    } [SEP] fn test_split_separator_semicolon_number_kth_l() {\n    new_ucmd!()\n       .args(&[\n            \"--number=l/1/3\",\n            \"--separator\",\n            \";\",\n            \"separator_semicolon.txt\",\n        ])\n       .succeeds()\n       .stdout_only(\"1;2;\");\n}    "]}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/regression.rs::check_regressions", "test": ["fn process_images<F>(dir: &str, input_decoder: Option<&str>, func: F)\nwhere\n    F: Fn(&PathBuf, PathBuf, &str),\n{\n    let base: PathBuf = BASE_PATH.iter().collect();\n    let decoders = &[\n        \"tga\", \"tiff\", \"png\", \"gif\", \"bmp\", \"ico\", \"jpg\", \"hdr\", \"pbm\", \"webp\",\n    ];\n    for decoder in decoders {\n        let mut path = base.clone();\n        path.push(dir);\n        path.push(decoder);\n        path.push(\"**\");\n        path.push(\n            \"*.\".to_string()\n                + match input_decoder {\n                    Some(val) => val,\n                    None => decoder,\n                },\n        );\n        let pattern = &*format!(\"{}\", path.display());\n        for path in glob::glob(pattern).unwrap().filter_map(Result::ok) {\n            func(&base, path, decoder)\n        }\n    }\n} [SEP] fn check_regressions() {\n    process_images(REGRESSION_DIR, None, |path| {\n        let _ = image::open(path);\n    })\n}"]}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/public_assigned.rs::test_public_assigned", "test": ["pub fn is_public_assigned(c: char) -> bool {\n    match c {\n        '\\u{0000}'..='\\u{0377}'\n        | '\\u{037A}'..='\\u{037F}'\n        | '\\u{0384}'..='\\u{038A}'\n        | '\\u{038C}'\n        | '\\u{038E}'..='\\u{03A1}'\n        | '\\u{03A3}'..='\\u{052F}'\n        | '\\u{0531}'..='\\u{0556}'\n        | '\\u{0559}'..='\\u{058A}'\n        | '\\u{058D}'..='\\u{058F}'\n        | '\\u{0591}'..='\\u{05C7}'\n        | '\\u{05D0}'..='\\u{05EA}'\n        | '\\u{05EF}'..='\\u{05F4}'\n        | '\\u{0600}'..='\\u{070D}'\n        | '\\u{070F}'..='\\u{074A}'\n        | '\\u{074D}'..='\\u{07B1}'\n        | '\\u{07C0}'..='\\u{07FA}'\n        | '\\u{07FD}'..='\\u{082D}'\n        | '\\u{0830}'..='\\u{083E}'\n        | '\\u{0840}'..='\\u{085B}'\n        | '\\u{085E}'\n        | '\\u{0860}'..='\\u{086A}'\n        | '\\u{0870}'..='\\u{088E}'\n        | '\\u{0890}'..='\\u{0891}'\n        | '\\u{0898}'..='\\u{0983}'\n        | '\\u{0985}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::new_client_returns_initial_io_state", "test": ["pub fn plaintext_bytes_to_read(&self) -> usize {\n        self.plaintext_bytes_to_read\n    } [SEP] fn new_client_returns_initial_io_state() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    let io_state = client.process_new_packets().unwrap();\n    println!(\"IoState is Debug {:?}\", io_state);\n    assert_eq!(io_state.plaintext_bytes_to_read(), 0);\n    assert!(!io_state.peer_has_closed());\n    assert!(io_state.tls_bytes_to_write() > 200);\n}    "]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/alias.rs::absolute_path", "test": ["pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    } [SEP] fn absolute_path() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        alias: vec![(f.join(\"foo\").to_str().unwrap().to_string(), vec![AliasValue::Ignore])],\n        modules: vec![f.clone().to_str().unwrap().to_string()],\n       ..ResolveOptions::default()\n    });\n    let resolution = resolver.resolve(&f, \"foo/index\");\n    assert_eq!(resolution, Err(ResolveError::Ignored(f.join(\"foo\"))));\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_dispatch_change", "test": ["pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    } [SEP] fn test_dispatch_change() {\n    use std::{error::Error, result::Result};\n\n    use online_config::ConfigManager;\n\n    #[derive(Clone)]\n    struct CfgManager(Arc<Mutex<RaftstoreConfig>>);\n\n    impl ConfigManager for CfgManager {\n        fn dispatch(&mut self, c: ConfigChange) -> Result<(), Box<dyn Error>> {\n            self.0.lock().unwrap().update(c)\n        }\n    }\n\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n    let mgr = CfgManager(Arc::new(Mutex::new(cfg.raft_store.clone())));\n    cfg_controller.register(Module::Raftstore, Box::new(mgr.clone()));\n\n    cfg_controller\n       .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n       .unwrap();\n\n    // config update\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // config change should also dispatch to raftstore config manager\n    assert_eq!(mgr.0.lock().unwrap().raft_log_gc_threshold, 2000);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_unimplemented_arg", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_unimplemented_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let context_arg = \"--context\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(context_arg)\n       .arg(file)\n       .arg(dir)\n       .fails()\n       .stderr_contains(\"Unimplemented\");\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_walk_glob", "test": ["pub fn stdout_does_not_match(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n           !regex.is_match(self.stdout_str()),\n            \"Stdout matches regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    } [SEP] fn test_ls_walk_glob() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\".test-1\");\n    at.mkdir(\"some-dir\");\n    at.touch(\n        Path::new(\"some-dir\")\n           .join(\"test-2~\")\n           .as_os_str()\n           .to_str()\n           .unwrap(),\n    );\n\n    #[allow(clippy::trivial_regex)]\n    let re_pwd = Regex::new(r\"^\\.\\n\").unwrap();\n\n    scene\n       .ucmd()\n       .arg(\"-1\")\n       .arg(\"--ignore-backups\")\n       .arg(\"some-dir\")\n       .succeeds()\n       .stdout_does_not_contain(\"test-2~\")\n       .stdout_does_not_contain(\"..\")\n       .stdout_does_not_match(&re_pwd);\n}_"]}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/multiline.rs::read_lines_test", "test": ["pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n} [SEP] fn read_lines_test() {\n    let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}\n"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_identifier", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn test_identifier() {\n    let between = \"SELECT a AS 3_barrr_asdf FROM db.table_name\";\n    hive().verified_stmt(between);\n}_"]}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_absolute_lock_time_time", "test": ["pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    } [SEP] fn serde_regression_absolute_lock_time_time() {\n    let seconds: u32 = 1653195600; // May 22nd, 5am UTC.\n    let t = absolute::LockTime::from_time(seconds).expect(\"valid time\");\n    let got = serialize(&t).unwrap();\n\n    let want = include_bytes!(\"data/serde/absolute_lock_time_seconds_bincode\") as &[_];\n    assert_eq!(got, want);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_line_bytes", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_split_separator_nl_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \"\\n\"])\n       .pipe_in(\"1\\n2\\n3\\n4\\n5\\n\")\n       .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_slash", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_tabs_slash() {\n    new_ucmd!()\n       .args(&[\"--tabs\", \"/\"])\n       .pipe_in(\"a\\tb\\tc\")\n       .succeeds()\n       .stdout_is(\"a       b       c\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_none", "test": ["async fn write(\n            &self,\n            name: &str,\n            reader: UnpinReader,\n            content_length: u64,\n        ) -> io::Result<()> {\n            (self.error_on_write)()?;\n            self.inner.write(name, reader, content_length).await\n        } [SEP] fn write_batch_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n    wb.write().unwrap();\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    wb.write().unwrap();\n}    "]}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/regression.rs::regression_captures_rep", "test": ["pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.locations();\n        self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n            text: text,\n            locs: locs,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    } [SEP] fn regression_captures_rep() {\n    let re = regex!(r\"([a-f]){2}(?P<foo>[x-z])\");\n    let caps = re.captures(text!(\"abx\")).unwrap();\n    assert_eq!(match_text!(caps.name(\"foo\").unwrap()), text!(\"x\"));\n}_"]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_11", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_11() {\n    let original = r##\"# H1 {#id1.class1.class2.class3}\n## H2 {.class1#id2.class2}\n\"##;\n    let expected = r##\"<h1 id=\"id1.class1.class2\" class=\"class3\">H1</h1>\n<h2 class=\"class1#id2.class2\">H2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date6", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_date6() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2000-01-01 00:00\", file])\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(946_684_800, 0);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_init_1", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn unexpand_init_1() {\n    new_ucmd!()\n       .args(&[\"-t4\"])\n       .pipe_in(\"     5\\n      6\\n       7\\n        8\\n\")\n       .run()\n       .stdout_is(\"\\t 5\\n\\t  6\\n\\t   7\\n\\t\\t8\\n\");\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_obsolete_syntax", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_obsolete_syntax() {\n    new_ucmd!()\n       .arg(\"-5\")\n       .arg(\"-s\")\n       .arg(\"space_separated_words.txt\")\n       .succeeds()\n       .stdout_is(\"test1\\n \\ntest2\\n \\ntest3\\n \\ntest4\\n \\ntest5\\n \\ntest6\\n \");\n}    "]}
{"test_id": "ibraheemdev-matchit/ibraheemdev-matchit-64af4bd/tests/tree.rs::issue_22", "test": ["pub fn at<'m, 'p>(&'m self, path: &'p str) -> Result<Match<'m, 'p, &'m T>, MatchError> {\n        match self.root.at(path.as_bytes()) {\n            Ok((value, params)) => Ok(Match {\n                // SAFETY: We only expose &mut T through &mut self\n                value: unsafe { &*value.get() },\n                params,\n            }),\n            Err(e) => Err(e),\n        }\n    } [SEP] fn issue_22() {\n    let mut x = Router::new();\n    x.insert(\"/foo_bar\", \"Welcome!\").unwrap();\n    x.insert(\"/foo/bar\", \"Welcome!\").unwrap();\n    assert_eq!(x.at(\"/foo/\").unwrap_err(), MatchError::NotFound);\n\n    let mut x = Router::new();\n    x.insert(\"/foo\", \"Welcome!\").unwrap();\n    x.insert(\"/foo/bar\", \"Welcome!\").unwrap();\n    assert_eq!(x.at(\"/foo/\").unwrap_err(), MatchError::ExtraTrailingSlash);\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_lines", "test": ["fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n} [SEP] fn test_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    // Split into two files without splitting up lines.\n    ucmd.args(&[\"-n\", \"l/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n2\\n3\\n\");\n    assert_eq!(file_read(\"xab\"), \"4\\n5\\n\");\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_negative_offset", "test": ["fn count(&self) -> usize {\n        self.collect().len()\n    } [SEP] fn test_up_to_match_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/-3\"])\n       .succeeds()\n       .stdout_only(\"10\\n131\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n       .expect(\"there should be splits created\")\n       .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 6));\n    assert_eq!(at.read(\"xx01\"), generate(6, 51));\n}    "]}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/fnmut.rs::parse", "test": ["fn parser(i: &[u8]) -> nom::IResult<&[u8], u64> {\n  complete::be_u64(i)\n} [SEP] fn parse() {\n  let mut counter = 0;\n\n  let res = {\n    let mut parser = many0::<_, _, (), _>(|i| {\n      counter += 1;\n      tag(\"abc\")(i)\n    });\n\n    parser(\"abcabcabcabc\").unwrap()\n  };\n\n  println!(\"res: {:?}\", res);\n  assert_eq!(counter, 5);\n}    "]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_iuse_percentage", "test": ["fn ceil(x: BigDecimal) -> BigInt {\n    if x.is_integer() {\n        // Unwrapping the Option because it always returns Some\n        x.to_bigint().unwrap()\n    } else {\n        (x + BigDecimal::one().half()).round(0).to_bigint().unwrap()\n    }\n} [SEP] fn test_iuse_percentage() {\n    let output = new_ucmd!()\n       .args(&[\"--total\", \"--output=itotal,iused,ipcent\"])\n       .succeeds()\n       .stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    for line in lines {\n        let mut iter = line.split_whitespace();\n        let reported_inodes = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_iused = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_percentage = iter.next().unwrap();\n\n        if reported_percentage == \"-\" {\n            assert_eq!(0.0, reported_inodes);\n            assert_eq!(0.0, reported_iused);\n        } else {\n            let reported_percentage = reported_percentage[..reported_percentage.len() - 1]\n               .parse::<u8>()\n               .unwrap();\n            let computed_percentage = (100.0 * (reported_iused / reported_inodes)).ceil() as u8;\n\n            assert_eq!(computed_percentage, reported_percentage);\n        }\n    }\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_array_agg_func", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn parse_array_agg_func() {\n    for sql in [\n        \"SELECT ARRAY_AGG(x ORDER BY x) AS a FROM T\",\n        \"SELECT ARRAY_AGG(x ORDER BY x LIMIT 2) FROM tbl\",\n        \"SELECT ARRAY_AGG(DISTINCT x ORDER BY x LIMIT 2) FROM tbl\",\n    ] {\n        bigquery().verified_stmt(sql);\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_command_empty_args", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_command_empty_args() {\n    new_ucmd!()\n       .args(&[\"\", \"\"])\n       .fails()\n       .stderr_contains(\"timeout: empty string\");\n}    "]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::drain", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n           .next_unsafe()\n           .map(|(key, ptr)| (key, unsafe { &*ptr }))\n    } [SEP] fn drain() {\n    let mut headers = HeaderMap::new();\n\n    // Insert a single value\n    let name: HeaderName = \"hello\".parse().unwrap();\n    headers.insert(name, \"world\".parse().unwrap());\n\n    {\n        let mut iter = headers.drain();\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"hello\");\n\n        assert_eq!(value, \"world\");\n\n        assert!(iter.next().is_none());\n    }\n\n    assert!(headers.is_empty());\n\n    // Insert two sequential values\n    headers.insert(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world\".parse().unwrap(),\n    );\n    headers.insert(\n        \"zomg\".parse::<HeaderName>().unwrap(),\n        \"bar\".parse().unwrap(),\n    );\n    headers.append(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world2\".parse().unwrap(),\n    );\n\n    // Drain...\n    {\n        let mut iter = headers.drain();\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"hello\");\n        assert_eq!(value, \"world\");\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name, None);\n        assert_eq!(value, \"world2\");\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"zomg\");\n        assert_eq!(value, \"bar\");\n\n        assert!(iter.next().is_none());\n    }\n}_"]}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes128_encrypted_file", "test": ["pub fn name(&self) -> &str {\n        &self.data.file_name\n    } [SEP] fn aes128_encrypted_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n       .by_name_decrypt(\"secret_data_128\", PASSWORD)\n       .expect(\"couldn't find file in archive\")\n       .expect(\"invalid password\");\n    assert_eq!(\"secret_data_128\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n       .expect(\"couldn't read encrypted file\");\n    assert_eq!(SECRET_CONTENT, content);\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/match_directive.rs::test_match_directive", "test": ["pub fn match_directive<'a>(comment: &'a str, directive: &str) -> Option<&'a str> {\n    assert!(\n        directive.ends_with(':'),\n        \"Directive must include trailing colon\"\n    );\n    let text = comment.trim_start_matches(';').trim_start();\n    if text.starts_with(directive) {\n        Some(text[directive.len()..].trim())\n    } else {\n        None\n    }\n} [SEP] fn test_match_directive() {\n    assert_eq!(match_directive(\"; foo: bar  \", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\" foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\"foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\";x foo: bar\", \"foo:\"), None);\n    assert_eq!(match_directive(\";;; foo: bar\", \"foo:\"), Some(\"bar\"));\n}\n"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_selects_columns", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    } [SEP] fn test_output_selects_columns() {\n    let output = new_ucmd!()\n       .args(&[\"--output=source\"])\n       .succeeds()\n       .stdout_move_str();\n    assert_eq!(output.lines().next().unwrap(), \"Filesystem\");\n\n    let output = new_ucmd!()\n       .args(&[\"--output=source,target\"])\n       .succeeds()\n       .stdout_move_str();\n    assert_eq!(\n        output\n           .lines()\n           .next()\n           .unwrap()\n           .split_whitespace()\n           .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\"]\n    );\n\n    let output = new_ucmd!()\n       .args(&[\"--output=source,target,used\"])\n       .succeeds()\n       .stdout_move_str();\n    assert_eq!(\n        output\n           .lines()\n           .next()\n           .unwrap()\n           .split_whitespace()\n           .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\", \"Used\"]\n    );\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::custom_context", "test": ["pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    } [SEP] fn custom_context() {\n    let t_ud = \"unconfined_t\";\n    let u_ud = \"unconfined_u\";\n    let r_ud = \"unconfined_r\";\n\n    new_ucmd!().args(&[\"--compute\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"/bin/false\"];\n    new_ucmd!().args(args).fails().code_is(1);\n\n    let args = &[\"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    new_ucmd!().args(&[\"--range=s0\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"--range=s0\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    for (ctx, u, r) in [\n        (\"unconfined_u:unconfined_r:unconfined_t:s0\", u_ud, r_ud),\n        (\"system_u:unconfined_r:unconfined_t:s0\",_"]}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_remove", "test": ["pub fn remove(&mut self, index: usize) -> A::Item {\n    let targets: &mut [A::Item] = &mut self.deref_mut()[index..];\n    let item = take(&mut targets[0]);\n\n    // A previous implementation used rotate_left\n    // rotate_right and rotate_left generate a huge amount of code and fail to\n    // inline; calling them here incurs the cost of all the cases they\n    // handle even though we're rotating a usually-small array by a constant\n    // 1 offset. This swap-based implementation benchmarks much better for\n    // small array lengths in particular.\n\n    for i in 0..targets.len() - 1 {\n      targets.swap(i, i + 1);\n    }\n    self.len -= 1;\n    item\n  } [SEP] fn ArrayVec_remove() {\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n  assert_eq!(av.remove(1), 2);\n  assert_eq!(&av[..], &[1, 3][..]);\n}_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_is_send_and_sync", "test": ["pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n} [SEP] fn server_is_send_and_sync() {\n    let (_, server) = make_pair(KeyType::Rsa);\n    &server as &dyn Send;\n    &server as &dyn Sync;\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_existing", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_numbered_if_existing_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=existing\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_i64", "test": ["fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n} [SEP] fn test_write_i64() {\n    let tests = &[\n        (3i64, \"3\"),\n        (-2i64, \"-2\"),\n        (-1234i64, \"-1234\"),\n        (i64::MIN, &i64::MIN.to_string()),\n    ];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_string", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn unterminated_string() {\n    assert_err_msg(r#\"{{ \"hey }}\"#, &[\"1:4\", \"expected a value that can be negated\"]);\n}"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_unnamed_fields_variant", "test": ["fn finish(&self) -> u64 {\n        self.inner.finish()\n    } [SEP] fn enum_unnamed_fields_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::UnnamedFields(\"Hello\".to_string(), \"World\".to_string());\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_distribute_by", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn test_distribute_by() {\n    let cluster = \"SELECT a FROM db.table DISTRIBUTE BY a, b\";\n    hive().verified_stmt(cluster);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_tab_as_word_boundary", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_fold_at_tab_as_word_boundary() {\n    new_ucmd!()\n       .args(&[\"-w8\", \"-s\"])\n       .pipe_in(\"a\\tbbb\\n\")\n       .succeeds()\n       .stdout_is(\"a\\t\\nbbb\\n\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_switching_replication_mode", "test": ["pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n} [SEP] fn test_switching_replication_mode() {\n    let mut cluster = prepare_cluster();\n    run_cluster(&mut cluster);\n    let region = cluster.get_region(b\"k1\");\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k2\", b\"v2\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n       .sim\n       .rl()\n       .async_command_on_node(1, request, cb)\n       .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    must_get_none(&cluster.get_engine(1), b\"k2\");\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 1);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n\n    cluster\n       .pd_client\n       .switch_replication_mode(DrAutoSyncState::Async, vec![]);\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_object", "test": ["fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if!json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_"]}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_deps_linefeed", "test": ["pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n     .args(self.args)\n     .envs(&self.env)\n     .current_dir(self.tempdir.path().join(self.current_dir))\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .stderr(Stdio::piped())\n     .spawn()\n     .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n       .write_all(self.stdin.as_bytes())\n       .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n     .wait_with_output()\n     .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if!equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_invalid_arg", "test": ["pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    } [SEP] fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_not_add_newline_when_line_longer_than_fold", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_bytewise_should_not_add_newline_when_line_longer_than_fold() {\n    new_ucmd!()\n       .args(&[\"-w2\", \"-b\"])\n       .pipe_in(\"1234\")\n       .succeeds()\n       .stdout_is(\"12\\n34\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_log.rs::test_node_compact_reserve_max_ticks", "test": ["fn test_compact_reserve_max_ticks<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 500;\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize::mb(20));\n    cluster.cfg.raft_store.raft_log_reserve_max_ticks = 2;\n    cluster.run();\n    let apply_key = keys::apply_state_key(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let mut before_states = HashMap::default();\n    for (&id, engines) in &cluster.engines {\n        must_get_equal(&engines.kv, b\"k1\", b\"v1\");\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &apply_key);\n        let state = state.take_truncated_state();\n        // compact should not start\n        assert_eq!(RAFT_INIT_LOG_INDEX, state.get_index());\n        assert_eq!(RAFT_INIT_LOG_TERM, state.get_term());\n        before_states.insert(id, state);\n    }\n\n    for i in 1..60 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n    }\n\n    // wait log gc.\n    sleep_ms(500);\n\n    // Should GC even if limit has not reached.\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &apply_key);\n        let after_state = state.take_truncated_state();\n        let before_state = &before_states[&id];\n        assert_ne!(after_state.get_index(), before_state"]}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_single_quote_attr", "test": ["fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    } [SEP] fn test_closing_bracket_in_single_quote_attr() {\n    let mut r = Reader::from_str(\"<a attr='>' check='2'></a>\");\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\">\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"2\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dirname.rs::test_path_without_trailing_slashes_and_zero", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_path_without_trailing_slashes_and_zero() {\n    new_ucmd!()\n       .arg(\"-z\")\n       .arg(\"/root/alpha/beta/gamma/delta/epsilon/omega\")\n       .succeeds()\n       .stdout_is(\"/root/alpha/beta/gamma/delta/epsilon\\u{0}\");\n\n    new_ucmd!()\n       .arg(\"--zero\")\n       .arg(\"/root/alpha/beta/gamma/delta/epsilon/omega\")\n       .succeeds()\n       .stdout_is(\"/root/alpha/beta/gamma/delta/epsilon\\u{0}\");\n}    "]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_isolation_inc", "test": ["pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    } [SEP] fn test_isolation_inc() {\n    const THREAD_NUM: usize = 4;\n    const INC_PER_THREAD: usize = 100;\n\n    let store = AssertionStorage::default();\n    let oracle = Arc::new(Oracle::new());\n    let punch_card = Arc::new(Mutex::new(vec![false; THREAD_NUM * INC_PER_THREAD]));\n\n    let mut threads = vec![];\n    for _ in 0..THREAD_NUM {\n        let (punch_card, store, oracle) =\n            (Arc::clone(&punch_card), store.clone(), Arc::clone(&oracle));\n        threads.push(thread::spawn(move || {\n            for _ in 0..INC_PER_THREAD {\n                let number = inc(&store.store, &oracle, b\"key\").unwrap() as usize;\n                let mut punch = punch_card.lock().unwrap();\n                assert_eq!(punch[number], false);\n                punch[number] = true;\n            }\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n    assert_eq!(\n        inc(&store.store, &oracle, b\"key\").unwrap() as usize,\n        THREAD_NUM * INC_PER_THREAD\n    );\n}_"]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::rename_table", "test": ["pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    } [SEP] fn rename_table() {\n    let rename = \"ALTER TABLE db.table_name RENAME TO db.table_2\";\n    hive().verified_stmt(rename);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_twice_1", "test": ["fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    } [SEP] fn write_batch_delete_range_twice_1() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_no_such_file", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_no_such_file() {\n    new_ucmd!()\n       .arg(\"invalid_file_txt\")\n       .fails()\n       .stderr_contains(\"No such file or directory\");\n}    "]}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/conversions.rs::test_rgbau8_to_rgbau16", "test": ["fn convert(&self) -> ImageBuffer<ToType, Vec<ToType::Subpixel>> {\n        let mut buffer: ImageBuffer<ToType, Vec<ToType::Subpixel>> =\n            ImageBuffer::new(self.width, self.height);\n        for (to, from) in buffer.pixels_mut().zip(self.pixels()) {\n            to.from_color(from)\n        }\n        buffer\n    } [SEP] fn test_rgbau8_to_rgbau16() {\n    let image_u16 = ImageBuffer::from_pixel(\n        2,\n        2,\n        image::Rgba::<u16>([u16::MAX, u16::MAX, u16::MAX, u16::MAX]),\n    );\n\n    let image_u8 = ImageBuffer::from_pixel(\n        2,\n        2,\n        image::Rgba::<u8>([u8::MAX, u8::MAX, u8::MAX, u8::MAX]),\n    );\n    let image_converted: ImageBuffer<Rgba<u16>, _> = image_u8.convert();\n\n    assert_eq!(image_u16, image_converted);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_symlink_non_existing_file", "test": ["pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_chmod_symlink_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let non_existing = \"test_chmod_symlink_non_existing_file\";\n    let test_symlink = \"test_chmod_symlink_non_existing_file_symlink\";\n    let expected_stdout = &format!(\n        \"failed to change mode of '{test_symlink}' from 0000 (---------) to 1500 (r-x-----T)\"\n    );\n    let expected_stderr = &format!(\"cannot operate on dangling symlink '{test_symlink}'\");\n\n    at.symlink_file(non_existing, test_symlink);\n\n    // this cannot succeed since the symbolic link dangles\n    scene\n       .ucmd()\n       .arg(\"755\")\n       .arg(\"-v\")\n       .arg(test_symlink)\n       .fails()\n       .code_is(1)\n       .stdout_contains(expected_stdout)\n       .stderr_contains(expected_stderr);\n\n    // this should be the same than with just '-v' but without stderr\n    scene\n       .ucmd()\n       .arg(\"755\")\n       .arg(\"-v\")\n       .arg(\"-f\")\n       .arg(test_symlink)\n       .run()\n       .code_is(1)\n       .no_stderr()\n       .stdout_contains(expected_stdout);\n\n    // this should only include  the dangling symlink message\n    // NOT the failure to change mode\n    scene\n       ."]}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_20", "test": ["pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n} [SEP] fn heading_attrs_test_20() {\n    let original = r##\"# H1 {foo}\n## H2 {#myid unknown this#is.ignored attr=value.myclass}\n\"##;\n    let expected = r##\"<h1>H1</h1>\n<h2 id=\"myid\" class=\"myclass\">H2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}_"]}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::function_arguments", "test": ["fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n} [SEP] fn function_arguments() {\n    let source = r#\"def a(b, c,/, d, e = 20, *args, named=5, other=20, **kwargs): pass\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_is_empty", "test": ["pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    } [SEP] fn write_batch_is_empty() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert!(wb.is_empty());\n    wb.put(b\"a\", b\"\").unwrap();\n    assert!(!wb.is_empty());\n    wb.write().unwrap();\n    assert!(!wb.is_empty());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    assert!(wb.is_empty());\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    assert!(!wb.is_empty());\n    wb.write().unwrap();\n    assert!(!wb.is_empty());\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_three_nodes", "test": ["pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    } [SEP] fn test_force_leader_three_nodes() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store3 = find_peer(&region, 3).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store3.clone());\n\n    cluster.stop_node(2);\n    cluster.stop_node(3);\n\n    // quorum is lost, can't propose command successfully.\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![2, 3]);\n    // remove the peers on failed nodes\n    cluster\n       .pd_client\n       .must_remove_peer(region.get_id(), find_peer(&region, 2).unwrap().clone());\n    cluster\n       .pd_client\n       .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    // forbid writes in force leader state\n    let put = new_put_cmd(b\"k3\", b\"v3\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, put);\n    // forbid reads in force leader state\n    let get = new_get_cmd(b\"k1\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, get);\n    // forbid read index in force leader state\n    let read_index = new_read_index_cmd();\n_"]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/login.rs::login_works", "test": ["pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    } [SEP] fn login_works() {\n    let wasmer_dir = TempDir::new().unwrap();\n\n    // running test locally: should always pass since\n    // developers don't have access to WAPM_DEV_TOKEN\n    if std::env::var(\"GITHUB_TOKEN\").is_err() {\n        return;\n    }\n    let wapm_dev_token = std::env::var(\"WAPM_DEV_TOKEN\").expect(\"WAPM_DEV_TOKEN env var not set\");\n    // Special case: GitHub secrets aren't visible to outside collaborators\n    if wapm_dev_token.is_empty() {\n        return;\n    }\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"login\")\n       .arg(\"--registry=wasmer.wtf\")\n       .arg(wapm_dev_token)\n       .env(\"WASMER_DIR\", wasmer_dir.path())\n       .assert();\n\n    assert\n       .success()\n       .stdout(contains(r#\"Login for Wasmer user \"ciuser\" saved\"#));\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_region_split", "test": ["pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    } [SEP] fn test_region_split() {\n    let cluster = new_server_cluster(1, 1);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let region = suite.cluster.get_region(&[]);\n    let mut req = suite.new_changedata_request(region.get_id());\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.get_id()));\n    block_on(req_tx.send((req.clone(), WriteFlags::default()))).unwrap();\n    // Make sure region 1 is registered.\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        // Even if there is no write,\n        // it should always outputs an Initialized event.\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 1, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n    // Split region.\n    suite.cluster.must_split(&region, b\"k0\");\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Error(err) => {\n            assert!(err.has_epoch_not_match(), \"{:?}\", err);\n        }\n        other => panic!_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/threads.rs::test_multi_memory", "test": ["pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    } [SEP] fn test_multi_memory() -> Result<()> {\n    let wat = r#\"(module\n        (import \"env\" \"imported\" (memory $imported 5 10 shared))\n        (memory (export \"owned\") 10 20)\n        (memory (export \"shared\") 1 2 shared)\n        (export \"imported\" (memory $imported))\n    )\"#;\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    config.wasm_multi_memory(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let incoming_shared_memory = SharedMemory::new(&engine, MemoryType::shared(5, 10))?;\n    let instance = Instance::new(&mut store, &module, &[incoming_shared_memory.into()])?;\n    let owned_memory = instance.get_memory(&mut store, \"owned\").unwrap();\n    let shared_memory = instance.get_shared_memory(&mut store, \"shared\").unwrap();\n    let imported_memory = instance.get_shared_memory(&mut store, \"imported\").unwrap();\n\n    assert_eq!(owned_memory.size(&store), 10);\n    assert_eq!(owned_memory.ty(&store).minimum(), 10);\n    assert_eq!(owned_memory.ty(&store).maximum(), Some(20));\n    assert_eq!(owned_memory.ty(&store).is_shared(), false);\n    assert_eq!(shared_memory.size(), 1);\n    assert_eq!(shared_memory.ty().minimum(), 1);\n    assert_eq!(shared_memory.ty().maximum(), Some(2));\n    assert_eq!(shared_memory.ty().is_shared(), true);\n    assert_eq!(imported_memory.size(), 5);\n    assert_eq!(imported_memory.ty().minimum(), 5);\n    assert_"]}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_even_if_resolver_fails", "test": ["pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n           .as_ref()\n           .map(<DnsName as AsRef<str>>::as_ref)\n    } [SEP] fn server_exposes_offered_sni_even_if_resolver_fails() {\n    let kt = KeyType::Rsa;\n    let resolver = rustls::server::ResolvesServerCertUsingSni::new();\n\n    let mut server_config = make_server_config(kt);\n    server_config.cert_resolver = Arc::new(resolver);\n    let server_config = Arc::new(server_config);\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"thisdoesNOTexist.com\"))\n               .unwrap();\n\n        assert_eq!(None, server.server_name());\n        transfer(&mut client, &mut server);\n        assert_eq!(\n            server.process_new_packets(),\n            Err(Error::General(\n                \"no server certificate chain resolved\".to_string()\n            ))\n        );\n        assert_eq!(Some(\"thisdoesnotexist.com\"), server.server_name());\n    }\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_owner", "test": ["pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    } [SEP] fn test_chown_only_owner() {\n    // test chown username file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    // since only superuser can change owner, we have to change from ourself to ourself\n    let result = scene\n       .ucmd()\n       .arg(user_name)\n       .arg(\"--verbose\")\n       .arg(file1)\n       .run();\n    result.stderr_contains(\"retained as\");\n\n    // try to change to another existing user, e.g. 'root'\n    scene\n       .ucmd()\n       .arg(\"root\")\n       .arg(\"--verbose\")\n       .arg(file1)\n       .fails()\n       .stderr_contains(\"failed to change\");\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_server_leader_change_with_uncommitted_log", "test": ["fn test_leader_change_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // So peer 3 won't replicate any message of the region but still can vote.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // peer 1 and peer 2 must have k2, but peer 3 must not.\n    for i in 1..3 {\n        let engine = cluster.get_engine(i);\n        must_get_equal(&engine, b\"k1\", b\"v1\");\n    }\n\n    let engine3 = cluster.get_engine(3);\n    must_get_none(&engine3, b\"k1\");\n\n    // now only peer 1 and peer 2 can step to leader.\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n           .msg_type(MessageType::MsgAppend)\n           .direction(Direction::Recv)\n           .allow(1),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it becomes leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n           .msg_type(MessageType"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_false.rs::test_help", "test": ["pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    } [SEP] fn test_help() {\n    new_ucmd!()\n       .args(&[\"--help\"])\n       .fails()\n       .stdout_contains(\"false\");\n}    "]}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::wasi_runner_on_disk_mount_using_relative_directory_on_the_host", "test": ["pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    } [SEP] fn wasi_runner_on_disk_mount_using_relative_directory_on_the_host() {\n    let temp = TempDir::new_in(env!(\"CARGO_TARGET_TMPDIR\")).unwrap();\n    std::fs::write(temp.path().join(\"main.py\"), \"print('Hello, World!')\").unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n       .arg(\"run\")\n       .arg(fixtures::python())\n       .arg(\"--mapdir=/app:.\")\n       .arg(\"--\")\n       .arg(\"/app/main.py\")\n       .env(\"RUST_LOG\", &*RUST_LOG)\n       .current_dir(temp.path())\n       .assert();\n\n    assert.success().stdout(contains(\"Hello, World!\"));\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn catch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw \"error\";\n            } catch {\n                a = 20;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"]}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::subquery_nested", "test": ["fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n} [SEP] fn subquery_nested() {\n    let needle = \"{int $i = _($i+_($i)); _($i)=10;}\";\n    let source = \"void b(){int bar = 100*17-f(bar+x(bar)); bar = 10;}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}_"]}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/regression.rs::invalid_regexes_no_crash", "test": ["pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    } [SEP] fn invalid_regexes_no_crash() {\n    assert!(regex_new!(\"(*)\").is_err());\n    assert!(regex_new!(\"(?:?)\").is_err());\n    assert!(regex_new!(\"(?)\").is_err());\n    assert!(regex_new!(\"*\").is_err());\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_command_with_args", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_command_with_args() {\n    new_ucmd!()\n       .args(&[\"-n\", \"19\", \"echo\", \"a\", \"b\", \"c\"])\n       .run()\n       .stdout_is(\"a b c\\n\");\n}    "]}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_role", "test": ["pub fn assert_eq_vec<T: ToString>(expected: &[&str], actual: &[T]) {\n    assert_eq!(\n        expected,\n        actual.iter().map(ToString::to_string).collect::<Vec<_>>()\n    );\n} [SEP] fn parse_drop_role() {\n    let sql = \"DROP ROLE abc\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names,\n            object_type,\n            if_exists,\n           ..\n        } => {\n            assert_eq_vec(&[\"abc\"], &names);\n            assert_eq!(ObjectType::Role, object_type);\n            assert!(!if_exists);\n        }\n        _ => unreachable!(),\n    };\n\n    let sql = \"DROP ROLE IF EXISTS def, magician, quaternion\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names,\n            object_type,\n            if_exists,\n           ..\n        } => {\n            assert_eq_vec(&[\"def\", \"magician\", \"quaternion\"], &names);\n            assert_eq!(ObjectType::Role, object_type);\n            assert!(if_exists);\n        }\n        _ => unreachable!(),\n    }\n}_"]}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/num.rs::as_primitive_test", "test": ["fn check_as_primitive<T: AsPrimitive>(t: T) {\n    let _: u32 = t.as_u32();\n    let _: u64 = t.as_u64();\n    let _: u128 = t.as_u128();\n    let _: usize = t.as_usize();\n    let _: f32 = t.as_f32();\n    let _: f64 = t.as_f64();\n} [SEP] fn as_primitive_test() {\n    check_as_primitive(1u32);\n    check_as_primitive(1u64);\n    check_as_primitive(1u128);\n    check_as_primitive(1usize);\n    check_as_primitive(1f32);\n    check_as_primitive(1f64);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_never", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_mv_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=never\")\n       .arg(file_a)\n       .arg(file_b)\n       .succeeds()\n       .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}_"]}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_test_argument", "test": ["fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n} [SEP] fn invalid_test_argument() {\n    assert_err_msg(\n        r#\"{% if a is odd(key=1) %}\"#,\n        &[\n            \"1:19\",\n            \"expected `or`, `and`, `not`, `<=`, `>=`, `<`, `>`, `==`, `!=`, `+`, `-`, `*`, `/`, `%`, or a filter\"\n        ],\n    );\n}"]}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes256_encrypted_file", "test": ["pub fn name(&self) -> &str {\n        &self.data.file_name\n    } [SEP] fn aes256_encrypted_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n       .by_name_decrypt(\"secret_data_256\", PASSWORD)\n       .expect(\"couldn't find file in archive\")\n       .expect(\"invalid password\");\n    assert_eq!(\"secret_data_256\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n       .expect(\"couldn't read encrypted and compressed file\");\n    assert_eq!(SECRET_CONTENT, content);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_partition_leader_in_minority_detect_in_majority", "test": ["fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_read_on_replica", "test": ["pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    } [SEP] fn test_read_on_replica() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.cfg.raft_store.hibernate_regions = false;\n    cluster.run();\n\n    let k1 = b\"k1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n    let (k3, v3) = (b\"k3\", b\"v3\");\n    let (k4, v4) = (b\"k4\", b\"v4\");\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(k1), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let mut leader_storage = cluster.sim.rl().storages[&leader.get_id()].clone();\n\n    let mut leader_ctx = Context::default();\n    leader_ctx.set_region_id(region.get_id());\n    leader_ctx.set_region_epoch(region.get_region_epoch().clone());\n    leader_ctx.set_peer(leader.clone());\n    let leader_snap_ctx = SnapContext {\n        pb_ctx: &leader_ctx,\n       ..Default::default()\n    };\n\n    // write some data\n    let peers = region.get_peers();\n    assert_none(leader_snap_ctx, &mut leader_storage, k2);\n    must_put(&leader_ctx, &leader_storage, k2, v2);\n\n    // read on follower\n    let mut follower_peer = None;\n    let mut follower_id = 0;\n    for p in peers {\n        if p.get_id()!= leader.get_id() {\n            follower_id = p.get_id();\n            follower_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_invalid_threshold", "test": ["pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    } [SEP] fn test_du_invalid_threshold() {\n    let ts = TestScenario::new(util_name!());\n\n    let threshold = \"-0\";\n\n    ts.ucmd().arg(format!(\"--threshold={threshold}\")).fails();\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_txn_failpoints", "test": ["pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    } [SEP] fn test_txn_failpoints() {\n    let mut engine = TestEngineBuilder::new().build().unwrap();\n    let (k, v) = (b\"k\", b\"v\");\n    fail::cfg(\"prewrite\", \"return(WriteConflict)\").unwrap();\n    must_prewrite_put_err(&mut engine, k, v, k, 10);\n    fail::remove(\"prewrite\");\n    must_prewrite_put(&mut engine, k, v, k, 10);\n    fail::cfg(\"commit\", \"delay(100)\").unwrap();\n    must_commit(&mut engine, k, 10, 20);\n    fail::remove(\"commit\");\n\n    let v1 = b\"v1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n    must_acquire_pessimistic_lock(&mut engine, k, k, 30, 30);\n    fail::cfg(\"pessimistic_prewrite\", \"return()\").unwrap();\n    must_pessimistic_prewrite_put_err(&mut engine, k, v1, k, 30, 30, DoPessimisticCheck);\n    must_prewrite_put(&mut engine, k2, v2, k2, 31);\n    fail::remove(\"pessimistic_prewrite\");\n    must_pessimistic_prewrite_put(&mut engine, k, v1, k, 30, 30, DoPessimisticCheck);\n    must_commit(&mut engine, k, 30, 40);\n    must_commit(&mut engine, k2, 31, 41);\n    must_get(&mut engine, k, 50, v1);\n    must_get(&mut engine, k2, 50, v2);\n}_"]}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_kv_service.rs::test_batch_get_memory_lock", "test": ["fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    } [SEP] fn test_batch_get_memory_lock() {\n    let (_cluster, client, ctx) = must_new_cluster_and_kv_client();\n\n    let mut req = BatchGetRequest::default();\n    req.set_context(ctx);\n    req.set_keys(vec![b\"a\".to_vec(), b\"b\".to_vec()].into());\n    req.version = 50;\n\n    fail::cfg(\"raftkv_async_snapshot_err\", \"return\").unwrap();\n    let resp = client.kv_batch_get(&req).unwrap();\n    // the injected error should be returned at both places for backward\n    // compatibility.\n    assert!(!resp.pairs[0].get_error().get_abort().is_empty());\n    assert!(!resp.get_error().get_abort().is_empty());\n    fail::remove(\"raftkv_async_snapshot_err\");\n}_"]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/fuel_consumption_mode.rs::eager_consumption_mode", "test": ["fn check_consumption_mode(mode: FuelConsumptionMode, given_fuel: u64, consumed_fuel: u64) {\n    assert!(given_fuel >= consumed_fuel);\n    let wasm = wat2wasm(test_module());\n    let (mut store, func) = default_test_setup(mode, &wasm);\n    let func = func.typed::<(), i32>(&store).unwrap();\n    // Now add enough fuel, so execution should succeed.\n    store.add_fuel(given_fuel).unwrap(); // this is just enough fuel for a successful `memory.grow`\n    assert_success(func.call(&mut store, ()));\n    assert_eq!(store.fuel_consumed(), Some(consumed_fuel));\n} [SEP] fn eager_consumption_mode() {\n    check_consumption_mode(FuelConsumptionMode::Eager, 1030, 1028);\n}"]}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_1", "test": ["fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n} [SEP] fn remove_entry_multi_1() {\n    let mut headers = HeaderMap::new();\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 1);\n    assert_eq!(headers.len(), 0);\n}_"]}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::class", "test": ["fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    } [SEP] fn class() {\n    test(\"class Foo extends (a, b) {}\", \"class Foo extends (a,b){}\");\n    test(\"class Foo { get foo() {} }\", \"class Foo{get foo(){}}\");\n    test(\"class Foo { set foo(x) {} }\", \"class Foo{set foo(x){}}\");\n    test(\"class Foo { static foo() {} }\", \"class Foo{static foo(){}}\");\n    test(\"class Foo { static get foo() {} }\", \"class Foo{static get foo(){}}\");\n    test(\"class Foo { static set foo(x) {} }\", \"class Foo{static set foo(x){}}\");\n}"]}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_add3_works", "test": ["pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    } [SEP] fn static_add3_works() {\n    let (mut store, add3, add3_dyn) = setup_add3();\n    let add3 = add3.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    let add3_dyn = add3_dyn.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    for a in 0..5 {\n        for b in 0..5 {\n            for c in 0..5 {\n                let expected = a + b + c;\n                assert_eq!(add3.call(&mut store, (a, b, c)).unwrap(), expected);\n                assert_eq!(add3_dyn.call(&mut store, (a, b, c)).unwrap(), expected);\n            }\n        }\n    }\n}_"]}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_binding_pattern_array", "test": ["pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    } [SEP] fn catch_binding_pattern_array() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw [20, 30];\n            } catch ([, n]) {\n                a = n;\n            }\n\n            a;\n        \"#},\n        30,\n    )]);\n}"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_ymdhm_time", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_touch_set_ymdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_ymdhm_time\";\n\n    ucmd.args(&[\"-t\", \"1501011234\", file])\n       .succeeds()\n       .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_with_group", "test": ["pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    } [SEP] fn test_install_target_new_file_with_group() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n    let gid = getegid();\n\n    at.touch(file);\n    at.mkdir(dir);\n    let result = ucmd\n       .arg(file)\n       .arg(\"--group\")\n       .arg(gid.to_string())\n       .arg(format!(\"{dir}/{file}\"))\n       .run();\n\n    if is_ci() && result.stderr_str().contains(\"no such group:\") {\n        // In the CI, some server are failing to return the group.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}_"]}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_string_handling", "test": ["pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    } [SEP] fn test_relative_string_handling() {\n    let result = new_ucmd!()\n       .args(&[\"-m\", \"--relative-to=prefix\", \"prefixed/1\"])\n       .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefixed/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefixed\\\\1\\n\");\n\n    let result = new_ucmd!()\n       .args(&[\"-m\", \"--relative-to=prefixed\", \"prefix/1\"])\n       .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefix/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefix\\\\1\\n\");\n\n    new_ucmd!()\n       .args(&[\"-m\", \"--relative-to=prefixed\", \"prefixed/1\"])\n       .succeeds()\n       .stdout_is(\"1\\n\");\n}_"]}
