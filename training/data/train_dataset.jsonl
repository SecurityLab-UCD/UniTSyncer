{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram_stream_upgrades_on_truncation", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_datagram_stream_upgrades_on_truncation() {\n    // Lookup to UDP should return a truncated message, then we expect lookup on TCP.\n    // This should occur even though `try_tcp_on_error` is set to false.\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let mut udp_message = message(query.clone(), vec![], vec![], vec![]);\n    udp_message.set_truncated(true);\n\n    let tcp_message = message(query.clone(), vec![tcp_record.clone()], vec![], vec![]);\n\n    let udp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        Default::default(),\n    );\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![udp_nameserver],\n        vec![tcp_nameserver],\n        None,\n        Default::default(),\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], tcp_record);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/substitute_alternate_syntax.rs::undefined", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn undefined() {\n    test(\"var x = undefined\", \"var x;\");\n    test(\n        \"var undefined = 1;function f() {var undefined=2;var x;}\",\n        \"var undefined=1;function f(){var undefined=2,x}\",\n    );\n    test(\"function f(undefined) {}\", \"function f(undefined){}\");\n    test(\"try {} catch(undefined) {}\", \"try{}catch(undefined){}\");\n    test(\"for (undefined in {}) {}\", \"for(undefined in {}){}\");\n    test(\"undefined++\", \"undefined++;\");\n    test(\"undefined += undefined;\", \"undefined+=void 0;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_suffix_empty_template", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_suffix_empty_template() {\n    new_ucmd!()\n        .args(&[\"--suffix=aXXXb\", \"\"])\n        .fails()\n        .stderr_is(\"mktemp: with --suffix, template '' must end in X\\n\");\n\n    new_ucmd!()\n        .args(&[\"-d\", \"--suffix=aXXXb\", \"\"])\n        .fails()\n        .stderr_is(\"mktemp: with --suffix, template '' must end in X\\n\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_externally_a_roundtrip", "code": "fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n}", "test": "fn test_externally_a_roundtrip() {\n    let v = EnumStructExternally::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    test_roundtrip(v);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_distinct_tuple", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_select_distinct_tuple() {\n    let sql = \"SELECT DISTINCT (name, id) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &vec![SelectItem::UnnamedExpr(Expr::Tuple(vec![\n            Expr::Identifier(Ident::new(\"name\")),\n            Expr::Identifier(Ident::new(\"id\")),\n        ]))],\n        &select.projection\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_invalid_range", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_invalid_range() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n\n    let mut select = DagSelect::from(&product);\n    select.key_ranges[0].set_start(b\"xxx\".to_vec());\n    select.key_ranges[0].set_end(b\"zzz\".to_vec());\n    let req = select.build();\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_other_error().is_empty());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_write_twice_2", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_write_twice_2() {\n    let db = default_engine();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"b\");\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n\n    let db = multi_batch_write_engine();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"b\");\n\n    for i in 0..128_usize {\n        let k = i.to_be_bytes();\n        let v = (2 * i + 1).to_be_bytes();\n        db.engine.put(&k, &v).unwrap();\n    }\n    for i in 0..128_usize {\n        let k = i.to_be_bytes();\n        let v = (2 * i + 1).to_be_bytes();\n        assert_eq!(db.engine.get_value(&k).unwrap().unwrap(), &v);\n    }\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        assert_eq!(db.engine.get_value(&x).unwrap().unwrap(), &x);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_preserve_root", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_chmod_preserve_root() {\n    new_ucmd!()\n        .arg(\"-R\")\n        .arg(\"--preserve-root\")\n        .arg(\"755\")\n        .arg(\"/\")\n        .fails()\n        .stderr_contains(\"chmod: it is dangerous to operate recursively on '/'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_no_match3", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_no_match3() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/0$/\", \"{50}\"])\n        .fails()\n        .stdout_is(\"18\\n30\\n30\\n30\\n30\\n3\\n\")\n        .stderr_is(\"csplit: '/0$/': match not found on repetition 5\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/0$/\", \"{50}\", \"-k\"])\n        .fails()\n        .stdout_is(\"18\\n30\\n30\\n30\\n30\\n3\\n\")\n        .stderr_is(\"csplit: '/0$/': match not found on repetition 5\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 6);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 20));\n    assert_eq!(at.read(\"xx02\"), generate(20, 30));\n    assert_eq!(at.read(\"xx03\"), generate(30, 40));\n    assert_eq!(at.read(\"xx04\"), generate(40, 50));\n    assert_eq!(at.read(\"xx05\"), \"50\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/os_attributes.rs::none", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn none() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo bar\n    \",\n    )\n    .stdout(\"bar\\n\")\n    .stderr(\"echo bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_wrong_time", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_sleep_wrong_time() {\n    new_ucmd!().args(&[\"0.1s\", \"abc\"]).fails();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::floor_log2_pow10_test", "code": "fn dragonbox_log2_10(q: i32) -> i32 {\n    let c = floor_shift(3, 0x5269e12f346e2bf9, 19);\n    let s = floor_shift(0, 0, 19);\n    (q * c - s) >> 19\n}", "test": "fn floor_log2_pow10_test() {\n    for q in -1233i32..=1233 {\n        let actual = algorithm::floor_log2_pow10(q);\n        let expected = dragonbox_log2_10(q);\n        assert_eq!(actual, expected);\n    }\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::function_arguments", "code": "fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n}", "test": "fn function_arguments() {\n    let source = r#\"def a(b, c,/, d, e = 20, *args, named=5, other=20, **kwargs): pass\"#;\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_when_symlink_part_is_missing", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_realpath_when_symlink_part_is_missing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"dir2\");\n    at.touch(\"dir2/bar\");\n\n    at.mkdir(\"dir1\");\n    at.relative_symlink_file(\"../dir2/bar\", \"dir1/foo1\");\n    at.relative_symlink_file(\"dir2/bar\", \"dir1/foo2\");\n    at.relative_symlink_file(\"../dir2/baz\", \"dir1/foo3\");\n    at.symlink_file(\"dir3/bar\", \"dir1/foo4\");\n\n    let expect1 = format!(\"dir2{MAIN_SEPARATOR}bar\");\n    let expect2 = format!(\"dir2{MAIN_SEPARATOR}baz\");\n\n    ucmd.args(&[\"dir1/foo1\", \"dir1/foo2\", \"dir1/foo3\", \"dir1/foo4\"])\n        .run()\n        .stdout_contains(expect1 + \"\\n\")\n        .stdout_contains(expect2 + \"\\n\")\n        .stderr_contains(\"realpath: dir1/foo2: No such file or directory\\n\")\n        .stderr_contains(\"realpath: dir1/foo4: No such file or directory\\n\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_block_missing_name", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_block_missing_name() {\n    assert_err_msg(r#\"{% block %}\"#, &[\"1:10\", \"expected an identifier (must start with a-z)\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_write_conflict", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_txn_store_write_conflict() {\n    let store = AssertionStorage::default();\n    let key = b\"key\";\n    let primary = b\"key\";\n    let conflict_start_ts = 5;\n    let conflict_commit_ts = 10;\n    store.put_ok(key, primary, conflict_start_ts, conflict_commit_ts);\n    let start_ts2 = 6;\n    store.prewrite_conflict(\n        vec![Mutation::make_put(Key::from_raw(key), primary.to_vec())],\n        primary,\n        start_ts2,\n        key,\n        conflict_start_ts,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_arch.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_apply_log.rs::test_basic_apply", "code": "fn apply(&mut self, _ctx: RpcContext<'_>, req: ApplyRequest, sink: UnarySink<ApplyResponse>) {\n        let label = \"apply\";\n        let start = Instant::now();\n        let importer = self.importer.clone();\n        let limiter = self.limiter.clone();\n        let max_raft_size = self.raft_entry_max_size.0 as usize;\n        let applier = self.writer.clone();\n\n        let handle_task = async move {\n            // Records how long the apply task waits to be scheduled.\n            sst_importer::metrics::IMPORTER_APPLY_DURATION\n                .with_label_values(&[\"queue\"])\n                .observe(start.saturating_elapsed().as_secs_f64());\n\n            let mut resp = ApplyResponse::default();\n\n            match Self::apply_imp(req, importer, applier, limiter, max_raft_size).await {\n                Ok(Some(r)) => resp.set_range(r),\n                Err(e) => resp.set_error(e),\n                _ => {}\n            }\n\n            debug!(\"finished apply kv file with {:?}\", resp);\n            crate::send_rpc_response!(Ok(resp), sink, label, start);\n        };\n        self.threads.spawn(handle_task);\n    }", "test": "fn test_basic_apply() {\n    let (_cluster, ctx, tikv, import) = util::new_cluster_and_tikv_import_client();\n    let tmp = TempDir::new().unwrap();\n    let storage = LocalStorage::new(tmp.path()).unwrap();\n    let default = [\n        (b\"k1\", b\"v1\", 1),\n        (b\"k2\", b\"v2\", 2),\n        (b\"k3\", b\"v3\", 3),\n        (b\"k4\", b\"v4\", 4),\n    ];\n    let default_rewritten = [(b\"r1\", b\"v1\", 1), (b\"r2\", b\"v2\", 2), (b\"r3\", b\"v3\", 3)];\n    let mut sst_meta =\n        util::make_plain_file(&storage, \"file1.log\", IntoIterator::into_iter(default));\n    util::register_range_for(&mut sst_meta, b\"k1\", b\"k3a\");\n    let mut req = ApplyRequest::new();\n    req.set_context(ctx.clone());\n    req.set_rewrite_rules(vec![util::rewrite_for(&mut sst_meta, b\"k\", b\"r\")].into());\n    req.set_metas(vec![sst_meta].into());\n    req.set_storage_backend(util::local_storage(&tmp));\n    import.apply(&req).unwrap();\n    util::check_applied_kvs_cf(\n        &tikv,\n        &ctx,\n        CF_DEFAULT,\n        IntoIterator::into_iter(default_rewritten),\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_create", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_create() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    let mut record = record;\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = io_loop\n        .block_on(client.create(record, origin))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_disk_full_for_region_leader", "code": "fn test_disk_full_leader_behaviors(usage: DiskUsage) {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // To ensure all replicas are not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n\n    // Test new normal proposals won't be allowed when disk is full.\n    let old_last_index = cluster.raft_local_state(1, 1).last_index;\n    let mut rx = cluster.async_put(b\"k2\", b\"v2\").unwrap();\n    assert_disk_full(&rx.recv_timeout(Duration::from_secs(2)).unwrap());\n    let new_last_index = cluster.raft_local_state(1, 1).last_index;\n    assert_eq!(old_last_index, new_last_index);\n\n    assert_region_leader_changed(&mut cluster, 1, 1);\n    fail::remove(get_fp(usage, 1));\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n\n    // merge/split is only allowed on disk almost full.\n    if usage != DiskUsage::AlreadyFull {\n        // Test split must be allowed when disk is full.\n        let region = cluster.get_region(b\"k1\");\n        cluster.must_split(&region, b\"k1\");\n    }\n    // Test transfer leader should be allowed.\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    // Transfer the leadership back to store 1.\n    fail::remove(get_fp(usage, 1));\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n\n    // Test remove peer should be allowed.\n    cluster.pd_client.must_remove_peer(1, new_peer(3, 3));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    // Test add peer should be allowed.\n    cluster.pd_client.must_add_peer(1, new_peer(3, 3));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    fail::remove(get_fp(usage, 1));\n}", "test": "fn test_disk_full_for_region_leader() {\n    test_disk_full_leader_behaviors(DiskUsage::AlmostFull);\n    test_disk_full_leader_behaviors(DiskUsage::AlreadyFull);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_select_failed", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_select_failed() {\n    let mut cluster = test_raftstore::new_server_cluster(0, 3);\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n    cluster.run();\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(b\"\"), None);\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let engine = cluster.sim.rl().storages[&leader.get_id()].clone();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) =\n        init_data_with_engine_and_commit(ctx.clone(), engine, &product, &[], true);\n\n    // Sleep until the leader lease is expired.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_heartbeat_interval()\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32\n            * 2,\n    );\n    for id in 1..=3 {\n        if id != ctx.get_peer().get_store_id() {\n            cluster.stop_node(id);\n        }\n    }\n    let req = DagSelect::from(&product).build_with(ctx.clone(), &[0]);\n    let f = endpoint.parse_and_handle_unary_request(req, None);\n    cluster.stop_node(ctx.get_peer().get_store_id());\n    drop(cluster);\n    let _ = futures::executor::block_on(f);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_3339_invalid_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_date_rfc_3339_invalid_arg() {\n    for param in [\"--iso-3339\", \"--rfc-3\"] {\n        new_ucmd!().arg(format!(\"{param}=foo\")).fails();\n    }\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::cube_array", "code": "fn require_and_forbid(required: &[Ca], forbidden: &[Ca], source: &str) {\n    let caps_used = capabilities_used(source);\n\n    let missing_caps: Vec<_> = required\n        .iter()\n        .filter(|&cap| !caps_used.contains(cap))\n        .cloned()\n        .collect();\n    if !missing_caps.is_empty() {\n        panic!(\"shader code should have requested these caps: {missing_caps:?}\\n\\n{source}\");\n    }\n\n    let forbidden_caps: Vec<_> = forbidden\n        .iter()\n        .filter(|&cap| caps_used.contains(cap))\n        .cloned()\n        .collect();\n    if !forbidden_caps.is_empty() {\n        panic!(\"shader code should not have requested these caps: {forbidden_caps:?}\\n\\n{source}\");\n    }\n}", "test": "fn cube_array() {\n    // ImageCubeArray is only for storage cube array images, which WGSL doesn't\n    // support\n    require_and_forbid(\n        &[Ca::SampledCubeArray],\n        &[Ca::ImageCubeArray],\n        r#\"\n        @group(0) @binding(0)\n        var image_cube: texture_cube_array<f32>;\n    \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_from_env_precedences", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_from_env_precedences() {\n    fn get_header(one: (&str, &str), two: (&str, &str)) -> String {\n        let (k1, v1) = one;\n        let (k2, v2) = two;\n        let output = new_ucmd!()\n            .arg(\"--output=size\")\n            .env(k1, v1)\n            .env(k2, v2)\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    let df_block_size = (\"DF_BLOCK_SIZE\", \"111\");\n    let block_size = (\"BLOCK_SIZE\", \"222\");\n    let blocksize = (\"BLOCKSIZE\", \"333\");\n\n    assert_eq!(get_header(df_block_size, block_size), \"111B-blocks\");\n    assert_eq!(get_header(df_block_size, blocksize), \"111B-blocks\");\n    assert_eq!(get_header(block_size, blocksize), \"222B-blocks\");\n}"}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/tests.rs::encode_engine_slice_error_when_buffer_too_small", "code": "fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError> {\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output_buf: &mut [u8],\n        ) -> Result<usize, EncodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect(\"usize overflow when calculating buffer size\");\n\n            if output_buf.len() < encoded_size {\n                return Err(EncodeSliceError::OutputSliceTooSmall);\n            }\n\n            let b64_output = &mut output_buf[0..encoded_size];\n\n            encode_with_padding(input_bytes, b64_output, engine, encoded_size);\n\n            Ok(encoded_size)\n        }\n\n        inner(self, input.as_ref(), output_buf)\n    }", "test": "fn encode_engine_slice_error_when_buffer_too_small() {\n    for num_triples in 1..100 {\n        let input = \"AAA\".repeat(num_triples);\n        let mut vec = vec![0; (num_triples - 1) * 4];\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            num_triples * 4,\n            STANDARD.encode_slice(&input, &mut vec).unwrap()\n        );\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/router.rs::test_router_trace", "code": "pub fn alive_cnt(&self) -> usize {\n        self.normals.len()\n    }", "test": "fn test_router_trace() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n\n    let register_runner = |addr| {\n        let (sender, runner) = Runner::new(10);\n        let mailbox = BasicMailbox::new(sender, runner, router.state_cnt().clone());\n        router.register(addr, mailbox);\n    };\n    let close_runner = |addr| {\n        router.close(addr);\n    };\n\n    let mut mailboxes = vec![];\n    for i in 0..10 {\n        register_runner(i);\n        mailboxes.push(router.mailbox(i).unwrap());\n    }\n    assert_eq!(router.alive_cnt(), 10);\n    assert_eq!(router.state_cnt().load(Ordering::Relaxed), 11);\n    for i in 0..10 {\n        close_runner(i);\n    }\n    assert_eq!(router.alive_cnt(), 0);\n    assert_eq!(router.state_cnt().load(Ordering::Relaxed), 11);\n    drop(mailboxes);\n    assert_eq!(router.alive_cnt(), 0);\n    assert_eq!(router.state_cnt().load(Ordering::Relaxed), 1);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::free", "code": "pub fn abort(mut self) -> Result {\n        // Set completed flag first, so that we don't go through the abort() path on drop, if this fails\n        self.completed = true;\n        self.abort_inner()\n    }", "test": "fn free() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n    {\n        let _table = txn.open_table(SLICE_TABLE).unwrap();\n        let mut table = txn.open_table(SLICE_TABLE2).unwrap();\n        table.insert([].as_slice(), [].as_slice()).unwrap();\n    }\n    txn.commit().unwrap();\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE2).unwrap();\n        table.remove([].as_slice()).unwrap();\n    }\n    txn.commit().unwrap();\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let allocated_pages = txn.stats().unwrap().allocated_pages();\n\n    let key = vec![0; 100];\n    let value = vec![0u8; 1024];\n    let target_db_size = 8 * 1024 * 1024;\n    // Write 10% of db space each iteration\n    let num_writes = target_db_size / 10 / (key.len() + value.len());\n    // Make sure an internal index page is required\n    assert!(num_writes > 64);\n\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..num_writes {\n            let mut mut_key = key.clone();\n            mut_key.extend_from_slice(&(i as u64).to_le_bytes());\n            table.insert(mut_key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    {\n        let key_range: Vec<usize> = (0..num_writes).collect();\n        // Delete in chunks to be sure that we don't run out of pages due to temp allocations\n        for chunk in key_range.chunks(10) {\n            let txn = db.begin_write().unwrap();\n            {\n                let mut table = txn.open_table(SLICE_TABLE).unwrap();\n                for i in chunk {\n                    let mut mut_key = key.clone();\n                    mut_key.extend_from_slice(&(*i as u64).to_le_bytes());\n                    table.remove(mut_key.as_slice()).unwrap();\n                }\n            }\n            txn.commit().unwrap();\n        }\n    }\n\n    // Extra commit to finalize the cleanup of the freed pages\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n    let txn = db.begin_write().unwrap();\n    assert_eq!(allocated_pages, txn.stats().unwrap().allocated_pages());\n    txn.abort().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printenv.rs::test_get_var", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_get_var() {\n    let result = TestScenario::new(util_name!())\n        .ucmd()\n        .env(\"KEY\", \"VALUE\")\n        .arg(\"KEY\")\n        .succeeds();\n\n    assert!(!result.stdout_str().is_empty());\n    assert_eq!(result.stdout_str().trim(), \"VALUE\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_no_change_to_user() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\"43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\"ownership of '{file}' retained as {user_name}\\n\"));\n    }\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_3_others_b", "code": "fn remove_values<K>(headers: &mut HeaderMap, key: K) -> Option<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => Some(e.remove_entry().1),\n        Entry::Vacant(_) => None,\n    }\n}", "test": "fn remove_entry_3_others_b() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n    headers.insert(VARY, \"*\".parse().unwrap());\n\n    assert_eq!(headers.len(), 6);\n\n    let vary = remove_values(&mut headers, VARY);\n    assert_eq!(vary, Some(\"*\".parse().unwrap()));\n    assert_eq!(headers.len(), 5);\n\n    let via = remove_values(&mut headers, VIA);\n    assert_eq!(via, Some(\"1.1 example.com\".parse().unwrap()));\n    assert_eq!(headers.len(), 3);\n\n    let cookie = remove_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookie, Some(\"cookie_1=value 1\".parse().unwrap()));\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_append", "code": "pub fn append(&mut self, other: &mut Self) {\n    assert!(\n      self.try_append(other).is_none(),\n      \"ArrayVec::append> total length {} exceeds capacity {}!\",\n      self.len() + other.len(),\n      A::CAPACITY\n    );\n  }", "test": "fn ArrayVec_append() {\n  let mut av = array_vec!([i32; 8] => 1, 2, 3);\n  let mut av2 = array_vec!([i32; 8] => 4, 5, 6);\n  //\n  av.append(&mut av2);\n  assert_eq!(av.as_slice(), &[1_i32, 2, 3, 4, 5, 6]);\n  assert_eq!(av2.as_slice(), &[]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::test_no_such_file", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_no_such_file() {\n    new_ucmd!()\n        .args(&[\"bogus_file_1\", \"bogus_file_2\"])\n        .fails()\n        .stderr_only(\"comm: bogus_file_1: No such file or directory\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_ephemeron_test", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "test": "fn eph_ephemeron_test() {\n    run_test(|| {\n        let gc_value = Gc::new(3);\n\n        {\n            let cloned_gc = gc_value.clone();\n\n            let ephemeron = Ephemeron::new(&cloned_gc, String::from(\"Hello World!\"));\n\n            assert_eq!(\n                *ephemeron.value().expect(\"Ephemeron is live\"),\n                String::from(\"Hello World!\")\n            );\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(\n                *ephemeron.value().expect(\"Ephemeron is still live here\"),\n                String::from(\"Hello World!\")\n            );\n\n            drop(gc_value);\n            force_collect();\n\n            assert!(ephemeron.value().is_none());\n        }\n    });\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::dotenv", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dotenv() {\n  Test::new()\n    .write(\".env\", \"KEY=ROOT\")\n    .write(\"sub/.env\", \"KEY=SUB\")\n    .write(\"sub/justfile\", \"default:\\n\\techo KEY=${KEY:-unset}\")\n    .args([\"sub/default\"])\n    .stdout(\"KEY=unset\\n\")\n    .stderr(\"echo KEY=${KEY:-unset}\\n\")\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_twice", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_twice() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    for i in 1..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_alter_role", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "test": "fn parse_alter_role() {\n    let sql = \"ALTER ROLE old_name WITH NAME = new_name\";\n    assert_eq!(\n        ms().parse_sql_statements(sql).unwrap(),\n        [Statement::AlterRole {\n            name: Ident {\n                value: \"old_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::RenameRole {\n                role_name: Ident {\n                    value: \"new_name\".into(),\n                    quote_style: None\n                }\n            },\n        }]\n    );\n\n    let sql = \"ALTER ROLE role_name ADD MEMBER new_member\";\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::AlterRole {\n            name: Ident {\n                value: \"role_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::AddMember {\n                member_name: Ident {\n                    value: \"new_member\".into(),\n                    quote_style: None\n                }\n            },\n        }\n    );\n\n    let sql = \"ALTER ROLE role_name DROP MEMBER old_member\";\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::AlterRole {\n            name: Ident {\n                value: \"role_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::DropMember {\n                member_name: Ident {\n                    value: \"old_member\".into(),\n                    quote_style: None\n                }\n            },\n        }\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_sampling_bernoulli", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_sampling_bernoulli() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n        (6, Some(\"name:1\"), 1),\n        (7, Some(\"name:1\"), 1),\n        (8, Some(\"name:1\"), 1),\n        (9, Some(\"name:2\"), 1),\n        (10, Some(\"name:2\"), 1),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    // Pass the 2nd column as a column group.\n    let req = new_analyze_sampling_req(&product, 1, 0, 0.5);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeColumnsResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let collector = analyze_resp.get_row_collector();\n    // The column group is at 4th place and the data should be equal to the 2nd.\n    assert_eq!(collector.get_null_counts(), vec![0, 1, 0, 1]);\n    assert_eq!(collector.get_count(), 9);\n    assert_eq!(collector.get_fm_sketch().len(), 4);\n    assert_eq!(collector.get_total_size(), vec![72, 56, 9, 56]);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_extended_priv_key", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_extended_priv_key() {\n    let s = include_str!(\"data/serde/extended_priv_key\");\n    let key = Xpriv::from_str(s.trim()).unwrap();\n    let got = serialize(&key).unwrap();\n    let want = include_bytes!(\"data/serde/extended_priv_key_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_quic_tests.rs::test_example_quic_toml_startup", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_example_quic_toml_startup() {\n    // env_logger::try_init().ok();\n\n    named_test_harness(\"dns_over_quic.toml\", move |_, _, _, _, quic_port| {\n        let mut cert_der = vec![];\n        let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"..\".to_owned());\n        println!(\"using server src path: {server_path} and quic_port: {quic_port:?}\");\n\n        File::open(format!(\n            \"{server_path}/tests/test-data/test_configs/sec/example.cert\"\n        ))\n        .expect(\"failed to open cert\")\n        .read_to_end(&mut cert_der)\n        .expect(\"failed to read cert\");\n\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = (\"127.0.0.1\", quic_port.expect(\"no quic_port\"))\n            .to_socket_addrs()\n            .unwrap()\n            .next()\n            .unwrap();\n\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        // using the mozilla default root store\n        let mut root_store = RootCertStore::empty();\n        root_store.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {\n            OwnedTrustAnchor::from_subject_spki_name_constraints(\n                ta.subject,\n                ta.spki,\n                ta.name_constraints,\n            )\n        }));\n\n        let cert = to_trust_anchor(&cert_der);\n        root_store.add(&cert).unwrap();\n\n        let client_config = ClientConfig::builder()\n            .with_safe_defaults()\n            .with_root_certificates(root_store)\n            .with_no_client_auth();\n\n        let mut quic_builder = QuicClientStream::builder();\n        quic_builder.crypto_config(client_config);\n\n        let mp = quic_builder.build(addr, \"ns.example.com\".to_string());\n        let client = AsyncClient::connect(mp);\n\n        // ipv4 should succeed\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n\n        // a second request should work...\n        query_a(&mut io_loop, &mut client);\n    })\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_basics_bad_name", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_du_basics_bad_name() {\n    new_ucmd!()\n        .arg(\"bad_name\")\n        .fails()\n        .stderr_only(\"du: bad_name: No such file or directory\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_dir_follow_retry", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_dir_follow_retry() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n    at.mkdir(\"DIR\");\n    ts.ucmd()\n        .arg(\"--follow=descriptor\")\n        .arg(\"--retry\")\n        .arg(\"DIR\")\n        .run()\n        .stderr_is(\n            \"tail: warning: --retry only effective for the initial open\\n\\\n                tail: error reading 'DIR': Is a directory\\n\\\n                tail: DIR: cannot follow end of this type of file\\n\\\n                tail: no files remaining\\n\",\n        )\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_too_many_args", "code": "fn expect_error(input: &[&str]) {\n    assert!(!new_ucmd!()\n        .args(input)\n        .fails()\n        .no_stdout()\n        .stderr_str()\n        .is_empty());\n}", "test": "fn test_too_many_args() {\n    expect_error(&[\"a\", \"b\", \"c\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nonexistent_file_is_not_regular", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_nonexistent_file_is_not_regular() {\n    new_ucmd!()\n        .args(&[\"-f\", \"nonexistent_file\"])\n        .run()\n        .code_is(1);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::break_nested_labels_loops_and_try", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn break_nested_labels_loops_and_try() {\n    let scenario = r#\"\n        function nestedLabels(x) {\n            let str = \"\";\n            foo: {\n                spacer: {\n                    bar: {\n                        while(true) {\n                            try {\n                                try {\n                                    break spacer;\n                                } finally {\n                                    str = \"foo\";\n                                }\n                            } catch(h) {} finally {\n                                str += \"bar\"\n                                if (x === true) {\n                                    break foo;\n                                } else {\n                                    break bar;\n                                }\n                            }\n                        }\n                        str += \" broke-while\"\n                    }\n                    str += \" broke-bar\"\n                }\n                str += \" broke-spacer\"\n            }\n            str += \" broke-foo\";\n            return str\n        }\n    \"#;\n\n    run_test_actions([\n        TestAction::run(scenario),\n        TestAction::assert_eq(\"nestedLabels(true)\", \"foobar broke-foo\"),\n        TestAction::assert_eq(\n            \"nestedLabels(false)\",\n            \"foobar broke-bar broke-spacer broke-foo\",\n        ),\n    ]);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::subexpression_with_multiple_args", "code": "fn parse_and_match_helper(needle: &str, source: &str, cpp: bool) -> Vec<QueryResult> {\n    let _ = SimpleLogger::init(LevelFilter::Info, Config::default());\n    log::set_max_level(log::LevelFilter::Debug);\n    let tree = weggli::parse(needle, cpp);\n    println!(\"{}\", tree.root_node().to_sexp());\n\n    let source_tree = weggli::parse(source, cpp);\n\n    println!(\"{}\", source_tree.root_node().to_sexp());\n\n    let mut c = tree.walk();\n    let qt = build_query_tree(needle, &mut c, cpp, None);\n\n    let matches = qt.matches(source_tree.root_node(), source);\n\n    for m in &matches {\n        println!(\"{}\", m.display(source, 0, 0));\n    }\n    matches\n}", "test": "fn subexpression_with_multiple_args() {\n    // https://github.com/googleprojectzero/weggli/issues/14\n\n    // An unfortunate effect of our sub expression syntax _($x) is \n    // that people might wrongly use it as a wildcard function call\n    // _($a, $b). This doesn't work (you want to use $fn($a,$b) instead).\n    // As we don't support sub expressions with multiple arguments, we\n    // can just transparently convert _(_, $b) to $something(_, $b) and\n    // warn the user.\n\n    let needle = \"{$b = getenv(_); _(_, $b);}\";\n\n    let source = r#\"\n    void displayHelp()\n    {\n        char *c = getenv(\"HOME\");\n        int t;\n        endwin();\n        printf(\"%s\\n\",version);\n        printf(\"  Located in %s/.davrc\\n\",c);\n        printf(\"  Edit %s/.davrc to customize function key bindings\\n\",c);\n        initscr();\n        quit(\"\");\n    }\"#;\n\n    let results = parse_and_match_helper(needle, source, false);\n\n    assert_eq!(results.len(), 2);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_data_sent", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn buffered_client_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n\n        check_read(&mut server.reader(), b\"hello\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_newline", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_newline() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\na\"])\n        .succeeds()\n        .stdout_only(\"\\na\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_lines_words_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_lines_words_chars() {\n    new_ucmd!()\n        .arg(\"-mlw\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25      87     442\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::double_equality_operator", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn double_equality_operator() {\n    // Sqlite supports this operator: https://www.sqlite.org/lang_expr.html#binaryops\n    let input = \"SELECT a==b FROM t\";\n    let expected = \"SELECT a = b FROM t\";\n    let _ = sqlite_and_generic().one_statement_parses_to(input, expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header_default", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_header_default() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--header\"])\n        .pipe_in(\"header\\n1K\\n1.1M\\n0.1G\")\n        .run()\n        .stdout_is(\"header\\n1000\\n1100000\\n100000000\\n\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_auth_works", "code": "pub fn do_handshake(\n    client: &mut (impl DerefMut + Deref<Target = ConnectionCommon<impl SideData>>),\n    server: &mut (impl DerefMut + Deref<Target = ConnectionCommon<impl SideData>>),\n) -> (usize, usize) {\n    let (mut to_client, mut to_server) = (0, 0);\n    while server.is_handshaking() || client.is_handshaking() {\n        to_server += transfer(client, server);\n        server.process_new_packets().unwrap();\n        to_client += transfer(server, client);\n        client.process_new_packets().unwrap();\n    }\n    (to_server, to_client)\n}", "test": "fn client_auth_works() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            do_handshake(&mut client, &mut server);\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_nonexistent", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_unlink_nonexistent() {\n    let file = \"test_unlink_nonexistent\";\n\n    new_ucmd!()\n        .arg(file)\n        .fails()\n        .stderr_is(\"unlink: cannot unlink 'test_unlink_nonexistent': No such file or directory\\n\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_all", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_delete_all() {\n    use hickory_proto::rr::rdata::AAAA;\n\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_all(record.name().clone(), origin.clone(), DNSClass::IN))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_rr_type(RecordType::AAAA);\n    record.set_data(Some(RData::AAAA(AAAA::new(1, 2, 3, 4, 5, 6, 7, 8))));\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_all(record.name().clone(), origin, DNSClass::IN))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(record.name().clone(), record.dns_class(), RecordType::A))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n\n    let result = io_loop\n        .block_on(client.query(record.name().clone(), record.dns_class(), RecordType::AAAA))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_before_tab_with_narrow_width", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_before_tab_with_narrow_width() {\n    new_ucmd!()\n        .arg(\"-w7\")\n        .pipe_in(\"a\\t1\")\n        .succeeds()\n        .stdout_is(\"a\\n\\t\\n1\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_oct", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn test_oct() {\n    assert_eq!(from_str(\"0o1461\"), Ok(0o1461));\n    assert_eq!(from_str(\"0o051\"), Ok(0o051));\n    assert_eq!(from_str(\"0o150700\"), Ok(0o150700));\n\n    assert_eq!(\n        from_str::<u8>(\"0o\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0o_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0o77777\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 8 },\n        })\n    );\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/escape.rs::test_ascii_string", "code": "fn check_same<T>(t: T)\nwhere\n    T: Debug + for<'a> Deserialize<'a> + PartialEq + Serialize,\n{\n    let s: String = to_string(&t).unwrap();\n\n    println!(\"Serialized: \\n\\n{}\\n\\n\", s);\n\n    assert_eq!(from_str(&s), Ok(t));\n}", "test": "fn test_ascii_string() {\n    let s: String = (1..128).into_iter().flat_map(from_u32).collect();\n\n    check_same(s);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_args_are_not_escaped", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn filter_args_are_not_escaped() {\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"hey\");\n    context.insert(\"to\", &\"&\");\n    let input = r#\"{{ my_var | replace(from=\"h\", to=to) }}\"#;\n\n    assert_eq!(render_template(input, &context).unwrap(), \"&amp;ey\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_read_only", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_max_commit_ts_error", "code": "pub fn is_zero(&self) -> bool {\n        let len = word_cnt!(self.int_cnt) + word_cnt!(self.frac_cnt);\n        self.word_buf[0..len as usize].iter().all(|&x| x == 0)\n    }", "test": "fn test_max_commit_ts_error() {\n    let engine = TestEngineBuilder::new().build().unwrap();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n    let cm = storage.get_concurrency_manager();\n\n    fail::cfg(\"after_prewrite_one_key\", \"sleep(500)\").unwrap();\n    let (prewrite_tx, prewrite_rx) = channel();\n    storage\n        .sched_txn_command(\n            commands::Prewrite::new(\n                vec![\n                    Mutation::make_put(Key::from_raw(b\"k1\"), b\"v\".to_vec()),\n                    Mutation::make_put(Key::from_raw(b\"k2\"), b\"v\".to_vec()),\n                ],\n                b\"k1\".to_vec(),\n                10.into(),\n                20000,\n                false,\n                2,\n                TimeStamp::default(),\n                100.into(),\n                Some(vec![b\"k2\".to_vec()]),\n                false,\n                AssertionLevel::Off,\n                Context::default(),\n            ),\n            Box::new(move |res| {\n                prewrite_tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    thread::sleep(Duration::from_millis(200));\n    cm.read_key_check(&Key::from_raw(b\"k1\"), |_| Err(()))\n        .unwrap_err();\n    cm.update_max_ts(200.into());\n\n    let res = prewrite_rx.recv().unwrap().unwrap();\n    assert!(res.min_commit_ts.is_zero());\n    assert!(res.one_pc_commit_ts.is_zero());\n\n    // There should not be any memory lock left.\n    cm.read_range_check(None, None, |_, _| Err(())).unwrap();\n\n    // Two locks should be written, the second one does not async commit.\n    let l1 = must_locked(&mut storage.get_engine(), b\"k1\", 10);\n    let l2 = must_locked(&mut storage.get_engine(), b\"k2\", 10);\n    assert!(l1.use_async_commit);\n    assert!(!l2.use_async_commit);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_batch_id_in_lease", "code": "fn test_batch_id_in_lease<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n\n    // Increase the Raft tick interval to make this test case running reliably.\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(100), None);\n    cluster.run();\n\n    let (split_key1, split_key2) = (b\"k22\", b\"k44\");\n    let keys = vec![b\"k11\", b\"k33\", b\"k55\"];\n    let _ = keys.iter().map(|&key| {\n        cluster.must_put(key, b\"v1\");\n    });\n\n    let region = pd_client.get_region(keys[0]).unwrap();\n    cluster.must_split(&region, split_key1);\n    let region = pd_client.get_region(keys[1]).unwrap();\n    cluster.must_split(&region, split_key2);\n    let mut peers = vec![];\n\n    // Transfer leader together to batch snapshot\n    for i in 0..3 {\n        let r = pd_client.get_region(keys[i]).unwrap();\n        let peer = cluster.leader_of_region(r.get_id()).unwrap();\n        if peer.get_store_id() != 1 {\n            for p in r.get_peers() {\n                if p.get_store_id() == 1 {\n                    cluster.must_transfer_leader(r.get_id(), p.clone());\n                    let peer = cluster.leader_of_region(r.get_id()).unwrap();\n                    assert_eq!(peer.get_store_id(), 1);\n                    peers.push(peer);\n                    break;\n                }\n            }\n        } else {\n            peers.push(peer.clone());\n        }\n    }\n    // Sleep to make sure lease expired\n    thread::sleep(election_timeout + Duration::from_millis(200));\n\n    // Send request to region 0 and 1 to renew their lease.\n    cluster.must_put(b\"k11\", b\"v2\");\n    cluster.must_put(b\"k33\", b\"v2\");\n    assert_eq!(b\"v2\".to_vec(), cluster.must_get(b\"k33\").unwrap());\n    assert_eq!(b\"v2\".to_vec(), cluster.must_get(b\"k11\").unwrap());\n\n    let regions: Vec<_> = keys\n        .into_iter()\n        .map(|key| pd_client.get_region(key).unwrap())\n        .collect();\n\n    let requests: Vec<(metapb::Peer, metapb::Region)> = peers\n        .iter()\n        .zip(regions)\n        .map(|(p, r)| (p.clone(), r))\n        .collect();\n    let responses = batch_read_on_peer(cluster, &requests);\n    let snaps: Vec<RegionSnapshot<RocksSnapshot>> = responses\n        .into_iter()\n        .map(|response| {\n            assert!(!response.response.get_header().has_error());\n            response.snapshot.unwrap()\n        })\n        .collect();\n\n    // Snapshot 0 and 1 will use one RocksSnapshot because we have renew their\n    // lease.\n    assert!(std::ptr::eq(\n        snaps[0].get_snapshot(),\n        snaps[1].get_snapshot()\n    ));\n    assert!(!std::ptr::eq(\n        snaps[0].get_snapshot(),\n        snaps[2].get_snapshot()\n    ));\n\n    // make sure that region 2 could renew lease.\n    cluster.must_put(b\"k55\", b\"v2\");\n    let responses = batch_read_on_peer(cluster, &requests);\n    let snaps2: Vec<RegionSnapshot<RocksSnapshot>> = responses\n        .into_iter()\n        .map(|response| {\n            assert!(!response.response.get_header().has_error());\n            response.snapshot.unwrap()\n        })\n        .collect();\n    assert_eq!(3, snaps2.len());\n    assert!(!std::ptr::eq(\n        snaps[0].get_snapshot(),\n        snaps2[0].get_snapshot()\n    ));\n    assert!(std::ptr::eq(\n        snaps2[0].get_snapshot(),\n        snaps2[1].get_snapshot()\n    ));\n    assert!(std::ptr::eq(\n        snaps2[0].get_snapshot(),\n        snaps2[2].get_snapshot()\n    ));\n}", "test": "fn test_node_batch_id_in_lease() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_batch_id_in_lease(&mut cluster);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_absolute_lock_time_height", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_absolute_lock_time_height() {\n    let t = absolute::LockTime::from_height(741521).expect(\"valid height\");\n    let got = serialize(&t).unwrap();\n    let want = include_bytes!(\"data/serde/absolute_lock_time_blocks_bincode\") as &[_];\n    assert_eq!(got, want);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_reject_proposal_during_region_split", "code": "pub fn recv_timeout(\n        &mut self,\n        timeout: Duration,\n    ) -> Result<Option<T>, std::sync::mpsc::RecvTimeoutError> {\n        let deadline = Instant::now() + timeout;\n        let delay = GLOBAL_TIMER_HANDLE.delay(deadline).compat();\n        let ret = future::select(self.inner.next(), delay);\n        match block_on(ret) {\n            future::Either::Left((msg, _)) => {\n                if let Some(Msg::Task(t)) = msg {\n                    return Ok(Some(t));\n                }\n                Ok(None)\n            }\n            future::Either::Right(_) => Err(std::sync::mpsc::RecvTimeoutError::Timeout),\n        }\n    }", "test": "fn test_reject_proposal_during_region_split() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k\", b\"v\");\n\n    // Pause on applying so that region split is not finished.\n    let fp = \"apply_before_split\";\n    fail::cfg(fp, \"pause\").unwrap();\n\n    // Try to split region.\n    let (split_tx, split_rx) = mpsc::channel();\n    let cb = Callback::read(Box::new(move |resp: ReadResponse<RocksSnapshot>| {\n        split_tx.send(resp.response).unwrap()\n    }));\n    let r = cluster.get_region(b\"\");\n    cluster.split_region(&r, b\"k\", cb);\n    split_rx\n        .recv_timeout(Duration::from_millis(100))\n        .unwrap_err();\n\n    // Try to put a key.\n    let force_delay_propose_batch_raft_command_fp = \"force_delay_propose_batch_raft_command\";\n    let mut receivers = vec![];\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"k1\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        // The write request should be blocked until split is finished.\n        cb_receivers.assert_not_ready();\n        receivers.push(cb_receivers);\n    }\n\n    fail::remove(fp);\n    // Split is finished.\n    assert!(\n        !split_rx\n            .recv_timeout(Duration::from_secs(1))\n            .unwrap()\n            .get_header()\n            .has_error()\n    );\n\n    // The write request fails due to epoch not match.\n    for mut r in receivers {\n        r.assert_err();\n    }\n\n    // New write request can succeed.\n    let write_req = make_write_req(&mut cluster, b\"k1\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    cb_receivers.assert_ok();\n}"}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes256_encrypted_uncompressed_file", "code": "pub fn name(&self) -> &str {\n        &self.data.file_name\n    }", "test": "fn aes256_encrypted_uncompressed_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n        .by_name_decrypt(\"secret_data_256_uncompressed\", PASSWORD)\n        .expect(\"couldn't find file in archive\")\n        .expect(\"invalid password\");\n    assert_eq!(\"secret_data_256_uncompressed\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"couldn't read encrypted file\");\n    assert_eq!(SECRET_CONTENT, content);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::initial_retransmit", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn initial_retransmit() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let client_ch = pair.begin_connect(client_config());\n    pair.client.drive(pair.time, pair.server.addr);\n    pair.client.outbound.clear(); // Drop initial\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_rpc_client", "code": "fn fetch_cluster_id(&mut self) -> Result<u64> {\n        if !self.raw_client.initialized() {\n            block_on(self.raw_client.wait_for_ready())?;\n        }\n        let id = self.raw_client.cluster_id();\n        assert!(id > 0);\n        Ok(id)\n    }", "test": "fn test_rpc_client() {\n    let rt = setup_runtime();\n    let _g = rt.enter();\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n\n    let mut client = new_client_v2(eps.clone(), None);\n    assert_ne!(client.fetch_cluster_id().unwrap(), 0);\n\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    debug!(\"bootstrap store {:?}\", store);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer.clone());\n    debug!(\"bootstrap region {:?}\", region);\n\n    client\n        .bootstrap_cluster(store.clone(), region.clone())\n        .unwrap();\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n\n    let tmp_stores = client.get_all_stores(false).unwrap();\n    assert_eq!(tmp_stores.len(), 1);\n    assert_eq!(tmp_stores[0], store);\n\n    let tmp_store = client.get_store(store_id).unwrap();\n    assert_eq!(tmp_store.get_id(), store.get_id());\n\n    let region_key = region.get_start_key();\n    let tmp_region = client.get_region(region_key).unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader, None);\n\n    let tmp_region = block_on(client.get_region_by_id(region_id))\n        .unwrap()\n        .unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let ts = must_get_tso(&mut client, 1);\n    assert_ne!(ts, TimeStamp::zero());\n\n    let ts100 = must_get_tso(&mut client, 100);\n    assert_eq!(ts.logical() + 100, ts100.logical());\n\n    let mut prev_id = 0;\n    for _ in 0..10 {\n        let mut client = new_client_v2(eps.clone(), None);\n        let alloc_id = client.alloc_id().unwrap();\n        assert!(alloc_id > prev_id);\n        prev_id = alloc_id;\n    }\n\n    let (tx, mut responses) = client\n        .create_region_heartbeat_stream(WakePolicy::Immediately)\n        .unwrap();\n    let mut req = pdpb::RegionHeartbeatRequest::default();\n    req.set_region(region.clone());\n    req.set_leader(peer.clone());\n    tx.send(req).unwrap();\n    block_on(tokio::time::timeout(\n        Duration::from_secs(3),\n        responses.next(),\n    ))\n    .unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader.unwrap(), peer);\n\n    block_on(client.store_heartbeat(\n        pdpb::StoreStats::default(),\n        None, // store_report\n        None,\n    ))\n    .unwrap();\n    block_on(client.ask_batch_split(metapb::Region::default(), 1)).unwrap();\n    block_on(client.report_batch_split(vec![metapb::Region::default(), metapb::Region::default()]))\n        .unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    client.scatter_region(region_info).unwrap();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_let", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_let() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (let i of [1, 2, 3]) {\n                    result = i;\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 3),\n        TestAction::assert_native_error(\"i\", JsNativeErrorKind::Reference, \"i is not defined\"),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_help() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .succeeds()\n        .stdout_contains(\"Arguments:\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_hex", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn test_hex() {\n    assert_eq!(from_str(\"0x507\"), Ok(0x507));\n    assert_eq!(from_str(\"0x1A5\"), Ok(0x1A5));\n    assert_eq!(from_str(\"0x53C537\"), Ok(0x53C537));\n\n    assert_eq!(\n        from_str::<u8>(\"0x\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0x_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0xFFF\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 6 },\n        })\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_unknown", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_unknown() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert_error(PathBuf::from(\"prefix/ci.js\"), ErrorEntry::UnknownFileType);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), (\"prefix\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_unknown\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::leaves_necessary_whitespace_all_nested", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn leaves_necessary_whitespace_all_nested() {\n    assert_eq!(\n        \"<u></u><u></u><u></u><u></u>\",\n        normalize_html(\"<u> </u><u> </u><u> </u><u> </u>\")\n    )\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u64toa_test", "code": "pub const fn decimal() -> u128 {\n        let mut builder = Self::new();\n        builder.mantissa_radix = 10;\n        builder.exponent_base = num::NonZeroU8::new(10);\n        builder.exponent_radix = num::NonZeroU8::new(10);\n        builder.build()\n    }", "test": "fn u64toa_test() {\n    let mut buffer = [b'\\x00'; 32];\n    unsafe {\n        assert_eq!(5u64.decimal(&mut buffer), 1);\n        assert_eq!(&buffer[..1], b\"5\");\n\n        assert_eq!(11u64.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"11\");\n\n        assert_eq!(99u64.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"99\");\n\n        assert_eq!(101u64.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"101\");\n\n        assert_eq!(999u64.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"999\");\n\n        assert_eq!(1001u64.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"1001\");\n\n        assert_eq!(9999u64.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"9999\");\n\n        assert_eq!(10001u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"10001\");\n\n        assert_eq!(65535u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"65535\");\n\n        assert_eq!(99999u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"99999\");\n\n        assert_eq!(100001u64.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"100001\");\n\n        assert_eq!(999999u64.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"999999\");\n\n        assert_eq!(1000001u64.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"1000001\");\n\n        assert_eq!(9999999u64.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"9999999\");\n\n        assert_eq!(10000001u64.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"10000001\");\n\n        assert_eq!(99999999u64.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"99999999\");\n\n        assert_eq!(100000001u64.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"100000001\");\n\n        assert_eq!(999999999u64.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"999999999\");\n\n        assert_eq!(1000000001u64.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"1000000001\");\n\n        assert_eq!(9999999999u64.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"9999999999\");\n\n        assert_eq!(10000000001u64.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"10000000001\");\n\n        assert_eq!(99999999999u64.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"99999999999\");\n\n        assert_eq!(100000000001u64.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"100000000001\");\n\n        assert_eq!(999999999999u64.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"999999999999\");\n\n        assert_eq!(1000000000001u64.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"1000000000001\");\n\n        assert_eq!(9999999999999u64.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"9999999999999\");\n\n        assert_eq!(10000000000001u64.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"10000000000001\");\n\n        assert_eq!(99999999999999u64.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"99999999999999\");\n\n        assert_eq!(100000000000001u64.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"100000000000001\");\n\n        assert_eq!(999999999999999u64.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"999999999999999\");\n\n        assert_eq!(1000000000000001u64.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"1000000000000001\");\n\n        assert_eq!(9999999999999999u64.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"9999999999999999\");\n\n        assert_eq!(10000000000000001u64.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"10000000000000001\");\n\n        assert_eq!(99999999999999999u64.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"99999999999999999\");\n\n        assert_eq!(100000000000000001u64.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"100000000000000001\");\n\n        assert_eq!(999999999999999999u64.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"999999999999999999\");\n\n        assert_eq!(1000000000000000001u64.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"1000000000000000001\");\n\n        assert_eq!(9999999999999999999u64.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"9999999999999999999\");\n\n        assert_eq!(10000000000000000001u64.decimal(&mut buffer), 20);\n        assert_eq!(&buffer[..20], b\"10000000000000000001\");\n\n        assert_eq!(18446744073709551615u64.decimal(&mut buffer), 20);\n        assert_eq!(&buffer[..20], b\"18446744073709551615\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_index_aggr_count", "code": "pub fn is_some(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_some(),\n            }\n        }\n    }", "test": "fn test_index_aggr_count() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:3\"), 3),\n        (4, Some(\"name:0\"), 1),\n        (5, Some(\"name:5\"), 4),\n        (6, Some(\"name:5\"), 4),\n        (7, None, 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n    // for dag\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .output_offsets(Some(vec![0]))\n        .build();\n    let mut resp = handle_select(&endpoint, req);\n    let mut spliter = DagChunkSpliter::new(resp.take_chunks().into(), 1);\n    let expected_encoded = datum::encode_value(\n        &mut EvalContext::default(),\n        &[Datum::U64(data.len() as u64)],\n    )\n    .unwrap();\n    let ret_data = spliter.next();\n    assert_eq!(ret_data.is_some(), true);\n    let result_encoded =\n        datum::encode_value(&mut EvalContext::default(), &ret_data.unwrap()).unwrap();\n    assert_eq!(&*result_encoded, &*expected_encoded);\n    assert_eq!(spliter.next().is_none(), true);\n\n    let exp = vec![\n        (Datum::Null, 1),\n        (Datum::Bytes(b\"name:0\".to_vec()), 2),\n        (Datum::Bytes(b\"name:3\".to_vec()), 1),\n        (Datum::Bytes(b\"name:5\".to_vec()), 2),\n    ];\n    // for dag\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .group_by(&[&product[\"name\"]])\n        .output_offsets(Some(vec![0, 1]))\n        .build();\n    resp = handle_select(&endpoint, req);\n    let mut row_count = 0;\n    let exp_len = exp.len();\n    let spliter = DagChunkSpliter::new(resp.take_chunks().into(), 2);\n    let mut results = spliter.collect::<Vec<Vec<Datum>>>();\n    sort_by!(results, 1, Bytes);\n    for (row, (name, cnt)) in results.iter().zip(exp) {\n        let expected_datum = vec![Datum::U64(cnt), name];\n        let expected_encoded =\n            datum::encode_value(&mut EvalContext::default(), &expected_datum).unwrap();\n        let result_encoded = datum::encode_value(&mut EvalContext::default(), row).unwrap();\n        assert_eq!(&*result_encoded, &*expected_encoded);\n        row_count += 1;\n    }\n    assert_eq!(row_count, exp_len);\n\n    let exp = vec![\n        (vec![Datum::Null, Datum::I64(4)], 1),\n        (vec![Datum::Bytes(b\"name:0\".to_vec()), Datum::I64(1)], 1),\n        (vec![Datum::Bytes(b\"name:0\".to_vec()), Datum::I64(2)], 1),\n        (vec![Datum::Bytes(b\"name:3\".to_vec()), Datum::I64(3)], 1),\n        (vec![Datum::Bytes(b\"name:5\".to_vec()), Datum::I64(4)], 2),\n    ];\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .group_by(&[&product[\"name\"], &product[\"count\"]])\n        .build();\n    resp = handle_select(&endpoint, req);\n    let mut row_count = 0;\n    let exp_len = exp.len();\n    let spliter = DagChunkSpliter::new(resp.take_chunks().into(), 3);\n    let mut results = spliter.collect::<Vec<Vec<Datum>>>();\n    sort_by!(results, 1, Bytes);\n    for (row, (gk_data, cnt)) in results.iter().zip(exp) {\n        let mut expected_datum = vec![Datum::U64(cnt)];\n        expected_datum.extend_from_slice(gk_data.as_slice());\n        let expected_encoded =\n            datum::encode_value(&mut EvalContext::default(), &expected_datum).unwrap();\n        let result_encoded = datum::encode_value(&mut EvalContext::default(), row).unwrap();\n        assert_eq!(&*result_encoded, &*expected_encoded);\n        row_count += 1;\n    }\n    assert_eq!(row_count, exp_len);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printenv.rs::test_ignore_equal_var", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_ignore_equal_var() {\n    let scene = TestScenario::new(util_name!());\n    // tested by gnu/tests/misc/printenv.sh\n    let result = scene.ucmd().env(\"a=b\", \"c\").arg(\"a=b\").fails();\n\n    assert!(result.stdout_str().is_empty());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_no_resolved_ts_before_downstream_initialized", "code": "fn do_test_no_resolved_ts_before_downstream_initialized(version: &str) {\n    let cluster = new_server_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let region = suite.cluster.get_region(b\"\");\n\n    let recv_resolved_ts = |event_feed: &ClientReceiver| {\n        let mut rx = event_feed.replace(None).unwrap();\n        let timeout = Duration::from_secs(1);\n        for _ in 0..10 {\n            if let Ok(Some(event)) = recv_timeout(&mut rx, timeout) {\n                let event = event.unwrap();\n                if event.has_resolved_ts() {\n                    event_feed.replace(Some(rx));\n                    return;\n                }\n                for e in event.get_events() {\n                    if let Some(Event_oneof_event::ResolvedTs(_)) = e.event {\n                        event_feed.replace(Some(rx));\n                        return;\n                    }\n                }\n            }\n        }\n        panic!(\"must receive a resolved ts\");\n    };\n\n    // Create 2 changefeeds and the second will be blocked in initialization.\n    let mut req_txs = Vec::with_capacity(2);\n    let mut event_feeds = Vec::with_capacity(2);\n    for i in 0..2 {\n        if i == 1 {\n            // Wait the first capture has been initialized.\n            recv_resolved_ts(&event_feeds[0]);\n            fail::cfg(\"cdc_incremental_scan_start\", \"pause\").unwrap();\n        }\n        let (mut req_tx, event_feed, _) = new_event_feed(suite.get_region_cdc_client(region.id));\n        let mut req = suite.new_changedata_request(region.id);\n        req.mut_header().set_ticdc_version(version.to_owned());\n        block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n        req_txs.push(req_tx);\n        event_feeds.push(event_feed);\n    }\n\n    let th = thread::spawn(move || {\n        // The first downstream can receive timestamps but the second should receive\n        // nothing.\n        let mut rx = event_feeds[0].replace(None).unwrap();\n        recv_timeout(&mut rx, Duration::from_secs(1)).unwrap();\n        let mut rx = event_feeds[1].replace(None).unwrap();\n        recv_timeout(&mut rx, Duration::from_secs(3)).unwrap_err();\n    });\n\n    th.join().unwrap();\n    fail::cfg(\"cdc_incremental_scan_start\", \"off\").unwrap();\n    suite.stop();\n}", "test": "fn test_no_resolved_ts_before_downstream_initialized() {\n    for version in &[\"4.0.7\", \"4.0.8\"] {\n        do_test_no_resolved_ts_before_downstream_initialized(version);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_mvcc_concurrent_commit_and_rollback_at_shutdown", "code": "pub fn has_region_error(&self) -> bool {\n        match self.detail {\n            ::std::option::Option::Some(Error_oneof_detail::RegionError(..)) => true,\n            _ => false,\n        }\n    }", "test": "fn test_mvcc_concurrent_commit_and_rollback_at_shutdown() {\n    let (mut cluster, mut client, mut ctx) = must_new_cluster_and_kv_client_mul(3);\n    let k = b\"key\".to_vec();\n    // Use big value to force it in default cf.\n    let v = vec![0; 10240];\n\n    let mut ts = 0;\n\n    // Prewrite\n    ts += 1;\n    let prewrite_start_version = ts;\n    let mut mutation = kvrpcpb::Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.set_key(k.clone());\n    mutation.set_value(v.clone());\n    must_kv_prewrite(\n        &client,\n        ctx.clone(),\n        vec![mutation],\n        k.clone(),\n        prewrite_start_version,\n    );\n\n    // So all following operation will not be committed by this leader.\n    let leader_fp = \"before_leader_handle_committed_entries\";\n    fail::cfg(leader_fp, \"pause\").unwrap();\n\n    // Commit\n    ts += 1;\n    let commit_version = ts;\n    let mut commit_req = CommitRequest::default();\n    commit_req.set_context(ctx.clone());\n    commit_req.start_version = prewrite_start_version;\n    commit_req.mut_keys().push(k.clone());\n    commit_req.commit_version = commit_version;\n    let _commit_resp = client.kv_commit_async(&commit_req).unwrap();\n\n    // Rollback\n    let rollback_start_version = prewrite_start_version;\n    let mut rollback_req = BatchRollbackRequest::default();\n    rollback_req.set_context(ctx.clone());\n    rollback_req.start_version = rollback_start_version;\n    rollback_req.mut_keys().push(k.clone());\n    let _rollback_resp = client.kv_batch_rollback_async(&rollback_req).unwrap();\n\n    // Sleep some time to make sure both commit and rollback are queued in latch.\n    thread::sleep(Duration::from_millis(100));\n    let shutdown_fp = \"after_shutdown_apply\";\n    fail::cfg_callback(shutdown_fp, move || {\n        fail::remove(leader_fp);\n        // Sleep some time to ensure all logs can be replicated.\n        thread::sleep(Duration::from_millis(300));\n    })\n    .unwrap();\n    let mut leader = cluster.leader_of_region(1).unwrap();\n    cluster.stop_node(leader.get_store_id());\n\n    // So a new leader should be elected.\n    cluster.must_put(b\"k2\", b\"v2\");\n    leader = cluster.leader_of_region(1).unwrap();\n    ctx.set_peer(leader.clone());\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    client = TikvClient::new(channel);\n\n    // The first request is commit, the second is rollback, the first one should\n    // succeed.\n    ts += 1;\n    let get_version = ts;\n    let mut get_req = GetRequest::default();\n    get_req.set_context(ctx);\n    get_req.key = k;\n    get_req.version = get_version;\n    let get_resp = client.kv_get(&get_req).unwrap();\n    assert!(\n        !get_resp.has_region_error() && !get_resp.has_error(),\n        \"{:?}\",\n        get_resp\n    );\n    assert_eq!(get_resp.value, v);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_unlink_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_unlink_file\";\n\n    at.touch(file);\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_follow_stdin_pipe", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_follow_stdin_pipe() {\n    new_ucmd!()\n        .arg(\"-f\")\n        .pipe_in_fixture(FOOBAR_TXT)\n        .run()\n        .stdout_is_fixture(\"follow_stdin.expected\")\n        .no_stderr();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_2() {\n    let original = r##\"| abc | defghi |\n:-: | -----------:\nbar | baz\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">abc</th>\n<th style=\"text-align: right\">defghi</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">bar</td>\n<td style=\"text-align: right\">baz</td>\n</tr>\n</tbody>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/multibyte_char.rs::bugfix", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn bugfix() {\n  Test::new().justfile(\"foo:\\nx := '''\u01e9'''\").run();\n}\n"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_invalid_input_line_count", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_shuf_invalid_input_line_count() {\n    new_ucmd!()\n        .args(&[\"-n\", \"a\"])\n        .fails()\n        .stderr_contains(\"invalid line count: 'a'\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/wasm/tests/wasm_testsuite.rs::reachability_is_correct", "code": "pub(crate) fn as_ref(&self) -> Imports<'_> {\n        Imports {\n            tables: self.tables.values().as_slice(),\n            globals: self.globals.values().as_slice(),\n            memories: self.memories.values().as_slice(),\n            functions: self.functions.values().as_slice(),\n        }\n    }", "test": "fn reachability_is_correct() {\n    let tests = vec![\n        (\n            r#\"\n        (module (func (param i32)\n         (loop\n          (block\n           local.get 0\n           br_if 0\n           br 1))))\"#,\n            vec![\n                (true, true),  // Loop\n                (true, true),  // Block\n                (true, true),  // LocalGet\n                (true, true),  // BrIf\n                (true, false), // Br\n                (false, true), // End\n                (true, true),  // End\n                (true, true),  // End\n            ],\n        ),\n        (\n            r#\"\n        (module (func (param i32)\n         (loop\n          (block\n           br 1\n           nop))))\"#,\n            vec![\n                (true, true),   // Loop\n                (true, true),   // Block\n                (true, false),  // Br\n                (false, false), // Nop\n                (false, false), // Nop\n                (false, false), // Nop\n                (false, false), // End\n            ],\n        ),\n        (\n            r#\"\n        (module (func (param i32) (result i32)\n          i32.const 1\n          return\n          i32.const 42))\"#,\n            vec![\n                (true, true),   // I32Const\n                (true, false),  // Return\n                (false, false), // I32Const\n                (false, false), // End\n            ],\n        ),\n    ];\n\n    for (wat, expected_reachability) in tests {\n        println!(\"testing wat:\\n{}\", wat);\n        let mut env = DummyEnvironment::new(TargetFrontendConfig {\n            default_call_conv: CallConv::SystemV,\n            pointer_width: PointerWidth::U64,\n        });\n        env.test_expected_reachability(expected_reachability);\n        let data = wat::parse_str(wat).unwrap();\n        translate_module(data.as_ref(), &mut env).unwrap();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u32_pow2_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u32_pow2_test() {\n    let values: &[u32] = &[\n        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,\n        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,\n        16383, 16384, 16385, 32767, 32768, 32769, 65535, 65536, 65537, 131071, 131072, 131073,\n        262143, 262144, 262145, 524287, 524288, 524289, 1048575, 1048576, 1048577, 2097151,\n        2097152, 2097153, 4194303, 4194304, 4194305, 8388607, 8388608, 8388609, 16777215, 16777216,\n        16777217, 33554431, 33554432, 33554433, 67108863, 67108864, 67108865, 134217727, 134217728,\n        134217729, 268435455, 268435456, 268435457, 536870911, 536870912, 536870913, 1073741823,\n        1073741824, 1073741825, 2147483647, 2147483648, 2147483649, 4294967295,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::ods_covered", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn ods_covered() {\n    setup();\n\n    let path = format!(\"{}/tests/covered.ods\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Ods<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"sheet1\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [String(\"a1\".to_string())],\n            [String(\"a2\".to_string())],\n            [String(\"a3\".to_string())],\n        ]\n    );\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/fnmut.rs::accumulate", "code": "fn parser(i: &[u8]) -> nom::IResult<&[u8], u64> {\n  complete::be_u64(i)\n}", "test": "fn accumulate() {\n  let mut v = Vec::new();\n\n  let (_, count) = {\n    let mut parser = many0_count::<_, _, (), _>(|i| {\n      let (i, o) = tag(\"abc\")(i)?;\n      v.push(o);\n      Ok((i, ()))\n    });\n    parser(\"abcabcabcabc\").unwrap()\n  };\n\n  println!(\"v: {:?}\", v);\n  assert_eq!(count, 4);\n  assert_eq!(v.len(), 4);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_b_roundtrip", "code": "fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n}", "test": "fn test_internally_b_roundtrip() {\n    let v = EnumStructInternally::VariantB { foo: 1, bar: 2 };\n    test_roundtrip(v);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::connect_lost_mtu_probes_do_not_trigger_congestion_control", "code": "pub fn stats(&self) -> ConnectionStats {\n        let mut stats = self.stats;\n        stats.path.rtt = self.path.rtt.get();\n        stats.path.cwnd = self.path.congestion.window();\n\n        stats\n    }", "test": "fn connect_lost_mtu_probes_do_not_trigger_congestion_control() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n\n    let (client_ch, server_ch) = pair.connect();\n    pair.drive();\n\n    let client_stats = pair.client_conn_mut(client_ch).stats();\n    let server_stats = pair.server_conn_mut(server_ch).stats();\n\n    // Sanity check (all MTU probes should have been lost)\n    assert_eq!(client_stats.path.sent_plpmtud_probes, 9);\n    assert_eq!(client_stats.path.lost_plpmtud_probes, 9);\n    assert_eq!(server_stats.path.sent_plpmtud_probes, 9);\n    assert_eq!(server_stats.path.lost_plpmtud_probes, 9);\n\n    // No congestion events\n    assert_eq!(client_stats.path.congestion_events, 0);\n    assert_eq!(server_stats.path.congestion_events, 0);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/run.rs::dont_run_duplicate_recipes", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dont_run_duplicate_recipes() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        # foo\n    \",\n    )\n    .args([\"foo\", \"foo\"])\n    .stderr(\n      \"\n      # foo\n    \",\n    )\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_interactive_skipped_vin", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_mv_arg_interactive_skipped_vin() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"a\");\n    at.touch(\"b\");\n    ucmd.args(&[\"-vin\", \"a\", \"b\"])\n        .fails()\n        .stderr_is(\"mv: not replacing 'b'\\n\")\n        .no_stdout();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/find.rs::unmined_sat", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn unmined_sat() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  CommandBuilder::new(\"--index-sats find 5000000000\")\n    .rpc_server(&rpc_server)\n    .expected_stderr(\"error: sat has not been mined as of index height\\n\")\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_number_r", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nl_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator\", \"\\n\", \"fivelines.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n4\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"2\\n5\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"3\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_19", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_19() {\n    let original = r##\"# H1 {.myclass #myid}\n## H2 {.z #m .a}\n\"##;\n    let expected = r##\"<h1 id=\"myid\" class=\"myclass\">H1</h1>\n<h2 id=\"m\" class=\"z a\">H2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_complete_io_for_write", "code": "pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    }", "test": "fn buffered_client_complete_io_for_write() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        client\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        client\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        {\n            let mut pipe = OtherSession::new_buffered(&mut server);\n            let (rdlen, wrlen) = client.complete_io(&mut pipe).unwrap();\n            assert!(rdlen == 0 && wrlen > 0);\n            println!(\"{:?}\", pipe.writevs);\n            assert_eq!(pipe.writevs, vec![vec![42, 42]]);\n        }\n        check_read(\n            &mut server.reader(),\n            b\"0123456789012345678901234567890123456789\",\n        );\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_in_posix_portability_mode", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_in_posix_portability_mode() {\n    fn get_header(block_size: &str) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-P\", \"-B\", block_size])\n            .succeeds()\n            .stdout_move_str();\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }\n\n    assert_eq!(get_header(\"1024\"), \"1024-blocks\");\n    assert_eq!(get_header(\"1K\"), \"1024-blocks\");\n    assert_eq!(get_header(\"1KB\"), \"1000-blocks\");\n    assert_eq!(get_header(\"1M\"), \"1048576-blocks\");\n    assert_eq!(get_header(\"1MB\"), \"1000000-blocks\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_numbered", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_numbered() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=numbered\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_snapshot_failed_2", "code": "pub fn has_not_leader(&self) -> bool {\n        self.not_leader.is_some()\n    }", "test": "fn test_snapshot_failed_2() {\n    let product = ProductTable::new();\n    let (store, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    store.get_engine().trigger_not_leader();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_region_error().has_not_leader());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_basic_flow_lock", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_stale_read_basic_flow_lock() {\n    let (cluster, pd_client, leader_client) = prepare_for_stale_read(new_peer(1, 1));\n    let mut follower_client2 = PeerClient::new(&cluster, 1, new_peer(2, 2));\n    follower_client2.ctx.set_stale_read(true);\n\n    // Write `(key1, value1)`\n    let commit_ts1 = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Prewrite on `key2` but not commit yet\n    let k2_prewrite_ts = get_tso(&pd_client);\n    leader_client.must_kv_prewrite(\n        vec![new_mutation(Op::Put, &b\"key2\"[..], &b\"value1\"[..])],\n        b\"key2\".to_vec(),\n        k2_prewrite_ts,\n    );\n    // Update `key1`\n    let commit_ts2 = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value2\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Assert `(key1, value2)` can't be read with `commit_ts2` due to it's larger\n    // than the `start_ts` of `key2`.\n    let resp = follower_client2.kv_read(b\"key1\".to_vec(), commit_ts2);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n    // Still can read `(key1, value1)` since `commit_ts1` is less than the `key2`\n    // lock's `start_ts`\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), commit_ts1);\n\n    // Prewrite on `key3` but not commit yet\n    let k3_prewrite_ts = get_tso(&pd_client);\n    leader_client.must_kv_prewrite(\n        vec![new_mutation(Op::Put, &b\"key3\"[..], &b\"value1\"[..])],\n        b\"key3\".to_vec(),\n        k3_prewrite_ts,\n    );\n    // Commit on `key2`\n    let k2_commit_ts = get_tso(&pd_client);\n    leader_client.must_kv_commit(vec![b\"key2\".to_vec()], k2_prewrite_ts, k2_commit_ts);\n\n    // Although there is still lock on the region, but the min lock is refreshed\n    // to the `key3`'s lock, now we can read `(key1, value2)` but not `(key2,\n    // value1)`\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value2\".to_vec(), commit_ts2);\n    let resp = follower_client2.kv_read(b\"key2\".to_vec(), k2_commit_ts);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    // Commit on `key3`\n    let k3_commit_ts = get_tso(&pd_client);\n    leader_client.must_kv_commit(vec![b\"key3\".to_vec()], k3_prewrite_ts, k3_commit_ts);\n\n    // Now there is not lock on the region, we can read any\n    // up to date data\n    follower_client2.must_kv_read_equal(b\"key2\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n    follower_client2.must_kv_read_equal(b\"key3\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "image-rs-image-gif/image-rs-image-gif-80fd8c0/tests/roundtrip.rs::encode_roundtrip", "code": "fn round_trip_from_image(original: &[u8]) {\n    let (width, height, global_palette);\n    let frames: Vec<Frame> = {\n        let mut decoder = Decoder::new(original).unwrap();\n        width = decoder.width();\n        height = decoder.height();\n        global_palette = decoder\n            .global_palette()\n            .unwrap_or_default()\n            .to_vec();\n        core::iter::from_fn(move || {\n            decoder.read_next_frame().unwrap().cloned()\n        }).collect()\n    };\n\n    let mut encoder = Encoder::new(vec![], width, height, &global_palette).unwrap();\n    for frame in &frames {\n        encoder.write_frame(frame).unwrap();\n    }\n    let buffer = encoder.into_inner().unwrap();\n\n    {\n        let mut decoder = Decoder::new(&buffer[..]).expect(\"Invalid info encoded\");\n        assert_eq!(decoder.width(), width);\n        assert_eq!(decoder.height(), height);\n        assert_eq!(global_palette, decoder.global_palette().unwrap_or_default());\n        let new_frames: Vec<_> = core::iter::from_fn(move || {\n            decoder.read_next_frame().unwrap().cloned()\n        }).collect();\n        assert_eq!(new_frames.len(), frames.len(), \"Diverging number of frames\");\n        for (new, reference) in new_frames.iter().zip(&frames) {\n            assert_eq!(new.delay, reference.delay);\n            assert_eq!(new.dispose, reference.dispose);\n            assert_eq!(new.transparent, reference.transparent);\n            assert_eq!(new.needs_user_input, reference.needs_user_input);\n            assert_eq!(new.top, reference.top);\n            assert_eq!(new.left, reference.left);\n            assert_eq!(new.width, reference.width);\n            assert_eq!(new.height, reference.height);\n            assert_eq!(new.interlaced, reference.interlaced);\n            assert_eq!(new.palette, reference.palette);\n            assert_eq!(new.buffer, reference.buffer);\n        }\n    }\n}", "test": "fn encode_roundtrip() {\n    const ORIGINAL: &'static [u8] = include_bytes!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/tests/samples/2x2.gif\"));\n    round_trip_from_image(ORIGINAL);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_backup_rawkv_convert", "code": "fn test_backup_rawkv_cross_version_impl(cur_api_ver: ApiVersion, dst_api_ver: ApiVersion) {\n    let suite = TestSuite::new(3, 144 * 1024 * 1024, cur_api_ver);\n    let key_count = 60;\n\n    let cf = match cur_api_ver {\n        ApiVersion::V2 => String::from(\"\"),\n        _ => String::from(CF_DEFAULT),\n    };\n    for i in 0..key_count {\n        let (k, v) = suite.gen_raw_kv(i);\n        suite.must_raw_put(k.clone().into_bytes(), v.clone().into_bytes(), cf.clone());\n    }\n\n    // Push down backup request.\n    let tmp = Builder::new().tempdir().unwrap();\n    let storage_path = make_unique_dir(tmp.path());\n    let rx = suite.backup_raw(\n        vec![b'r', b'a'], // start\n        vec![b'r', b'z'], // end\n        cf,\n        &storage_path,\n        dst_api_ver,\n    );\n    let resps1 = block_on(rx.collect::<Vec<_>>());\n    // Only leader can handle backup.\n    assert_eq!(resps1.len(), 1);\n    let files1 = resps1[0].files.clone();\n    assert!(!resps1[0].get_files().is_empty());\n\n    let mut target_suite = TestSuite::new(3, 144 * 1024 * 1024, dst_api_ver);\n    // Use importer to restore backup files.\n    let backend = make_local_backend(&storage_path);\n    let storage = create_storage(&backend, Default::default()).unwrap();\n    let region = target_suite.cluster.get_region(b\"\");\n    let mut sst_meta = SstMeta::default();\n    sst_meta.region_id = region.get_id();\n    sst_meta.set_region_epoch(region.get_region_epoch().clone());\n    sst_meta.set_uuid(uuid::Uuid::new_v4().as_bytes().to_vec());\n    sst_meta.set_api_version(dst_api_ver);\n    let mut metas = vec![];\n    for f in files1.clone().into_iter() {\n        let mut reader = storage.read(&f.name);\n        let mut content = vec![];\n        block_on(reader.read_to_end(&mut content)).unwrap();\n        let mut m = sst_meta.clone();\n        m.crc32 = calc_crc32_bytes(&content);\n        m.length = content.len() as _;\n        m.cf_name = name_to_cf(&f.name).to_owned();\n        metas.push((m, content));\n    }\n\n    for (m, c) in &metas {\n        for importer in target_suite.cluster.sim.rl().importers.values() {\n            let mut f = importer.create(m).unwrap();\n            f.append(c).unwrap();\n            f.finish().unwrap();\n        }\n\n        // Make ingest command.\n        let mut ingest = Request::default();\n        ingest.set_cmd_type(CmdType::IngestSst);\n        ingest.mut_ingest_sst().set_sst(m.clone());\n        let mut header = RaftRequestHeader::default();\n        let leader = target_suite.context.get_peer().clone();\n        header.set_peer(leader);\n        header.set_region_id(target_suite.context.get_region_id());\n        header.set_region_epoch(target_suite.context.get_region_epoch().clone());\n        let mut cmd = RaftCmdRequest::default();\n        cmd.set_header(header);\n        cmd.mut_requests().push(ingest);\n        let resp = target_suite\n            .cluster\n            .call_command_on_leader(cmd, Duration::from_secs(5))\n            .unwrap();\n        assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    }\n\n    let cf = match dst_api_ver {\n        ApiVersion::V2 => String::from(\"\"),\n        _ => String::from(CF_DEFAULT),\n    };\n    for i in 0..key_count {\n        let (k, v) = target_suite.gen_raw_kv(i);\n        let key = {\n            let mut key = k.into_bytes();\n            if cur_api_ver != ApiVersion::V2 && dst_api_ver == ApiVersion::V2 {\n                let mut apiv2_key = [b'r', 0, 0, 0].to_vec();\n                apiv2_key.extend(key);\n                key = apiv2_key;\n            }\n            key\n        };\n        let ret_val = target_suite.must_raw_get(key, cf.clone());\n        assert_eq!(v.clone().into_bytes(), ret_val);\n    }\n\n    // Backup file should have same contents.\n    // Set non-empty range to check if it's incorrectly encoded.\n    let (backup_start, backup_end) = if cur_api_ver != dst_api_ver {\n        (\n            vec![b'r', 0, 0, 0, b'r', b'a'],\n            vec![b'r', 0, 0, 0, b'r', b'z'],\n        )\n    } else {\n        (vec![b'r', b'a'], vec![b'r', b'z'])\n    };\n    let rx = target_suite.backup_raw(\n        backup_start, // start\n        backup_end,   // end\n        cf,\n        &make_unique_dir(tmp.path()),\n        dst_api_ver,\n    );\n    let resps3 = block_on(rx.collect::<Vec<_>>());\n    let files3 = resps3[0].files.clone();\n\n    // After https://github.com/tikv/tikv/pull/8707 merged.\n    // the backup file name will based on local timestamp.\n    // so the two backup's file name may not be same, we should skip this check.\n    assert_eq!(files1.len(), 1);\n    assert_eq!(files3.len(), 1);\n    assert_eq!(files1[0].total_bytes, files3[0].total_bytes);\n    assert_eq!(files1[0].total_kvs, files3[0].total_kvs);\n    suite.stop();\n    target_suite.stop();\n}", "test": "fn test_backup_rawkv_convert() {\n    let raw_test_cases = vec![\n        (ApiVersion::V1, ApiVersion::V1),\n        (ApiVersion::V1ttl, ApiVersion::V1ttl),\n        (ApiVersion::V2, ApiVersion::V2),\n        (ApiVersion::V1, ApiVersion::V2),\n        (ApiVersion::V1ttl, ApiVersion::V2),\n    ];\n    for (cur_api_ver, dst_api_ver) in raw_test_cases {\n        test_backup_rawkv_cross_version_impl(cur_api_ver, dst_api_ver);\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/nested.rs::nested_many_instantiations", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn nested_many_instantiations() -> Result<()> {\n    let component = r#\"\n(component\n  (import \"count\" (func $count))\n  (component $c1\n    (import \"count\" (func $count))\n    (core func $count_lower (canon lower (func $count)))\n    (core module $m\n        (import \"\" \"\" (func $count))\n        (start $count)\n    )\n    (core instance (instantiate $m (with \"\" (instance (export \"\" (func $count_lower))))))\n    (core instance (instantiate $m (with \"\" (instance (export \"\" (func $count_lower))))))\n  )\n  (component $c2\n    (import \"count\" (func $count))\n    (instance (instantiate $c1 (with \"count\" (func $count))))\n    (instance (instantiate $c1 (with \"count\" (func $count))))\n  )\n  (component $c3\n    (import \"count\" (func $count))\n    (instance (instantiate $c2 (with \"count\" (func $count))))\n    (instance (instantiate $c2 (with \"count\" (func $count))))\n  )\n  (component $c4\n    (import \"count\" (func $count))\n    (instance (instantiate $c3 (with \"count\" (func $count))))\n    (instance (instantiate $c3 (with \"count\" (func $count))))\n  )\n\n  (instance (instantiate $c4 (with \"count\" (func $count))))\n)\n    \"#;\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"count\", |mut store: StoreContextMut<'_, u32>, _: ()| {\n            *store.data_mut() += 1;\n            Ok(())\n        })?;\n    linker.instantiate(&mut store, &component)?;\n    assert_eq!(*store.data(), 16);\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_get_tombstone_store", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_get_tombstone_store() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let mut client = new_client_v2(eps, None);\n\n    let mut all_stores = vec![];\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    client.bootstrap_cluster(store.clone(), region).unwrap();\n\n    all_stores.push(store);\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n    let s = client.get_all_stores(false).unwrap();\n    assert_eq!(s, all_stores);\n\n    // Add tombstone store.\n    let mut store99 = metapb::Store::default();\n    store99.set_id(99);\n    store99.set_state(metapb::StoreState::Tombstone);\n    server.default_handler().add_store(store99.clone());\n\n    let r = client.get_store(99);\n    assert_eq!(r.unwrap_err().error_code(), error_code::pd::STORE_TOMBSTONE);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::include_directive_with_no_path", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn include_directive_with_no_path() {\n  Test::new()\n    .justfile(\"!include\")\n    .arg(\"--unstable\")\n    .status(EXIT_FAILURE)\n    .stderr_regex(\"error: !include directive on line 1 of `.*` has no argument\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_numeric_suffix_no_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_short_numeric_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"-d\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x10\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x11\"), \"99\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_read_from_nonexistent_file", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_read_from_nonexistent_file() {\n    new_ucmd!()\n        .args(&[\"bogusfile\"])\n        .fails()\n        .stderr_only(\"wc: bogusfile: No such file or directory\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_initial_table_limits_exceeded", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_initial_table_limits_exceeded() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 23 anyfunc))\"#)?;\n\n    let mut store = Store::new(&engine, StoreLimitsBuilder::new().table_elements(4).build());\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table minimum size of 23 elements exceeds table limits\"\n        ),\n    }\n\n    match Table::new(\n        &mut store,\n        TableType::new(ValType::FuncRef, 99, None),\n        Val::FuncRef(None),\n    ) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table minimum size of 99 elements exceeds table limits\"\n        ),\n    }\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_infinite_symlink_expansion_to_files", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_infinite_symlink_expansion_to_files() {\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"check_rome_test_infinite_symlink_expansion_to_files\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    let symlink1_path = subdir1_path.join(\"symlink1\");\n    let symlink2_path = subdir2_path.join(\"symlink2\");\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&symlink2_path, &symlink1_path).unwrap();\n        symlink(&symlink1_path, &symlink2_path).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&symlink2_path, &symlink1_path));\n        check_windows_symlink!(symlink_dir(&symlink1_path, &symlink2_path));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"check\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Don't use a snapshot here, since the diagnostics can be reported in\n    // arbitrary order:\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(\"Deeply nested symlink expansion\")));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink1_path.display().to_string())));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink2_path.display().to_string())));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::squeeze_all_files", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn squeeze_all_files() {\n    // empty lines at the end of a file are \"squeezed\" together with empty lines at the beginning\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.write(\"input1\", \"a\\n\\n\");\n    at.write(\"input2\", \"\\n\\nb\");\n    ucmd.args(&[\"input1\", \"input2\", \"-s\"])\n        .succeeds()\n        .stdout_only(\"a\\n\\nb\");\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_multiple_a", "code": "pub fn remove<K2: PartialEq<K> + ?Sized>(&mut self, key: &K2) -> Option<V> {\n        self.find(key)\n            .map(|pos| self.vec.remove(pos))\n            .map(|(_, v)| v)\n    }", "test": "fn remove_multiple_a() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n    headers.insert(VARY, \"*\".parse().unwrap());\n\n    assert_eq!(headers.len(), 6);\n\n    let cookie = headers.remove(SET_COOKIE);\n    assert_eq!(cookie, Some(\"cookie_1=value 1\".parse().unwrap()));\n    assert_eq!(headers.len(), 3);\n\n    let via = headers.remove(VIA);\n    assert_eq!(via, Some(\"1.1 example.com\".parse().unwrap()));\n    assert_eq!(headers.len(), 1);\n\n    let vary = headers.remove(VARY);\n    assert_eq!(vary, Some(\"*\".parse().unwrap()));\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_ceil_log2_pow5", "code": "pub fn ceil_log2_pow5(e: i32) -> i32 /* or u32 -> u32 */ {\n    log2_pow5(e) + 1\n}", "test": "fn test_ceil_log2_pow5() {\n    assert_eq!(1, ceil_log2_pow5(0));\n    assert_eq!(3, ceil_log2_pow5(1));\n    assert_eq!(5, ceil_log2_pow5(2));\n    assert_eq!(7, ceil_log2_pow5(3));\n    assert_eq!(10, ceil_log2_pow5(4));\n    assert_eq!(8192, ceil_log2_pow5(3528));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_reboot", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_reboot() {\n    let eps_count = 1;\n    let server = MockServer::with_case(eps_count, Arc::new(AlreadyBootstrapped));\n    let eps = server.bind_addrs();\n    let client = new_client(eps, None);\n\n    assert!(!client.is_cluster_bootstrapped().unwrap());\n\n    match client.bootstrap_cluster(metapb::Store::default(), metapb::Region::default()) {\n        Err(PdError::ClusterBootstrapped(_)) => (),\n        _ => {\n            panic!(\"failed, should return ClusterBootstrapped\");\n        }\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_buckets", "code": "pub fn get_latest_buckets_version(&self) -> u64 {\n        self.latest_buckets_version\n    }", "test": "fn test_buckets() {\n    let product = ProductTable::new();\n    let (mut cluster, raft_engine, ctx) = new_raft_engine(1, \"\");\n\n    let (_, endpoint, _) =\n        init_data_with_engine_and_commit(ctx.clone(), raft_engine, &product, &[], true);\n\n    let req = DagSelect::from(&product).build_with(ctx, &[0]);\n    let resp = handle_request(&endpoint, req.clone());\n    assert_eq!(resp.get_latest_buckets_version(), 0);\n\n    let mut bucket_key = product.get_record_range_all().get_start().to_owned();\n    bucket_key.push(0);\n    let region = cluster.get_region(&bucket_key);\n    let bucket = Bucket {\n        keys: vec![bucket_key],\n        size: 1024,\n    };\n    cluster.refresh_region_bucket_keys(&region, vec![bucket], None, None);\n\n    let wait_refresh_buckets = |old_buckets_ver| {\n        let mut resp = Default::default();\n        for _ in 0..10 {\n            resp = handle_request(&endpoint, req.clone());\n            if resp.get_latest_buckets_version() != old_buckets_ver {\n                break;\n            }\n            thread::sleep(Duration::from_millis(100));\n        }\n        assert_ne!(resp.get_latest_buckets_version(), old_buckets_ver);\n    };\n\n    wait_refresh_buckets(0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_bootstrap.rs::test_node_bootstrap_idempotent", "code": "fn test_bootstrap_idempotent<T: Simulator>(cluster: &mut Cluster<T>) {\n    // assume that there is a node  bootstrap the cluster and add region in pd\n    // successfully\n    cluster.add_first_region().unwrap();\n    // now at same time start the another node, and will receive `cluster is not\n    // bootstrap` it will try to bootstrap with a new region, but will failed\n    // the region number still 1\n    cluster.start().unwrap();\n    cluster.check_regions_number(1);\n    cluster.shutdown();\n    sleep_ms(500);\n    cluster.start().unwrap();\n    cluster.check_regions_number(1);\n}", "test": "fn test_node_bootstrap_idempotent() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_bootstrap_idempotent(&mut cluster);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_with_files_and_pattern_and_verification", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_copy_into_with_files_and_pattern_and_verification() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 'gcs://mybucket/./../a.csv' AS some_alias \",\n        \"FILES = ('file1.json', 'file2.json') \",\n        \"PATTERN = '.*employees0[1-5].csv.gz' \",\n        \"VALIDATION_MODE = RETURN_7_ROWS\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            files,\n            pattern,\n            validation_mode,\n            from_stage_alias,\n            ..\n        } => {\n            assert_eq!(files.unwrap(), vec![\"file1.json\", \"file2.json\"]);\n            assert_eq!(pattern.unwrap(), \".*employees0[1-5].csv.gz\");\n            assert_eq!(validation_mode.unwrap(), \"RETURN_7_ROWS\");\n            assert_eq!(from_stage_alias.unwrap(), Ident::new(\"some_alias\"));\n        }\n        _ => unreachable!(),\n    }\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_catalog_lookup", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "async fn test_catalog_lookup() {\n    let example = create_example();\n    let test = create_test();\n    let origin = example.origin().clone();\n    let test_origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(example)));\n    catalog.upsert(test_origin.clone(), Box::new(Arc::new(test)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n\n    let ns = result.name_servers();\n    assert!(ns.is_empty());\n\n    // other zone\n    let mut question: Message = Message::new();\n    let mut query: Query = Query::new();\n    query.set_name(test_origin.into());\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::A(A::new(94, 184, 216, 34))\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_transfer_leader", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_merge_transfer_leader() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.store_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    // To ensure the region has applied to its current term so that later `split`\n    // can success without any retries. Then, `left_peer_3` will must be `1003`.\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), peer_1);\n    let k = b\"k1_for_apply_to_current_term\";\n    cluster.must_put(k, b\"value\");\n    must_get_equal(&cluster.get_engine(1), k, b\"value\");\n\n    cluster.must_split(&region, b\"k2\");\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let left_peer_1 = find_peer(&left, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1.clone());\n\n    let left_peer_3 = find_peer(&left, 3).unwrap().to_owned();\n    assert_eq!(left_peer_3.get_id(), 1003);\n\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n\n    // Prevent peer 1003 to handle ready when it's leader\n    let before_handle_raft_ready_1003 = \"before_handle_raft_ready_1003\";\n    fail::cfg(before_handle_raft_ready_1003, \"pause\").unwrap();\n\n    let epoch = cluster.get_region_epoch(left.get_id());\n    let mut transfer_leader_req =\n        new_admin_request(left.get_id(), &epoch, new_transfer_leader_cmd(left_peer_3));\n    transfer_leader_req.mut_header().set_peer(left_peer_1);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, transfer_leader_req, Callback::None)\n        .unwrap();\n    fail::remove(schedule_merge_fp);\n\n    pd_client.check_merged_timeout(left.get_id(), Duration::from_secs(5));\n\n    fail::remove(before_handle_raft_ready_1003);\n    sleep_ms(100);\n    cluster.must_put(b\"k4\", b\"v4\");\n    must_get_equal(&cluster.get_engine(3), b\"k4\", b\"v4\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search_arguments.rs::passing_dot_as_argument_is_allowed", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn passing_dot_as_argument_is_allowed() {\n  Test::new()\n    .justfile(\n      \"\n        say ARG:\n          echo {{ARG}}\n      \",\n    )\n    .write(\n      \"child/justfile\",\n      \"say ARG:\\n '{{just_executable()}}' ../say {{ARG}}\",\n    )\n    .current_dir(\"child\")\n    .args([\"say\", \".\"])\n    .stdout(\".\\n\")\n    .stderr_regex(\"'.*' ../say .\\necho .\\n\")\n    .run();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::negative_query", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn negative_query() {\n    let source = r#\"\n    void f() {\n        char buf[10];\n        if (i<10) {\n        memcpy(buf,src, i);\n        }\n    }\n    \"#;\n\n    let needle = \"{char $b[_]; memcpy($b, _, $i);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n\n    let needle = \"{char $b[_]; not: memcpy($b, _, $i);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 0);\n\n    let needle = \"{char $b[_]; not: $i < _; memcpy($b, _, $i);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 0);\n\n    let needle = \"{char $b[_]; not: $i > _; memcpy($b, _, $i);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n\n    let needle = \"{char $b[_]; memcpy($b, _, $i); NOT: $i < 10;}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_complete_io_for_handshake", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn buffered_client_complete_io_for_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    assert!(client.is_handshaking());\n    let (rdlen, wrlen) = client\n        .complete_io(&mut OtherSession::new_buffered(&mut server))\n        .unwrap();\n    assert!(rdlen > 0 && wrlen > 0);\n    assert!(!client.is_handshaking());\n    assert!(!client.wants_write());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_extends", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_extends() {\n    assert_err_msg(\"{% extends %}\", &[\"1:12\", \"expected a string\"]);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_3", "code": "fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n}", "test": "fn remove_entry_multi_3() {\n    let mut headers = HeaderMap::new();\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 3);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601_date", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_8601_date() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!()\n            .arg(format!(\"{param}=date\"))\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_default_with_io_blksize", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_default_with_io_blksize() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_default_with_io_blksize\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[name, \"---io-blksize\", \"2M\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_bytes", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_positive_bytes() {\n    new_ucmd!()\n        .args(&[\"-c\", \"+3\"])\n        .pipe_in(\"abcde\")\n        .succeeds()\n        .stdout_is(\"cde\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_basic", "code": "fn must_detect_deadlock(cluster: &mut Cluster<ServerCluster>, key: &[u8], ts: u64) {\n    // Sometimes, deadlocks can't be detected at once due to leader change, but it\n    // will be detected.\n    for _ in 0..5 {\n        let (client, ctx) = build_leader_client(cluster, key);\n        if deadlock(&client, ctx, key, ts) {\n            return;\n        }\n    }\n    panic!(\"failed to detect deadlock\");\n}", "test": "fn test_detect_deadlock_basic() {\n    let mut cluster = new_cluster_for_deadlock_test(3);\n    must_split_region(&mut cluster, b\"k\", b\"k\");\n    must_transfer_leader(&mut cluster, b\"\", 1);\n    must_transfer_leader(&mut cluster, b\"k\", 1);\n    deadlock_detector_leader_must_be(&mut cluster, 1);\n\n    // Detect on leader\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n    // Detect on follower\n    must_transfer_leader(&mut cluster, b\"\", 2);\n    deadlock_detector_leader_must_be(&mut cluster, 2);\n    must_detect_deadlock(&mut cluster, b\"k1\", 20);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_delimited_identifiers", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_delimited_identifiers() {\n    // check that quoted identifiers in any position remain quoted after serialization\n    let select = hive().verified_only_select(\n        r#\"SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"\"#,\n    );\n    // check FROM\n    match only(select.from).relation {\n        TableFactor::Table {\n            name,\n            alias,\n            args,\n            with_hints,\n            version,\n            partitions: _,\n        } => {\n            assert_eq!(vec![Ident::with_quote('\"', \"a table\")], name.0);\n            assert_eq!(Ident::with_quote('\"', \"alias\"), alias.unwrap().name);\n            assert!(args.is_none());\n            assert!(with_hints.is_empty());\n            assert!(version.is_none());\n        }\n        _ => panic!(\"Expecting TableFactor::Table\"),\n    }\n    // check SELECT\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::CompoundIdentifier(vec![\n            Ident::with_quote('\"', \"alias\"),\n            Ident::with_quote('\"', \"bar baz\"),\n        ]),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::with_quote('\"', \"myfun\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[1]),\n    );\n    match &select.projection[2] {\n        SelectItem::ExprWithAlias { expr, alias } => {\n            assert_eq!(&Expr::Identifier(Ident::with_quote('\"', \"simple id\")), expr);\n            assert_eq!(&Ident::with_quote('\"', \"column alias\"), alias);\n        }\n        _ => panic!(\"Expected ExprWithAlias\"),\n    }\n\n    hive().verified_stmt(r#\"CREATE TABLE \"foo\" (\"bar\" \"int\")\"#);\n    hive().verified_stmt(r#\"ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)\"#);\n    //TODO verified_stmt(r#\"UPDATE foo SET \"bar\" = 5\"#);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_merge_into_using_table", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_merge_into_using_table() {\n    let sql = \"MERGE INTO target_table USING source_table \\\n        ON target_table.id = source_table.oooid \\\n        WHEN MATCHED THEN \\\n            UPDATE SET target_table.description = source_table.description \\\n        WHEN NOT MATCHED THEN \\\n            INSERT (ID, description) VALUES (source_table.id, source_table.description)\";\n\n    verified_stmt(sql);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/table.rs::table_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn table_test_3() {\n    let original = r##\"> Test  | Table\n> ------|------\n> Row 1 | Every\n> Row 2 | Day\n>\n> Paragraph\n\"##;\n    let expected = r##\"<blockquote>\n<table><thead><tr><th>Test  </th><th> Table</th></tr></thead>\n<tr><td>Row 1 </td><td> Every</td></tr>\n<tr><td>Row 2 </td><td> Day</td></tr>\n</table>\n<p>Paragraph</p>\n</blockquote>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ptx.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_stale_learner_restart", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_stale_learner_restart() {\n    let mut cluster = new_node_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.raft_log_gc_threshold = 10;\n    let r = cluster.run_conf_change();\n    cluster\n        .pd_client\n        .must_add_peer(r, new_learner_peer(2, 1003));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    // Simulates slow apply.\n    fail::cfg(\"on_handle_apply_1003\", \"return\").unwrap();\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    let mut state: RaftLocalState = cluster\n        .get_raft_engine(1)\n        .get_raft_state(r)\n        .unwrap()\n        .unwrap();\n    let last_index = state.get_last_index();\n    let timer = Instant::now();\n    while timer.saturating_elapsed() < Duration::from_secs(5) {\n        state = cluster\n            .get_raft_engine(2)\n            .get_raft_state(r)\n            .unwrap()\n            .unwrap();\n        if last_index <= state.get_hard_state().get_commit() {\n            break;\n        }\n        thread::sleep(Duration::from_millis(10));\n    }\n    if state.last_index != last_index {\n        panic!(\"store 2 has not catched up logs after 5 secs.\");\n    }\n    cluster.shutdown();\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n    fail::remove(\"on_handle_apply_1003\");\n    cluster.run_node(2).unwrap();\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--parents\")\n        .arg(TEST_COPY_FROM_FOLDER_FILE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(\n        at.read(&format!(\n            \"{TEST_COPY_TO_FOLDER}/{TEST_COPY_FROM_FOLDER_FILE}\"\n        )),\n        \"Hello, World!\\n\"\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::do_while_loop", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn do_while_loop() {\n    run_test_actions([\n        TestAction::assert_eq(\n            indoc! {r#\"\n                a = 0;\n                do {\n                    a += 1;\n                } while (a < 10);\n                a\n            \"#},\n            10,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                pow = 0;\n                b = 1;\n                do {\n                    pow += 1;\n                    b *= 2;\n                } while (pow < 8);\n                b\n            \"#},\n            256,\n        ),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_no_further_output", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_no_further_output() {\n    new_ucmd!()\n        .args(&[\"-e\", \"a\\\\cb\", \"c\"])\n        .succeeds()\n        .stdout_only(\"a\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_0_conn", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_concurrent_requests_0_conn() {\n    let mut options = ResolverOpts::default();\n\n    // there are two connections, but no concurrency requested, 0==1\n    options.num_concurrent_reqs = 0;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(1);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send,\n    );\n    let udp2_nameserver = udp1_nameserver.clone();\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_when_split_region", "code": "fn must_detect_deadlock(cluster: &mut Cluster<ServerCluster>, key: &[u8], ts: u64) {\n    // Sometimes, deadlocks can't be detected at once due to leader change, but it\n    // will be detected.\n    for _ in 0..5 {\n        let (client, ctx) = build_leader_client(cluster, key);\n        if deadlock(&client, ctx, key, ts) {\n            return;\n        }\n    }\n    panic!(\"failed to detect deadlock\");\n}", "test": "fn test_detect_deadlock_when_split_region() {\n    let mut cluster = new_cluster_for_deadlock_test(3);\n    must_split_region(&mut cluster, b\"\", b\"k1\");\n    // After split, the leader is still store(1).\n    deadlock_detector_leader_must_be(&mut cluster, 1);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n    // Transfer the new region's leader to store(2) and deadlock occours on it.\n    must_transfer_leader(&mut cluster, b\"k1\", 2);\n    deadlock_detector_leader_must_be(&mut cluster, 1);\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_prerelease", "code": "pub(super) fn assert_to_string(value: impl Display, expected: &str) {\n    assert_eq!(value.to_string(), expected);\n}", "test": "fn test_prerelease() {\n    let err = prerelease_err(\"1.b\\0\");\n    assert_to_string(err, \"unexpected character in pre-release identifier\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::round_downward_test", "code": "pub(crate) fn round_downward(fp: &mut ExtendedFloat, shift: i32) {\n    // Bit shift so the leading bit is in the hidden bit.\n    // No rounding schemes, so we just ignore everything else.\n    let is_truncated = round_toward(fp, shift);\n    downard(fp, is_truncated);\n}", "test": "fn round_downward_test() {\n    // b0000000\n    let mut fp = ExtendedFloat { mant: 0x00, exp: 0 };\n    round_downward(&mut fp, 6);\n    assert_eq!(fp.mant, 0);\n\n    // b1000000\n    let mut fp = ExtendedFloat { mant: 0x40, exp: 0 };\n    round_downward(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    // b1100000\n    let mut fp = ExtendedFloat { mant: 0x60, exp: 0 };\n    round_downward(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    // b1110000\n    let mut fp = ExtendedFloat { mant: 0x70, exp: 0 };\n    round_downward(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_node_latency", "code": "fn test_multi_latency<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(DelayFilter::new(Duration::from_millis(\n        30,\n    ))));\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_node_latency() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_multi_latency(&mut cluster);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_elements_private_static", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_elements_private_static() {\n    test_formatting(\n        r#\"\n        class A {\n            static #a;\n            static #b = 1;\n            static #c() {}\n            static #d(a, b, c) {\n                return a + b + c;\n            }\n            static set #e(value) {}\n            static get #e() {}\n        }\n        \"#,\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_25", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_25() {\n    let original = r##\"H1 {.foo\n.bar}\n==\n\"##;\n    let expected = r##\"<h1>H1 {.foo\n.bar}</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_false.rs::test_short_options", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_short_options() {\n    for option in [\"-h\", \"-V\"] {\n        new_ucmd!().arg(option).fails().stdout_is(\"\");\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_inscribe_respects_dry_run_flag", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn batch_inscribe_respects_dry_run_flag() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let output = CommandBuilder::new(\"wallet inscribe --fee-rate 2.1 --batch batch.yaml --dry-run\")\n    .write(\"inscription.txt\", \"Hello World\")\n    .write(\n      \"batch.yaml\",\n      \"mode: shared-output\\ninscriptions:\\n- file: inscription.txt\\n\",\n    )\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  assert!(rpc_server.mempool().is_empty());\n\n  let request = TestServer::spawn_with_args(&rpc_server, &[])\n    .request(format!(\"/content/{}\", output.inscriptions[0].id));\n\n  assert_eq!(request.status(), 404);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_inscribe_fails_if_batchfile_has_no_inscriptions", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn batch_inscribe_fails_if_batchfile_has_no_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(\"wallet inscribe --fee-rate 2.1 --batch batch.yaml\")\n    .write(\"inscription.txt\", \"Hello World\")\n    .write(\"batch.yaml\", \"mode: shared-output\\ninscriptions: []\\n\")\n    .rpc_server(&rpc_server)\n    .stderr_regex(\".*batchfile must contain at least one inscription.*\")\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_36", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_36() {\n    let original = r##\"# {}\n## {}\n### {\\}\n#### {} {}\n\n#{}\n\"##;\n    let expected = r##\"<h1></h1>\n<h2></h2>\n<h3>{}</h3>\n<h4>{}</h4>\n<p>#{}</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::drop_delayed", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn drop_delayed() -> Result<()> {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    let module = Module::new(&engine, &wat::parse_str(r#\"(import \"\" \"\" (func))\"#)?)?;\n\n    let mut store = Store::new(&engine, ());\n    let func = linker.get(&mut store, \"\", \"\").unwrap();\n    Instance::new(&mut store, &module, &[func])?;\n\n    drop(store);\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    let mut store = Store::new(&engine, ());\n    let func = linker.get(&mut store, \"\", \"\").unwrap();\n    Instance::new(&mut store, &module, &[func])?;\n\n    drop(store);\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    drop(linker);\n\n    assert_eq!(HITS.load(SeqCst), 1);\n\n    Ok(())\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_is_send_and_sync", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn client_is_send_and_sync() {\n    let (client, _) = make_pair(KeyType::Rsa);\n    &client as &dyn Send;\n    &client as &dyn Sync;\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_31", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_31() {\n    let original = r##\"# H1 {#`code`}\n## H2 {#foo__bar__baz}\n### H3 {#foo**bar**baz}\n\"##;\n    let expected = r##\"<h1 id=\"`code`\">H1</h1>\n<h2 id=\"foo__bar__baz\">H2</h2>\n<h3 id=\"foo**bar**baz\">H3</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_with_specifier_not_at_start", "code": "fn run_cmd(arg: &str, expected_prefix: &str, expected_suffix: &str) {\n        let expected_msg = format!(\n            \"{} specifier not at start of number: {}\",\n            expected_prefix.quote(),\n            expected_suffix.quote()\n        );\n        new_ucmd!().arg(arg).fails().stderr_contains(expected_msg);\n    }", "test": "fn test_tabs_with_specifier_not_at_start() {\n    fn run_cmd(arg: &str, expected_prefix: &str, expected_suffix: &str) {\n        let expected_msg = format!(\n            \"{} specifier not at start of number: {}\",\n            expected_prefix.quote(),\n            expected_suffix.quote()\n        );\n        new_ucmd!().arg(arg).fails().stderr_contains(expected_msg);\n    }\n    run_cmd(\"--tabs=1/\", \"/\", \"/\");\n    run_cmd(\"--tabs=1/2\", \"/\", \"/2\");\n    run_cmd(\"--tabs=1+\", \"+\", \"+\");\n    run_cmd(\"--tabs=1+2\", \"+\", \"+2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_spaces_after_fields", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_spaces_after_fields() {\n    new_ucmd!()\n        .args(&[\"-a\"])\n        .pipe_in(\"   \\t        A B C D             A\\t\\n\")\n        .run()\n        .stdout_is(\"\\t\\tA B C D\\t\\t    A\\t\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_comma_only", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_comma_only() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \",\"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        .stdout_is(\"a       b       c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_starts_combined_shorts", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_obs_lines_starts_combined_shorts() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"obs-lines-starts-shorts\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-200xd\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date5", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date5() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"1970-01-01 18:43:33.023456789\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    // Slightly different result on Windows for nano seconds\n    // TODO: investigate\n    #[cfg(windows)]\n    let expected = FileTime::from_unix_time(67413, 23_456_700);\n    #[cfg(not(windows))]\n    let expected = FileTime::from_unix_time(67413, 23_456_789);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_4", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_4() {\n    let original = r##\"[^lorem]: If heaven ever wishes to grant me a boon, it will be a total effacing of the results of a mere chance which fixed my eye on a certain stray piece of shelf-paper. It was nothing on which I would naturally have stumbled in the course of my daily round, for it was an old number of an Australian journal, the Sydney Bulletin for April 18, 1925. It had escaped even the cutting bureau which had at the time of its issuance been avidly collecting material for my uncle's research.\n\nI had largely given over my inquiries into what Professor Angell called the \"Cthulhu Cult\", and was visiting a learned friend in Paterson, New Jersey; the curator of a local museum and a mineralogist of note. Examining one day the reserve specimens roughly set on the storage shelves in a rear room of the museum, my eye was caught by an odd picture in one of the old papers spread beneath the stones. It was the Sydney Bulletin I have mentioned, for my friend had wide affiliations in all conceivable foreign parts; and the picture was a half-tone cut of a hideous stone image almost identical with that which Legrasse had found in the swamp.\n\"##;\n    let expected = r##\"<div class=\"footnote-definition\" id=\"lorem\"><sup class=\"footnote-definition-label\">1</sup>\n<p>If heaven ever wishes to grant me a boon, it will be a total effacing of the results of a mere chance which fixed my eye on a certain stray piece of shelf-paper. It was nothing on which I would naturally have stumbled in the course of my daily round, for it was an old number of an Australian journal, the Sydney Bulletin for April 18, 1925. It had escaped even the cutting bureau which had at the time of its issuance been avidly collecting material for my uncle's research.</p>\n</div>\n<p>I had largely given over my inquiries into what Professor Angell called the &quot;Cthulhu Cult&quot;, and was visiting a learned friend in Paterson, New Jersey; the curator of a local museum and a mineralogist of note. Examining one day the reserve specimens roughly set on the storage shelves in a rear room of the museum, my eye was caught by an odd picture in one of the old papers spread beneath the stones. It was the Sydney Bulletin I have mentioned, for my friend had wide affiliations in all conceivable foreign parts; and the picture was a half-tone cut of a hideous stone image almost identical with that which Legrasse had found in the swamp.</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_count_up", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_count_up() {\n    new_ucmd!()\n        .args(&[\"10\"])\n        .run()\n        .stdout_is(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_datagram() {\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n    let tcp_message = message(query.clone(), vec![tcp_record], vec![], vec![]);\n    let udp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        Default::default(),\n    );\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![udp_nameserver],\n        vec![tcp_nameserver],\n        None,\n        Default::default(),\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_exclude_type_option", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_exclude_type_option() {\n    new_ucmd!().args(&[\"-x\", \"ext4\", \"-x\", \"ext3\"]).succeeds();\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::keep_alive", "code": "pub fn is_closed(&self) -> bool {\n        self.state.is_closed()\n    }", "test": "fn keep_alive() {\n    let _guard = subscribe();\n    const IDLE_TIMEOUT: u64 = 10;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            keep_alive_interval: Some(Duration::from_millis(IDLE_TIMEOUT / 2)),\n            max_idle_timeout: Some(VarInt(IDLE_TIMEOUT)),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    // Run a good while longer than the idle timeout\n    let end = pair.time + Duration::from_millis(20 * IDLE_TIMEOUT);\n    while pair.time < end {\n        if !pair.step() {\n            if let Some(time) = min_opt(pair.client.next_wakeup(), pair.server.next_wakeup()) {\n                pair.time = time;\n            }\n        }\n        assert!(!pair.client_conn_mut(client_ch).is_closed());\n        assert!(!pair.server_conn_mut(server_ch).is_closed());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_spaces_follow_tabs_0", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_spaces_follow_tabs_0() {\n    // The two first spaces can be included into the first tab.\n    new_ucmd!()\n        .pipe_in(\"  \\t\\t   A\")\n        .run()\n        .stdout_is(\"\\t\\t   A\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_splitting_with_default_mtu", "code": "pub(super) fn drive_client(&mut self) {\n        let span = info_span!(\"client\");\n        let _guard = span.enter();\n        self.client.drive(self.time, self.server.addr);\n        for x in self.client.outbound.drain(..) {\n            if packet_size(&x) > self.mtu {\n                info!(\n                    packet_size = packet_size(&x),\n                    \"dropping packet (max size exceeded)\"\n                );\n                continue;\n            }\n            if x.contents[0] & packet::LONG_HEADER_FORM == 0 {\n                let spin = x.contents[0] & packet::SPIN_BIT != 0;\n                self.spins += (spin == self.last_spin) as u64;\n                self.last_spin = spin;\n            }\n            if let Some(ref socket) = self.client.socket {\n                socket.send_to(&x.contents, x.destination).unwrap();\n            }\n            if self.server.addr == x.destination {\n                self.server.inbound.push_back((\n                    self.time + self.latency,\n                    x.ecn,\n                    x.contents.as_ref().into(),\n                ));\n            }\n        }\n    }", "test": "fn packet_splitting_with_default_mtu() {\n    let _guard = subscribe();\n\n    // The payload needs to be split in 2 in order to be sent, because it is higher than the max MTU\n    let payload = vec![42; 1300];\n\n    let mut pair = Pair::default();\n    let (client_ch, _) = pair.connect();\n    pair.drive();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert_eq!(pair.client.outbound.len(), 2);\n\n    pair.drive_client();\n    assert_eq!(pair.server.inbound.len(), 2);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_describe", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_describe() {\n    let describe = r#\"DESCRIBE namespace.`table`\"#;\n    hive().verified_stmt(describe);\n    generic(None).verified_stmt(describe);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nonexistent_file_is_not_symlink", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_nonexistent_file_is_not_symlink() {\n    let scenario = TestScenario::new(util_name!());\n\n    scenario\n        .ucmd()\n        .args(&[\"!\", \"-h\", \"nonexistent_file\"])\n        .succeeds();\n    scenario\n        .ucmd()\n        .args(&[\"!\", \"-L\", \"nonexistent_file\"])\n        .succeeds();\n}"}
{"test_id": "casey-just/casey-just-af55be3/bin/ref-type/tests/integration.rs::junk_is_other", "code": "pub(crate) fn stdout(mut self, stdout: impl Into<String>) -> Self {\n    self.stdout = stdout.into();\n    self\n  }", "test": "fn junk_is_other() {\n  assert_eq!(stdout(\"refs/tags/asdf\"), \"::set-output name=value::other\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_failing_nonexistent_parent", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_install_target_new_file_failing_nonexistent_parent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n    let dir = \"target_dir\";\n\n    at.touch(file1);\n\n    ucmd.arg(file1)\n        .arg(format!(\"{dir}/{file2}\"))\n        .fails()\n        .stderr_contains(\"No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_hex_big_number", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hex_big_number() {\n    new_ucmd!()\n        .args(&[\n            \"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"0x100000000000000000000000000000000\",\n        ])\n        .succeeds()\n        .stdout_is(\n            \"340282366920938463463374607431768211455\\n340282366920938463463374607431768211456\\n\",\n        );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module.rs::checks_incompatible_target", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn checks_incompatible_target() -> Result<()> {\n    let mut target = target_lexicon::Triple::host();\n    target.operating_system = target_lexicon::OperatingSystem::Unknown;\n    match Module::new(\n        &Engine::new(Config::new().target(&target.to_string())?)?,\n        \"(module)\",\n    ) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert!(\n            format!(\"{:?}\", e).contains(\"configuration does not match the host\"),\n            \"bad error: {:?}\",\n            e\n        ),\n    }\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_term_change", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_term_change() {\n    let cluster = new_server_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let region = suite.cluster.get_region(&[]);\n    suite\n        .cluster\n        .must_transfer_leader(region.id, new_peer(2, 2));\n    // Simulate network partition.\n    let recv_filter =\n        Box::new(RegionPacketFilter::new(region.get_id(), 1).direction(Direction::Recv));\n    suite.cluster.sim.wl().add_recv_filter(1, recv_filter);\n    // Transfer leader to peer 3 and then change it back to peer 2.\n    // Peer 1 would not get a new SoftState.\n    suite\n        .cluster\n        .must_transfer_leader(region.id, new_peer(3, 3));\n    suite\n        .cluster\n        .must_transfer_leader(region.id, new_peer(2, 2));\n    suite.cluster.sim.wl().clear_recv_filters(1);\n\n    suite\n        .cluster\n        .pd_client\n        .must_remove_peer(region.id, new_peer(3, 3));\n    let region = suite.cluster.get_region(&[]);\n    let req = suite.new_changedata_request(region.id);\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let mut counter = 0;\n    let mut previous_ts = 0;\n    loop {\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            assert!(resolved_ts.ts >= previous_ts);\n            assert!(resolved_ts.regions == vec![region.id]);\n            previous_ts = resolved_ts.ts;\n            counter += 1;\n        }\n        if counter > 5 {\n            break;\n        }\n    }\n    event_feed_wrap.replace(None);\n    suite.stop();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_dec", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn test_dec() {\n    assert_eq!(from_str(\"1461\"), Ok(1461));\n    assert_eq!(from_str(\"51\"), Ok(51));\n    assert_eq!(from_str(\"150700\"), Ok(150700));\n\n    assert_eq!(\n        from_str::<i8>(\"-_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 2 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"256\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 4 },\n        })\n    );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::unary_ops", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn unary_ops() {\n    // TODO: need to port\n    // These cases are handled by PeepholeRemoveDeadCode in closure-compiler.\n    // test_same(\"!foo();\");\n    // test_same(\"~foo();\");\n    // test_same(\"-foo();\");\n\n    // These cases are handled here.\n    test(\"a=!true\", \"a=!!0;\");\n    test(\"a=!10\", \"a=!1;\");\n    test(\"a=!false\", \"a=!!1;\");\n    test_same(\"a=!foo();\");\n    test(\"a=-0\", \"a=-0;\");\n    test(\"a=-(0)\", \"a=-0;\");\n    test_same(\"a=-Infinity;\");\n    test(\"a=-NaN\", \"a=NaN;\");\n    test_same(\"a=-foo();\");\n    test(\"a=~~0\", \"a=0;\");\n    test(\"a=~~10\", \"a=10;\");\n    test(\"a=~-7\", \"a=6;\");\n\n    test(\"a=+true\", \"a=1;\");\n    test(\"a=+10\", \"a=10;\");\n    test(\"a=+false\", \"a=0;\");\n    test_same(\"a=+foo();\");\n    test_same(\"a=+f;\");\n    // test(\"a=+(f?true:false)\", \"a=+(f?1:0);\"); // TODO(johnlenz): foldable\n    test(\"a=+0\", \"a=0;\");\n    test(\"a=+Infinity\", \"a=Infinity;\");\n    test(\"a=+NaN\", \"a=NaN;\");\n    test(\"a=+-7\", \"a=-7;\");\n    test(\"a=+.5\", \"a=.5;\");\n\n    test(\"a=~0xffffffff\", \"a=0;\");\n    test(\"a=~~0xffffffff\", \"a=-1;\");\n    // test_same(\"a=~.5\", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::is_empty", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "test": "fn is_empty() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert!(!table.is_empty().unwrap());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/not_feature_format_tests.rs::format_properties_test", "code": "pub const fn flags(&self) -> u128 {\n        FORMAT & flags::FLAG_MASK\n    }", "test": "fn format_properties_test() {\n    let format = NumberFormat::<{ STANDARD }> {};\n    assert_eq!(format.flags(), STANDARD & format::FLAG_MASK);\n    assert_eq!(format.interface_flags(), STANDARD & format::INTERFACE_FLAG_MASK);\n    assert_eq!(format.digit_separator(), b'\\x00');\n    assert_eq!(format.base_prefix(), b'\\x00');\n    assert_eq!(format.base_suffix(), b'\\x00');\n    assert_eq!(format.mantissa_radix(), 10);\n    assert_eq!(format.radix(), 10);\n    assert_eq!(format.exponent_base(), 10);\n    assert_eq!(format.exponent_radix(), 10);\n    assert_eq!(format.required_integer_digits(), false);\n    assert_eq!(format.required_fraction_digits(), false);\n    assert_eq!(format.required_exponent_digits(), true);\n    assert_eq!(format.required_mantissa_digits(), true);\n    assert_eq!(format.required_digits(), true);\n    assert_eq!(format.no_positive_mantissa_sign(), false);\n    assert_eq!(format.required_mantissa_sign(), false);\n    assert_eq!(format.no_exponent_notation(), false);\n    assert_eq!(format.no_positive_exponent_sign(), false);\n    assert_eq!(format.required_exponent_sign(), false);\n    assert_eq!(format.no_exponent_without_fraction(), false);\n    assert_eq!(format.no_special(), false);\n    assert_eq!(format.case_sensitive_special(), false);\n    assert_eq!(format.no_integer_leading_zeros(), false);\n    assert_eq!(format.no_float_leading_zeros(), false);\n    assert_eq!(format.required_exponent_notation(), false);\n    assert_eq!(format.case_sensitive_exponent(), false);\n    assert_eq!(format.case_sensitive_base_prefix(), false);\n    assert_eq!(format.case_sensitive_base_suffix(), false);\n    assert_eq!(format.integer_internal_digit_separator(), false);\n    assert_eq!(format.fraction_internal_digit_separator(), false);\n    assert_eq!(format.exponent_internal_digit_separator(), false);\n    assert_eq!(format.internal_digit_separator(), false);\n    assert_eq!(format.integer_leading_digit_separator(), false);\n    assert_eq!(format.fraction_leading_digit_separator(), false);\n    assert_eq!(format.exponent_leading_digit_separator(), false);\n    assert_eq!(format.leading_digit_separator(), false);\n    assert_eq!(format.integer_trailing_digit_separator(), false);\n    assert_eq!(format.fraction_trailing_digit_separator(), false);\n    assert_eq!(format.exponent_trailing_digit_separator(), false);\n    assert_eq!(format.trailing_digit_separator(), false);\n    assert_eq!(format.integer_consecutive_digit_separator(), false);\n    assert_eq!(format.fraction_consecutive_digit_separator(), false);\n    assert_eq!(format.exponent_consecutive_digit_separator(), false);\n    assert_eq!(format.consecutive_digit_separator(), false);\n    assert_eq!(format.special_digit_separator(), false);\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_error.rs::test_serialize_nested_enum", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + ser::Serialize,\n{\n    let mut vec = Vec::with_capacity(128);\n    to_writer(&mut vec, value)?;\n    String::from_utf8(vec).map_err(|error| error::new(ErrorImpl::FromUtf8(error)))\n}", "test": "fn test_serialize_nested_enum() {\n    #[derive(Serialize, Debug)]\n    enum Outer {\n        Inner(Inner),\n    }\n    #[derive(Serialize, Debug)]\n    enum Inner {\n        Newtype(usize),\n        Tuple(usize, usize),\n        Struct { x: usize },\n    }\n\n    let expected = \"serializing nested enums in YAML is not supported yet\";\n\n    let e = Outer::Inner(Inner::Newtype(0));\n    let error = serde_yaml::to_string(&e).unwrap_err();\n    assert_eq!(error.to_string(), expected);\n\n    let e = Outer::Inner(Inner::Tuple(0, 0));\n    let error = serde_yaml::to_string(&e).unwrap_err();\n    assert_eq!(error.to_string(), expected);\n\n    let e = Outer::Inner(Inner::Struct { x: 0 });\n    let error = serde_yaml::to_string(&e).unwrap_err();\n    assert_eq!(error.to_string(), expected);\n\n    let e = Value::Tagged(Box::new(TaggedValue {\n        tag: Tag::new(\"Outer\"),\n        value: Value::Tagged(Box::new(TaggedValue {\n            tag: Tag::new(\"Inner\"),\n            value: Value::Null,\n        })),\n    }));\n    let error = serde_yaml::to_string(&e).unwrap_err();\n    assert_eq!(error.to_string(), expected);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i128_min", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_i128_min() {\n    assert_eq!(\n        std::i128::MIN,\n        from_str(&to_string(&std::i128::MIN).unwrap()).unwrap()\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_rawkv_cf", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_txn_store_rawkv_cf() {\n    let store = AssertionStorage::default();\n    store.raw_put_ok(CF_DEFAULT.to_string(), b\"k1\".to_vec(), b\"v1\".to_vec());\n    store.raw_get_ok(CF_DEFAULT.to_string(), b\"k1\".to_vec(), Some(b\"v1\".to_vec()));\n    store.raw_get_ok(\"\".to_string(), b\"k1\".to_vec(), Some(b\"v1\".to_vec()));\n    store.raw_get_ok(CF_LOCK.to_string(), b\"k1\".to_vec(), None);\n\n    store.raw_put_ok(\"\".to_string(), b\"k2\".to_vec(), b\"v2\".to_vec());\n    store.raw_put_ok(CF_LOCK.to_string(), b\"k3\".to_vec(), b\"v3\".to_vec());\n    store.raw_get_ok(CF_DEFAULT.to_string(), b\"k2\".to_vec(), Some(b\"v2\".to_vec()));\n    store.raw_get_ok(CF_LOCK.to_string(), b\"k3\".to_vec(), Some(b\"v3\".to_vec()));\n    store.raw_get_ok(CF_DEFAULT.to_string(), b\"k3\".to_vec(), None);\n    store.raw_scan_ok(\n        CF_DEFAULT.to_string(),\n        b\"\".to_vec(),\n        None,\n        3,\n        vec![(b\"k1\", b\"v1\"), (b\"k2\", b\"v2\")],\n    );\n\n    store.raw_put_err(\"foobar\".to_string(), b\"key\".to_vec(), b\"value\".to_vec());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_container_name_in_forloop", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn missing_container_name_in_forloop() {\n    assert_err_msg(\"{% for i in %}\", &[\"1:13\", \"expected an expression or an array of values\"]);\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_int_min_i64", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_int_min_i64() {\n    let thing = i64::MIN;\n    let yaml = indoc! {\"\n        -9223372036854775808\n    \"};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::str_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn str_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n\n    let mut iter = table.iter().unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n\n    let mut iter: Range<&str, &str> = table.range(\"a\"..\"z\").unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::key_update_simple", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn key_update_simple() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Bi)\n        .expect(\"couldn't open first stream\");\n\n    const MSG1: &[u8] = b\"hello1\";\n    pair.client_send(client_ch, s).write(MSG1).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Bi }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Bi), Some(stream) if stream == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG1\n    );\n    let _ = chunks.finalize();\n\n    info!(\"initiating key update\");\n    pair.client_conn_mut(client_ch).initiate_key_update();\n\n    const MSG2: &[u8] = b\"hello2\";\n    pair.client_send(client_ch, s).write(MSG2).unwrap();\n    pair.drive();\n\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), Some(Event::Stream(StreamEvent::Readable { id })) if id == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 6 && chunk.bytes == MSG2\n    );\n    let _ = chunks.finalize();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_eq!(pair.server_conn_mut(server_ch).lost_packets(), 0);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::comma", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn comma() {\n    test(\"1, 2, 3\", \"1,2,3;\");\n    test(\"1, a = b, 3\", \"1,a=b,3;\");\n    test(\"1, (2, 3), 4\", \"1,(2,3),4;\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_stream_read", "code": "fn test_server_stream_read(stream_kind: StreamKind, read_kind: ReadKind) {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n        let data = b\"world\";\n        client.writer().write_all(data).unwrap();\n\n        {\n            let mut pipe = OtherSession::new(&mut client);\n            transfer_eof(&mut server);\n\n            let stream: Box<dyn Read> = match stream_kind {\n                StreamKind::Ref => Box::new(Stream::new(&mut server, &mut pipe)),\n                StreamKind::Owned => Box::new(StreamOwned::new(server, pipe)),\n            };\n\n            test_stream_read(read_kind, stream, data)\n        }\n    }\n}", "test": "fn server_stream_read() {\n    test_server_stream_read(StreamKind::Ref, ReadKind::Buf);\n    test_server_stream_read(StreamKind::Owned, ReadKind::Buf);\n    #[cfg(read_buf)]\n    {\n        test_server_stream_read(StreamKind::Ref, ReadKind::BorrowedBuf);\n        test_server_stream_read(StreamKind::Owned, ReadKind::BorrowedBuf);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_basic", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_basic() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&32_usize.to_be_bytes(), &128_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n    for i in 0..32_usize {\n        let x = i.to_be_bytes();\n        assert!(db.engine.get_value(&x).unwrap().is_some());\n    }\n    for i in 32..128_usize {\n        let x = i.to_be_bytes();\n        assert!(db.engine.get_value(&x).unwrap().is_none());\n    }\n    for i in 128..256_usize {\n        let x = i.to_be_bytes();\n        assert!(db.engine.get_value(&x).unwrap().is_some());\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::zero_rtt_rejection", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn zero_rtt_rejection() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"foo\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto.clone()));\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(0), [][..].into());\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost { .. })\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    pair.client.connections.clear();\n    pair.server.connections.clear();\n\n    // Changing protocols invalidates 0-RTT\n    client_crypto.alpn_protocols = vec![\"bar\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n    info!(\"resuming session\");\n    let client_ch = pair.begin_connect(client_config);\n    assert!(pair.client_conn_mut(client_ch).has_0rtt());\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"Hello, 0-RTT!\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n    assert!(!pair.client_conn_mut(client_ch).accepted_0rtt());\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let s2 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    assert_eq!(s, s2);\n\n    let mut recv = pair.server_recv(server_ch, s2);\n    let mut chunks = recv.read(false).unwrap();\n    assert_eq!(chunks.next(usize::MAX), Err(ReadError::Blocked));\n    let _ = chunks.finalize();\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_strikethrough.rs::gfm_strikethrough_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_strikethrough_test_1() {\n    let original = r##\"~~Hi~~ Hello, ~there~ world!\n\"##;\n    let expected = r##\"<p><del>Hi</del> Hello, <del>there</del> world!</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_ingest_multiple_sst", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_multiple_sst() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n\n    let temp_dir = Builder::new()\n        .prefix(\"test_ingest_multiple_sst\")\n        .tempdir()\n        .unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range1 = (0, 100);\n    let (mut meta1, data1) = gen_sst_file(sst_path, sst_range1);\n    meta1.set_region_id(ctx.get_region_id());\n    meta1.set_region_epoch(ctx.get_region_epoch().clone());\n\n    let sst_path2 = temp_dir.path().join(\"write-test.sst\");\n    let sst_range2 = (100, 200);\n    let (mut meta2, data2) = gen_sst_file(sst_path2, sst_range2);\n    meta2.set_region_id(ctx.get_region_id());\n    meta2.set_region_epoch(ctx.get_region_epoch().clone());\n    meta2.set_cf_name(\"write\".to_owned());\n\n    send_upload_sst(&import, &meta1, &data1).unwrap();\n    send_upload_sst(&import, &meta2, &data2).unwrap();\n\n    let mut ingest = MultiIngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.mut_ssts().push(meta1);\n    ingest.mut_ssts().push(meta2);\n    let resp = import.multi_ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n\n    // Check ingested kvs\n    check_ingested_kvs(&tikv, &ctx, sst_range1);\n    check_ingested_kvs_cf(&tikv, &ctx, \"write\", sst_range2);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_overflow", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn indent_size_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=257\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::multimap_signature_lifetimes", "code": "pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    }", "test": "fn multimap_signature_lifetimes() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let def: MultimapTableDefinition<&str, u64> = MultimapTableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(def).unwrap();\n        table.insert(\"bye\", 0).unwrap();\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.get(key.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.range(key.as_str()..).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.remove_all(key.as_str()).unwrap()\n        };\n    }\n    write_txn.commit().unwrap();\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_empty_payload", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_empty_payload() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0, 0, 0, 0, 0, 0, 1,\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_pd_client_heartbeat_send_failed", "code": "fn is_ok(&self) -> bool {\n        let count = self.count.fetch_add(1, Ordering::SeqCst);\n        if count != 0 && count % self.retry == 0 {\n            // it's ok.\n            return true;\n        }\n        // let's sleep awhile, so that client will update its connection.\n        thread::sleep(REQUEST_RECONNECT_INTERVAL);\n        false\n    }", "test": "fn test_pd_client_heartbeat_send_failed() {\n    let pd_client_send_fail_fp = \"region_heartbeat_send_failed\";\n    fail::cfg(pd_client_send_fail_fp, \"return()\").unwrap();\n    let server = MockServer::with_case(1, Arc::new(AlreadyBootstrapped));\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps, None);\n    let poller = Builder::new_multi_thread()\n        .thread_name(thd_name!(\"poller\"))\n        .worker_threads(1)\n        .build()\n        .unwrap();\n    let (tx, rx) = mpsc::channel();\n    let f =\n        client.handle_region_heartbeat_response(1, move |resp| tx.send(resp).unwrap_or_default());\n    poller.spawn(f);\n\n    let heartbeat_send_fail = |ok| {\n        let mut region = metapb::Region::default();\n        region.set_id(1);\n        poller.spawn(client.region_heartbeat(\n            store::RAFT_INIT_LOG_TERM,\n            region,\n            metapb::Peer::default(),\n            RegionStat::default(),\n            None,\n        ));\n        let rsp = rx.recv_timeout(Duration::from_millis(100));\n        if ok {\n            assert!(rsp.is_ok());\n            assert_eq!(rsp.unwrap().get_region_id(), 1);\n        } else {\n            rsp.unwrap_err();\n        }\n\n        let region = block_on(client.get_region_by_id(1));\n        if ok {\n            assert!(region.is_ok());\n            let r = region.unwrap();\n            assert!(r.is_some());\n            assert_eq!(1, r.unwrap().get_id());\n        } else {\n            region.unwrap_err();\n        }\n    };\n    // send fail if network is block.\n    heartbeat_send_fail(false);\n    fail::remove(pd_client_send_fail_fp);\n    // send success after network recovered.\n    heartbeat_send_fail(true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_allow_empty_files", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_allow_empty_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n    assert_eq!(at.read(\"xad\"), \"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_show_tabs", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_show_tabs() {\n    for same_param in [\"-T\", \"--show-tabs\", \"--show-ta\"] {\n        new_ucmd!()\n            .args(&[same_param])\n            .pipe_in(\"\\t\\0\\n\")\n            .succeeds()\n            .stdout_only(\"^I\\0\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_custom_backup_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_should_raise_an_error_for_unresolved_configuration", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn extends_should_raise_an_error_for_unresolved_configuration() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"formatTYPO.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), test_file.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_should_raise_an_error_for_unresolved_configuration\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_set_transaction", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_set_transaction() {\n    // SET TRANSACTION shares transaction mode parsing code with START\n    // TRANSACTION, so no need to duplicate the tests here. We just do a quick\n    // sanity check.\n    match verified_stmt(\"SET TRANSACTION READ ONLY, READ WRITE, ISOLATION LEVEL SERIALIZABLE\") {\n        Statement::SetTransaction {\n            modes,\n            session,\n            snapshot,\n        } => {\n            assert_eq!(\n                modes,\n                vec![\n                    TransactionMode::AccessMode(TransactionAccessMode::ReadOnly),\n                    TransactionMode::AccessMode(TransactionAccessMode::ReadWrite),\n                    TransactionMode::IsolationLevel(TransactionIsolationLevel::Serializable),\n                ]\n            );\n            assert!(!session);\n            assert_eq!(snapshot, None);\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_multiple_input_line_count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_shuf_multiple_input_line_count() {\n    let result = new_ucmd!()\n        .args(&[\"-i10-200\", \"-n\", \"10\", \"-n\", \"5\"])\n        .succeeds();\n\n    result.no_stderr();\n\n    let result_count = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .count();\n    assert_eq!(result_count, 5, \"Output should have 5 items\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_zero_len_not_equals_zero_len_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_zero_len_not_equals_zero_len_is_false() {\n    new_ucmd!().args(&[\"\", \"!=\", \"\"]).run().code_is(1);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::simple", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn simple() {\n    assert_eq!(\n        parse_and_match(\"{int $a = _+foo+$a;}\", \"void foo() {int bar=10+foo+bar;}\"),\n        1\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ignore_vcs_ignored_file", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ignore_vcs_ignored_file() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = r#\"{\n        \"vcs\": {\n            \"enabled\": true,\n            \"clientKind\": \"git\",\n            \"useIgnoreFile\": true\n        }\n    }\"#;\n\n    let git_ignore = r#\"\nfile2.js\n\"#;\n\n    let code2 = r#\"foo.call(); bar.call();\"#;\n    let code1 = r#\"array.map(sentence => sentence.split(' ')).flat();\"#;\n\n    // ignored files\n    let file_path1 = Path::new(\"file1.js\");\n    fs.insert(file_path1.into(), code1.as_bytes());\n    let file_path2 = Path::new(\"file2.js\");\n    fs.insert(file_path2.into(), code2.as_bytes());\n\n    // configuration\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), rome_json.as_bytes());\n\n    // git ignore file\n    let ignore_file = Path::new(\".gitignore\");\n    fs.insert(ignore_file.into(), git_ignore.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignore_vcs_ignored_file\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/slash_operator.rs::no_lhs_once", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn no_lhs_once() {\n  Test::new()\n    .justfile(\"x := / 'a'\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout(\"/a\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_no_circular", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_link_no_circular() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let link = \"test_link_no_circular\";\n\n    ucmd.args(&[link, link])\n        .fails()\n        .stderr_is(\"link: cannot create link 'test_link_no_circular' to 'test_link_no_circular': No such file or directory\\n\");\n    assert!(!at.file_exists(link));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_return", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn test_trap_return() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| bail!(\"test 123\"));\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n    assert!(format!(\"{e:?}\").contains(\"test 123\"));\n\n    assert!(\n        e.downcast_ref::<WasmBacktrace>().is_some(),\n        \"error should contain a WasmBacktrace\"\n    );\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::invoke_post_return", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn invoke_post_return() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"f\" (func $f))\n\n            (core func $f_lower\n                (canon lower (func $f))\n            )\n            (core module $m\n                (import \"\" \"\" (func $f))\n\n                (func (export \"thunk\"))\n\n                (func $post_return\n                    call $f)\n                (export \"post-return\" (func $post_return))\n            )\n            (core instance $i (instantiate $m\n                (with \"\" (instance\n                    (export \"\" (func $f_lower))\n                ))\n            ))\n            (func (export \"thunk\")\n                (canon lift\n                    (core func $i \"thunk\")\n                    (post-return (func $i \"post-return\"))\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"f\",\n        |mut store: StoreContextMut<'_, bool>, _: ()| -> Result<()> {\n            assert!(!*store.data());\n            *store.data_mut() = true;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_typed_func::<(), ()>(&mut store, \"thunk\")?;\n\n    assert!(!*store.data());\n    thunk.call(&mut store, ())?;\n    assert!(!*store.data());\n    thunk.post_return(&mut store)?;\n    assert!(*store.data());\n\n    Ok(())\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::draft_version_compat", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn draft_version_compat() {\n    let _guard = subscribe();\n\n    let mut client_config = client_config();\n    client_config.version(0xff00_0020);\n\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect_with(client_config);\n\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(\n                        ApplicationClose { error_code: VarInt(42), ref reason }\n                    )}) if reason == REASON);\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client.known_connections(), 0);\n    assert_eq!(pair.client.known_cids(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error_scaled32_test", "code": "fn compute_error_scaled32(q: i32, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f32>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error_scaled32_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(\n        compute_error_scaled32(0, 4611686018427387904, 39),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686293305294848, 39),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686568183201792, 39),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686843061108736, 39),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611687117939015680, 39),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372036854775808, 6),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372586610589696, 6),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373136366403584, 6),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373686122217472, 6),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223374235878031360, 6),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_node_split_epoch_not_match_right_derive", "code": "fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n        .iter()\n        .map(|&k| pd_client.get_region(k).unwrap())\n        .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec![\n        // All regions should be returned as request uses an oldest epoch.\n        (get_old, regions.clone()),\n        // Only new split regions should be returned.\n        (get_middle, regions[1..].to_vec()),\n        // Epoch is too new that TiKV can't offer any useful hint.\n        (get_new, vec![regions[3].clone()]),\n    ];\n    if right_derive {\n        // TiKV search backward when right derive.\n        cases[0].1.reverse();\n        cases[1].1.reverse();\n    }\n    for (get, exp) in cases {\n        let resp = cluster\n            .call_command_on_leader(get.clone(), Duration::from_secs(5))\n            .unwrap();\n        assert!(resp.get_header().has_error(), \"{:?}\", get);\n        assert!(\n            resp.get_header().get_error().has_epoch_not_match(),\n            \"{:?}\",\n            get\n        );\n        assert_eq!(\n            resp.get_header()\n                .get_error()\n                .get_epoch_not_match()\n                .get_current_regions(),\n            &*exp,\n            \"{:?}\",\n            get\n        );\n    }\n}", "test": "fn test_node_split_epoch_not_match_right_derive() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_split_epoch_not_match(&mut cluster, true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_bytes_prime_part_size", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_bytes_prime_part_size() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"test_split_bytes_prime_part_size\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    // 1753 is prime and greater than the buffer size, 1024.\n    ucmd.args(&[\"-b\", \"1753\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 6);\n    let mut fns = glob.collect();\n    // glob.collect() is not guaranteed to return in sorted order, so we sort.\n    fns.sort();\n    #[allow(clippy::needless_range_loop)]\n    for i in 0..5 {\n        assert_eq!(glob.directory.metadata(&fns[i]).len(), 1753);\n    }\n    assert_eq!(glob.directory.metadata(&fns[5]).len(), 1235);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::block", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn block() {\n    test_formatting(\n        r#\"\n        {\n            let a = function_call();\n            console.log(\"hello\");\n        }\n        another_statement();\n        \"#,\n    );\n    // TODO: Once block labels are implemtned, this should be tested:\n    // super::super::test_formatting(\n    //     r#\"\n    //     block_name: {\n    //         let a = function_call();\n    //         console.log(\"hello\");\n    //     }\n    //     another_statement();\n    //     \"#,\n    // );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_gen_split_check_bucket_ranges", "code": "pub fn send_half_split_region_message(\n        &mut self,\n        _region: &metapb::Region,\n        _expected_bucket_ranges: Option<Vec<BucketRange>>,\n    ) {\n        unimplemented!()\n    }", "test": "fn test_gen_split_check_bucket_ranges() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.cfg.coprocessor.region_bucket_size = ReadableSize(5);\n    cluster.cfg.coprocessor.enable_region_bucket = Some(true);\n    // disable report buckets; as it will reset the user traffic stats to randomize\n    // the test result\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::secs(5);\n    // Make merge check resume quickly.\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(100);\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n\n    cluster.must_put(b\"k11\", b\"v1\");\n    let region = pd_client.get_region(b\"k11\").unwrap();\n\n    let bucket = Bucket {\n        keys: vec![b\"k11\".to_vec()],\n        size: 1024 * 1024 * 200,\n    };\n\n    let mut expected_buckets = metapb::Buckets::default();\n    expected_buckets.set_keys(bucket.clone().keys.into());\n    expected_buckets\n        .keys\n        .insert(0, region.get_start_key().to_vec());\n    expected_buckets.keys.push(region.get_end_key().to_vec());\n    let buckets = vec![bucket];\n\n    // initialize fsm.peer.bucket_regions\n    cluster.refresh_region_bucket_keys(\n        &region,\n        buckets.clone(),\n        Option::None,\n        Some(expected_buckets.clone()),\n    );\n    cluster.must_put(b\"k10\", b\"v1\");\n    cluster.must_put(b\"k12\", b\"v1\");\n\n    let expected_bucket_ranges = vec![\n        BucketRange(vec![], b\"k11\".to_vec()),\n        BucketRange(b\"k11\".to_vec(), vec![]),\n    ];\n    cluster.send_half_split_region_message(&region, Some(expected_bucket_ranges));\n\n    // set fsm.peer.last_bucket_regions\n    cluster.refresh_region_bucket_keys(\n        &region,\n        buckets,\n        Option::None,\n        Some(expected_buckets.clone()),\n    );\n    // because the diff between last_bucket_regions and bucket_regions is zero,\n    // bucket range for split check should be empty.\n    let expected_bucket_ranges = vec![];\n    cluster.send_half_split_region_message(&region, Some(expected_bucket_ranges));\n\n    // split the region\n    pd_client.must_split_region(region, pdpb::CheckPolicy::Usekey, vec![b\"k11\".to_vec()]);\n\n    let left = pd_client.get_region(b\"k10\").unwrap();\n    let right = pd_client.get_region(b\"k12\").unwrap();\n    if right.get_id() == 1 {\n        // the bucket_ranges should be None to refresh the bucket\n        cluster.send_half_split_region_message(&right, None);\n    } else {\n        // the bucket_ranges should be None to refresh the bucket\n        cluster.send_half_split_region_message(&left, None);\n    }\n\n    // merge the region\n    pd_client.must_merge(left.get_id(), right.get_id());\n    let region = pd_client.get_region(b\"k10\").unwrap();\n    // the bucket_ranges should be None to refresh the bucket\n    cluster.send_half_split_region_message(&region, None);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_reverse_then_forward_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iter_reverse_then_forward_engine() {\n    let db = default_engine();\n    iter_reverse_then_forward(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_close_notify", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn client_close_notify() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that alerts don't overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n        client.send_close_notify();\n\n        transfer(&mut client, &mut server);\n        let io_state = server.process_new_packets().unwrap();\n        assert!(io_state.peer_has_closed());\n        check_read_and_close(&mut server.reader(), b\"from-client!\");\n\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        check_read(&mut client.reader(), b\"from-server!\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_sequence4", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_sequence4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%0$%\", \"/^4/\"])\n        .succeeds()\n        .stdout_only(\"90\\n33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(10, 40));\n    assert_eq!(at.read(\"xx01\"), generate(40, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_infinite_lease", "code": "fn rl(&self) -> RwLockReadGuard<'_, T> {\n        self.read().unwrap()\n    }", "test": "fn test_infinite_lease() {\n    let mut cluster = new_node_cluster(0, 3);\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    // Use large election timeout to make leadership stable.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    // Override max leader lease to 2 seconds.\n    let max_lease = Duration::from_secs(2);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n\n    let peer = new_peer(1, 1);\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let key = b\"k\";\n    cluster.must_put(key, b\"v0\");\n    for id in 2..=cluster.engines.len() as u64 {\n        cluster.pd_client.must_add_peer(region_id, new_peer(id, id));\n        must_get_equal(&cluster.get_engine(id), key, b\"v0\");\n    }\n\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(&mut cluster, peer.clone(), region.clone(), key, b\"v0\");\n    assert_eq!(detector.ctx.rl().len(), 0);\n\n    // Wait for the leader lease to expire.\n    thread::sleep(max_lease);\n\n    // Check if renew-lease-tick proposed a read index and renewed the leader lease.\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n    assert_eq!(detector.ctx.rl().len(), 1);\n    // Issue a read request to verify the lease.\n    must_read_on_peer(&mut cluster, peer.clone(), region, key, b\"v0\");\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer));\n    assert_eq!(detector.ctx.rl().len(), 1);\n\n    // renew-lease-tick shouldn't propose any request if the leader lease is not\n    // expired.\n    for _ in 0..4 {\n        cluster.must_put(key, b\"v0\");\n        thread::sleep(max_lease / 4);\n    }\n    assert_eq!(detector.ctx.rl().len(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mknod.rs::test_mknod_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_mknod_help() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .succeeds()\n        .no_stderr()\n        .stdout_contains(\"Usage:\");\n}"}
{"test_id": "image-rs-image-png/image-rs-image-png-e113d76/tests/check_testimages.rs::render_images", "code": "pub fn samples(self) -> usize {\n        self.samples_u8().into()\n    }", "test": "fn render_images() {\n    process_images(\"results.txt\", &TEST_SUITES, |path| {\n        let mut decoder = png::Decoder::new(File::open(path)?);\n        decoder.set_transformations(png::Transformations::normalize_to_color8());\n        let mut reader = decoder.read_info()?;\n        let mut img_data = vec![0; reader.output_buffer_size()];\n        let info = reader.next_frame(&mut img_data)?;\n        // First sanity check:\n        assert_eq!(\n            img_data.len(),\n            info.width as usize\n                * info.height as usize\n                * info.color_type.samples()\n                * info.bit_depth as usize\n                / 8\n        );\n        let mut crc = Crc32::new();\n        crc.update(&img_data);\n        Ok(crc.finalize())\n    })\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::post_return_all_types", "code": "pub fn call(mut self) -> Self {\n        self.is_call = true;\n        self\n    }", "test": "fn post_return_all_types() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"i32\") (result i32)\n                    i32.const 1)\n                (func (export \"i64\") (result i64)\n                    i64.const 2)\n                (func (export \"f32\") (result f32)\n                    f32.const 3)\n                (func (export \"f64\") (result f64)\n                    f64.const 4)\n\n                (func (export \"post-i32\") (param i32)\n                    local.get 0\n                    i32.const 1\n                    i32.ne\n                    if unreachable end)\n                (func (export \"post-i64\") (param i64)\n                    local.get 0\n                    i64.const 2\n                    i64.ne\n                    if unreachable end)\n                (func (export \"post-f32\") (param f32)\n                    local.get 0\n                    f32.const 3\n                    f32.ne\n                    if unreachable end)\n                (func (export \"post-f64\") (param f64)\n                    local.get 0\n                    f64.const 4\n                    f64.ne\n                    if unreachable end)\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"i32\") (result u32)\n                (canon lift (core func $i \"i32\") (post-return (func $i \"post-i32\")))\n            )\n            (func (export \"i64\") (result u64)\n                (canon lift (core func $i \"i64\") (post-return (func $i \"post-i64\")))\n            )\n            (func (export \"f32\") (result float32)\n                (canon lift (core func $i \"f32\") (post-return (func $i \"post-f32\")))\n            )\n            (func (export \"f64\") (result float64)\n                (canon lift (core func $i \"f64\") (post-return (func $i \"post-f64\")))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let i32 = instance.get_typed_func::<(), (u32,)>(&mut store, \"i32\")?;\n    let i64 = instance.get_typed_func::<(), (u64,)>(&mut store, \"i64\")?;\n    let f32 = instance.get_typed_func::<(), (f32,)>(&mut store, \"f32\")?;\n    let f64 = instance.get_typed_func::<(), (f64,)>(&mut store, \"f64\")?;\n\n    assert_eq!(i32.call(&mut store, ())?, (1,));\n    i32.post_return(&mut store)?;\n\n    assert_eq!(i64.call(&mut store, ())?, (2,));\n    i64.post_return(&mut store)?;\n\n    assert_eq!(f32.call(&mut store, ())?, (3.,));\n    f32.post_return(&mut store)?;\n\n    assert_eq!(f64.call(&mut store, ())?, (4.,));\n    f64.post_return(&mut store)?;\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sum.rs::test_invalid_metadata", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_invalid_metadata() {\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"b\")\n        .fails()\n        .stderr_is(\"sum: b: No such file or directory\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_relative_recursive", "code": "pub fn resolve_link(&self, path: &str) -> String {\n        log_info(\"resolve_link\", self.plus_as_string(path));\n        match fs::read_link(self.plus(path)) {\n            Ok(p) => self.minus_as_string(p.to_str().unwrap()),\n            Err(_) => String::new(),\n        }\n    }", "test": "fn test_relative_recursive() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"dir\");\n    ucmd.args(&[\"-sr\", \"dir\", \"dir/recursive\"]).succeeds();\n    assert_eq!(at.resolve_link(\"dir/recursive\"), \".\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_never", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_never() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=never\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_dictionary_order", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_dictionary_order() {\n    test_helper(\"dictionary_order\", &[\"-d\"]);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::math_test", "code": "pub fn is_normalized(&self) -> bool {\n        bigint::is_normalized(self)\n    }", "test": "fn math_test() {\n    let mut x = VecType::try_from(&[0, 1, 9]).unwrap();\n    assert_eq!(x.is_normalized(), true);\n    x.try_push(0).unwrap();\n    assert_eq!(&*x, &[0, 1, 9, 0]);\n    assert_eq!(x.is_normalized(), false);\n    x.normalize();\n    assert_eq!(&*x, &[0, 1, 9]);\n    assert_eq!(x.is_normalized(), true);\n\n    x.add_small(1);\n    assert_eq!(&*x, &[1, 1, 9]);\n    x.add_small(LIMB_MAX);\n    assert_eq!(&*x, &[0, 2, 9]);\n\n    x.mul_small(3);\n    assert_eq!(&*x, &[0, 6, 27]);\n    x.mul_small(LIMB_MAX);\n    let expected: VecType = if bigint::LIMB_BITS == 32 {\n        vec_from_u32(&[0, 4294967290, 4294967274, 26])\n    } else {\n        vec_from_u32(&[0, 0, 4294967290, 4294967295, 4294967274, 4294967295, 26])\n    };\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(5);\n    x *= &y;\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);\n    assert_eq!(&*x, &*expected);\n\n    // Test with carry\n    let mut x = VecType::from_u64(1);\n    assert_eq!(&*x, &[1]);\n    x.add_small(LIMB_MAX);\n    assert_eq!(&*x, &[0, 1]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_scan_detail", "code": "pub fn has_time_detail(&self) -> bool {\n        self.time_detail.is_some()\n    }", "test": "fn test_scan_detail() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = {\n        let engine = TestEngineBuilder::new().build().unwrap();\n        let mut cfg = Config::default();\n        cfg.end_point_batch_row_limit = 50;\n        init_data_with_details(Context::default(), engine, &product, &data, true, &cfg)\n    };\n\n    let reqs = vec![\n        DagSelect::from(&product).build(),\n        DagSelect::from_index(&product, &product[\"name\"]).build(),\n    ];\n\n    for mut req in reqs {\n        req.mut_context().set_record_scan_stat(true);\n        req.mut_context().set_record_time_stat(true);\n\n        let resp = handle_request(&endpoint, req);\n        assert!(resp.get_exec_details().has_time_detail());\n        let scan_detail = resp.get_exec_details().get_scan_detail();\n        // Values would occur in data cf are inlined in write cf.\n        assert_eq!(scan_detail.get_write().get_total(), 5);\n        assert_eq!(scan_detail.get_write().get_processed(), 4);\n        assert_eq!(scan_detail.get_lock().get_total(), 1);\n\n        assert!(resp.get_exec_details_v2().has_time_detail());\n        assert!(resp.get_exec_details_v2().has_time_detail_v2());\n        let scan_detail_v2 = resp.get_exec_details_v2().get_scan_detail_v2();\n        assert_eq!(scan_detail_v2.get_total_versions(), 5);\n        assert_eq!(scan_detail_v2.get_processed_versions(), 4);\n        assert!(scan_detail_v2.get_processed_versions_size() > 0);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/resolved_ts/tests/failpoints/mod.rs::test_check_leader_timeout", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_check_leader_timeout() {\n    let mut suite = TestSuite::new(3);\n    let region = suite.cluster.get_region(&[]);\n\n    // Prewrite\n    let (k, v) = (b\"k1\", b\"v\");\n    let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.key = k.to_vec();\n    mutation.value = v.to_vec();\n    suite.must_kv_prewrite(region.id, vec![mutation], k.to_vec(), start_ts, false);\n    suite\n        .cluster\n        .must_transfer_leader(region.id, new_peer(1, 1));\n\n    // The `resolved-ts` won't be updated due to there is lock on the region,\n    // the `resolved-ts` may not be the `start_ts` of the lock if the `resolved-ts`\n    // is updated with a newer ts before the prewrite request come, but still the\n    // `resolved-ts` won't be updated\n    let rts = suite.region_resolved_ts(region.id).unwrap();\n\n    let store2_fp = \"before_check_leader_store_2\";\n    fail::cfg(store2_fp, \"pause\").unwrap();\n    let store3_fp = \"before_check_leader_store_3\";\n    fail::cfg(store3_fp, \"pause\").unwrap();\n\n    // Commit\n    let commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.must_kv_commit(region.id, vec![k.to_vec()], start_ts, commit_ts);\n    sleep_ms(6000);\n    // Check rts was not advanced after 5s\n    suite.must_get_rts(region.id, rts);\n    fail::remove(store2_fp);\n    // And can be advanced after store2 recovered.\n    suite.must_get_rts_ge(region.id, commit_ts);\n\n    fail::remove(store3_fp);\n    suite.stop();\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::storage_image_formats", "code": "fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n}", "test": "fn storage_image_formats() {\n    require_and_forbid(\n        &[Ca::Shader],\n        &[Ca::StorageImageExtendedFormats],\n        r#\"\n            @group(0) @binding(0)\n            var image_rg32f: texture_storage_2d<rgba16uint, read>;\n        \"#,\n    );\n\n    require(\n        &[Ca::StorageImageExtendedFormats],\n        r#\"\n            @group(0) @binding(0)\n            var image_rg32f: texture_storage_2d<rg32float, read>;\n        \"#,\n    );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u32toa_test", "code": "pub const fn decimal() -> u128 {\n        let mut builder = Self::new();\n        builder.mantissa_radix = 10;\n        builder.exponent_base = num::NonZeroU8::new(10);\n        builder.exponent_radix = num::NonZeroU8::new(10);\n        builder.build()\n    }", "test": "fn u32toa_test() {\n    let mut buffer = [b'\\x00'; 16];\n    unsafe {\n        assert_eq!(5u32.decimal(&mut buffer), 1);\n        assert_eq!(&buffer[..1], b\"5\");\n\n        assert_eq!(11u32.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"11\");\n\n        assert_eq!(99u32.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"99\");\n\n        assert_eq!(101u32.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"101\");\n\n        assert_eq!(999u32.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"999\");\n\n        assert_eq!(1001u32.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"1001\");\n\n        assert_eq!(9999u32.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"9999\");\n\n        assert_eq!(10001u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"10001\");\n\n        assert_eq!(65535u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"65535\");\n\n        assert_eq!(99999u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"99999\");\n\n        assert_eq!(100001u32.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"100001\");\n\n        assert_eq!(999999u32.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"999999\");\n\n        assert_eq!(1000001u32.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"1000001\");\n\n        assert_eq!(9999999u32.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"9999999\");\n\n        assert_eq!(10000001u32.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"10000001\");\n\n        assert_eq!(99999999u32.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"99999999\");\n\n        assert_eq!(100000001u32.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"100000001\");\n\n        assert_eq!(999999999u32.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"999999999\");\n\n        assert_eq!(1000000001u32.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"1000000001\");\n\n        assert_eq!(4294967295u32.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"4294967295\");\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::cover_offset", "code": "pub fn cover_offset(self, offset: TextSize) -> TextRange {\n        self.cover(TextRange::empty(offset))\n    }", "test": "fn cover_offset() {\n    assert_eq!(range(1..3).cover_offset(size(0)), range(0..3));\n    assert_eq!(range(1..3).cover_offset(size(1)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(2)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(3)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(4)), range(1..4));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_cleanup_rollback", "code": "pub fn cleanup_ok(\n        &self,\n        key: &[u8],\n        start_ts: impl Into<TimeStamp>,\n        current_ts: impl Into<TimeStamp>,\n    ) {\n        self.store\n            .cleanup(\n                self.ctx.clone(),\n                Key::from_raw(key),\n                start_ts.into(),\n                current_ts.into(),\n            )\n            .unwrap();\n    }", "test": "fn test_txn_store_cleanup_rollback() {\n    let store = AssertionStorage::default();\n    store.put_ok(b\"secondary\", b\"s-0\", 1, 2);\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"p-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n        ],\n        b\"primary\",\n        5,\n    );\n    store.get_err(b\"secondary\", 10);\n    store.rollback_ok(vec![b\"primary\"], 5);\n    store.cleanup_ok(b\"primary\", 5, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date4", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"1970-01-01 18:43:33\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(67413, 0);\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pd_client_legacy.rs::test_watch_global_config_on_closed_server", "code": "fn get_name(&self) -> &'static str {\n        self.name\n    }", "test": "fn test_watch_global_config_on_closed_server() {\n    let (mut server, client) = new_test_server_and_client(ReadableDuration::millis(100));\n    let global_items = vec![(\"test1\", \"val1\"), (\"test2\", \"val2\"), (\"test3\", \"val3\")];\n    let items_clone = global_items.clone();\n\n    let client = Arc::new(client);\n    let cli_clone = client.clone();\n    use futures::StreamExt;\n    let background_worker = Builder::new(\"background\").thread_count(1).create();\n    background_worker.spawn_async_task(async move {\n        match cli_clone.watch_global_config(\"global\".into(), 0) {\n            Ok(mut stream) => {\n                let mut i: usize = 0;\n                while let Some(grpc_response) = stream.next().await {\n                    match grpc_response {\n                        Ok(r) => {\n                            for item in r.get_changes() {\n                                assert_eq!(item.get_name(), items_clone[i].0);\n                                assert_eq!(\n                                    from_utf8(item.get_payload()).unwrap(),\n                                    items_clone[i].1\n                                );\n                                i += 1;\n                            }\n                        }\n                        Err(err) => panic!(\"failed to get stream, err: {:?}\", err),\n                    }\n                }\n            }\n            Err(err) => {\n                if !err.to_string().contains(\"UNAVAILABLE\") {\n                    // Not 14-UNAVAILABLE\n                    panic!(\"other error occur {:?}\", err)\n                }\n            }\n        }\n    });\n\n    if let Err(err) = futures::executor::block_on(\n        client.store_global_config(\n            \"global\".into(),\n            global_items\n                .iter()\n                .map(|(name, value)| {\n                    let mut item = GlobalConfigItem::default();\n                    item.set_name(name.to_string());\n                    item.set_payload(value.as_bytes().into());\n                    item\n                })\n                .collect::<Vec<GlobalConfigItem>>(),\n        ),\n    ) {\n        panic!(\"error occur {:?}\", err);\n    }\n\n    thread::sleep(Duration::from_millis(100));\n    server.stop();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_create", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_create() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client.create(record, origin).expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_long_format", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_long_format() {\n    let login = \"root\";\n    let pw: Passwd = Passwd::locate(login).unwrap();\n    let user_info = pw.user_info.unwrap_or_default();\n    let user_dir = pw.user_dir.unwrap_or_default();\n    let user_shell = pw.user_shell.unwrap_or_default();\n    let real_name = user_info.replace('&', &pw.name.capitalize());\n    let ts = TestScenario::new(util_name!());\n    ts.ucmd().arg(\"-l\").arg(login).succeeds().stdout_is(format!(\n        \"Login name: {login:<28}In real life:  {real_name}\\nDirectory: {user_dir:<29}Shell:  {user_shell}\\n\\n\"\n    ));\n\n    ts.ucmd()\n        .arg(\"-lb\")\n        .arg(login)\n        .succeeds()\n        .stdout_is(format!(\n            \"Login name: {login:<28}In real life:  {real_name}\\n\\n\"\n        ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_none_no_commit", "code": "fn drop(&mut self) {\n        self.scheduler.stop();\n    }", "test": "fn write_batch_none_no_commit() {\n    let db = default_engine();\n    let wb = db.engine.write_batch();\n    drop(wb);\n\n    let db = multi_batch_write_engine();\n    let wb = db.engine.write_batch_with_cap(1024);\n    drop(wb);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_invalid_option", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_invalid_option() {\n    new_ucmd!().arg(\"-w\").arg(\"-q\").arg(\"/\").fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_initial_tab_counts_as_8_columns", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_initial_tab_counts_as_8_columns() {\n    new_ucmd!()\n        .arg(\"-w8\")\n        .pipe_in(\"\\t1\")\n        .succeeds()\n        .stdout_is(\"\\t\\n1\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_snap_recovery.rs::test_snap_wait_apply", "code": "pub fn recv(&mut self, peer_msg_buf: &mut Vec<PeerMsg>, batch_size: usize) -> usize {\n        let l = peer_msg_buf.len();\n        for i in l..batch_size {\n            match self.receiver.try_recv() {\n                Ok(msg) => peer_msg_buf.push(msg),\n                Err(e) => {\n                    if let TryRecvError::Disconnected = e {\n                        self.is_stopped = true;\n                    }\n                    return i - l;\n                }\n            }\n        }\n        batch_size - l\n    }", "test": "fn test_snap_wait_apply() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.store_io_pool_size = 0;\n\n    cluster.run();\n\n    // write a key to let leader stuck.\n    cluster.must_put(b\"k\", b\"v\");\n    must_get_equal(&cluster.get_engine(1), b\"k\", b\"v\");\n    must_get_equal(&cluster.get_engine(2), b\"k\", b\"v\");\n    must_get_equal(&cluster.get_engine(3), b\"k\", b\"v\");\n\n    // add filter to make leader 1 cannot receive follower append response.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgAppendResponse)\n            .direction(Direction::Recv),\n    ));\n\n    // make a async put request to let leader has inflight raft log.\n    cluster.async_put(b\"k2\", b\"v2\").unwrap();\n    std::thread::sleep(Duration::from_millis(800));\n\n    let router = cluster.sim.wl().get_router(1).unwrap();\n\n    let (tx, rx) = std::sync::mpsc::sync_channel(1);\n\n    router.broadcast_normal(|| {\n        PeerMsg::SignificantMsg(SignificantMsg::SnapshotRecoveryWaitApply(\n            SnapshotRecoveryWaitApplySyncer::new(1, tx.clone()),\n        ))\n    });\n\n    // we expect recv timeout because the leader peer on store 1 cannot finished the\n    // apply. so the wait apply will timeout.\n    rx.recv_timeout(Duration::from_secs(1)).unwrap_err();\n\n    // clear filter so we can make wait apply finished.\n    cluster.clear_send_filters();\n    std::thread::sleep(Duration::from_millis(800));\n\n    // after clear the filter the leader peer on store 1 can finsihed the wait\n    // apply.\n    let (tx, rx) = std::sync::mpsc::sync_channel(1);\n    router.broadcast_normal(|| {\n        PeerMsg::SignificantMsg(SignificantMsg::SnapshotRecoveryWaitApply(\n            SnapshotRecoveryWaitApplySyncer::new(1, tx.clone()),\n        ))\n    });\n\n    // we expect recv the region id from rx.\n    assert_eq!(rx.recv(), Ok(1));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_32", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_32() {\n    let original = r##\"H1 {#`code`}\n==\n\nH2-1 {#foo__bar__baz}\n----\n\nH2-2 {#foo**bar**baz}\n--\n\"##;\n    let expected = r##\"<h1 id=\"`code`\">H1</h1>\n<h2 id=\"foo__bar__baz\">H2-1</h2>\n<h2 id=\"foo**bar**baz\">H2-2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encode_all_bytes_url", "code": "fn encode<T: AsRef<[u8]>>(&self, input: T) -> String {\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> String\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect(\"integer overflow when calculating buffer size\");\n\n            let mut buf = vec![0; encoded_size];\n\n            encode_with_padding(input_bytes, &mut buf[..], engine, encoded_size);\n\n            String::from_utf8(buf).expect(\"Invalid UTF8\")\n        }\n\n        inner(self, input.as_ref())\n    }", "test": "fn encode_all_bytes_url() {\n    let bytes: Vec<u8> = (0..=255).collect();\n\n    assert_eq!(\n        \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0\\\n         -P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn\\\n         -AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq\\\n         -wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy\\\n         8_T19vf4-fr7_P3-_w==\",\n        &engine::GeneralPurpose::new(&URL_SAFE, PAD).encode(bytes)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_time", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_time() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-t\", \"--time\", \"--t\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible_no_size_arg", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_compatible_no_size_arg() {\n    new_ucmd!().arg(\"-a\").succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_flow_control.rs::test_cdc_congest", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_cdc_congest() {\n    let mut cluster = new_server_cluster(1, 1);\n    // Increase the Raft tick interval to make this test case running reliably.\n    configure_for_lease_read(&mut cluster.cfg, Some(100), None);\n    let memory_quota = 1024; // 1KB\n    let mut suite = TestSuiteBuilder::new()\n        .cluster(cluster)\n        .memory_quota(memory_quota)\n        .build();\n\n    let req = suite.new_changedata_request(1);\n    let (mut req_tx, _event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(1));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let event = receive_event(false);\n    event.events.into_iter().for_each(|e| {\n        match e.event.unwrap() {\n            // Even if there is no write,\n            // it should always outputs an Initialized event.\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        }\n    });\n\n    // Client must receive messages when there is no congest error.\n    let value_size = memory_quota / 2;\n    let (k, v) = (\"key1\".to_owned(), vec![5; value_size]);\n    // Prewrite\n    let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.key = k.clone().into_bytes();\n    mutation.value = v;\n    suite.must_kv_prewrite(1, vec![mutation], k.into_bytes(), start_ts);\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1, \"{:?}\", events);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Entries(entries) => {\n            assert_eq!(entries.entries.len(), 1);\n            assert_eq!(entries.entries[0].get_type(), EventLogType::Prewrite);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    // Trigger congest error.\n    let value_size = memory_quota * 2;\n    let (k, v) = (\"key2\".to_owned(), vec![5; value_size]);\n    // Prewrite\n    let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.key = k.clone().into_bytes();\n    mutation.value = v;\n    suite.must_kv_prewrite(1, vec![mutation], k.into_bytes(), start_ts);\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1, \"{:?}\", events);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Error(e) => {\n            // Unknown errors are translated into region_not_found.\n            assert!(e.has_region_not_found(), \"{:?}\", e);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    // The delegate must be removed.\n    let scheduler = suite.endpoints.values().next().unwrap().scheduler();\n    let (tx, rx) = mpsc::channel();\n    scheduler\n        .schedule(Task::Validate(Validate::Region(\n            1,\n            Box::new(move |delegate| {\n                tx.send(delegate.is_none()).unwrap();\n            }),\n        )))\n        .unwrap();\n\n    assert!(\n        rx.recv_timeout(Duration::from_millis(1000)).unwrap(),\n        \"find unexpected delegate\"\n    );\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_should_report_invalid_empty_number_on_empty_stdin", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_should_report_invalid_empty_number_on_empty_stdin() {\n    new_ucmd!()\n        .args(&[\"--from=auto\"])\n        .pipe_in(\"\\n\")\n        .run()\n        .stderr_is(\"numfmt: invalid number: ''\\n\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::persistent_savepoint", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn persistent_savepoint() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &str> = TableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.insert(&0, \"hello\").unwrap();\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let savepoint_id = txn.persistent_savepoint().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.remove(&0).unwrap();\n    }\n    txn.commit().unwrap();\n\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    // Make sure running the GC doesn't invalidate the savepoint\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n\n    let mut txn = db.begin_write().unwrap();\n    let savepoint = txn.get_persistent_savepoint(savepoint_id).unwrap();\n\n    txn.restore_savepoint(&savepoint).unwrap();\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(definition).unwrap();\n    assert_eq!(table.get(&0).unwrap().unwrap().value(), \"hello\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_not_retry_sync", "code": "fn test_not_retry<F: Fn(&RpcClient)>(func: F) {\n    let eps_count = 1;\n    // NotRetry mocker returns Ok() with error header first, and next returns Ok()\n    // without any error header.\n    let not_retry = Arc::new(NotRetry::new());\n    let server = MockServer::with_case(eps_count, not_retry);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps, None);\n\n    func(&client);\n}", "test": "fn test_not_retry_sync() {\n    let sync = |client: &RpcClient| {\n        client.get_store(1).unwrap_err();\n    };\n    test_not_retry(sync);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::lateral_derived", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "test": "fn lateral_derived() {\n    fn chk(lateral_in: bool) {\n        let lateral_str = if lateral_in { \"LATERAL \" } else { \"\" };\n        let sql = format!(\n            \"SELECT * FROM customer LEFT JOIN {lateral_str}\\\n             (SELECT * FROM order WHERE order.customer = customer.id LIMIT 3) AS order ON true\"\n        );\n        let select = verified_only_select(&sql);\n        let from = only(select.from);\n        assert_eq!(from.joins.len(), 1);\n        let join = &from.joins[0];\n        assert_eq!(\n            join.join_operator,\n            JoinOperator::LeftOuter(JoinConstraint::On(Expr::Value(Value::Boolean(true))))\n        );\n        if let TableFactor::Derived {\n            lateral,\n            ref subquery,\n            alias: Some(ref alias),\n        } = join.relation\n        {\n            assert_eq!(lateral_in, lateral);\n            assert_eq!(Ident::new(\"order\"), alias.name);\n            assert_eq!(\n                subquery.to_string(),\n                \"SELECT * FROM order WHERE order.customer = customer.id LIMIT 3\"\n            );\n        } else {\n            unreachable!()\n        }\n    }\n    chk(false);\n    chk(true);\n\n    let sql = \"SELECT * FROM LATERAL UNNEST ([10,20,30]) as numbers WITH OFFSET;\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: WITH\".to_string()),\n        res.unwrap_err()\n    );\n\n    let sql = \"SELECT * FROM a LEFT JOIN LATERAL (b CROSS JOIN c)\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\n            \"Expected SELECT, VALUES, or a subquery in the query body, found: b\".to_string()\n        ),\n        res.unwrap_err()\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_single_table_in_parenthesis", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn test_single_table_in_parenthesis() {\n    // Parenthesized table names are non-standard, but supported in Snowflake SQL\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN (b))\",\n        \"SELECT * FROM (a NATURAL JOIN b)\",\n    );\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN ((b)))\",\n        \"SELECT * FROM (a NATURAL JOIN b)\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_missing_value", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_interactive_missing_value() {\n    // `--interactive` is equivalent to `--interactive=always` or `-i`\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_missing_value_file1\";\n    let file2 = \"test_rm_interactive_missing_value_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--interactive\")\n        .arg(file1)\n        .arg(file2)\n        .pipe_in(\"y\\ny\")\n        .succeeds();\n\n    assert!(!at.file_exists(file1));\n    assert!(!at.file_exists(file2));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::trap_smoke", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn trap_smoke() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let f = Func::wrap(&mut store, || -> Result<()> { bail!(\"test\") });\n    let err = f.call(&mut store, &[], &mut []).unwrap_err();\n    assert!(err.to_string().contains(\"test\"));\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_line_length_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_line_length_lines() {\n    new_ucmd!()\n        .arg(\"-Ll\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25      48\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_random_shuffle_two_runs_not_the_same", "code": "pub fn stdout_move_str(self) -> String {\n        String::from_utf8(self.stdout).unwrap()\n    }", "test": "fn test_random_shuffle_two_runs_not_the_same() {\n    for arg in [\"-R\", \"-k1,1R\"] {\n        // check to verify that two random shuffles are not equal; this has the\n        // potential to fail in the very unlikely event that the random order is the same\n        // as the starting order, or if both random sorts end up having the same order.\n        const FILE: &str = \"default_unsorted_ints.expected\";\n        let (at, _ucmd) = at_and_ucmd!();\n        let result = new_ucmd!().arg(arg).arg(FILE).run().stdout_move_str();\n        let expected = at.read(FILE);\n        let unexpected = new_ucmd!().arg(arg).arg(FILE).run().stdout_move_str();\n\n        assert_ne!(result, expected);\n        assert_ne!(result, unexpected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_group", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_no_change_to_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\":43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\"ownership of '{file}' retained as {group_name}\\n\"));\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression13", "code": "fn new () -> Self { Self { savepoints : vec ! [] , uncommitted_persistent : Default :: default () , persistent_countdown : MAX_PERSISTENT_SAVEPOINTS , } }", "test": "fn regression13() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: MultimapTableDefinition<u64, &[u8]> = MultimapTableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_multimap_table(table_def).unwrap();\n        let value = vec![0; 1026];\n        t.insert(&539717, value.as_slice()).unwrap();\n        let value = vec![0; 530];\n        t.insert(&539717, value.as_slice()).unwrap();\n    }\n    tx.abort().unwrap();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_break_label", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_in_break_label() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var str = \"\";\n\n            outer: for (let i in [1, 2]) {\n                inner: for (let b in [2, 3, 4]) {\n                    if (b === \"1\") {\n                        break outer;\n                    }\n                    str = str + b;\n                }\n                str = str + i;\n            }\n            str\n        \"#},\n        \"0\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_change_directory", "code": "pub fn stdout_move_str(self) -> String {\n        String::from_utf8(self.stdout).unwrap()\n    }", "test": "fn test_change_directory() {\n    let scene = TestScenario::new(util_name!());\n    let temporary_directory = tempdir().unwrap();\n\n    let temporary_path = temporary_directory.path();\n    let temporary_path = temporary_path\n        .strip_prefix(r\"\\\\?\\\")\n        .unwrap_or(temporary_path);\n\n    let env_cd = env::current_dir().unwrap();\n    let env_cd = env_cd.strip_prefix(r\"\\\\?\\\").unwrap_or(&env_cd);\n\n    assert_ne!(env_cd, temporary_path);\n\n    // COMSPEC is a variable that contains the full path to cmd.exe\n    let cmd_path = env::var(\"COMSPEC\").unwrap();\n\n    // command to print out current working directory\n    let pwd = [&*cmd_path, \"/C\", \"cd\"];\n\n    let out = scene\n        .ucmd()\n        .arg(\"--chdir\")\n        .arg(temporary_path)\n        .args(&pwd)\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(out.trim(), temporary_path.as_os_str());\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_nxdomain_where_no_name_exists", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "test": "fn test_nxdomain_where_no_name_exists() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        let msg = io_loop\n            .block_on(client.query(\n                Name::from_str(\"nxdomain.example.com.\").unwrap(),\n                DNSClass::IN,\n                RecordType::SRV,\n            ))\n            .unwrap();\n        assert_eq!(msg.response_code(), ResponseCode::NXDomain);\n        assert!(msg.answers().is_empty());\n    })\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::small_mul_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn small_mul_test() {\n    // No overflow check, 1-int.\n    let mut x = VecType::from_u32(5);\n    bigint::small_mul(&mut x, 7);\n    let expected = VecType::from_u32(35);\n    assert_eq!(&*x, &*expected);\n\n    // No overflow check, 2-ints.\n    let mut x = VecType::from_u64(0x4000000040000);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x00140000, 0x140000]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 1 carry.\n    let mut x = VecType::from_u32(0x33333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 1 carry, internal.\n    let mut x = VecType::from_u64(0x133333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 6]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 2 carries.\n    let mut x = VecType::from_u64(0x3333333333333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 0, 1]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::integer_test", "code": "fn check_integer<T: num::Integer>(mut x: T) {\n    // Copy, partialeq, partialord, ord, eq\n    let _ = x;\n    assert!(x > T::ONE);\n    assert!(x != T::ONE);\n    assert_eq!(x.min(T::ONE), T::ONE);\n    assert_eq!(x.max(T::ONE), x);\n\n    // Operations\n    let _ = x + T::ONE;\n    let _ = x - T::ONE;\n    let _ = x * T::ONE;\n    let _ = x / T::ONE;\n    let _ = x % T::ONE;\n    x += T::ONE;\n    x -= T::ONE;\n    x *= T::ONE;\n    x /= T::ONE;\n    x %= T::ONE;\n\n    // Bitwise operations\n    let _ = x & T::ONE;\n    let _ = x | T::ONE;\n    let _ = x ^ T::ONE;\n    x &= T::ONE;\n    x |= T::ONE;\n    x ^= T::ONE;\n\n    // Bitshifts\n    let _ = x << 1i32;\n    let _ = x >> 1i32;\n    x <<= 1i32;\n    x >>= 1i32;\n\n    // Conversions already tested.\n}", "test": "fn integer_test() {\n    check_integer(65u8);\n    check_integer(65u16);\n    check_integer(65u32);\n    check_integer(65u64);\n    check_integer(65u128);\n    check_integer(65usize);\n    check_integer(65i8);\n    check_integer(65i16);\n    check_integer(65i32);\n    check_integer(65i64);\n    check_integer(65i128);\n    check_integer(65isize);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_leader_down", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_witness_leader_down() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n\n    let peer_on_store2 = find_peer(&region, nodes[1]).unwrap().clone();\n    // nonwitness -> witness\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store2.get_id()],\n        vec![true],\n    );\n\n    // the other follower is isolated\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    for i in 1..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), format!(\"v{}\", i).as_bytes());\n    }\n    // the leader is down\n    cluster.stop_node(1);\n\n    // witness would help to replicate the logs\n    cluster.clear_send_filters();\n\n    // forbid writes\n    let put = new_put_cmd(b\"k3\", b\"v3\");\n    must_get_error_is_witness(&mut cluster, &region, put);\n    // forbid reads\n    let get = new_get_cmd(b\"k1\");\n    must_get_error_is_witness(&mut cluster, &region, get);\n    // forbid read index\n    let read_index = new_read_index_cmd();\n    must_get_error_is_witness(&mut cluster, &region, read_index);\n\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store3);\n    cluster.must_put(b\"k1\", b\"v1\");\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap().store_id,\n        nodes[2],\n    );\n    assert_eq!(cluster.must_get(b\"k9\"), Some(b\"v9\".to_vec()));\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::while_simple", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn while_simple() {\n    let needle = \"{while(_) {$i=10; bar=10;}}\";\n    let source = \"void foo() {while(foo<10) {foo=10; x=1; bar=10;}}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stdbuf.rs::test_stdbuf_line_buffering_stdin_fails", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_stdbuf_line_buffering_stdin_fails() {\n    new_ucmd!()\n        .args(&[\"-i\", \"L\", \"head\"])\n        .fails()\n        .usage_error(\"line buffering stdin is meaningless\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_store_allowlist", "code": "fn check_msg_count(max_delay_ms: u64, count: &AtomicUsize, expected: usize) {\n    let mut got = 0;\n    for _delay_ms in 0..max_delay_ms / 10 {\n        got = count.load(Ordering::SeqCst);\n        if got >= expected {\n            return;\n        }\n        thread::sleep(time::Duration::from_millis(10));\n    }\n    panic!(\"check_msg_count wants {}, gets {}\", expected, got);\n}", "test": "fn test_store_allowlist() {\n    let pd_server = test_pd::Server::new(1);\n    let eps = pd_server.bind_addrs();\n    let pd_client = Arc::new(test_pd::util::new_client(eps, None));\n    let bg_worker = WorkerBuilder::new(thd_name!(\"background\"))\n        .thread_count(2)\n        .create();\n    let resolver = resolve::new_resolver(pd_client, &bg_worker, FakeExtension).0;\n    let mut raft_client = get_raft_client(FakeExtension, resolver);\n\n    let msg_count1 = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count1 = Arc::new(AtomicUsize::new(0));\n    let service1 = MockKvForRaft::new(Arc::clone(&msg_count1), Arc::clone(&batch_msg_count1), true);\n    let (_mock_server1, port1) = create_mock_server(service1, 60200, 60300).unwrap();\n\n    let msg_count2 = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count2 = Arc::new(AtomicUsize::new(0));\n    let service2 = MockKvForRaft::new(Arc::clone(&msg_count2), Arc::clone(&batch_msg_count2), true);\n    let (_mock_server2, port2) = create_mock_server(service2, 60300, 60400).unwrap();\n\n    let mut store1 = metapb::Store::default();\n    store1.set_id(1);\n    store1.set_address(format!(\"127.0.0.1:{}\", port1));\n    pd_server.default_handler().add_store(store1.clone());\n\n    let mut store2 = metapb::Store::default();\n    store2.set_id(2);\n    store2.set_address(format!(\"127.0.0.1:{}\", port2));\n    pd_server.default_handler().add_store(store2.clone());\n\n    for _ in 0..10 {\n        let mut raft_m = RaftMessage::default();\n        raft_m.mut_to_peer().set_store_id(1);\n        raft_client.send(raft_m).unwrap();\n    }\n    raft_client.flush();\n    check_msg_count(500, &msg_count1, 10);\n\n    raft_client.set_store_allowlist(vec![2, 3]);\n    for _ in 0..3 {\n        let mut raft_m = RaftMessage::default();\n        raft_m.mut_to_peer().set_store_id(1);\n        raft_client.send(raft_m).unwrap_err();\n    }\n    for _ in 0..5 {\n        let mut raft_m = RaftMessage::default();\n        raft_m.mut_to_peer().set_store_id(2);\n        raft_client.send(raft_m).unwrap();\n    }\n    raft_client.flush();\n    check_msg_count(500, &msg_count1, 10);\n    check_msg_count(500, &msg_count2, 5);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::custom_limiter_detect_grow_failure", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn custom_limiter_detect_grow_failure() -> Result<()> {\n    if std::env::var(\"WASMTIME_TEST_NO_HOG_MEMORY\").is_ok() {\n        return Ok(());\n    }\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(10).table_elements(10);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    let engine = Engine::new(&config).unwrap();\n    let linker = Linker::new(&engine);\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let context = FailureDetector::default();\n\n    let mut store = Store::new(&engine, context);\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n    let instance = linker.instantiate(&mut store, &module)?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    // Grow the memory by 640 KiB (10 pages)\n    memory.grow(&mut store, 10)?;\n\n    assert!(store.data().memory_error.is_none());\n    assert_eq!(store.data().memory_current, 0);\n    assert_eq!(store.data().memory_desired, 10 * 64 * 1024);\n\n    // Grow past the static limit set by ModuleLimits.\n    // The ResourceLimiter will permit this, but the grow will fail.\n    assert_eq!(\n        memory.grow(&mut store, 1).unwrap_err().to_string(),\n        \"failed to grow memory by `1`\"\n    );\n\n    assert_eq!(store.data().memory_current, 10 * 64 * 1024);\n    assert_eq!(store.data().memory_desired, 11 * 64 * 1024);\n    assert_eq!(\n        store.data().memory_error.as_ref().unwrap(),\n        \"Memory maximum size exceeded\"\n    );\n\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n    // Grow the table 10 elements\n    table.grow(&mut store, 10, Val::FuncRef(None))?;\n\n    assert!(store.data().table_error.is_none());\n    assert_eq!(store.data().table_current, 0);\n    assert_eq!(store.data().table_desired, 10);\n\n    // Grow past the static limit set by ModuleLimits.\n    // The ResourceLimiter will permit this, but the grow will fail.\n    assert_eq!(\n        table\n            .grow(&mut store, 1, Val::FuncRef(None))\n            .unwrap_err()\n            .to_string(),\n        \"failed to grow table by `1`\"\n    );\n\n    assert_eq!(store.data().table_current, 10);\n    assert_eq!(store.data().table_desired, 11);\n    assert_eq!(\n        store.data().table_error.as_ref().unwrap(),\n        \"Table maximum size exceeded\"\n    );\n\n    drop(store);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_verbose", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_verbose() {\n    new_ucmd!()\n        .args(&[\"-b\", \"5\", \"--verbose\", \"asciilowercase.txt\"])\n        .succeeds()\n        .stdout_only(\n            \"creating file 'xaa'\ncreating file 'xab'\ncreating file 'xac'\ncreating file 'xad'\ncreating file 'xae'\ncreating file 'xaf'\n\",\n        );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_cdc_rawkv_resolved_ts", "code": "pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    }", "test": "fn test_cdc_rawkv_resolved_ts() {\n    let mut suite = TestSuite::new(1, ApiVersion::V2);\n    let cluster = &suite.cluster;\n\n    let region = cluster.get_region(b\"\");\n    let region_id = region.get_id();\n    let leader = region.get_peers()[0].clone();\n    let node_id = leader.get_id();\n    let ts_provider = cluster.sim.rl().get_causal_ts_provider(node_id).unwrap();\n\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut req = suite.new_changedata_request(region_id);\n    req.set_kv_api(ChangeDataRequestKvApi::RawKv);\n    let (mut req_tx, _event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region_id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n\n    let event = receive_event(false);\n    event\n        .events\n        .into_iter()\n        .for_each(|e| match e.event.unwrap() {\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        });\n    // Sleep a while to make sure the stream is registered.\n    sleep_ms(1000);\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n    ctx.set_api_version(ApiVersion::V2);\n    let mut put_req = RawPutRequest::default();\n    put_req.set_context(ctx);\n    put_req.key = b\"rk3\".to_vec();\n    put_req.value = b\"v3\".to_vec();\n\n    let pause_write_fp = \"raftkv_async_write\";\n    fail::cfg(pause_write_fp, \"pause\").unwrap();\n    let ts = block_on(ts_provider.async_get_ts()).unwrap();\n    let handle = thread::spawn(move || {\n        let _ = client.raw_put(&put_req).unwrap();\n    });\n\n    sleep_ms(100);\n\n    let event = receive_event(true).resolved_ts.unwrap();\n    assert!(\n        ts.next() >= TimeStamp::from(event.ts),\n        \"{} {}\",\n        ts,\n        TimeStamp::from(event.ts)\n    );\n    // Receive again to make sure resolved ts <= ongoing request's ts.\n    let event = receive_event(true).resolved_ts.unwrap();\n    assert!(\n        ts.next() >= TimeStamp::from(event.ts),\n        \"{} {}\",\n        ts,\n        TimeStamp::from(event.ts)\n    );\n\n    fail::remove(pause_write_fp);\n    handle.join().unwrap();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::savepoint", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn savepoint() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &str> = TableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.insert(&0, \"hello\").unwrap();\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let savepoint = txn.ephemeral_savepoint().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.remove(&0).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let mut txn = db.begin_write().unwrap();\n    let savepoint2 = txn.ephemeral_savepoint().unwrap();\n\n    txn.restore_savepoint(&savepoint).unwrap();\n\n    assert!(matches!(\n        txn.restore_savepoint(&savepoint2).err().unwrap(),\n        SavepointError::InvalidSavepoint\n    ));\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(definition).unwrap();\n    assert_eq!(table.get(&0).unwrap().unwrap().value(), \"hello\");\n\n    // Test that savepoints can be used multiple times\n    let mut txn = db.begin_write().unwrap();\n    txn.restore_savepoint(&savepoint).unwrap();\n    txn.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::version", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn version() {\n    new_ucmd!().arg(\"--version\").succeeds();\n    new_ucmd!().arg(\"-V\").succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/cf_names.rs::default_names", "code": "fn cf_names(&self, _region_id: u64) -> Vec<String> {\n        engine_traits::DATA_CFS\n            .iter()\n            .map(|s| s.to_string())\n            .collect()\n    }", "test": "fn default_names() {\n    let db = default_engine();\n    let names = db.engine.cf_names();\n    assert_eq!(names.len(), 1);\n    assert_eq!(names[0], CF_DEFAULT);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tr.rs::test_unicode", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_unicode() {\n    new_ucmd!()\n        .args(&[\", \u252c\u2500\u252c\", \"\u256f\ufe35\u253b\u2501\u253b\"])\n        .pipe_in(\"(,\u00b0\u25a1\u00b0\uff09, \u252c\u2500\u252c\")\n        .run()\n        .stdout_is(\"(\u256f\u00b0\u25a1\u00b0\uff09\u256f\ufe35\u253b\u2501\u253b\");\n}\n\n#[test]\nfn test_delete() {\n    new_ucmd!()\n "}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_number_kth_of_n", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_number_kth_of_n() {\n    new_ucmd!()\n        .args(&[\"--number=3/5\", \"asciilowercase.txt\"])\n        .succeeds()\n        .stdout_only(\"klmno\");\n    new_ucmd!()\n        .args(&[\"--number=5/5\", \"asciilowercase.txt\"])\n        .succeeds()\n        .stdout_only(\"uvwxyz\\n\");\n    new_ucmd!()\n        .args(&[\"-e\", \"--number=99/100\", \"asciilowercase.txt\"])\n        .succeeds()\n        .stdout_only(\"\");\n    #[cfg(unix)]\n    new_ucmd!()\n        .args(&[\"--number=3/10\", \"/dev/null\"])\n        .succeeds()\n        .stdout_only(\"\");\n    #[cfg(target_pointer_width = \"64\")]\n    new_ucmd!()\n        .args(&[\n            \"--number=r/9223372036854775807/18446744073709551615\",\n            \"asciilowercase.txt\",\n        ])\n        .succeeds()\n        .stdout_only(\"\");\n    new_ucmd!()\n        .args(&[\"--number=0/5\", \"asciilowercase.txt\"])\n        .fails()\n        .stderr_contains(\"split: invalid chunk number: 0\");\n    new_ucmd!()\n        .args(&[\"--number=10/5\", \"asciilowercase.txt\"])\n        .fails()\n        .stderr_contains(\"split: invalid chunk number: 10\");\n    #[cfg(target_pointer_width = \"64\")]\n    new_ucmd!()\n        .args(&[\n            \"--number=9223372036854775807/18446744073709551616\",\n            \"asciilowercase.txt\",\n        ])\n        .fails()\n        .stderr_contains(\"split: invalid number of chunks: 18446744073709551616\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/raftstore.rs::test_update_raftstore_config", "code": "pub fn shutdown(&mut self) {\n        if self.name_prefix.is_none() {\n            return;\n        }\n        let name_prefix = self.name_prefix.take().unwrap();\n        info!(\"shutdown batch system {}\", name_prefix);\n        self.router.broadcast_shutdown();\n        let mut last_error = None;\n        for h in self.workers.lock().unwrap().drain(..) {\n            debug!(\"waiting for {}\", h.thread().name().unwrap());\n            if let Err(e) = h.join() {\n                error!(\"failed to join worker thread: {:?}\", e);\n                last_error = Some(e);\n            }\n        }\n        if let Some(e) = last_error {\n            safe_panic!(\"failed to join worker thread: {:?}\", e);\n        }\n        info!(\"batch system {} is stopped.\", name_prefix);\n    }", "test": "fn test_update_raftstore_config() {\n    let (mut config, _dir) = TikvConfig::with_tmp().unwrap();\n    config.validate().unwrap();\n    let (cfg_controller, router, _, mut system) = start_raftstore(config.clone(), &_dir);\n\n    // dispatch updated config\n    let change = new_changes(vec![\n        (\"raftstore.messages-per-tick\", \"12345\"),\n        (\"raftstore.raft-log-gc-threshold\", \"54321\"),\n        (\"raftstore.raft-max-size-per-msg\", \"128MiB\"),\n        (\"raftstore.apply-max-batch-size\", \"1234\"),\n        (\"raftstore.store-max-batch-size\", \"4321\"),\n        (\"raftstore.raft-entry-max-size\", \"32MiB\"),\n        (\"raftstore.apply-yield-write-size\", \"10KiB\"),\n    ]);\n\n    cfg_controller.update(change).unwrap();\n\n    // config should be updated\n    let mut raft_store = config.raft_store;\n    raft_store.messages_per_tick = 12345;\n    raft_store.apply_yield_write_size = ReadableSize::kb(10);\n    raft_store.raft_log_gc_threshold = 54321;\n    raft_store.apply_batch_system.max_batch_size = Some(1234);\n    raft_store.store_batch_system.max_batch_size = Some(4321);\n    raft_store.raft_max_size_per_msg = ReadableSize::mb(128);\n    raft_store.raft_entry_max_size = ReadableSize::mb(32);\n    let validate_store_cfg = |raft_cfg: &Config| {\n        let raftstore_cfg = raft_cfg.clone();\n        validate_store(&router, move |cfg: &Config| {\n            assert_eq!(cfg, &raftstore_cfg);\n        });\n    };\n    validate_store_cfg(&raft_store);\n\n    let invalid_cfgs = vec![\n        (\"raftstore.apply-max-batch-size\", \"10241\"),\n        (\"raftstore.store-max-batch-size\", \"10241\"),\n        (\"raftstore.apply-max-batch-size\", \"0\"),\n        (\"raftstore.store-max-batch-size\", \"0\"),\n        (\"raftstore.raft-entry-max-size\", \"0KiB\"),\n        (\"raftstore.raft-entry-max-size\", \"4GiB\"),\n    ];\n    for cfg in invalid_cfgs {\n        let change = new_changes(vec![cfg]);\n        cfg_controller.update(change).unwrap_err();\n\n        // update failed, original config should not be changed.\n        validate_store_cfg(&raft_store);\n    }\n\n    let max_cfg = vec![\n        (\"raftstore.apply-max-batch-size\", \"10240\"),\n        (\"raftstore.store-max-batch-size\", \"10240\"),\n        (\"raftstore.raft-entry-max-size\", \"3GiB\"),\n    ];\n    cfg_controller.update(new_changes(max_cfg)).unwrap();\n    raft_store.apply_batch_system.max_batch_size = Some(10240);\n    raft_store.store_batch_system.max_batch_size = Some(10240);\n    raft_store.raft_entry_max_size = ReadableSize::gb(3);\n    validate_store_cfg(&raft_store);\n\n    let min_cfg = vec![\n        (\"raftstore.apply-max-batch-size\", \"1\"),\n        (\"raftstore.store-max-batch-size\", \"1\"),\n        (\"raftstore.raft-entry-max-size\", \"1\"),\n    ];\n    cfg_controller.update(new_changes(min_cfg)).unwrap();\n    raft_store.apply_batch_system.max_batch_size = Some(1);\n    raft_store.store_batch_system.max_batch_size = Some(1);\n    raft_store.raft_entry_max_size = ReadableSize(1);\n    validate_store_cfg(&raft_store);\n\n    system.shutdown();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_option_suppress_matched", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_option_suppress_matched() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"--suppress-matched\", \"/0$/\", \"{*}\"])\n        .succeeds()\n        .stdout_only(\"18\\n27\\n27\\n27\\n27\\n0\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 6);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(11, 20));\n    assert_eq!(at.read(\"xx02\"), generate(21, 30));\n    assert_eq!(at.read(\"xx03\"), generate(31, 40));\n    assert_eq!(at.read(\"xx04\"), generate(41, 50));\n    assert_eq!(at.read(\"xx05\"), \"\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon_tests.rs::compute_float_f64_test", "code": "pub fn compute_float64(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f64, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1066 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1066 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1065 + INVALID_FP, 9223372036854778879));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_6", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_6() {\n    let original = r##\"> He's also really stupid. [^why]\n>\n> [^why]: Because your mamma!\n\nAs such, we can guarantee that the non-childish forms of entertainment are probably more entertaining to adults, since, having had a whole childhood doing the childish ones, the non-childish ones are merely the ones that haven't gotten boring yet.\n\"##;\n    let expected = r##\"<blockquote>\n<p>He's also really stupid. <sup class=\"footnote-reference\"><a href=\"#why\">1</a></sup></p>\n<div class=\"footnote-definition\" id=\"why\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Because your mamma!</p>\n</div>\n</blockquote>\n<p>As such, we can guarantee that the non-childish forms of entertainment are probably more entertaining to adults, since, having had a whole childhood doing the childish ones, the non-childish ones are merely the ones that haven't gotten boring yet.</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_if_existing_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_numbered_if_existing_backup_nil() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n    let file_b_backup = \"test_install_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    scene\n        .ucmd()\n        .arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
{"test_id": "image-rs-image-gif/image-rs-image-gif-80fd8c0/tests/crashtest.rs::try_decode_crash_regression", "code": "fn try_decode_file(options: &DecodeOptions, data: Vec<u8>) -> Result<(), gif::DecodingError> {\n    let mut reader = options.clone().read_info(io::Cursor::new(data))?;\n    while reader.read_next_frame()?.is_some() {}\n    Ok(())\n}", "test": "fn try_decode_crash_regression() {\n    let files = fs::read_dir(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/tests/crashtest\")).unwrap();\n    let options = DecodeOptions::new();\n\n    for entry in files {\n        let entry = entry.unwrap();\n        if let Some(ext) = entry.path().extension() {\n            if ext.to_str() != Some(\"gif\") {\n                panic!(\"Unexpected file {} in crashtests, should end with .gif\", entry.path().display());\n            }\n        } else {\n            panic!(\"Unexpected file {} in crashtests, should end with .gif\", entry.path().display());\n        }\n\n        let file_data = fs::read(entry.path()).unwrap();\n        let _ = try_decode_file(&options, file_data);\n    }\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_farbfeld", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_farbfeld() {\n    truncate_images(\"farbfeld\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_time_and_reference", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_both_time_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_time_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-t\", \"2015010112342\", \"-r\", ref_file, file])\n        .fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_stdin_stdout_skip_bytes", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_stdout_skip_bytes() {\n    let input = build_ascii_block(521);\n    let mut output = String::from_utf8(input.clone()).unwrap();\n    let _ = output.drain(..256);\n    new_ucmd!()\n        .args(&[\"status=none\", \"skip=256\", \"ibs=128\", \"iflag=skip_bytes\"])\n        .pipe_in(input)\n        .run()\n        .no_stderr()\n        .stdout_only(output);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/json_api.rs::get_sat_without_sat_index", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "test": "fn get_sat_without_sat_index() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  let response = TestServer::spawn_with_server_args(&rpc_server, &[], &[\"--enable-json-api\"])\n    .json_request(\"/sat/2099999997689999\");\n\n  assert_eq!(response.status(), StatusCode::OK);\n\n  let mut sat_json: SatJson = serde_json::from_str(&response.text().unwrap()).unwrap();\n\n  // this is a hack to ignore the timestamp, since it changes for every request\n  sat_json.timestamp = 0;\n\n  pretty_assert_eq!(\n    sat_json,\n    SatJson {\n      number: 2099999997689999,\n      decimal: \"6929999.0\".into(),\n      degree: \"5\u00b0209999\u20321007\u20330\u2034\".into(),\n      name: \"a\".into(),\n      block: 6929999,\n      cycle: 5,\n      epoch: 32,\n      period: 3437,\n      offset: 0,\n      rarity: Rarity::Uncommon,\n      percentile: \"100%\".into(),\n      satpoint: None,\n      timestamp: 0,\n      inscriptions: vec![],\n    }\n  )\n}\n\n#[tes"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_page_length_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_page_length_option() {\n    let test_file_path = \"test.log\";\n    for (arg, expected) in [\n        (\"100\", \"test_page_length.log.expected\"),\n        (\"5\", \"test_page_length1.log.expected\"),\n    ] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[\"--pages=2:3\", \"-l\", arg, \"-n\", test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(expected, &[(\"{last_modified_time}\", &value)]);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_for_learner", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_for_learner() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 5;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(40);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    // replace one peer with learner\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store1.clone());\n    cluster.pd_client.must_add_peer(\n        region.get_id(),\n        new_learner_peer(peer_on_store1.get_store_id(), peer_on_store1.get_id()),\n    );\n    // Sleep 100 ms to wait for the new learner to be initialized.\n    sleep_ms(100);\n\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    // wait election timeout\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 2,\n    ));\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // promote the learner first and remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_add_peer(region.get_id(), find_peer(&region, 1).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n    cluster.must_transfer_leader(region.get_id(), find_peer(&region, 1).unwrap().clone());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_more.rs::test_valid_arg", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_valid_arg() {\n    if std::io::stdout().is_terminal() {\n        new_ucmd!().arg(\"-c\").succeeds();\n        new_ucmd!().arg(\"--print-over\").succeeds();\n\n        new_ucmd!().arg(\"-p\").succeeds();\n        new_ucmd!().arg(\"--clean-print\").succeeds();\n\n        new_ucmd!().arg(\"-s\").succeeds();\n        new_ucmd!().arg(\"--squeeze\").succeeds();\n\n        new_ucmd!().arg(\"-u\").succeeds();\n        new_ucmd!().arg(\"--plain\").succeeds();\n\n        new_ucmd!().arg(\"-n\").arg(\"10\").succeeds();\n        new_ucmd!().arg(\"--lines\").arg(\"0\").succeeds();\n        new_ucmd!().arg(\"--number\").arg(\"0\").succeeds();\n\n        new_ucmd!().arg(\"-F\").arg(\"10\").succeeds();\n        new_ucmd!().arg(\"--from-line\").arg(\"0\").succeeds();\n    }\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic.rs::term_test", "code": "fn term(input: &[u8]) -> IResult<&[u8], i64> {\n  let (input, init) = factor(input)?;\n  fold_many0(\n    pair(one_of(\"*/\"), factor),\n    move || init,\n    |acc, (op, val)| {\n      if op == '*' {\n        acc * val\n      } else {\n        acc / val\n      }\n    },\n  )(input)\n}", "test": "fn term_test() {\n  assert_eq!(term(\" 12 *2 /  3\"), Ok((\"\", 8)));\n  assert_eq!(term(\" 2* 3  *2 *2 /  3\"), Ok((\"\", 8)));\n  assert_eq!(term(\" 48 /  3/2\"), Ok((\"\", 8)));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_invalid_kill_after", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_invalid_kill_after() {\n    new_ucmd!()\n        .args(&[\"-k\", \"xyz\", \"1\", \"sleep\", \"0\"])\n        .fails()\n        .code_is(125)\n        .usage_error(\"invalid time interval 'xyz'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_no_clobber", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_no_clobber() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_no_clobber_file_a\";\n    let file_b = \"test_mv_no_clobber_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"-n\")\n        .arg(file_a)\n        .arg(file_b)\n        .fails()\n        .code_is(1)\n        .stderr_only(format!(\"mv: not replacing '{file_b}'\\n\"));\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_off", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_off() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=off\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_paths.rs::test_paths", "code": "pub fn resolve_path_alias(&self, specifier: &str) -> Vec<PathBuf> {\n        if specifier.starts_with(|s| s == '/' || s == '.') {\n            return vec![];\n        }\n\n        let base_url_iter = self\n            .compiler_options\n            .base_url\n            .as_ref()\n            .map_or_else(Vec::new, |base_url| vec![base_url.normalize_with(specifier)]);\n\n        let Some(paths_map) = &self.compiler_options.paths else { return base_url_iter };\n\n        let paths = paths_map.get(specifier).map_or_else(\n            || {\n                let mut longest_prefix_length = 0;\n                let mut longest_suffix_length = 0;\n                let mut best_key: Option<&String> = None;\n\n                for key in paths_map.keys() {\n                    if let Some((prefix, suffix)) = key.split_once('*') {\n                        if (best_key.is_none() || prefix.len() > longest_prefix_length)\n                            && specifier.starts_with(prefix)\n                            && specifier.ends_with(suffix)\n                        {\n                            longest_prefix_length = prefix.len();\n                            longest_suffix_length = suffix.len();\n                            best_key.replace(key);\n                        }\n                    }\n                }\n\n                best_key.and_then(|key| paths_map.get(key)).map_or_else(Vec::new, |paths| {\n                    paths\n                        .iter()\n                        .map(|path| {\n                            path.replace(\n                                '*',\n                                &specifier[longest_prefix_length\n                                    ..specifier.len() - longest_suffix_length],\n                            )\n                        })\n                        .collect::<Vec<_>>()\n                })\n            },\n            Clone::clone,\n        );\n\n        paths\n            .into_iter()\n            .map(|p| self.compiler_options.paths_base.normalize_with(p))\n            .chain(base_url_iter)\n            .collect()\n    }", "test": "fn test_paths() {\n    let path = Path::new(\"/foo/tsconfig.json\");\n    let mut tsconfig_json = serde_json::json!({\n        \"compilerOptions\": {\n            \"paths\": {\n                \"jquery\": [\"node_modules/jquery/dist/jquery\"],\n                \"*\": [\"generated/*\"],\n                \"bar/*\": [\"test/*\"],\n                \"bar/baz/*\": [\"baz/*\", \"yo/*\"],\n                \"@/components/*\": [\"components/*\"],\n                \"url\": [\"node_modules/my-url\"],\n            }\n        }\n    })\n    .to_string();\n    let tsconfig = TsConfig::parse(path, &mut tsconfig_json).unwrap();\n\n    let data = [\n        (\"jquery\", vec![\"/foo/node_modules/jquery/dist/jquery\"]),\n        (\"test\", vec![\"/foo/generated/test\"]),\n        (\"test/hello\", vec![\"/foo/generated/test/hello\"]),\n        (\"bar/hi\", vec![\"/foo/test/hi\"]),\n        (\"bar/baz/hi\", vec![\"/foo/baz/hi\", \"/foo/yo/hi\"]),\n        (\"@/components/button\", vec![\"/foo/components/button\"]),\n        (\"./jquery\", vec![]),\n        (\"url\", vec![\"/foo/node_modules/my-url\"]),\n    ];\n\n    for (specifier, expected) in data {\n        let paths = tsconfig.resolve_path_alias(specifier);\n        let expected = expected.into_iter().map(PathBuf::from).collect::<Vec<_>>();\n        assert_eq!(paths, expected, \"{specifier}\");\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow2_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u64_pow2_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        15,\n        16,\n        17,\n        31,\n        32,\n        33,\n        63,\n        64,\n        65,\n        127,\n        128,\n        129,\n        255,\n        256,\n        257,\n        511,\n        512,\n        513,\n        1023,\n        1024,\n        1025,\n        2047,\n        2048,\n        2049,\n        4095,\n        4096,\n        4097,\n        8191,\n        8192,\n        8193,\n        16383,\n        16384,\n        16385,\n        32767,\n        32768,\n        32769,\n        65535,\n        65536,\n        65537,\n        131071,\n        131072,\n        131073,\n        262143,\n        262144,\n        262145,\n        524287,\n        524288,\n        524289,\n        1048575,\n        1048576,\n        1048577,\n        2097151,\n        2097152,\n        2097153,\n        4194303,\n        4194304,\n        4194305,\n        8388607,\n        8388608,\n        8388609,\n        16777215,\n        16777216,\n        16777217,\n        33554431,\n        33554432,\n        33554433,\n        67108863,\n        67108864,\n        67108865,\n        134217727,\n        134217728,\n        134217729,\n        268435455,\n        268435456,\n        268435457,\n        536870911,\n        536870912,\n        536870913,\n        1073741823,\n        1073741824,\n        1073741825,\n        2147483647,\n        2147483648,\n        2147483649,\n        4294967295,\n        4294967296,\n        4294967297,\n        8589934591,\n        8589934592,\n        8589934593,\n        17179869183,\n        17179869184,\n        17179869185,\n        34359738367,\n        34359738368,\n        34359738369,\n        68719476735,\n        68719476736,\n        68719476737,\n        137438953471,\n        137438953472,\n        137438953473,\n        274877906943,\n        274877906944,\n        274877906945,\n        549755813887,\n        549755813888,\n        549755813889,\n        1099511627775,\n        1099511627776,\n        1099511627777,\n        2199023255551,\n        2199023255552,\n        2199023255553,\n        4398046511103,\n        4398046511104,\n        4398046511105,\n        8796093022207,\n        8796093022208,\n        8796093022209,\n        17592186044415,\n        17592186044416,\n        17592186044417,\n        35184372088831,\n        35184372088832,\n        35184372088833,\n        70368744177663,\n        70368744177664,\n        70368744177665,\n        140737488355327,\n        140737488355328,\n        140737488355329,\n        281474976710655,\n        281474976710656,\n        281474976710657,\n        562949953421311,\n        562949953421312,\n        562949953421313,\n        1125899906842623,\n        1125899906842624,\n        1125899906842625,\n        2251799813685247,\n        2251799813685248,\n        2251799813685249,\n        4503599627370495,\n        4503599627370496,\n        4503599627370497,\n        9007199254740991,\n        9007199254740992,\n        9007199254740993,\n        18014398509481983,\n        18014398509481984,\n        18014398509481985,\n        36028797018963967,\n        36028797018963968,\n        36028797018963969,\n        72057594037927935,\n        72057594037927936,\n        72057594037927937,\n        144115188075855871,\n        144115188075855872,\n        144115188075855873,\n        288230376151711743,\n        288230376151711744,\n        288230376151711745,\n        576460752303423487,\n        576460752303423488,\n        576460752303423489,\n        1152921504606846975,\n        1152921504606846976,\n        1152921504606846977,\n        2305843009213693951,\n        2305843009213693952,\n        2305843009213693953,\n        4611686018427387903,\n        4611686018427387904,\n        4611686018427387905,\n        9223372036854775807,\n        9223372036854775808,\n        9223372036854775809,\n        18446744073709551615,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_overwrite_nonempty_dir", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_mv_overwrite_nonempty_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_overwrite_nonempty_dir_a\";\n    let dir_b = \"test_mv_overwrite_nonempty_dir_b\";\n    let dummy = \"test_mv_overwrite_nonempty_dir_b/file\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    at.touch(dummy);\n    // Not same error as GNU; the error message is a rust builtin\n    // TODO: test (and implement) correct error message (or at least decide whether to do so)\n    // Current: \"mv: couldn't rename path (Directory not empty; from=a; to=b)\"\n    // GNU:     \"mv: cannot move 'a' to 'b': Directory not empty\"\n\n    // Verbose output for the move should not be shown on failure\n    let result = ucmd.arg(\"-vT\").arg(dir_a).arg(dir_b).fails();\n    result.no_stdout();\n    assert!(!result.stderr_str().is_empty());\n\n    assert!(at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_concatenated_with_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_line_bytes_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C8\", \"letters.txt\"]).succeeds();\n    assert_eq!(at.read(\"xaa\"), \"aaaaaaaa\");\n    assert_eq!(at.read(\"xab\"), \"a\\nbbbb\\n\");\n    assert_eq!(at.read(\"xac\"), \"cccc\\ndd\\n\");\n    assert_eq!(at.read(\"xad\"), \"ee\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/error_messages.rs::argument_count_mismatch", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn argument_count_mismatch() {\n  Test::new()\n    .justfile(\"foo a b:\")\n    .args([\"foo\"])\n    .stderr(\n      \"\n      error: Recipe `foo` got 0 arguments but takes 2\n      usage:\n          just foo a b\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/allow_duplicate_recipes.rs::allow_duplicate_recipes_with_args", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn allow_duplicate_recipes_with_args() {\n  Test::new()\n    .justfile(\n      \"\n      b a:\n        echo foo\n      b c d:\n        echo bar {{c}} {{d}}\n\n      set allow-duplicate-recipes\n    \",\n    )\n    .args([\"b\", \"one\", \"two\"])\n    .stdout(\"bar one two\\n\")\n    .stderr(\"echo bar one two\\n\")\n    .run();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::var_decl_hoisting_2_variables_hoisting", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn var_decl_hoisting_2_variables_hoisting() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            x = y;\n\n            var x = 10;\n            var y = 5;\n\n            x;\n        \"#},\n        10,\n    )]);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_fails_if_bitcoin_core_is_too_old", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_fails_if_bitcoin_core_is_too_old() {\n  let rpc_server = test_bitcoincore_rpc::builder().version(230000).build();\n\n  CommandBuilder::new(\"wallet inscribe --file hello.txt --fee-rate 1\")\n    .write(\"hello.txt\", \"HELLOWORLD\")\n    .expected_exit_code(1)\n    .expected_stderr(\"error: Bitcoin Core 24.0.0 or newer required, current version is 23.0.0\\n\")\n    .rpc_server(&rpc_server)\n    .run_and_extract_stdout();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/sats.rs::sats_from_tsv_parse_error", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn sats_from_tsv_parse_error() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(\"--index-sats wallet sats --tsv foo.tsv\")\n    .write(\"foo.tsv\", \"===\")\n    .rpc_server(&rpc_server)\n    .expected_exit_code(1)\n    .expected_stderr(\n      \"error: failed to parse sat from string \\\"===\\\" on line 1: invalid digit found in string\\n\",\n    )\n    .run_and_extract_stdout();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_merge_pessimistic_locks_propose_fail", "code": "fn read(&self, _name: &str) -> crate::ExternalData<'_> {\n            unimplemented!(\"use restore instead of read\")\n        }", "test": "fn test_merge_pessimistic_locks_propose_fail() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    // Sending a TransferLeaeder message to make left region fail to propose.\n\n    let snapshot = cluster.must_get_snapshot_of_region(left.id);\n    let txn_ext = snapshot.ext().get_txn_ext().unwrap().clone();\n    let lock = PessimisticLock {\n        primary: b\"k1\".to_vec().into_boxed_slice(),\n        start_ts: 10.into(),\n        ttl: 3000,\n        for_update_ts: 20.into(),\n        min_commit_ts: 30.into(),\n        last_change_ts: 15.into(),\n        versions_to_last_change: 3,\n    };\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(Key::from_raw(b\"k1\"), lock)])\n        .unwrap();\n\n    fail::cfg(\"raft_propose\", \"pause\").unwrap();\n\n    cluster.merge_region(left.id, right.id, Callback::None);\n    thread::sleep(Duration::from_millis(500));\n    assert_eq!(\n        txn_ext.pessimistic_locks.read().status,\n        LocksStatus::MergingRegion\n    );\n\n    // With the fail point set, we will fail to propose the locks or the\n    // PrepareMerge request.\n    fail::cfg(\"raft_propose\", \"return()\").unwrap();\n\n    // But after that, the pessimistic locks status should remain unchanged.\n    for _ in 0..5 {\n        thread::sleep(Duration::from_millis(500));\n        if txn_ext.pessimistic_locks.read().status == LocksStatus::Normal {\n            return;\n        }\n    }\n    panic!(\n        \"pessimistic locks status should return to Normal, but got {:?}\",\n        txn_ext.pessimistic_locks.read().status\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_top_level", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_top_level() {\n    verified_stmt(\"SELECT 1\");\n    verified_stmt(\"(SELECT 1)\");\n    verified_stmt(\"((SELECT 1))\");\n    verified_stmt(\"VALUES (1)\");\n    verified_stmt(\"VALUES ROW(1, true, 'a'), ROW(2, false, 'b')\");\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::unnamed_field_struct", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "test": "fn unnamed_field_struct() {\n    #[derive(CacheKey, Hash)]\n    struct UnnamedFieldsStruct(String, String);\n\n    let mut key = CacheKeyHasher::new();\n\n    let unnamed_fields = UnnamedFieldsStruct(\"Hello\".into(), \"World\".into());\n\n    unnamed_fields.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    unnamed_fields.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_preserve_timestamps", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_preserve_timestamps() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n    at.touch(file1);\n\n    ucmd.arg(file1).arg(file2).arg(\"-p\").succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n\n    let file1_metadata = at.metadata(file1);\n    let file2_metadata = at.metadata(file2);\n\n    assert_eq!(\n        file1_metadata.accessed().ok(),\n        file2_metadata.accessed().ok()\n    );\n    assert_eq!(\n        file1_metadata.modified().ok(),\n        file2_metadata.modified().ok()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_numeric", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_mode_numeric() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"dir1\";\n    let dir2 = \"dir2\";\n\n    let file = \"file\";\n    let mode_arg = \"--mode=333\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    scene\n        .ucmd()\n        .arg(file)\n        .arg(dir)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n\n    let mode_arg = \"-m 0333\";\n    at.mkdir(dir2);\n\n    scene.ucmd().arg(mode_arg).arg(file).arg(dir2).succeeds();\n\n    let dest_file = &format!(\"{dir2}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_compatible", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_uname_compatible() {\n    new_ucmd!().arg(\"-a\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_all", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_all() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_mv_arg_update_none_file1\";\n    let file2 = \"test_mv_arg_update_none_file2\";\n    let file1_content = \"file1 content\\n\";\n    let file2_content = \"file2 content\\n\";\n\n    at.write(file1, file1_content);\n    at.write(file2, file2_content);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(file2), file1_content);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::iter", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn iter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.iter().unwrap();\n    for i in 0..10 {\n        let (k, v) = iter.next().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::timeout_async_hook", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "async fn timeout_async_hook() -> Result<(), Error> {\n    struct HandlerR;\n\n    #[async_trait::async_trait]\n    impl CallHookHandler<State> for HandlerR {\n        async fn handle_call_event(&self, obj: &mut State, ch: CallHook) -> Result<()> {\n            if obj.calls_into_host > 200 {\n                bail!(\"timeout\");\n            }\n\n            match ch {\n                CallHook::CallingHost => obj.calls_into_host += 1,\n                CallHook::CallingWasm => obj.calls_into_wasm += 1,\n                CallHook::ReturningFromHost => obj.returns_from_host += 1,\n                CallHook::ReturningFromWasm => obj.returns_from_wasm += 1,\n            }\n\n            Ok(())\n        }\n    }\n\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook_async(HandlerR {});\n\n    assert_eq!(store.data().calls_into_host, 0);\n    assert_eq!(store.data().returns_from_host, 0);\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |_caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (loop $start\n                    (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0))\n                    (br $start)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_typed_func::<(), ()>(&mut store, \"export\")\n        .expect(\"export is func\");\n\n    store.set_epoch_deadline(1);\n    store.epoch_deadline_async_yield_and_update(1);\n    assert!(export.call_async(&mut store, ()).await.is_err());\n\n    // One switch from vm to host to call f, another in return from f.\n    assert!(store.data().calls_into_host > 1);\n    assert!(store.data().returns_from_host > 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/name.rs::test_module_no_name", "code": "pub fn name(&self) -> Option<&str> {\n        self.compiled_module().module().name.as_deref()\n    }", "test": "fn test_module_no_name() -> anyhow::Result<()> {\n    let engine = Engine::default();\n    let wat = r#\"\n        (module\n        (func (export \"run\") (nop))\n        )\n    \"#;\n\n    let module = Module::new(&engine, wat)?;\n    assert_eq!(module.name(), None);\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_witness_leader_transfer_out", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_witness_leader_transfer_out() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n\n    // prevent this peer from applying the switch witness command until it's elected\n    // as the Raft leader\n    fail::cfg(\"before_exec_batch_switch_witness\", \"pause\").unwrap();\n    let peer_on_store2 = find_peer(&region, nodes[1]).unwrap().clone();\n    // nonwitness -> witness\n    cluster\n        .pd_client\n        .switch_witnesses(region.get_id(), vec![peer_on_store2.get_id()], vec![true]);\n    // make sure the left peers have applied switch witness cmd\n    std::thread::sleep(Duration::from_millis(500));\n\n    // the other follower is isolated\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    for i in 1..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), format!(\"v{}\", i).as_bytes());\n    }\n    // the leader is down\n    cluster.stop_node(1);\n\n    // new leader would help to replicate the logs\n    cluster.clear_send_filters();\n    std::thread::sleep(Duration::from_millis(1000));\n    // make sure the new leader has became to the witness\n    fail::remove(\"before_exec_batch_switch_witness\");\n    std::thread::sleep(Duration::from_millis(500));\n\n    // forbid writes\n    let put = new_put_cmd(b\"k3\", b\"v3\");\n    must_get_error_is_witness(&mut cluster, &region, put);\n    // forbid reads\n    let get = new_get_cmd(b\"k1\");\n    must_get_error_is_witness(&mut cluster, &region, get);\n    // forbid read index\n    let read_index = new_read_index_cmd();\n    must_get_error_is_witness(&mut cluster, &region, read_index);\n\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n\n    cluster.must_transfer_leader(region.get_id(), peer_on_store3);\n    cluster.must_put(b\"k1\", b\"v1\");\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap().store_id,\n        nodes[2],\n    );\n    assert_eq!(cluster.must_get(b\"k9\"), Some(b\"v9\".to_vec()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_zero_len_equals_zero_len", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_zero_len_equals_zero_len() {\n    new_ucmd!().args(&[\"\", \"=\", \"\"]).succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_flashback.rs::test_flashback_for_local_read", "code": "pub fn get_last_index(&self) -> u64 {\n        self.last_index\n    }", "test": "fn test_flashback_for_local_read() {\n    let mut cluster = new_node_cluster(0, 3);\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(50), None);\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    cluster.run();\n    cluster.must_put(TEST_KEY, TEST_VALUE);\n    let mut region = cluster.get_region(TEST_KEY);\n    let store_id = 3;\n    let peer = new_peer(store_id, 3);\n    cluster.must_transfer_leader(region.get_id(), peer);\n\n    // Check local read before prepare flashback\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    let last_index = state.get_last_index();\n    // Make sure the leader transfer procedure timeouts.\n    sleep(election_timeout * 2);\n    must_request_without_flashback_flag(&mut cluster, &mut region.clone(), new_get_cmd(TEST_KEY));\n    // Check the leader does a local read.\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    assert_eq!(state.get_last_index(), last_index);\n\n    // Prepare flashback.\n    cluster.must_send_wait_flashback_msg(region.get_id(), AdminCmdType::PrepareFlashback);\n    // Check the leader does a local read.\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    assert_eq!(state.get_last_index(), last_index + 1);\n    // Wait for apply_res to set leader lease.\n    sleep_ms(500);\n    // Read should fail.\n    must_get_flashback_in_progress_error(&mut cluster, &mut region.clone(), new_get_cmd(TEST_KEY));\n    // Wait for the leader's lease to expire to ensure that a renew lease interval\n    // has elapsed.\n    sleep(election_timeout * 2);\n    // Read should fail.\n    must_get_flashback_in_progress_error(&mut cluster, &mut region.clone(), new_get_cmd(TEST_KEY));\n    // Also check read by propose was blocked\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    assert_eq!(state.get_last_index(), last_index + 1);\n    // Finish flashback.\n    cluster.must_send_wait_flashback_msg(region.get_id(), AdminCmdType::FinishFlashback);\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    assert_eq!(state.get_last_index(), last_index + 2);\n\n    // Check local read after finish flashback\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    let last_index = state.get_last_index();\n    // Make sure the leader transfer procedure timeouts.\n    sleep(election_timeout * 2);\n    must_request_without_flashback_flag(&mut cluster, &mut region.clone(), new_get_cmd(TEST_KEY));\n    // Check the leader does a local read.\n    let state = cluster.raft_local_state(region.get_id(), store_id);\n    assert_eq!(state.get_last_index(), last_index);\n    // A local read with flashback flag will not be blocked since it won't have any\n    // side effects.\n    must_request_with_flashback_flag(&mut cluster, &mut region, new_get_cmd(TEST_KEY));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_id.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_corner_case3", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_corner_case3() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/15/-3\", \"14\", \"/15/\"])\n        .fails()\n        .stderr_is(\"csplit: '/15/': match not found\\n\")\n        .stdout_is(\"24\\n6\\n111\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_first_only_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_first_only_1() {\n    new_ucmd!()\n        .args(&[\"-t3\", \"--first-only\"])\n        .pipe_in(\"        A     B\")\n        .run()\n        .stdout_is(\"\\t\\t  A     B\");\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_int_max_u64", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_int_max_u64() {\n    let thing = u64::MAX;\n    let yaml = indoc! {\"\n        18446744073709551615\n    \"};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::negative_complex", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn negative_complex() {\n    let source = r#\"\n    void f() {\n        void *ptr;\n        void *x;\n        ptr = NULL;\n        g(&ptr);\n        g(&x);\n        x = NULL;\n        }\n    }\n    \"#;\n\n    let needle = \"{_ *$p; $func(&$p);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 2);\n\n    let needle = \"{_ *$p; NOT: $p = _; $func(&$p);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_u64", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_u64() {\n    let tests = &[(3u64, \"3\"), (u64::MAX, &u64::MAX.to_string())];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_mode", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_mkdir_mode() {\n    let _guard = TEST_MUTEX.lock();\n    new_ucmd!().arg(\"-m\").arg(\"755\").arg(\"test_dir\").succeeds();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::smoke", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "test": "fn smoke() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        0.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(0));\n    assert!(g.set(&mut store, 0.into()).is_err());\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        1i32.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(1));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I64, Mutability::Const),\n        2i64.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i64(), Some(2));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::F32, Mutability::Const),\n        3.0f32.into(),\n    )?;\n    assert_eq!(g.get(&mut store).f32(), Some(3.0));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::F64, Mutability::Const),\n        4.0f64.into(),\n    )?;\n    assert_eq!(g.get(&mut store).f64(), Some(4.0));\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_count_2", "code": "fn count(&self) -> usize {\n        panic!()\n    }", "test": "fn write_batch_count_2() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert_eq!(wb.count(), 0);\n    wb.put(b\"a\", b\"\").unwrap();\n    assert_eq!(wb.count(), 1);\n    wb.delete(b\"a\").unwrap();\n    assert_eq!(wb.count(), 2);\n    wb.delete_range(b\"a\", b\"b\").unwrap();\n    assert_eq!(wb.count(), 3);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 3);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    assert_eq!(wb.count(), 0);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    assert_eq!(wb.count(), 257);\n    wb.delete(b\"a\").unwrap();\n    assert_eq!(wb.count(), 258);\n    wb.delete_range(b\"a\", b\"b\").unwrap();\n    assert_eq!(wb.count(), 259);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 259);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printf.rs::escaped_octal", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn escaped_octal() {\n    new_ucmd!().args(&[\"\\\\101\"]).succeeds().stdout_only(\"A\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_numeric_suffix_with_value_spaced", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_short_numeric_suffix_with_value_spaced() {\n    new_ucmd!()\n        .args(&[\"-n\", \"4\", \"-d\", \"9\", \"threebytes.txt\"])\n        .fails()\n        .stderr_contains(\"split: cannot open '9' for reading: No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::fails_on_invalid_number", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn fails_on_invalid_number() {\n    new_ucmd!().arg(\"not-a-valid-number\").fails();\n    new_ucmd!()\n        .arg(\"not-a-valid-number\")\n        .arg(\"12\")\n        .fails()\n        .stdout_contains(\"12: 2 2 3\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::user_must_provide_fee_rate_to_send", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn user_must_provide_fee_rate_to_send() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  let (inscription, _) = inscribe(&rpc_server);\n\n  CommandBuilder::new(format!(\n    \"wallet send bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {inscription}\"\n  ))\n  .rpc_server(&rpc_server)\n  .expected_exit_code(2)\n  .stderr_regex(\n    \".*error: the following required arguments were not provided:\n.*--fee-rate <FEE_RATE>.*\",\n  )\n  .run_and_extract_stdout();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_class_simple", "code": "pub fn test(self) {\n        let res: Result<_, _> = self.into();\n\n        res.unwrap();\n    }", "test": "fn test_class_simple() {\n    SemanticTester::js(\"export class Foo {}\")\n        .has_root_symbol(\"Foo\")\n        .contains_flags(SymbolFlags::Class | SymbolFlags::Export)\n        .has_number_of_references(0)\n        .is_exported()\n        .test();\n\n    SemanticTester::js(\"class Foo {}; let f = new Foo()\")\n        .has_root_symbol(\"Foo\")\n        .has_number_of_reads(1)\n        .test();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_multiple_statements", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "test": "fn parse_multiple_statements() {\n    fn test_with(sql1: &str, sql2_kw: &str, sql2_rest: &str) {\n        // Check that a string consisting of two statements delimited by a semicolon\n        // parses the same as both statements individually:\n        let res = parse_sql_statements(&(sql1.to_owned() + \";\" + sql2_kw + sql2_rest));\n        assert_eq!(\n            vec![\n                one_statement_parses_to(sql1, \"\"),\n                one_statement_parses_to(&(sql2_kw.to_owned() + sql2_rest), \"\"),\n            ],\n            res.unwrap()\n        );\n        // Check that extra semicolon at the end is stripped by normalization:\n        one_statement_parses_to(&(sql1.to_owned() + \";\"), sql1);\n        // Check that forgetting the semicolon results in an error:\n        let res = parse_sql_statements(&(sql1.to_owned() + \" \" + sql2_kw + sql2_rest));\n        assert_eq!(\n            ParserError::ParserError(\"Expected end of statement, found: \".to_string() + sql2_kw),\n            res.unwrap_err()\n        );\n    }\n    test_with(\"SELECT foo\", \"SELECT\", \" bar\");\n    // ensure that SELECT/WITH is not parsed as a table or column alias if ';'\n    // separating the statements is omitted:\n    test_with(\"SELECT foo FROM baz\", \"SELECT\", \" bar\");\n    test_with(\"SELECT foo\", \"WITH\", \" cte AS (SELECT 1 AS s) SELECT bar\");\n    test_with(\n        \"SELECT foo FROM baz\",\n        \"WITH\",\n        \" cte AS (SELECT 1 AS s) SELECT bar\",\n    );\n    test_with(\"DELETE FROM foo\", \"SELECT\", \" bar\");\n    test_with(\"INSERT INTO foo VALUES (1)\", \"SELECT\", \" bar\");\n    test_with(\"CREATE TABLE foo (baz INT)\", \"SELECT\", \" bar\");\n    // Make sure that empty statements do not cause an error:\n    let res = parse_sql_statements(\";;\");\n    assert_eq!(0, res.unwrap().len());\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/regression.rs::regression_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn regression_test_3() {\n    let original = r##\"[![debug-stub-derive on crates.io][cratesio-image]][cratesio]\n[![debug-stub-derive on docs.rs][docsrs-image]][docsrs]\n\n[cratesio-image]: https://img.shields.io/crates/v/debug_stub_derive.svg\n[cratesio]: https://crates.io/crates/debug_stub_derive\n[docsrs-image]: https://docs.rs/debug_stub_derive/badge.svg?version=0.3.0\n[docsrs]: https://docs.rs/debug_stub_derive/0.3.0/\n\"##;\n    let expected = r##\"<p><a href=\"https://crates.io/crates/debug_stub_derive\"><img src=\"https://img.shields.io/crates/v/debug_stub_derive.svg\" alt=\"debug-stub-derive on crates.io\" /></a>\n<a href=\"https://docs.rs/debug_stub_derive/0.3.0/\"><img src=\"https://docs.rs/debug_stub_derive/badge.svg?version=0.3.0\" alt=\"debug-stub-derive on docs.rs\" /></a></p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_status_command.rs::test_latency_inspect", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_latency_inspect() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    cluster.run();\n    let router = cluster.sim.wl().get_router(1).unwrap();\n    let (tx, rx) = std::sync::mpsc::sync_channel(10);\n    let inspector = LatencyInspector::new(\n        1,\n        Box::new(move |_, duration| {\n            let dur = duration.sum();\n            tx.send(dur).unwrap();\n        }),\n    );\n    let msg = StoreMsg::LatencyInspect {\n        send_time: Instant::now(),\n        inspector,\n    };\n    router.send_control(msg).unwrap();\n    rx.recv_timeout(std::time::Duration::from_secs(2)).unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_version_flag", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_version_flag() {\n    let version_short = new_ucmd!().arg(\"-V\").succeeds();\n    let version_long = new_ucmd!().arg(\"--version\").succeeds();\n\n    assert_eq!(version_short.stdout_str(), version_long.stdout_str());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_put", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_put() {\n    let db = default_engine();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n\n    let db = multi_batch_write_engine();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"aa\").unwrap();\n    for i in 128..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        assert_eq!(db.engine.get_value(&x).unwrap().unwrap(), &x);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_option_keep", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_option_keep() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-k\", \"numbers50.txt\", \"/20/\", \"/nope/\"])\n        .fails()\n        .stderr_is(\"csplit: '/nope/': match not found\\n\")\n        .stdout_is(\"48\\n93\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), generate(20, 51));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::mul_test", "code": "fn check_mul(xmant: u64, xexp: i32, ymant: u64, yexp: i32, zmant: u64, zexp: i32) {\n    let x = ExtendedFloat80 {\n        mant: xmant,\n        exp: xexp,\n    };\n    let y = ExtendedFloat80 {\n        mant: ymant,\n        exp: yexp,\n    };\n    let z = ExtendedFloat80 {\n        mant: zmant,\n        exp: zexp,\n    };\n    let r = compact::mul(&x, &y);\n    assert_eq!(r, z);\n}", "test": "fn mul_test() {\n    // Normalized (64-bit mantissa)\n    check_mul(13164036458569648128, -213, 9223372036854775808, -62, 6582018229284824064, -211);\n\n    // Check both values need high bits set.\n    check_mul(1 << 32, -31, 1 << 32, -31, 1, 2);\n    check_mul(10 << 31, -31, 10 << 31, -31, 25, 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basenc.rs::test_z85_not_padded", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_z85_not_padded() {\n    // The z85 crate deviates from the standard in some cases; we have to catch those\n    new_ucmd!()\n        .args(&[\"--z85\", \"-d\"])\n        .pipe_in(\"##########\")\n        .fails()\n        .stderr_only(\"basenc: error: invalid input\\n\");\n    new_ucmd!()\n        .args(&[\"--z85\"])\n        .pipe_in(\"123\")\n        .fails()\n        .stderr_only(\"basenc: error: invalid input (length must be multiple of 4 characters)\\n\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::apply_unsafe_with_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn apply_unsafe_with_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    // last line doesn't have code fix\n    let source = \"let a = 4;\ndebugger;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let expected = \"const a = 4;\nconsole.log(a);\nfunction f() {\\n\\targuments;\\n}\n\";\n\n    let test1 = Path::new(\"test1.js\");\n    fs.insert(test1.into(), source.as_bytes());\n\n    let test2 = Path::new(\"test2.js\");\n    fs.insert(test2.into(), source.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply-unsafe\"),\n                test1.as_os_str().to_str().unwrap(),\n                test2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(test1)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, expected);\n    drop(file);\n\n    content.clear();\n\n    let mut file = fs\n        .open(test2)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_unsafe_with_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_leader_drop_with_pessimistic_lock", "code": "pub fn leader_of_region(&mut self, region_id: u64) -> Option<metapb::Peer> {\n        let timer = Instant::now_coarse();\n        let timeout = Duration::from_secs(5);\n        let mut store_ids = None;\n        while timer.saturating_elapsed() < timeout {\n            match self.voter_store_ids_of_region(region_id) {\n                None => thread::sleep(Duration::from_millis(10)),\n                Some(ids) => {\n                    store_ids = Some(ids);\n                    break;\n                }\n            }\n        }\n        let store_ids = store_ids?;\n        if let Some(l) = self.leaders.get(&region_id) {\n            // leader may be stopped in some tests.\n            if self.valid_leader_id(region_id, l.get_store_id()) {\n                return Some(l.clone());\n            }\n        }\n        self.reset_leader_of_region(region_id);\n        let mut leader = None;\n        let mut leaders = HashMap::default();\n\n        let node_ids = self.sim.rl().get_node_ids();\n        // For some tests, we stop the node but pd still has this information,\n        // and we must skip this.\n        let alive_store_ids: Vec<_> = store_ids\n            .iter()\n            .filter(|id| node_ids.contains(id))\n            .cloned()\n            .collect();\n        while timer.saturating_elapsed() < timeout {\n            for store_id in &alive_store_ids {\n                let l = match self.query_leader(*store_id, region_id, Duration::from_secs(1)) {\n                    None => continue,\n                    Some(l) => l,\n                };\n                leaders\n                    .entry(l.get_id())\n                    .or_insert((l, vec![]))\n                    .1\n                    .push(*store_id);\n            }\n            if let Some((_, (l, c))) = leaders.iter().max_by_key(|(_, (_, c))| c.len()) {\n                if c.contains(&l.get_store_id()) {\n                    leader = Some(l.clone());\n                    // Technically, correct calculation should use two quorum when in joint\n                    // state. Here just for simplicity.\n                    if c.len() > store_ids.len() / 2 {\n                        break;\n                    }\n                }\n            }\n            debug!(\"failed to detect leaders\"; \"leaders\" => ?leaders, \"store_ids\" => ?store_ids);\n            sleep_ms(10);\n            leaders.clear();\n        }\n\n        if let Some(l) = leader {\n            self.leaders.insert(region_id, l);\n        }\n\n        self.leaders.get(&region_id).cloned()\n    }", "test": "fn test_leader_drop_with_pessimistic_lock() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    let txn_ext = cluster\n        .must_get_snapshot_of_region(1)\n        .ext()\n        .get_txn_ext()\n        .unwrap()\n        .clone();\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(\n            Key::from_raw(b\"k1\"),\n            PessimisticLock {\n                primary: b\"k1\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 10.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n        .unwrap();\n\n    // Isolate node 1, leader should be transferred to another node.\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    assert_ne!(cluster.leader_of_region(1).unwrap().id, 1);\n\n    // When peer 1 becomes leader again, the pessimistic locks should be cleared\n    // before.\n    cluster.clear_send_filters();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    assert!(txn_ext.pessimistic_locks.read().is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_plus", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_plus() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \"+\"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        .stdout_is(\"a       b       c\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_does_not_use_inscribed_sats_as_cardinal_utxos", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn send_does_not_use_inscribed_sats_as_cardinal_utxos() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let txid = rpc_server.mine_blocks_with_subsidy(1, 10_000)[0].txdata[0].txid();\n  CommandBuilder::new(format!(\n    \"wallet inscribe --satpoint {txid}:0:0 --file degenerate.png --fee-rate 0\"\n  ))\n  .write(\"degenerate.png\", [1; 100])\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Inscribe>();\n\n  let txid = rpc_server.mine_blocks_with_subsidy(1, 100)[0].txdata[0].txid();\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {txid}:0:0\"\n  ))\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(\"error: wallet does not contain enough cardinal UTXOs, please add additional funds to wallet.\\n\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression21", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn regression21() {\n    let tmpfile = create_tempfile();\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let mut table = txn.open_table(U64_TABLE).unwrap();\n\n    for i in 0..100 {\n        table.insert(i, i).unwrap();\n    }\n\n    table.drain(..1).unwrap();\n\n    drop(table);\n    txn.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/cell.rs::boa_borrow_mut_test", "code": "pub(crate) fn push<T>(&mut self, value: T)\n    where\n        T: Into<JsValue>,\n    {\n        self.stack.push(value.into());\n    }", "test": "fn boa_borrow_mut_test() {\n    run_test(|| {\n        let v = Gc::new(GcRefCell::new(Vec::new()));\n\n        for _ in 1..=259 {\n            let cell = Gc::new(GcRefCell::new([0u8; 10]));\n            v.borrow_mut().push(cell);\n        }\n    });\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::checked_math", "code": "pub fn checked_add(self, offset: TextSize) -> Option<TextRange> {\n        Some(TextRange {\n            start: self.start.checked_add(offset)?,\n            end: self.end.checked_add(offset)?,\n        })\n    }", "test": "fn checked_math() {\n    assert_eq!(size(1).checked_add(size(1)), Some(size(2)));\n    assert_eq!(size(1).checked_sub(size(1)), Some(size(0)));\n    assert_eq!(size(1).checked_sub(size(2)), None);\n    assert_eq!(size(!0).checked_add(size(1)), None);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::exprstmt", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn exprstmt() {\n    let source = r#\"\n        void foo() {\n            a = func(bar);\n        }\"#;\n\n    let needle = \"{func(bar);}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::parse_delimited_identifiers", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_delimited_identifiers() {\n    // check that quoted identifiers in any position remain quoted after serialization\n    let select = redshift().verified_only_select(\n        r#\"SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"\"#,\n    );\n    // check FROM\n    match only(select.from).relation {\n        TableFactor::Table {\n            name,\n            alias,\n            args,\n            with_hints,\n            version,\n            partitions: _,\n        } => {\n            assert_eq!(vec![Ident::with_quote('\"', \"a table\")], name.0);\n            assert_eq!(Ident::with_quote('\"', \"alias\"), alias.unwrap().name);\n            assert!(args.is_none());\n            assert!(with_hints.is_empty());\n            assert!(version.is_none());\n        }\n        _ => panic!(\"Expecting TableFactor::Table\"),\n    }\n    // check SELECT\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::CompoundIdentifier(vec![\n            Ident::with_quote('\"', \"alias\"),\n            Ident::with_quote('\"', \"bar baz\"),\n        ]),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::with_quote('\"', \"myfun\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[1]),\n    );\n    match &select.projection[2] {\n        SelectItem::ExprWithAlias { expr, alias } => {\n            assert_eq!(&Expr::Identifier(Ident::with_quote('\"', \"simple id\")), expr);\n            assert_eq!(&Ident::with_quote('\"', \"column alias\"), alias);\n        }\n        _ => panic!(\"Expected ExprWithAlias\"),\n    }\n\n    redshift().verified_stmt(r#\"CREATE TABLE \"foo\" (\"bar\" \"int\")\"#);\n    redshift().verified_stmt(r#\"ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)\"#);\n    //TODO verified_stmt(r#\"UPDATE foo SET \"bar\" = 5\"#);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_agg_with_order_by", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_agg_with_order_by() {\n    let supported_dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(HiveDialect {}),\n        ],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT FIRST_VALUE(x ORDER BY x) AS a FROM T\",\n        \"SELECT FIRST_VALUE(x ORDER BY x) FROM tbl\",\n        \"SELECT LAST_VALUE(x ORDER BY x, y) AS a FROM T\",\n        \"SELECT LAST_VALUE(x ORDER BY x ASC, y DESC) AS a FROM T\",\n    ] {\n        supported_dialects.verified_stmt(sql);\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::f32_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn f32_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, f32> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(&0, &0.3).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(0.3, table.get(&0).unwrap().unwrap().value());\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::long_numerics", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn long_numerics() {\n    let query = r#\"SELECT MIN(MIN(10, 5), 1L) AS a\"#;\n    hive().verified_stmt(query);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append_multi", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_append_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let mut record3 = record.clone();\n    record3.set_data(Some(RData::A(A::new(101, 11, 101, 12))));\n\n    // build the append set\n    let mut rrset = RecordSet::from(record2.clone());\n    rrset.insert(record3.clone(), 0);\n\n    let result = io_loop\n        .block_on(client.append(rrset, origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n    assert!(result.answers().iter().any(|rr| *rr == record3));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    // TODO: technically this is a test for the Server, not client...\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_analyze", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_analyze() {\n    let analyze = r#\"ANALYZE TABLE db.table_name PARTITION (a = '1234', b) COMPUTE STATISTICS NOSCAN CACHE METADATA\"#;\n    hive().verified_stmt(analyze);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_continue_label", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_in_continue_label() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var str = \"\";\n\n            outer: for (let i in [1, 2]) {\n                inner: for (let b in [2, 3, 4]) {\n                    if (b === \"1\") {\n                        continue outer;\n                    }\n                    str = str + b;\n                }\n                str = str + i;\n            }\n            str\n        \"#},\n        \"00\",\n    )]);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::stop_fallback_when_fallback_is_false", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn stop_fallback_when_fallback_is_false() {\n  Test::new()\n    .tree(tree! {\n      a: {\n        b: {\n          justfile: \"\n            set fallback := true\n\n            foo:\n              echo subdir\n          \"\n        },\n        justfile: \"\n          bar:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\n      \"\n      baz:\n        echo root\n    \",\n    )\n    .args([\"baz\"])\n    .current_dir(\"a/b\")\n    .stderr(\n      \"\n      error: Justfile does not contain recipe `baz`.\n      Did you mean `bar`?\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_line_num_out_of_range4", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_line_num_out_of_range4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"40\", \"{*}\"])\n        .fails()\n        .stdout_is(\"108\\n33\\n\")\n        .stderr_is(\"csplit: '40': line number out of range on repetition 1\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"40\", \"{*}\", \"-k\"])\n        .fails()\n        .stdout_is(\"108\\n33\\n\")\n        .stderr_is(\"csplit: '40': line number out of range on repetition 1\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 40));\n    assert_eq!(at.read(\"xx01\"), generate(40, 51));\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_hs_retransmit", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "test": "fn server_hs_retransmit() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let client_ch = pair.begin_connect(client_config());\n    pair.step();\n    assert!(!pair.client.inbound.is_empty()); // Initial + Handshakes\n    pair.client.inbound.clear();\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::key_update_reordered", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "test": "fn key_update_reordered() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Bi)\n        .expect(\"couldn't open first stream\");\n\n    const MSG1: &[u8] = b\"1\";\n    pair.client_send(client_ch, s).write(MSG1).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert!(!pair.client.outbound.is_empty());\n    pair.client.delay_outbound();\n\n    pair.client_conn_mut(client_ch).initiate_key_update();\n    info!(\"updated keys\");\n\n    const MSG2: &[u8] = b\"two\";\n    pair.client_send(client_ch, s).write(MSG2).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    pair.client.finish_delay();\n    pair.drive();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Bi }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Bi), Some(stream) if stream == s);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(true).unwrap();\n    let buf1 = chunks.next(usize::MAX).unwrap().unwrap();\n    assert_matches!(&*buf1.bytes, MSG1);\n    let buf2 = chunks.next(usize::MAX).unwrap().unwrap();\n    assert_eq!(buf2.bytes, MSG2);\n    let _ = chunks.finalize();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_eq!(pair.server_conn_mut(server_ch).lost_packets(), 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_change_leader_async", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_change_leader_async() {\n    let eps_count = 3;\n    let server = MockServer::with_case(eps_count, Arc::new(LeaderChange::new()));\n    let eps = server.bind_addrs();\n\n    let counter = Arc::new(AtomicUsize::new(0));\n    let client = new_client(eps, None);\n    let counter1 = Arc::clone(&counter);\n    client.handle_reconnect(move || {\n        counter1.fetch_add(1, Ordering::SeqCst);\n    });\n    let leader = client.get_leader();\n\n    for _ in 0..5 {\n        let region = block_on(client.get_region_by_id(1));\n        region.ok();\n\n        let new = client.get_leader();\n        if new != leader {\n            assert!(counter.load(Ordering::SeqCst) >= 1);\n            return;\n        }\n        thread::sleep(LeaderChange::get_leader_interval());\n    }\n\n    panic!(\"failed, leader should changed\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_runlevel", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_runlevel() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-r\", \"--runlevel\", \"--r\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n\n        #[cfg(not(target_os = \"linux\"))]\n        ts.ucmd().arg(opt).succeeds().stdout_is(\"\");\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_char", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_char() {\n    let tests = &[\n        ('n', \"\\\"n\\\"\"),\n        ('\"', \"\\\"\\\\\\\"\\\"\"),\n        ('\\\\', \"\\\"\\\\\\\\\\\"\"),\n        ('/', \"\\\"/\\\"\"),\n        ('\\x08', \"\\\"\\\\b\\\"\"),\n        ('\\x0C', \"\\\"\\\\f\\\"\"),\n        ('\\n', \"\\\"\\\\n\\\"\"),\n        ('\\r', \"\\\"\\\\r\\\"\"),\n        ('\\t', \"\\\"\\\\t\\\"\"),\n        ('\\x0B', \"\\\"\\\\u000b\\\"\"),\n        ('\\u{3A3}', \"\\\"\\u{3A3}\\\"\"),\n    ];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::hashbang_use_strict_no_with", "code": "pub(super) fn check_script_parser<L>(js: &str, expr: L, interner: &mut Interner)\nwhere\n    L: Into<Box<[StatementListItem]>>,\n{\n    assert_eq!(\n        Parser::new(Source::from_bytes(js))\n            .parse_script(interner)\n            .expect(\"failed to parse\"),\n        Script::new(StatementList::from(expr.into()))\n    );\n}", "test": "fn hashbang_use_strict_no_with() {\n    check_script_parser(\n        r#\"#!\\\"use strict\"\n        \"#,\n        vec![],\n        &mut Interner::default(),\n    );\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_stream", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn stop_stream() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"stopping stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    assert_matches!(\n        pair.client_send(client_ch, s).write(b\"foo\"),\n        Err(WriteError::Stopped(ERROR))\n    );\n    assert_matches!(\n        pair.client_send(client_ch, s).finish(),\n        Err(FinishError::Stopped(ERROR))\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_existing_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_link_existing_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_existing_file\";\n    let link = \"test_link_existing_file_link\";\n\n    at.touch(file);\n    at.write(file, \"foobar\");\n    assert!(at.file_exists(file));\n\n    ucmd.args(&[file, link]).succeeds().no_stderr();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(link));\n    assert_eq!(at.read(file), at.read(link));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_uname() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_cleanup_commit", "code": "pub fn rollback_err(&self, keys: Vec<&[u8]>, start_ts: impl Into<TimeStamp>) {\n        let keys: Vec<Key> = keys.iter().map(|x| Key::from_raw(x)).collect();\n        self.store\n            .rollback(self.ctx.clone(), keys, start_ts.into())\n            .unwrap_err();\n    }", "test": "fn test_txn_store_cleanup_commit() {\n    let store = AssertionStorage::default();\n    store.put_ok(b\"secondary\", b\"s-0\", 1, 2);\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"p-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n        ],\n        b\"primary\",\n        5,\n    );\n    store.get_err(b\"secondary\", 8);\n    store.get_err(b\"secondary\", 12);\n    store.commit_ok(vec![b\"primary\"], 5, 10, 10);\n    store.cleanup_err(b\"primary\", 5, 0);\n    store.rollback_err(vec![b\"primary\"], 5);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_non_existing_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_chmod_non_existing_file() {\n    new_ucmd!()\n        .arg(\"-R\")\n        .arg(\"-r,a+w\")\n        .arg(\"does-not-exist\")\n        .fails()\n        .stderr_contains(\"cannot access 'does-not-exist': No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_ascii_10k_to_stdout", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_ascii_10k_to_stdout() {\n    let output = build_ascii_block(1024 * 1024);\n    // build_test_file!(\"ascii-10k.txt\", &output);\n    let output = String::from_utf8(output).unwrap();\n\n    new_ucmd!()\n        .args(&[\"status=none\", \"if=ascii-10k.txt\"])\n        .run()\n        .no_stderr()\n        .stdout_is(output)\n        .success();\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_stateless_reset", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn server_stateless_reset() {\n    let _guard = subscribe();\n    let mut reset_key = vec![0; 64];\n    let mut rng = rand::thread_rng();\n    rng.fill_bytes(&mut reset_key);\n    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);\n\n    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));\n\n    let mut pair = Pair::new(endpoint_config.clone(), server_config());\n    let (client_ch, _) = pair.connect();\n    pair.drive(); // Flush any post-handshake frames\n    pair.server.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);\n    // Force the server to generate the smallest possible stateless reset\n    pair.client.connections.get_mut(&client_ch).unwrap().ping();\n    info!(\"resetting\");\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::Reset\n        })\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/ctor.rs::new_engine_missing_dir", "code": "pub fn sync(&mut self) -> Result<()> {\n        if self.enable_log {\n            self.append_file.as_mut().unwrap().sync_all()?;\n        }\n        Ok(())\n    }", "test": "fn new_engine_missing_dir() {\n    let dir = tempdir();\n    let path = dir.path();\n    let path = path.join(\"missing\").to_str().unwrap().to_owned();\n    let db = KvTestEngine::new_kv_engine(&path, ALL_CFS).unwrap();\n    db.put(b\"foo\", b\"bar\").unwrap();\n    db.sync().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_comma_with_plus_2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_comma_with_plus_2() {\n    new_ucmd!()\n        .args(&[\"--tabs=1,+5\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\" a    b    c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_negative_indexing", "code": "pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    }", "test": "fn test_negative_indexing() {\n    let positive_lines_index = new_ucmd!().arg(\"-n\").arg(\"5\").arg(FOOBAR_TXT).run();\n\n    let negative_lines_index = new_ucmd!().arg(\"-n\").arg(\"-5\").arg(FOOBAR_TXT).run();\n\n    let positive_bytes_index = new_ucmd!().arg(\"-c\").arg(\"20\").arg(FOOBAR_TXT).run();\n\n    let negative_bytes_index = new_ucmd!().arg(\"-c\").arg(\"-20\").arg(FOOBAR_TXT).run();\n\n    assert_eq!(positive_lines_index.stdout(), negative_lines_index.stdout());\n    assert_eq!(positive_bytes_index.stdout(), negative_bytes_index.stdout());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/failpoints/test_split.rs::test_restart_resume", "code": "pub fn get_tablet_index(&self) -> u64 {\n        self.tablet_index\n    }", "test": "fn test_restart_resume() {\n    let mut cluster = Cluster::default();\n    let raft_engine = cluster.node(0).running_state().unwrap().raft_engine.clone();\n    let router = &mut cluster.routers[0];\n\n    let region_id = 2;\n    let region = router.region_detail(region_id);\n    let peer = region.get_peers()[0].clone();\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    let fp = \"async_write_before_cb\";\n    fail::cfg(fp, \"return\").unwrap();\n\n    let split_region_id = 1000;\n    let mut new_peer = peer.clone();\n    new_peer.set_id(1001);\n    split_region(\n        router,\n        region,\n        peer,\n        split_region_id,\n        new_peer,\n        None,\n        None,\n        b\"k11\",\n        b\"k11\",\n        true,\n    );\n\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"k22\", b\"value\");\n    let header = Box::new(router.new_request_for(region_id).take_header());\n    let (msg, mut sub) = PeerMsg::simple_write(header, put.encode());\n    router.send(region_id, msg).unwrap();\n    // Send a command to ensure split init is triggered.\n    block_on(sub.wait_proposed());\n\n    let region_state = raft_engine\n        .get_region_state(split_region_id, u64::MAX)\n        .unwrap()\n        .unwrap();\n    assert_eq!(region_state.get_tablet_index(), RAFT_INIT_LOG_INDEX);\n    let path = cluster\n        .node(0)\n        .tablet_registry()\n        .tablet_path(split_region_id, RAFT_INIT_LOG_INDEX);\n    assert!(!path.exists(), \"{} should not exist\", path.display());\n    drop(raft_engine);\n\n    cluster.restart(0);\n    // If split is resumed, the tablet should be installed.\n    assert!(\n        path.exists(),\n        \"{} should exist after restart\",\n        path.display()\n    );\n\n    // Both region should be recovered correctly.\n    let cases = vec![\n        (split_region_id, b\"k01\", b\"v01\"),\n        (region_id, b\"k21\", b\"v21\"),\n    ];\n    let router = &mut cluster.routers[0];\n    let new_epoch = router\n        .new_request_for(split_region_id)\n        .take_header()\n        .take_region_epoch();\n    // Split will be resumed for region 2, not removing the fp will make write block\n    // forever.\n    fail::remove(fp);\n    let timer = Instant::now();\n    for (region_id, key, val) in cases {\n        let mut put = SimpleWriteEncoder::with_capacity(64);\n        put.put(CF_DEFAULT, key, val);\n        let mut header = Box::new(router.new_request_for(region_id).take_header());\n        while timer.elapsed() < Duration::from_secs(3) {\n            // We need to wait till source peer replay split.\n            if *header.get_region_epoch() != new_epoch {\n                thread::sleep(Duration::from_millis(100));\n                header = Box::new(router.new_request_for(region_id).take_header());\n                continue;\n            }\n            break;\n        }\n        assert_eq!(*header.get_region_epoch(), new_epoch, \"{:?}\", header);\n        let (msg, sub) = PeerMsg::simple_write(header, put.encode());\n        router.send(region_id, msg).unwrap();\n        // Send a command to ensure split init is triggered.\n        let resp = block_on(sub.result()).unwrap();\n        assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_elements_static", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_elements_static() {\n    test_formatting(\n        r#\"\n        class A {\n            static a;\n            static b = 1;\n            static c() {}\n            static d(a, b, c) {\n                return a + b + c;\n            }\n            static set e(value) {}\n            static get e() {}\n        }\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_no_permission", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_no_permission() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.mkdir_all(SUB_DIR_LINKS);\n\n    ts.ccmd(\"chmod\").arg(\"-r\").arg(SUB_DIR_LINKS).succeeds();\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).fails();\n    result.stderr_contains(\"du: cannot read directory 'subdir/links': Permission denied\");\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference\n            .stderr_str()\n            .contains(\"du: cannot read directory 'subdir/links': Permission denied\")\n        {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n\n    _du_no_permission(result.stdout_str());\n}"}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/parse_self.rs::test_parse_self_debug_info", "code": "fn impl_parse_self_debug_info<R: gimli::Reader>(\n    debug_info: &DebugInfo<R>,\n    debug_abbrev: &DebugAbbrev<R>,\n) {\n    let mut iter = debug_info.units();\n    while let Some(unit) = iter.next().expect(\"Should parse compilation unit\") {\n        let abbrevs = unit\n            .abbreviations(&debug_abbrev)\n            .expect(\"Should parse abbreviations\");\n\n        let mut cursor = unit.entries(&abbrevs);\n\n        while cursor.next_dfs().expect(\"Should parse next dfs\").is_some() {\n            let entry = cursor.current().expect(\"Should have a current entry\");\n\n            let mut attrs = entry.attrs();\n            while let Some(attr) = attrs.next().expect(\"Should parse entry's attribute\") {\n                if let AttributeValue::Exprloc(expression) = attr.value() {\n                    parse_expression(expression, unit.encoding());\n                }\n            }\n        }\n    }\n}", "test": "fn test_parse_self_debug_info() {\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = DebugInfo::new(&debug_info, LittleEndian);\n\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);\n\n    impl_parse_self_debug_info(&debug_info, &debug_abbrev);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::as_header_name", "code": "pub fn get<K2: PartialEq<K> + ?Sized>(&self, key: &K2) -> Option<&V> {\n        self.find(key).map(move |pos| &self.vec[pos].1)\n    }", "test": "fn as_header_name() {\n    let mut m = HeaderMap::new();\n    let v: HeaderValue = \"localhost\".parse().unwrap();\n    m.insert(HOST, v.clone());\n\n    let expected = Some(&v);\n\n    assert_eq!(m.get(\"host\"), expected);\n    assert_eq!(m.get(&HOST), expected);\n\n    let s = String::from(\"host\");\n    assert_eq!(m.get(&s), expected);\n    assert_eq!(m.get(s.as_str()), expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_empty_name", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_empty_name() {\n    new_ucmd!()\n        .arg(\"-i\")\n        .arg(\"=xyz\")\n        .run()\n        .stderr_only(\"env: warning: no name specified for value 'xyz'\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_chroot_extra_arg", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_chroot_extra_arg() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let dir = \"CHROOT_DIR\";\n    at.mkdir(dir);\n    let env_cd = std::env::current_dir().unwrap();\n    // Verify that -P is pwd's and not chroot\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"pwd\", \"-P\"]) {\n        assert_eq!(\n            result.success().no_stderr().stdout_str(),\n            env_cd.to_str().unwrap()\n        );\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_reject_proposal_during_rollback_region_merge", "code": "fn assert_ok(&mut self) {\n        self.assert_applied_ok();\n        // proposed and committed should be invoked before applied\n        self.proposed.try_recv().unwrap();\n        self.committed.try_recv().unwrap();\n    }", "test": "fn test_reject_proposal_during_rollback_region_merge() {\n    let mut cluster = new_node_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n    cluster.run_conf_change();\n\n    let r = cluster.get_region(b\"\");\n    cluster.must_split(&r, b\"k\");\n\n    // Don't enter the second phase of region merge.\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    let source = cluster.get_region(b\"\");\n    let target = cluster.get_region(b\"k\");\n    // The call is finished when prepare_merge is applied.\n    cluster.must_try_merge(source.get_id(), target.get_id());\n\n    // Add a peer to trigger rollback.\n    pd_client.must_add_peer(target.get_id(), new_peer(2, 4));\n    cluster.must_put(b\"k\", b\"v\");\n    must_get_equal(&cluster.get_engine(1), b\"k\", b\"v\");\n\n    // Pause on applying so that rolling back merge is not finished.\n    let rollback_merge_fp = \"apply_before_rollback_merge\";\n    fail::cfg(rollback_merge_fp, \"pause\").unwrap();\n    fail::remove(schedule_merge_fp);\n    sleep_ms(200);\n\n    // Write request is rejected because the source region is merging.\n    // It's not handled by epoch checker now.\n    let force_delay_propose_batch_raft_command_fp = \"force_delay_propose_batch_raft_command\";\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"a\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        cb_receivers.assert_err();\n    }\n\n    fail::remove(rollback_merge_fp);\n    // Make sure the rollback is done.\n    cluster.must_put(b\"a\", b\"v\");\n\n    // New write request can succeed.\n    let write_req = make_write_req(&mut cluster, b\"a\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    cb_receivers.assert_ok();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_destroy_source_peer_while_merging", "code": "pub fn get_state(&self) -> Arc<AtomicCell<DownstreamState>> {\n        self.state.clone()\n    }", "test": "fn test_destroy_source_peer_while_merging() {\n    let mut cluster = new_node_cluster(0, 5);\n    configure_for_merge(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    for i in 1..=5 {\n        must_get_equal(&cluster.get_engine(i), b\"k1\", b\"v1\");\n        must_get_equal(&cluster.get_engine(i), b\"k3\", b\"v3\");\n    }\n\n    cluster.must_split(&pd_client.get_region(b\"k1\").unwrap(), b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n    cluster.must_transfer_leader(right.get_id(), new_peer(1, 1));\n\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    // Start merge and wait until peer 5 apply prepare merge\n    cluster.must_try_merge(right.get_id(), left.get_id());\n    cluster.must_peer_state(right.get_id(), 5, PeerState::Merging);\n\n    // filter heartbeat and append message for peer 5\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(right.get_id(), 5)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgHeartbeat)\n            .msg_type(MessageType::MsgAppend),\n    ));\n\n    // remove peer from target region to trigger merge rollback.\n    pd_client.must_remove_peer(left.get_id(), find_peer(&left, 2).unwrap().clone());\n    must_get_none(&cluster.get_engine(2), b\"k1\");\n\n    // Merge must rollbacked if we can put more data to the source region\n    fail::remove(schedule_merge_fp);\n    cluster.must_put(b\"k4\", b\"v4\");\n    for i in 1..=4 {\n        must_get_equal(&cluster.get_engine(i), b\"k4\", b\"v4\");\n    }\n\n    // remove peer 5 from peer list so it will destroy itself by tombstone message\n    // and should not persist the `merge_state`\n    pd_client.must_remove_peer(right.get_id(), new_peer(5, 5));\n    must_get_none(&cluster.get_engine(5), b\"k3\");\n\n    // so that other peers will send message to store 5\n    pd_client.must_add_peer(right.get_id(), new_peer(5, 6));\n    // but it is still in tombstone state due to the message filter\n    let state = cluster.region_local_state(right.get_id(), 5);\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // let the peer on store 4 have a larger peer id\n    pd_client.must_remove_peer(right.get_id(), new_peer(4, 4));\n    pd_client.must_add_peer(right.get_id(), new_peer(4, 7));\n    must_get_equal(&cluster.get_engine(4), b\"k4\", b\"v4\");\n\n    // if store 5 have persist the merge state, peer 2 and peer 3 will be destroyed\n    // because store 5 will response their request vote message with a gc\n    // message, and peer 7 will cause store 5 panic because peer 7 have larger\n    // peer id than the peer in the merge state\n    cluster.clear_send_filters();\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n\n    cluster.must_put(b\"k5\", b\"v5\");\n    assert!(!state.has_merge_state(), \"{:?}\", state);\n    for i in 2..=5 {\n        must_get_equal(&cluster.get_engine(i), b\"k5\", b\"v5\");\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_alter_partition", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_alter_partition() {\n    let alter = \"ALTER TABLE db.table PARTITION (a = 2) RENAME TO PARTITION (a = 1)\";\n    hive().verified_stmt(alter);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_extra_operand", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_extra_operand() {\n    new_ucmd!()\n        .args(&[\"-c\", \"file1\", \"file2\"])\n        .fails()\n        .stderr_contains(\"dircolors: extra operand 'file2'\\n\")\n        .no_stdout();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::reopen_table", "code": "pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    }", "test": "fn reopen_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"0\", \"0\").unwrap();\n    }\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"1\", \"1\").unwrap();\n    }\n    write_txn.commit().unwrap();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_add_partition", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_add_partition() {\n    let add = \"ALTER TABLE db.table ADD IF NOT EXISTS PARTITION (a = 'asdf', b = 2)\";\n    hive().verified_stmt(add);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query", "code": "pub fn eq_case(&self, other: &Self) -> bool {\n        self.cmp_with_f::<CaseSensitive>(other) == Ordering::Equal\n    }", "test": "fn test_query(client: &mut AsyncClient) -> impl Future<Output = ()> {\n    let name = Name::from_ascii(\"WWW.example.com\").unwrap();\n\n    client\n        .query(name.clone(), DNSClass::IN, RecordType::A)\n        .map_ok(move |response| {\n            println!(\"response records: {response:?}\");\n            assert!(response\n                .queries()\n                .first()\n                .expect(\"expected query\")\n                .name()\n                .eq_case(&name));\n\n            let record = &response.answers()[0];\n            assert_eq!(record.name(), &name);\n            assert_eq!(record.record_type(), RecordType::A);\n            assert_eq!(record.dns_class(), DNSClass::IN);\n\n            if let RData::A(ref address) = record.data().unwrap() {\n                assert_eq!(address, &A::new(93, 184, 216, 34))\n            } else {\n                panic!();\n            }\n        })\n        .map(|r: Result<_, _>| r.expect(\"query failed\"))\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_fold_before_tab_with_narrow_width", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_fold_before_tab_with_narrow_width() {\n    new_ucmd!()\n        .args(&[\"-w7\", \"-b\"])\n        .pipe_in(\"a\\t1\")\n        .succeeds()\n        .stdout_is(\"a\\t1\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_make_temp_dir", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mktemp_make_temp_dir() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE6)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE7)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-d\")\n        .arg(TEST_TEMPLATE8)\n        .fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_tab", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_tab() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\t\"])\n        .succeeds()\n        .stdout_only(\"\\t\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_no_match1", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_no_match1() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_cert_resolve_reduces_sigalgs_for_ecdsa_ciphersuite", "code": "fn check_sigalgs_reduced_by_ciphersuite(\n    kt: KeyType,\n    suite: CipherSuite,\n    expected_sigalgs: Vec<SignatureScheme>,\n) {\n    let client_config = finish_client_config(\n        kt,\n        ClientConfig::builder()\n            .with_cipher_suites(&[find_suite(suite)])\n            .with_safe_default_kx_groups()\n            .with_safe_default_protocol_versions()\n            .unwrap(),\n    );\n\n    let mut server_config = make_server_config(kt);\n\n    server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n        expected_sigalgs: Some(expected_sigalgs),\n        expected_cipher_suites: Some(vec![suite, CipherSuite::TLS_EMPTY_RENEGOTIATION_INFO_SCSV]),\n        ..Default::default()\n    });\n\n    let mut client = ClientConnection::new(Arc::new(client_config), dns_name(\"localhost\")).unwrap();\n    let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n    let err = do_handshake_until_error(&mut client, &mut server);\n    assert!(err.is_err());\n}", "test": "fn server_cert_resolve_reduces_sigalgs_for_ecdsa_ciphersuite() {\n    check_sigalgs_reduced_by_ciphersuite(\n        KeyType::Ecdsa,\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n        vec![\n            SignatureScheme::ECDSA_NISTP384_SHA384,\n            SignatureScheme::ECDSA_NISTP256_SHA256,\n            SignatureScheme::ED25519,\n        ],\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_drop_schema_if_exists", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_drop_schema_if_exists() {\n    let sql = \"DROP SCHEMA IF EXISTS schema_name\";\n    let ast = pg().verified_stmt(sql);\n    match ast {\n        Statement::Drop {\n            object_type,\n            if_exists: true,\n            ..\n        } => assert_eq!(object_type, ObjectType::Schema),\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_5", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_5() {\n    let original = r##\"| abc | def |\n| --- | --- |\n| bar | baz |\nbar\n\nbar\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bar</td>\n<td>baz</td>\n</tr>\n<tr>\n<td>bar</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>bar</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_38", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_38() {\n    let original = r##\"# horizontal tab    \n# horizontal tab    {#ht}\n## form feed\f\n## form feed\f{#ff}\n### vertical tab\u000b\n### vertical tab\u000b{#vt}\n\"##;\n    let expected = r##\"<h1>horizontal tab    </h1>\n<h1 id=\"ht\">horizontal tab    </h1>\n<h2>form feed\f</h2>\n<h2 id=\"ff\">form feed\f</h2>\n<h3>vertical tab\u000b</h3>\n<h3 id=\"vt\">vertical tab\u000b</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_filter_basics", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "test": "fn test_filter_basics() {\n    fn test(a: u32, b: u32) -> Result<u32, Error> {\n        Ok(a + b)\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"test\", test);\n    assert_eq!(\n        env.empty_state()\n            .apply_filter(\"test\", args!(23, 42))\n            .unwrap(),\n        Value::from(65)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_source_peer_read_delegate_after_apply", "code": "pub fn lock(\n            &mut self,\n            pk: &[u8],\n            start_ts: impl Into<TimeStamp>,\n            commit_ts: impl Into<TimeStamp>,\n        ) {\n            let start_ts = start_ts.into();\n            let m = Mutation::make_lock(Key::from_raw(pk));\n            self.prewrite(m, pk, start_ts);\n            self.commit(pk, start_ts, commit_ts);\n        }", "test": "fn test_source_peer_read_delegate_after_apply() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_split(&cluster.get_region(b\"\"), b\"k2\");\n    let target = cluster.get_region(b\"k1\");\n    let source = cluster.get_region(b\"k3\");\n\n    cluster.must_transfer_leader(target.get_id(), find_peer(&target, 1).unwrap().to_owned());\n\n    let on_destroy_peer_fp = \"destroy_peer\";\n    fail::cfg(on_destroy_peer_fp, \"pause\").unwrap();\n\n    // Merge finish means the leader of the target region have call\n    // `on_ready_commit_merge`\n    pd_client.must_merge(source.get_id(), target.get_id());\n\n    // The source peer's `ReadDelegate` should not be removed yet and mark as\n    // `pending_remove`\n    assert!(\n        cluster.store_metas[&1]\n            .lock()\n            .unwrap()\n            .readers\n            .get(&source.get_id())\n            .unwrap()\n            .pending_remove\n    );\n\n    fail::remove(on_destroy_peer_fp);\n    // Wait for source peer is destroyed\n    sleep_ms(100);\n\n    assert!(\n        cluster.store_metas[&1]\n            .lock()\n            .unwrap()\n            .readers\n            .get(&source.get_id())\n            .is_none()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_dangling_directory", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_dangling_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_dangling_dir\";\n    let link = \"test_symlink_dangling_dir_link\";\n\n    ucmd.args(&[\"-s\", dir, link]).succeeds().no_stderr();\n    assert!(!at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_top", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_mssql_top() {\n    let sql = \"SELECT TOP 5 bar, baz FROM foo\";\n    let _ = ms_and_generic().one_statement_parses_to(sql, \"SELECT TOP (5) bar, baz FROM foo\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_prompt_learner", "code": "pub fn must_add_peer(&self, region_id: u64, peer: metapb::Peer) {\n        self.add_peer(region_id, peer.clone());\n        self.must_have_peer(region_id, peer);\n    }", "test": "fn test_prompt_learner() {\n    let mut cluster = new_server_cluster(0, 4);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(20);\n    cluster.pd_client.disable_default_operator();\n    cluster.run_conf_change();\n    cluster.pd_client.must_add_peer(1, new_peer(2, 2));\n    cluster.pd_client.must_add_peer(1, new_peer(3, 3));\n\n    cluster.pd_client.must_add_peer(1, new_learner_peer(4, 4));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n\n    // Suppose there is only one way partition.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).direction(Direction::Send),\n    ));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 4).direction(Direction::Send),\n    ));\n    let idx = cluster.truncated_state(1, 1).get_index();\n    // Trigger a log compaction.\n    for i in 0..cluster.cfg.raft_store.raft_log_gc_count_limit() * 2 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), format!(\"v{}\", i).as_bytes());\n    }\n    cluster.wait_log_truncated(1, 1, idx + 1);\n    // Wait till leader peer goes to sleep again.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n    cluster.clear_send_filters();\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).direction(Direction::Send),\n    ));\n    cluster.pd_client.must_add_peer(1, new_peer(4, 4));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_padding_without_overflow", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_padding_without_overflow() {\n    new_ucmd!()\n        .args(&[\"-i\", \"1000\", \"-s\", \"x\", \"-n\", \"rz\", \"simple.txt\"])\n        .run()\n        .stdout_is(\n            \"000001xL1\\n001001xL2\\n002001xL3\\n003001xL4\\n004001xL5\\n005001xL6\\n006001xL7\\n0070\\\n             01xL8\\n008001xL9\\n009001xL10\\n010001xL11\\n011001xL12\\n012001xL13\\n013001xL14\\n014\\\n             001xL15\\n\",\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_switch_witness", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_witness_switch_witness() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // nonwitness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    std::thread::sleep(Duration::from_millis(100));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    // witness -> non-witness\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![false],\n    );\n\n    std::thread::sleep(Duration::from_millis(100));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_carriage_return_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_carriage_return_should_be_preserved() {\n    new_ucmd!().pipe_in(\"\\r\").succeeds().stdout_is(\"\\r\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_number", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse_number() {\n    parse(\"255\").unwrap_err();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::wrapping_octal", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn wrapping_octal() {\n    // Some odd behavior of GNU. Values of \\0400 and greater do not fit in the\n    // u8 that we write to stdout. So we test that it wraps:\n    //\n    // We give it this input:\n    //     \\o501 = 1_0100_0001 (yes, **9** bits)\n    // This should be wrapped into:\n    //     \\o101 = 'A' = 0100_0001,\n    // because we only write a single character\n    new_ucmd!()\n        .arg(\"-e\")\n        .arg(\"\\\\0501\")\n        .succeeds()\n        .stdout_is(\"A\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_email", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_date_email() {\n    for param in [\"--rfc-email\", \"--rfc-e\", \"-R\"] {\n        new_ucmd!().arg(param).succeeds();\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::compare_test", "code": "pub fn compare(x: &[Limb], y: &[Limb]) -> cmp::Ordering {\n        if x.len() > y.len() {\n            cmp::Ordering::Greater\n        } else if x.len() < y.len() {\n            cmp::Ordering::Less\n        } else {\n            let iter = x.iter().rev().zip(y.iter().rev());\n            for (&xi, &yi) in iter {\n                if xi > yi {\n                    return cmp::Ordering::Greater;\n                } else if xi < yi {\n                    return cmp::Ordering::Less;\n                }\n            }\n            // Equal case.\n            cmp::Ordering::Equal\n        }\n    }", "test": "fn compare_test() {\n    // Simple\n    let x = Bigint {\n        data: from_u32(&[1]),\n    };\n    let y = Bigint {\n        data: from_u32(&[2]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Less);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Greater);\n\n    // Check asymmetric\n    let x = Bigint {\n        data: from_u32(&[5, 1]),\n    };\n    let y = Bigint {\n        data: from_u32(&[2]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n\n    // Check when we use reverse ordering properly.\n    let x = Bigint {\n        data: from_u32(&[5, 1, 9]),\n    };\n    let y = Bigint {\n        data: from_u32(&[6, 2, 8]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = Bigint {\n        data: from_u32(&[0, 1, 9]),\n    };\n    let y = Bigint {\n        data: from_u32(&[4294967295, 0, 9]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_basic_upgrade_test", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "test": "fn eph_basic_upgrade_test() {\n    run_test(|| {\n        let init_gc = Gc::new(String::from(\"foo\"));\n\n        let weak = WeakGc::new(&init_gc);\n\n        let new_gc = weak.upgrade().expect(\"Weak is still live\");\n\n        drop(weak);\n        force_collect();\n\n        assert_eq!(*init_gc, *new_gc);\n    });\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_u64", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_parse_u64() {\n    test_parse_ok(vec![\n        (\"0\", 0u64),\n        (\"3\", 3u64),\n        (\"1234\", 1234),\n        (&u64::MAX.to_string(), u64::MAX),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_backspace_should_not_decrease_column_count_past_zero", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_backspace_should_not_decrease_column_count_past_zero() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"1\\x08\\x083456\")\n        .succeeds()\n        .stdout_is(\"1\\x08\\x0834\\n56\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_vm.rs::test_error_info", "code": "pub fn name(&self) -> Option<&str> {\n        self.repr.name.as_deref()\n    }", "test": "fn test_error_info() {\n    let mut c = CodeGenerator::new(\"hello.html\", \"\");\n    c.set_line(1);\n    c.add(Instruction::EmitRaw(\"<h1>Hello</h1>\\n\"));\n    c.set_line(2);\n    c.add(Instruction::Lookup(\"a_string\"));\n    c.add(Instruction::Lookup(\"an_int\"));\n    c.add(Instruction::Add);\n\n    let mut ctx = std::collections::BTreeMap::new();\n    ctx.insert(\"a_string\", Value::from(\"foo\"));\n    ctx.insert(\"an_int\", Value::from(42));\n\n    let err = simple_eval(&c.finish().0, ctx).unwrap_err();\n    assert_eq!(err.name(), Some(\"hello.html\"));\n    assert_eq!(err.line(), Some(2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_ls", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_ls_ls() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/convert_self.rs::test_convert_eh_frame", "code": "pub fn cie_count(&self) -> usize {\n        self.cies.len()\n    }", "test": "fn test_convert_eh_frame() {\n    // Convert existing section\n    let eh_frame = read_section(\"eh_frame\");\n    let mut eh_frame = read::EhFrame::new(&eh_frame, LittleEndian);\n    // The `.eh_frame` fixture data was created on a 64-bit machine.\n    eh_frame.set_address_size(8);\n    let frames = write::FrameTable::from(&eh_frame, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert eh_frame information\");\n    assert_eq!(frames.cie_count(), 2);\n    assert_eq!(frames.fde_count(), 3482);\n\n    // Write to new section\n    let mut write_eh_frame = write::EhFrame(EndianVec::new(LittleEndian));\n    frames\n        .write_eh_frame(&mut write_eh_frame)\n        .expect(\"Should write eh_frame information\");\n    let eh_frame = write_eh_frame.slice();\n    assert_eq!(eh_frame.len(), 147144);\n\n    // Convert new section\n    let mut eh_frame = read::EhFrame::new(&eh_frame, LittleEndian);\n    eh_frame.set_address_size(8);\n    let frames = write::FrameTable::from(&eh_frame, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert eh_frame information\");\n    assert_eq!(frames.cie_count(), 2);\n    assert_eq!(frames.fde_count(), 3482);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_with_owner", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_target_new_file_with_owner() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n    let uid = geteuid();\n\n    at.touch(file);\n    at.mkdir(dir);\n    let result = ucmd\n        .arg(file)\n        .arg(\"--owner\")\n        .arg(uid.to_string())\n        .arg(format!(\"{dir}/{file}\"))\n        .run();\n\n    if is_ci() && result.stderr_str().contains(\"no such user:\") {\n        // In the CI, some server are failing to return the user id.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_lt", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_lt() {\n    // Test iterators that skip single, leading or trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4__5_.56\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/restore.rs::restore_generates_same_descriptors_with_passphrase", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn restore_generates_same_descriptors_with_passphrase() {\n  let passphrase = \"foo\";\n  let (mnemonic, descriptors) = {\n    let rpc_server = test_bitcoincore_rpc::spawn();\n\n    let create::Output { mnemonic, .. } =\n      CommandBuilder::new([\"wallet\", \"create\", \"--passphrase\", passphrase])\n        .rpc_server(&rpc_server)\n        .run_and_deserialize_output();\n\n    (mnemonic, rpc_server.descriptors())\n  };\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new([\n    \"wallet\",\n    \"restore\",\n    \"--passphrase\",\n    passphrase,\n    &mnemonic.to_string(),\n  ])\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Empty>();\n\n  assert_eq!(rpc_server.descriptors(), descriptors);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_to_stdout_with_ibs_obs", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_to_stdout_with_ibs_obs() {\n    let output: Vec<_> = String::from(\"y\\n\").bytes().cycle().take(1024).collect();\n    let output = String::from_utf8(output).unwrap();\n\n    new_ucmd!()\n        .args(&[\"status=none\", \"if=y-nl-1k.txt\", \"ibs=521\", \"obs=1031\"])\n        .run()\n        .no_stderr()\n        .stdout_is(output)\n        .success();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::no_lint_if_linter_is_disabled", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn no_lint_if_linter_is_disabled() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_failing_omitting_directory", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_failing_omitting_directory() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file1 = \"file1\";\n    let dir1 = \"dir1\";\n    let no_dir2 = \"no-dir2\";\n    let dir3 = \"dir3\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir3);\n    at.touch(file1);\n\n    // GNU install checks for existing target dir first before checking on source params\n    scene\n        .ucmd()\n        .arg(file1)\n        .arg(dir1)\n        .arg(no_dir2)\n        .fails()\n        .stderr_contains(\"is not a directory\");\n\n    // file1 will be copied before install fails on dir1\n    scene\n        .ucmd()\n        .arg(file1)\n        .arg(dir1)\n        .arg(dir3)\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"omitting directory\");\n    assert!(at.file_exists(format!(\"{dir3}/{file1}\")));\n\n    // install also fails, when only one source param is given\n    scene\n        .ucmd()\n        .arg(dir1)\n        .arg(dir3)\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"omitting directory\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i64_min", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_i64_min() {\n    assert_eq!(\n        std::i64::MIN,\n        from_str(&to_string(&std::i64::MIN).unwrap()).unwrap()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_empty_directory_with_parents", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_empty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n\n    ucmd.arg(\"-p\").arg(NESTED_DIR).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(NESTED_DIR));\n    assert!(!at.dir_exists(DIR));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_del_select", "code": "pub fn get_scan_detail_v2(&self) -> &ScanDetailV2 {\n        self.scan_detail_v2.as_ref().unwrap_or_else(|| ScanDetailV2::default_instance())\n    }", "test": "fn test_del_select() {\n    let mut data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:3\"), 3),\n        (4, Some(\"name:0\"), 1),\n        (5, Some(\"name:5\"), 4),\n        (6, Some(\"name:5\"), 4),\n        (7, None, 4),\n    ];\n\n    let product = ProductTable::new();\n    let (mut store, endpoint) = init_with_data(&product, &data);\n\n    store.begin();\n    let (id, name, cnt) = data.remove(3);\n    let name_datum = name.map(|s| s.as_bytes()).into();\n    store\n        .delete_from(&product)\n        .execute(id, vec![id.into(), name_datum, cnt.into()]);\n    store.commit();\n\n    // for dag\n    let mut req = DagSelect::from_index(&product, &product[\"id\"]).build();\n    req.mut_context().set_record_scan_stat(true);\n\n    let resp = handle_request(&endpoint, req);\n    let mut sel_resp = SelectResponse::default();\n    sel_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let spliter = DagChunkSpliter::new(sel_resp.take_chunks().into(), 1);\n    let mut row_count = 0;\n    for _ in spliter {\n        row_count += 1;\n    }\n    assert_eq!(row_count, 5);\n\n    assert!(resp.get_exec_details_v2().has_time_detail());\n    assert!(resp.get_exec_details_v2().has_time_detail_v2());\n    let scan_detail_v2 = resp.get_exec_details_v2().get_scan_detail_v2();\n    assert_eq!(scan_detail_v2.get_total_versions(), 8);\n    assert_eq!(scan_detail_v2.get_processed_versions(), 5);\n    assert!(scan_detail_v2.get_processed_versions_size() > 0);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::leaves_necessary_whitespace_alone", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn leaves_necessary_whitespace_alone() {\n    assert_eq!(\"<u>a</u> b <u>c</u>\", normalize_html(\"<u>a</u> b <u>c</u>\"))\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_push_pop", "code": "pub fn push(&mut self, val: A::Item) {\n    let x = self.try_push(val);\n    assert!(x.is_none(), \"ArrayVec::push> capacity overflow!\");\n  }", "test": "fn ArrayVec_push_pop() {\n  let mut av: ArrayVec<[i32; 4]> = Default::default();\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n\n  av.push(10_i32);\n  assert_eq!(av.len(), 1);\n  assert_eq!(av[0], 10);\n  assert_eq!(av.pop(), Some(10));\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n\n  av.push(10);\n  av.push(11);\n  av.push(12);\n  av.push(13);\n  assert_eq!(av[0], 10);\n  assert_eq!(av[1], 11);\n  assert_eq!(av[2], 12);\n  assert_eq!(av[3], 13);\n  assert_eq!(av.len(), 4);\n  assert_eq!(av.pop(), Some(13));\n  assert_eq!(av.len(), 3);\n  assert_eq!(av.pop(), Some(12));\n  assert_eq!(av.len(), 2);\n  assert_eq!(av.pop(), Some(11));\n  assert_eq!(av.len(), 1);\n  assert_eq!(av.pop(), Some(10));\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_none", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=none\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_hosts", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_lookup_hosts() {\n    let authority = create_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let mut hosts = Hosts::default();\n    let record = Record::from_rdata(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        86400,\n        RData::A(A::new(10, 0, 1, 104)),\n    );\n    hosts.insert(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        RecordType::A,\n        Lookup::new_with_max_ttl(\n            Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A),\n            Arc::from([record]),\n        ),\n    );\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(hosts)),\n        None,\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(lookup.iter().next().unwrap(), Ipv4Addr::new(10, 0, 1, 104));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_stdin_explicit", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_stdin_explicit() {\n    new_ucmd!()\n        .pipe_in_fixture(\"lorem_ipsum.txt\")\n        .arg(\"-\")\n        .run()\n        .stdout_is(\"     13     109     772 -\\n\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::error_message_when_parsing_cbor_metadata_is_reasonable", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn error_message_when_parsing_cbor_metadata_is_reasonable() {\n  CommandBuilder::new(\n    \"wallet inscribe --fee-rate 1 --cbor-metadata metadata.cbor --file content.png\",\n  )\n  .write(\"content.png\", [1; 520])\n  .write(\"metadata.cbor\", [0x61])\n  .stderr_regex(\".*failed to parse CBOR metadata.*\")\n  .expected_exit_code(1)\n  .run_and_extract_stdout();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_extends_no_string", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_extends_no_string() {\n    assert_err_msg(\"{% extends 1 %}\", &[\"1:12\", \"expected a string\"]);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::apply_unsafe_with_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn apply_unsafe_with_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    // last line doesn't have code fix\n    let source = \"let a = 4;\ndebugger;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let expected = \"const a = 4;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let test1 = Path::new(\"test1.js\");\n    fs.insert(test1.into(), source.as_bytes());\n\n    let test2 = Path::new(\"test2.js\");\n    fs.insert(test2.into(), source.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply-unsafe\"),\n                test1.as_os_str().to_str().unwrap(),\n                test2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(test1)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, expected);\n    drop(file);\n\n    content.clear();\n\n    let mut file = fs\n        .open(test2)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_unsafe_with_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/modules.rs::test_exports", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_exports() {\n    let test = SemanticTester::js(\n        \"\n        function foo(a, b) {\n            let c = a + b;\n            return c / 2\n        }\n\n        export class ExportModifier {\n            constructor(x) {\n                this.x = x;\n            }\n        }\n\n        const defaultExport = 1;\n\n        export { foo };\n        export default defaultExport;\n        \",\n    );\n\n    test.has_some_symbol(\"foo\").is_exported().test();\n\n    // FIXME: failing\n    // test.has_some_symbol(\"defaultExport\").is_exported().test();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_macro_content", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_macro_content() {\n    assert_err_msg(\n        r#\"\n{% macro input(label, type) %}\n    {% macro nested() %}\n    {% endmacro nested %}\n{% endmacro input %}\n    \"#,\n        &[\"3:5\", \"unexpected tag; expected `{% endmacro %}` or the macro content\"],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_turnoff_warmup_entry_cache", "code": "pub fn must_transfer_leader(&mut self, region_id: u64, leader: metapb::Peer) {\n        let timer = Instant::now();\n        loop {\n            self.reset_leader_of_region(region_id);\n            let cur_leader = self.leader_of_region(region_id);\n            if let Some(ref cur_leader) = cur_leader {\n                if cur_leader.get_id() == leader.get_id()\n                    && cur_leader.get_store_id() == leader.get_store_id()\n                {\n                    return;\n                }\n            }\n            if timer.saturating_elapsed() > Duration::from_secs(5) {\n                panic!(\n                    \"failed to transfer leader to [{}] {:?}, current leader: {:?}\",\n                    region_id, leader, cur_leader\n                );\n            }\n            self.transfer_leader(region_id, leader.clone());\n        }\n    }", "test": "fn test_turnoff_warmup_entry_cache() {\n    let mut cluster = new_node_cluster(0, 3);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n    cluster.cfg.raft_store.max_entry_cache_warmup_duration = ReadableDuration::secs(0);\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_non_authority_target_on_connect_request", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "test": "async fn reject_non_authority_target_on_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(frames::headers(1).request(\"CONNECT\", \"https://bread/baguette\"))\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::dropped_write", "code": "pub fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: TableDefinition<K, V>,\n    ) -> Result<Table<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Normal)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(Table::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn dropped_write() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    drop(write_txn);\n    let read_txn = db.begin_read().unwrap();\n    let result = read_txn.open_table(STR_TABLE);\n    assert!(matches!(result, Err(TableError::TableDoesNotExist(_))));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_keep_last_trailing_specifier", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_keep_last_trailing_specifier() {\n    // If there are multiple trailing specifiers, use only the last one\n    // before the number.\n    new_ucmd!()\n        .arg(\"--tabs=1,+/+/5\")\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          0         1\n        //          01234567890\n        .stdout_is(\" a   b    c\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_when_updating_wait_info", "code": "fn is_none(&self) -> bool {\n        false\n    }", "test": "fn test_detect_deadlock_when_updating_wait_info() {\n    use kvproto::kvrpcpb::PessimisticLockKeyResultType::*;\n    let mut cluster = new_cluster_for_deadlock_test(3);\n\n    let key1 = b\"key1\";\n    let key2 = b\"key2\";\n    let (client, ctx) = build_leader_client(&mut cluster, key1);\n    let client = Arc::new(client);\n\n    fn async_pessimistic_lock(\n        client: Arc<TikvClient>,\n        ctx: Context,\n        key: &[u8],\n        ts: u64,\n    ) -> mpsc::Receiver<PessimisticLockResponse> {\n        let (tx, rx) = mpsc::channel();\n        let key = vec![key.to_vec()];\n        thread::spawn(move || {\n            let resp =\n                kv_pessimistic_lock_resumable(&client, ctx, key, ts, ts, Some(1000), false, false);\n            tx.send(resp).unwrap();\n        });\n        rx\n    }\n\n    // key1: txn 11 and 12 waits for 10\n    // key2: txn 11 waits for 12\n    let resp = kv_pessimistic_lock_resumable(\n        &client,\n        ctx.clone(),\n        vec![key1.to_vec()],\n        10,\n        10,\n        Some(1000),\n        false,\n        false,\n    );\n    assert!(resp.region_error.is_none());\n    assert!(resp.errors.is_empty());\n    assert_eq!(resp.results[0].get_type(), LockResultNormal);\n    let resp = kv_pessimistic_lock_resumable(\n        &client,\n        ctx.clone(),\n        vec![key2.to_vec()],\n        12,\n        12,\n        Some(1000),\n        false,\n        false,\n    );\n    assert!(resp.region_error.is_none());\n    assert!(resp.errors.is_empty());\n    assert_eq!(resp.results[0].get_type(), LockResultNormal);\n    let rx_txn11_k1 = async_pessimistic_lock(client.clone(), ctx.clone(), key1, 11);\n    let rx_txn12_k1 = async_pessimistic_lock(client.clone(), ctx.clone(), key1, 12);\n    let rx_txn11_k2 = async_pessimistic_lock(client.clone(), ctx.clone(), key2, 11);\n    // All blocked.\n    assert_eq!(\n        rx_txn11_k1\n            .recv_timeout(Duration::from_millis(50))\n            .unwrap_err(),\n        RecvTimeoutError::Timeout\n    );\n    assert_eq!(rx_txn12_k1.try_recv().unwrap_err(), TryRecvError::Empty);\n    assert_eq!(rx_txn11_k2.try_recv().unwrap_err(), TryRecvError::Empty);\n\n    // Release lock at ts=10 on key1 so that txn 11 will be granted the lock.\n    must_kv_pessimistic_rollback(&client, ctx.clone(), key1.to_vec(), 10, 10);\n    let resp = rx_txn11_k1\n        .recv_timeout(Duration::from_millis(200))\n        .unwrap();\n    assert!(resp.region_error.is_none());\n    assert!(resp.errors.is_empty());\n    assert_eq!(resp.results[0].get_type(), LockResultNormal);\n    // And then 12 waits for k1 on key1, which forms a deadlock.\n    let resp = rx_txn12_k1\n        .recv_timeout(Duration::from_millis(1000))\n        .unwrap();\n    assert!(resp.region_error.is_none());\n    assert!(resp.errors[0].has_deadlock());\n    assert_eq!(resp.results[0].get_type(), LockResultFailed);\n    // Check correctness of the wait chain.\n    let wait_chain = resp.errors[0].get_deadlock().get_wait_chain();\n    assert_eq!(wait_chain[0].get_txn(), 11);\n    assert_eq!(wait_chain[0].get_wait_for_txn(), 12);\n    assert_eq!(wait_chain[0].get_key(), key2);\n    assert_eq!(wait_chain[1].get_txn(), 12);\n    assert_eq!(wait_chain[1].get_wait_for_txn(), 11);\n    assert_eq!(wait_chain[1].get_key(), key1);\n\n    // Clean up.\n    must_kv_pessimistic_rollback(&client, ctx.clone(), key1.to_vec(), 11, 11);\n    must_kv_pessimistic_rollback(&client, ctx.clone(), key2.to_vec(), 12, 12);\n    let resp = rx_txn11_k2\n        .recv_timeout(Duration::from_millis(500))\n        .unwrap();\n    assert!(resp.region_error.is_none());\n    assert!(resp.errors.is_empty());\n    assert_eq!(resp.results[0].get_type(), LockResultNormal);\n    must_kv_pessimistic_rollback(&client, ctx, key2.to_vec(), 11, 11);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_server_continues_on_bad_data_udp", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_server_continues_on_bad_data_udp() {\n    named_test_harness(\"example.toml\", |udp_port, _, _, _, _| {\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            udp_port.expect(\"no udp_port\"),\n        );\n        let stream = UdpClientStream::<TokioUdpSocket>::new(addr);\n        let client = AsyncClient::connect(stream);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n\n        // Send a bad packet, this should get rejected by the server\n        let raw_socket = UdpSocket::bind(SocketAddr::new(Ipv4Addr::new(0, 0, 0, 0).into(), 0))\n            .expect(\"couldn't bind raw\");\n\n        raw_socket\n            .send_to(b\"0xDEADBEEF\", addr)\n            .expect(\"raw send failed\");\n\n        // just tests that multiple queries work\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            udp_port.expect(\"no udp_port\"),\n        );\n        let stream = UdpClientStream::<TokioUdpSocket>::new(addr);\n        let client = AsyncClient::connect(stream);\n\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n    })\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscription_content", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "test": "fn inscription_content() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let (inscription, _) = inscribe(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let response =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/content/{inscription}\"));\n\n  assert_eq!(response.status(), StatusCode::OK);\n  assert_eq!(\n    response.headers().get(\"content-type\").unwrap(),\n    \"text/plain;charset=utf-8\"\n  );\n  assert_eq!(\n    response\n      .headers()\n      .get_all(\"content-security-policy\")\n      .into_iter()\n      .collect::<Vec<&http::HeaderValue>>(),\n    &[\n      \"default-src 'self' 'unsafe-eval' 'unsafe-inline' data: blob:\",\n      \"default-src *:*/content/ *:*/blockheight *:*/blockhash *:*/blockhash/ *:*/blocktime *:*/r/ 'unsafe-eval' 'unsafe-inline' data: blob:\",\n    ]\n  );\n  assert_eq!(response.bytes().unwrap(), \"FOO\");\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::very_large_mul_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn very_large_mul_test() {\n    // Test cases triggered to that would normally use `karatsuba_mul`.\n    // Karatsuba multiplication was ripped out, however, these are useful\n    // test cases.\n    let mut x: VecType = vec_from_u32(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n    let y: VecType = vec_from_u32(&[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[\n        4, 13, 28, 50, 80, 119, 168, 228, 300, 385, 484, 598, 728, 875, 1040, 1224, 1340, 1435,\n        1508, 1558, 1584, 1585, 1560, 1508, 1428, 1319, 1180, 1010, 808, 573, 304,\n    ]);\n    assert_eq!(&*x, &*expected);\n\n    // Test cases triggered to that would normally use `karatsuba_uneven_mul`.\n    let mut x: VecType = vec_from_u32(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n    let y: VecType = vec_from_u32(&[\n        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\n        28, 29, 30, 31, 32, 33, 34, 35, 36, 37,\n    ]);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[\n        4, 13, 28, 50, 80, 119, 168, 228, 300, 385, 484, 598, 728, 875, 1040, 1224, 1360, 1496,\n        1632, 1768, 1904, 2040, 2176, 2312, 2448, 2584, 2720, 2856, 2992, 3128, 3264, 3400, 3536,\n        3672, 3770, 3829, 3848, 3826, 3762, 3655, 3504, 3308, 3066, 2777, 2440, 2054, 1618, 1131,\n        592,\n    ]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_undefined_roundtrip", "code": "pub fn is_undefined(&self) -> bool {\n        matches!(&self.0, ValueRepr::Undefined)\n    }", "test": "fn test_undefined_roundtrip() {\n    let v = Value::UNDEFINED;\n    let v2 = Value::from_serializable(&v);\n    assert!(v.is_undefined());\n    assert!(v2.is_undefined());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_copr_bypass_or_access_locks", "code": "async fn handle_request(&mut self) -> Result<MemoryTraceGuard<Response>> {\n        let ret = match self.req.get_tp() {\n            AnalyzeType::TypeIndex | AnalyzeType::TypeCommonHandle => {\n                let req = self.req.take_idx_req();\n                let ranges = std::mem::take(&mut self.ranges);\n                table::check_table_ranges::<F>(&ranges)?;\n                let mut scanner = RangesScanner::<_, F>::new(RangesScannerOptions {\n                    storage: self.storage.take().unwrap(),\n                    ranges: ranges\n                        .into_iter()\n                        .map(|r| Range::from_pb_range(r, false))\n                        .collect(),\n                    scan_backward_in_range: false,\n                    is_key_only: true,\n                    is_scanned_range_aware: false,\n                });\n                let res = AnalyzeContext::handle_index(\n                    req,\n                    &mut scanner,\n                    self.req.get_tp() == AnalyzeType::TypeCommonHandle,\n                )\n                .await;\n                scanner.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeColumn => {\n                let col_req = self.req.take_col_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n                let mut builder = SampleBuilder::<_, F>::new(col_req, None, storage, ranges)?;\n                let res = AnalyzeContext::handle_column(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            // Type mixed is analyze common handle and columns by scan table rows once.\n            AnalyzeType::TypeMixed => {\n                let col_req = self.req.take_col_req();\n                let idx_req = self.req.take_idx_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n                let mut builder =\n                    SampleBuilder::<_, F>::new(col_req, Some(idx_req), storage, ranges)?;\n                let res = AnalyzeContext::handle_mixed(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeFullSampling => {\n                let col_req = self.req.take_col_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n\n                let mut builder = RowSampleBuilder::<_, F>::new(\n                    col_req,\n                    storage,\n                    ranges,\n                    self.quota_limiter.clone(),\n                    self.is_auto_analyze,\n                )?;\n\n                let res = AnalyzeContext::handle_full_sampling(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeSampleIndex => Err(Error::Other(\n                \"Analyze of this kind not implemented\".to_string(),\n            )),\n        };\n        match ret {\n            Ok(data) => {\n                let memory_size = data.capacity();\n                let mut resp = Response::default();\n                resp.set_data(data);\n                Ok(MEMTRACE_ANALYZE.trace_guard(resp, memory_size))\n            }\n            Err(Error::Other(e)) => {\n                let mut resp = Response::default();\n                resp.set_other_error(e);\n                Ok(resp.into())\n            }\n            Err(e) => Err(e),\n        }\n    }", "test": "fn test_copr_bypass_or_access_locks() {\n    let data = vec![\n        (1, Some(\"name:1\"), 1), // no lock\n        (2, Some(\"name:2\"), 2), // bypass lock\n        (3, Some(\"name:3\"), 3), // access lock(range)\n        (4, Some(\"name:4\"), 4), // access lock(range)\n        (6, Some(\"name:6\"), 6), // access lock(point)\n        (8, Some(\"name:8\"), 8), // not conflict lock\n    ];\n\n    let product = ProductTable::new();\n    let (store, _) = init_with_data(&product, &data);\n    let expected_data = vec![\n        (1, Some(\"name:1\"), 1),\n        (2, Some(\"name:2\"), 2),\n        (3, Some(\"name:33\"), 33),\n        (4, Some(\"name:44\"), 44),\n        (6, Some(\"name:66\"), 66),\n        (8, Some(\"name:8\"), 8),\n    ];\n    // lock row 3, 4, 6\n    let (mut store, endpoint, _) = init_data_with_engine_and_commit(\n        Default::default(),\n        store.get_engine(),\n        &product,\n        &expected_data[2..5],\n        false,\n    );\n    let access_lock = store.current_ts();\n    // lock row 2\n    store.begin();\n    store.delete_from(&product).execute(\n        data[1].0,\n        vec![\n            data[1].0.into(),\n            data[1].1.map(|s| s.as_bytes()).into(),\n            data[1].2.into(),\n        ],\n    );\n    let bypass_lock = store.current_ts();\n    let read_ts = TimeStamp::new(next_id() as u64);\n    // lock row 8 with larger ts\n    store.begin();\n    store.delete_from(&product).execute(\n        data[5].0,\n        vec![\n            data[5].0.into(),\n            data[5].1.map(|s| s.as_bytes()).into(),\n            data[5].2.into(),\n        ],\n    );\n\n    let mut ctx = Context::default();\n    ctx.set_isolation_level(IsolationLevel::Si);\n    ctx.set_resolved_locks(vec![bypass_lock.into_inner()]);\n    ctx.set_committed_locks(vec![access_lock.into_inner()]);\n    let ranges = vec![\n        product.get_record_range(1, 4),\n        product.get_record_range_one(6),\n        product.get_record_range_one(8),\n    ];\n\n    // DAG\n    {\n        let mut req = DagSelect::from(&product).build_with(ctx.clone(), &[0]);\n        req.set_start_ts(read_ts.into_inner());\n        req.set_ranges(ranges.clone().into());\n\n        let mut resp = handle_select(&endpoint, req);\n        let mut row_count = 0;\n        let spliter = DagChunkSpliter::new(resp.take_chunks().into(), 3);\n        for (row, (id, name, cnt)) in spliter.zip(expected_data) {\n            let name_datum = name.map(|s| s.as_bytes()).into();\n            let expected_encoded = datum::encode_value(\n                &mut EvalContext::default(),\n                &[Datum::I64(id), name_datum, cnt.into()],\n            )\n            .unwrap();\n            let result_encoded = datum::encode_value(&mut EvalContext::default(), &row).unwrap();\n            assert_eq!(result_encoded, &*expected_encoded);\n            row_count += 1;\n        }\n        assert_eq!(row_count, data.len());\n    }\n\n    // analyze\n    {\n        let mut col_req = AnalyzeColumnsReq::default();\n        col_req.set_columns_info(product.columns_info().into());\n        let mut analy_req = AnalyzeReq::default();\n        analy_req.set_tp(AnalyzeType::TypeColumn);\n        analy_req.set_col_req(col_req);\n        let mut req = Request::default();\n        req.set_context(ctx.clone());\n        req.set_start_ts(read_ts.into_inner());\n        req.set_ranges(ranges.clone().into());\n        req.set_tp(REQ_TYPE_ANALYZE);\n        req.set_data(analy_req.write_to_bytes().unwrap());\n        let resp = handle_request(&endpoint, req);\n        assert!(!resp.get_data().is_empty());\n        assert!(!resp.has_locked(), \"{:?}\", resp);\n    }\n\n    // checksum\n    {\n        let checksum = ChecksumRequest::default();\n        let mut req = Request::default();\n        req.set_context(ctx);\n        req.set_start_ts(read_ts.into_inner());\n        req.set_ranges(ranges.into());\n        req.set_tp(REQ_TYPE_CHECKSUM);\n        req.set_data(checksum.write_to_bytes().unwrap());\n        let resp = handle_request(&endpoint, req);\n        assert!(!resp.get_data().is_empty());\n        assert!(!resp.has_locked(), \"{:?}\", resp);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_prewrite_without_value", "code": "pub fn get_entries(&self) -> &EventEntries {\n        match self.event {\n            ::std::option::Option::Some(Event_oneof_event::Entries(ref v)) => v,\n            _ => EventEntries::default_instance(),\n        }\n    }", "test": "fn test_prewrite_without_value() {\n    let cluster = new_server_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let rid = suite.cluster.get_region(&[]).id;\n    let ctx = suite.get_context(rid);\n    let client = suite.get_tikv_client(rid).clone();\n    let large_value = vec![b'x'; 2 * txn_types::SHORT_VALUE_MAX_LEN];\n\n    // Perform a pessimistic prewrite with a large value.\n    let mut muts = vec![Mutation::default()];\n    muts[0].set_op(Op::Put);\n    muts[0].key = b\"key\".to_vec();\n    muts[0].value = large_value.clone();\n    try_kv_prewrite_pessimistic(&client, ctx.clone(), muts, b\"key\".to_vec(), 10);\n\n    let req = suite.new_changedata_request(rid);\n    let (mut req_tx, _, receive_event) = new_event_feed(suite.get_region_cdc_client(rid));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n\n    // The prewrite can be retrieved from incremental scan.\n    let event = receive_event(false);\n    assert_eq!(\n        event.get_events()[0].get_entries().entries[0].value,\n        large_value\n    );\n\n    // check_txn_status will put the lock again, but without value.\n    must_check_txn_status(&client, ctx.clone(), b\"key\", 10, 12, 12);\n    must_kv_commit(&client, ctx, vec![b\"key\".to_vec()], 10, 14, 14);\n    // The lock without value shouldn't be retrieved.\n    let event = receive_event(false);\n    assert_eq!(event.get_events()[0].get_entries().entries[0].commit_ts, 14);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_str_prefixed_chunks_by_lines", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_str_prefixed_chunks_by_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_str_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-l\", \"1000\", name, \"d\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"d[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::drain_drop_immediately", "code": "fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }", "test": "fn drain_drop_immediately() {\n    // test mem::forgetting does not double-free\n\n    let mut headers = HeaderMap::new();\n    headers.insert(\"hello\", \"world\".parse().unwrap());\n    headers.insert(\"zomg\", \"bar\".parse().unwrap());\n    headers.append(\"hello\", \"world2\".parse().unwrap());\n\n    let iter = headers.drain();\n    assert_eq!(iter.size_hint(), (2, Some(3)));\n    // not consuming `iter`\n}"}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/issues.rs::take_till0_issue", "code": "fn nothing(i: Partial<&[u8]>) -> IResult<Partial<&[u8]>, &[u8]> {\n        take_till0(|_| true).parse_peek(i)\n    }", "test": "fn take_till0_issue() {\n    use winnow::token::take_till0;\n\n    fn nothing(i: Partial<&[u8]>) -> IResult<Partial<&[u8]>, &[u8]> {\n        take_till0(|_| true).parse_peek(i)\n    }\n\n    assert_eq!(\n        nothing(Partial::new(b\"\")),\n        Err(ErrMode::Incomplete(Needed::new(1)))\n    );\n    assert_eq!(\n        nothing(Partial::new(b\"abc\")),\n        Ok((Partial::new(&b\"abc\"[..]), &b\"\"[..]))\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_tests", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_tests() {\n    let mut context = Context::new();\n    context.insert(\"is_true\", &true);\n    context.insert(\"is_false\", &false);\n    context.insert(\"age\", &18);\n    context.insert(\"name\", &\"john\");\n    let mut map = HashMap::new();\n    map.insert(0, 1);\n    context.insert(\"map\", &map);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert::<Option<usize>, _>(\"maybe\", &None);\n\n    let inputs = vec![\n        (\"{% if is_true is defined %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if hello is undefined %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is string %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is number %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is even %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is odd %}Admin{%else%}even{% endif %}\", \"even\"),\n        (\"{% if age is divisibleby(2) %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if numbers is iterable %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if map is iterable %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if map is object %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is starting_with('j') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is ending_with('n') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if numbers is containing(2) %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is matching('^j.*') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if maybe is defined %}Admin{% endif %}\", \"Admin\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::lid_number_arg_gnu_compatibility() {\n    ", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "nvalid_number_arg_gnu_compatibility() {\n    let commands = vec![\"bs\", \"cbs\", \"count\", \"ibs\", \"obs\", \"seek\", \"skip\"];\n\n    for command in commands {\n        new_ucmd!()\n            .args(&[format!(\"{command}=\")])\n            .fails()\n            .stderr_is(\"dd: invalid number: \u2018\u2019\\n\");\n\n        new_ucmd!()\n            .args(&[format!(\"{command}=29d\")])\n            .fails()\n            .stderr_is(\"dd: invalid number: \u201829d\u2019\\n\");\n    }\n}\n\n#[test]\nfn test"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_negative_interval", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_negative_interval() {\n    new_ucmd!()\n        .args(&[\"--\", \"-1\"])\n        .fails()\n        .usage_error(\"invalid time interval '-1': Number was negative\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_mixed_style_list", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_mixed_style_list() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \", 3,6 9\"])\n        .pipe_in(\"a\\tb\\tc\\td\\te\")\n        .succeeds()\n        .stdout_is(\"a  b  c  d e\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_remove_suffix", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_remove_suffix() {\n    new_ucmd!()\n        .args(&[\"/usr/local/bin/reallylongexecutable.exe\", \".exe\"])\n        .succeeds()\n        .stdout_only(\"reallylongexecutable\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_descend_directory", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_descend_directory() {\n    // This test descends into each directory and deletes the files and folders inside of them\n    // This test will have the rm process asks 6 question and us answering Y to them will delete all the files and folders\n\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"a/at.txt\";\n    let file_2 = \"a/b/bt.txt\";\n\n    at.mkdir_all(\"a/b/\");\n    at.touch(file_1);\n    at.touch(file_2);\n\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-ri\")\n        .arg(\"a\")\n        .run_no_wait();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n\n    child.wait().unwrap();\n\n    assert!(!at.dir_exists(\"a/b\"));\n    assert!(!at.dir_exists(\"a\"));\n    assert!(!at.file_exists(file_1));\n    assert!(!at.file_exists(file_2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_when_single_input_exceeds_max_duration_then_no_error", "code": "pub fn no_output(&self) -> &Self {\n        self.no_stdout().no_stderr()\n    }", "test": "fn test_sleep_when_single_input_exceeds_max_duration_then_no_error() {\n    let mut child = new_ucmd!()\n        .arg(format!(\"{}\", u64::MAX as u128 + 1))\n        .timeout(Duration::from_secs(10))\n        .run_no_wait();\n\n    #[cfg(unix)]\n    child\n        .delay(100)\n        .kill()\n        .make_assertion()\n        .with_current_output()\n        .signal_is(9) // make sure it was us who terminated the process\n        .no_output();\n    #[cfg(windows)]\n    child\n        .delay(100)\n        .kill()\n        .make_assertion()\n        .with_current_output()\n        .failure()\n        .no_output();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_expression_with_not", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn missing_expression_with_not() {\n    assert_err_msg(\"{% if not %}\", &[\"1:11\", \"expected an expression\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_rawkv.rs::test_raw_put_key_guard", "code": "pub fn must_raw_get(&self, k: Vec<u8>, cf: String) -> Vec<u8> {\n        let mut request = RawGetRequest::default();\n        let mut context = self.context.clone();\n        if context.api_version == ApiVersion::V1ttl {\n            context.api_version = ApiVersion::V1;\n        }\n        request.set_context(context);\n        request.set_key(k);\n        request.set_cf(cf);\n        let mut response = self.tikv_cli.raw_get(&request).unwrap();\n        retry_req!(\n            self.tikv_cli.raw_get(&request).unwrap(),\n            !response.has_region_error() && response.error.is_empty(),\n            response,\n            10,   // retry 10 times\n            1000  // 1s timeout\n        );\n        assert!(response.error.is_empty(), \"{:?}\", response.get_error());\n        response.take_value()\n    }", "test": "fn test_raw_put_key_guard() {\n    let mut suite = TestSuite::new(3, ApiVersion::V2);\n    let pause_write_fp = \"raftkv_async_write\";\n\n    let test_key = b\"rk3\".to_vec();\n    let test_value = b\"v3\".to_vec();\n\n    let region = suite.cluster.get_region(&test_key);\n    let region_id = region.get_id();\n    let client = suite.get_client(region_id);\n    let ctx = suite.get_context(region_id);\n    let node_id = region.get_peers()[0].get_id();\n    let leader_cm = suite.cluster.sim.rl().get_concurrency_manager(node_id);\n    let ts_provider = suite.get_causal_ts_provider(node_id).unwrap();\n    let ts = block_on(ts_provider.async_get_ts()).unwrap();\n\n    let copy_test_key = test_key.clone();\n    let copy_test_value = test_value.clone();\n    fail::cfg(pause_write_fp, \"pause\").unwrap();\n    let handle = thread::spawn(move || {\n        must_raw_put(&client, ctx, copy_test_key, copy_test_value);\n    });\n\n    // Wait for global_min_lock_ts.\n    sleep_ms(500);\n    let start = Instant::now();\n    while leader_cm.global_min_lock_ts().is_none()\n        && start.saturating_elapsed() < Duration::from_secs(5)\n    {\n        sleep_ms(200);\n    }\n\n    // Before raw_put finish, min_ts should be the ts of \"key guard\" of the raw_put\n    // request.\n    assert_eq!(suite.must_raw_get(&test_key), None);\n    let min_ts = leader_cm.global_min_lock_ts();\n    assert_eq!(min_ts.unwrap(), ts.next());\n\n    fail::remove(pause_write_fp);\n    handle.join().unwrap();\n\n    // After raw_put is finished, \"key guard\" is released.\n    assert_eq!(suite.must_raw_get(&test_key), Some(test_value));\n    let min_ts = leader_cm.global_min_lock_ts();\n    assert!(min_ts.is_none());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_backslash", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_backslash() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\\\\\\"])\n        .succeeds()\n        .stdout_only(\"\\\\\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_zero_terminated", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_zero_terminated() {\n    new_ucmd!()\n        .args(&[\"-d_\", \"-z\", \"-f\", \"1\"])\n        .pipe_in(\"9_1\\n8_2\\n\\x007_3\")\n        .succeeds()\n        .stdout_only(\"9\\x007\\0\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/failpoints/test_bootstrap.rs::test_bootstrap_half_way_failure", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_bootstrap_half_way_failure() {\n    let server = test_pd::Server::new(1);\n    let eps = server.bind_addrs();\n    let pd_client = test_pd::util::new_client(eps, None);\n    let path = TempDir::new().unwrap();\n    let engines = engine_test::new_temp_engine(&path);\n    let bootstrap = || {\n        let logger = slog_global::borrow_global().new(o!());\n        let mut bootstrap = Bootstrap::new(&engines.raft, 0, &pd_client, logger);\n        match bootstrap.bootstrap_store() {\n            Ok(store_id) => {\n                let mut store = Store::default();\n                store.set_id(store_id);\n                bootstrap.bootstrap_first_region(&store, store_id)\n            }\n            Err(e) => Err(e),\n        }\n    };\n\n    // Try to start this node, return after persisted some keys.\n    fail::cfg(\"node_after_bootstrap_store\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_store\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    let ident = engines.raft.get_store_ident().unwrap().unwrap();\n    assert_ne!(ident.get_store_id(), 0);\n\n    // Check whether it can bootstrap cluster successfully.\n    fail::remove(\"node_after_bootstrap_store\");\n    fail::cfg(\"node_after_prepare_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_prepare_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    fail::remove(\"node_after_prepare_bootstrap_cluster\");\n    fail::cfg(\"node_after_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    // Although aborted by error, rebootstrap should continue.\n    bootstrap().unwrap().unwrap();\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    // Second bootstrap should be noop.\n    assert_eq!(bootstrap().unwrap(), None);\n\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_no_permission_file", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_sync_no_permission_file() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n    let f = \"file\";\n    at.touch(f);\n\n    ts.ccmd(\"chmod\").arg(\"0200\").arg(f).succeeds();\n    ts.ucmd().arg(f).succeeds();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_start", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_start() {\n  assert_eval_eq(\"trim_start('  f  ')\", \"f  \");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_strikethrough.rs::gfm_strikethrough_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_strikethrough_test_3() {\n    let original = r##\"This will ~~~not~~~ strike.\n\"##;\n    let expected = r##\"<p>This will ~~~not~~~ strike.</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_same_rollback_one", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_same_rollback_one() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n\n    assert!(a.is_some());\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in max_keys..2 * max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    for i in max_keys..2 * max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_3() {\n    let original = r##\"| f\\|oo  |\n| ------ |\n| b `\\|` az |\n| b **\\|** im |\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>f|oo</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b <code>\\|</code> az</td>\n</tr>\n<tr>\n<td>b <strong>|</strong> im</td>\n</tr>\n</tbody>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_files0_disabled_files_argument", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_files0_disabled_files_argument() {\n    const MSG: &str = \"file operands cannot be combined with --files0-from\";\n    new_ucmd!()\n        .args(&[\"--files0-from=files0_list.txt\"])\n        .arg(\"lorem_ipsum.txt\")\n        .fails()\n        .stderr_contains(MSG)\n        .stdout_is(\"\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::cmp_test", "code": "fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.as_f32().partial_cmp(&other.as_f32())\n    }", "test": "fn cmp_test() {\n    // Simple\n    let x = VecType::from_u32(1);\n    let y = VecType::from_u32(2);\n    assert_eq!(x.partial_cmp(&x), Some(cmp::Ordering::Equal));\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Less);\n\n    // Check asymmetric\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    let y = VecType::from_u32(2);\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Check when we use reverse ordering properly.\n    let x = VecType::try_from(&[5, 1, 9]).unwrap();\n    let y = VecType::try_from(&[6, 2, 8]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = VecType::try_from(&[0, 1, 9]).unwrap();\n    let y = VecType::try_from(&[4294967295, 0, 9]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_too_many_args_output", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_too_many_args_output() {\n    new_ucmd!()\n        .args(&[\"a\", \"b\", \"c\"])\n        .fails()\n        .usage_error(\"extra operand 'c'\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_both_data_sent", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn buffered_both_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        do_handshake(&mut client, &mut server);\n\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n\n        check_read(&mut client.reader(), b\"from-server!\");\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_existing_file_truncated", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_existing_file_truncated() {\n    // Set up test if needed (eg. after failure)\n    let fname = \"this-file-exists-truncated.txt\";\n    let fpath = fixture_path!(fname);\n    match fpath.metadata() {\n        Ok(m) if m.len() == 256 => {}\n        _ => build_test_file!(&fpath, &vec![0; 256]),\n    }\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", \"if=null.txt\", of!(fname)])\n        .run()\n        .no_stdout()\n        .no_stderr()\n        .success();\n\n    assert_eq!(0, fix.metadata(fname).len());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_whoami.rs::test_succeeds_on_all_platforms", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_succeeds_on_all_platforms() {\n    new_ucmd!().succeeds().no_stderr();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_node_update_localreader_after_removed", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_node_update_localreader_after_removed() {\n    let mut cluster = new_node_cluster(0, 6);\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n\n    // Add 4 peers.\n    for i in 2..6 {\n        pd_client.must_add_peer(r1, new_peer(i, i));\n    }\n\n    // Make sure peer 1 leads the region.\n    cluster.must_transfer_leader(r1, new_peer(1, 1));\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // Make sure peer 2 is initialized.\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, key, value);\n\n    // Pause peer 2 apply worker if it executes AddNode.\n    let add_node_fp = \"apply_on_add_node_1_2\";\n    fail::cfg(add_node_fp, \"pause\").unwrap();\n\n    // Add peer 6.\n    pd_client.must_add_peer(r1, new_peer(6, 6));\n\n    // Isolate peer 2 from rest of the cluster.\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Remove peer 2, so it will receive a gc msssage\n    // after max_leader_missing_duration timeout.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n    thread::sleep(cluster.cfg.raft_store.max_leader_missing_duration.0 * 2);\n\n    // Continue peer 2 apply worker, so that peer 2 tries to\n    // update region to its read delegate.\n    fail::remove(add_node_fp);\n\n    // Make sure peer 2 is removed in node 2.\n    cluster.must_region_not_exist(r1, 2);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::no_savepoint_resurrection", "code": "fn commit(self) {\n        self.file.sync_all().unwrap();\n        self.inner.commit().unwrap();\n    }", "test": "fn no_savepoint_resurrection() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::builder()\n        .set_cache_size(41178283)\n        .create(tmpfile.path())\n        .unwrap();\n\n    let tx = db.begin_write().unwrap();\n    let persistent_savepoint = tx.persistent_savepoint().unwrap();\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    let savepoint2 = tx.ephemeral_savepoint().unwrap();\n    tx.delete_persistent_savepoint(persistent_savepoint)\n        .unwrap();\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.restore_savepoint(&savepoint2).unwrap();\n    tx.delete_persistent_savepoint(persistent_savepoint)\n        .unwrap();\n    tx.commit().unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_write_and_ingest_with_tde", "code": "fn run_test_write_sst(ctx: Context, tikv: TikvClient, import: ImportSstClient) {\n    let mut meta = new_sst_meta(0, 0);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    let mut keys = vec![];\n    let mut values = vec![];\n    let sst_range = (0, 10);\n    for i in sst_range.0..sst_range.1 {\n        keys.push(vec![i]);\n        values.push(vec![i]);\n    }\n    let resp = send_write_sst(&import, &meta, keys, values, 1).unwrap();\n\n    for m in resp.metas.into_iter() {\n        let mut ingest = IngestRequest::default();\n        ingest.set_context(ctx.clone());\n        ingest.set_sst(m.clone());\n        let resp = import.ingest(&ingest).unwrap();\n        assert!(!resp.has_error());\n    }\n    check_ingested_txn_kvs(&tikv, &ctx, sst_range, 2);\n}", "test": "fn test_write_and_ingest_with_tde() {\n    let (_tmp_dir, _cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client_tde();\n    run_test_write_sst(ctx, tikv, import);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_fold_bit_shift", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_fold_bit_shift() {\n    test(\"x = 1 << 0\", \"x=1;\");\n    test(\"x = -1 << 0\", \"x=-1;\");\n    test(\"x = 1 << 1\", \"x=2;\");\n    test(\"x = 3 << 1\", \"x=6;\");\n    test(\"x = 1 << 8\", \"x=256;\");\n\n    test(\"x = 1 >> 0\", \"x=1;\");\n    test(\"x = -1 >> 0\", \"x=-1;\");\n    test(\"x = 1 >> 1\", \"x=0;\");\n    test(\"x = 2 >> 1\", \"x=1;\");\n    test(\"x = 5 >> 1\", \"x=2;\");\n    test(\"x = 127 >> 3\", \"x=15;\");\n    test(\"x = 3 >> 1\", \"x=1;\");\n    test(\"x = 3 >> 2\", \"x=0;\");\n    test(\"x = 10 >> 1\", \"x=5;\");\n    test(\"x = 10 >> 2\", \"x=2;\");\n    test(\"x = 10 >> 5\", \"x=0;\");\n\n    test(\"x = 10 >>> 1\", \"x=5;\");\n    test(\"x = 10 >>> 2\", \"x=2;\");\n    test(\"x = 10 >>> 5\", \"x=0;\");\n    test(\"x = -1 >>> 1\", \"x=2147483647;\"); // 0x7fffffff\n    test(\"x = -1 >>> 0\", \"x=4294967295;\"); // 0xffffffff\n    test(\"x = -2 >>> 0\", \"x=4294967294;\"); // 0xfffffffe\n    test(\"x = 0x90000000 >>> 28\", \"x=9;\");\n\n    test(\"x = 0xffffffff << 0\", \"x=-1;\");\n    test(\"x = 0xffffffff << 4\", \"x=-16;\");\n    test(\"1 << 32\", \"1<<32;\");\n    test(\"1 << -1\", \"1<<-1;\");\n    test(\"1 >> 32\", \"1>>32;\");\n}"}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::zlib_decoder_empty_read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "test": "fn zlib_decoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::write::ZlibEncoder::new(Vec::new(), flate2::Compression::default());\n    encoder.write_all(original).unwrap();\n    let encoded: Vec<u8> = encoder.finish().unwrap();\n    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());\n    assert_eq!(decoder.read(&mut []).unwrap(), 0);\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_decode", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_decode() {\n    for decode_param in [\"-d\", \"--decode\", \"--dec\"] {\n        let input = \"aGVsbG8sIHdvcmxkIQ==\"; // spell-checker:disable-line\n        new_ucmd!()\n            .arg(decode_param)\n            .pipe_in(input)\n            .succeeds()\n            .stdout_only(\"hello, world!\");\n    }\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::compound", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn compound() {\n    let source = r#\"\n        void foo() {\n            int x=10;\n            if (x>10) {\n                x=10;\n            }\n        }\"#;\n\n    let needle = \"{$x=10; if($x>10) {$x=10;}}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::recursion", "code": "pub fn last(&self) -> Option<&V> {\n        self.elems.last()\n    }", "test": "fn recursion() -> Result<(), Error> {\n    // Make sure call hook behaves reasonably when called recursively\n\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\"host\", \"f\", |mut caller: Caller<State>, n: i32| {\n        assert_eq!(caller.data().context.last(), Some(&Context::Host));\n\n        assert_eq!(caller.data().calls_into_host, caller.data().calls_into_wasm);\n\n        // Recurse\n        if n > 0 {\n            caller\n                .get_export(\"export\")\n                .expect(\"caller exports \\\"export\\\"\")\n                .into_func()\n                .expect(\"export is a func\")\n                .typed::<i32, ()>(&caller)\n                .expect(\"export typing\")\n                .call(&mut caller, n - 1)\n                .unwrap()\n        }\n    })?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32)))\n            (func (export \"export\") (param i32)\n                (call $f (local.get 0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate(&mut store, &module)?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    // Recursion depth:\n    let n: usize = 10;\n\n    export.call(&mut store, &[Val::I32(n as i32)], &mut [])?;\n\n    // Recurse down to 0: n+1 calls\n    assert_eq!(store.data().calls_into_host, n + 1);\n    assert_eq!(store.data().returns_from_host, n + 1);\n    assert_eq!(store.data().calls_into_wasm, n + 1);\n    assert_eq!(store.data().returns_from_wasm, n + 1);\n\n    export\n        .typed::<i32, ()>(&store)?\n        .call(&mut store, n as i32)?;\n\n    assert_eq!(store.data().calls_into_host, 2 * (n + 1));\n    assert_eq!(store.data().returns_from_host, 2 * (n + 1));\n    assert_eq!(store.data().calls_into_wasm, 2 * (n + 1));\n    assert_eq!(store.data().returns_from_wasm, 2 * (n + 1));\n\n    Ok(())\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_example_toml_startup", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_example_toml_startup() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n\n        // just tests that multiple queries work\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n    })\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_specific_rules", "code": "pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    }", "test": "fn check_specific_rules() {\n    {\n        // exceptions have not effect if important filter matches\n        let engine = Engine::from_rules_debug(\n            [\"||www.facebook.com/*/plugin\"],\n            Default::default(),\n        );\n\n        let request = Request::new(\"https://www.facebook.com/v3.2/plugins/comments.ph\", \"\", \"\").unwrap();\n        let checked =\n            engine.check_network_request(&request);\n\n        assert_eq!(checked.matched, true);\n    }\n\n    #[cfg(feature = \"resource-assembler\")]\n    {\n        use std::path::Path;\n\n        // exceptions have no effect if important filter matches\n        let mut engine = Engine::from_rules_debug(\n            [\n                \"||cdn.taboola.com/libtrc/*/loader.js$script,redirect=noopjs,important,domain=cnet.com\",\n            ],\n            Default::default(),\n        );\n        let resources = adblock::resources::resource_assembler::assemble_web_accessible_resources(\n            Path::new(\"data/test/fake-uBO-files/web_accessible_resources\"),\n            Path::new(\"data/test/fake-uBO-files/redirect-resources.js\"),\n        );\n        engine.use_resources(resources);\n\n        let request = Request::new(\n            \"http://cdn.taboola.com/libtrc/test/loader.js\",\n            \"http://cnet.com\",\n            \"script\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, true);\n        assert_eq!(checked.redirect, Some(\"data:application/javascript;base64,KGZ1bmN0aW9uKCkgewogICAgJ3VzZSBzdHJpY3QnOwp9KSgpOwo=\".to_owned()));\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::sha256", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn sha256() {\n  Test::new()\n    .justfile(\"x := sha256('5943ee37-0000-1000-8000-010203040506')\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout(\"2330d7f5eb94a820b54fed59a8eced236f80b633a504289c030b6a65aef58871\")\n    .run();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::comma", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn comma() {\n    test(\"1, 2, 3\", \"1,2,3;\");\n    // test(\"(1, 2), 3\", \"1,2,3;\");\n    // test(\"1, (2, 3)\", \"1,2,3;\");\n    test(\"a ? (b, c) : (d, e)\", \"a?(b,c):(d,e);\");\n    test(\"let x = (a, b)\", \"let x=(a,b);\");\n    test(\"(x = a), b\", \"x=a,b;\");\n    test(\"x = (a, b)\", \"x=(a,b);\");\n    test(\"x((1, 2))\", \"x((1,2));\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_column_with_lock", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_column_with_lock() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    for &iso_level in &[IsolationLevel::Si, IsolationLevel::Rc] {\n        let (_, endpoint, _) = init_data_with_commit(&product, &data, false);\n\n        let mut req = new_analyze_column_req(&product, 3, 3, 3, 3, 4, 32);\n        let mut ctx = Context::default();\n        ctx.set_isolation_level(iso_level);\n        req.set_context(ctx);\n\n        let resp = handle_request(&endpoint, req);\n        match iso_level {\n            IsolationLevel::Si => {\n                assert!(resp.get_data().is_empty(), \"{:?}\", resp);\n                assert!(resp.has_locked(), \"{:?}\", resp);\n            }\n            IsolationLevel::Rc => {\n                let mut analyze_resp = AnalyzeColumnsResp::default();\n                analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n                let hist = analyze_resp.get_pk_hist();\n                assert!(hist.get_buckets().is_empty());\n                assert_eq!(hist.get_ndv(), 0);\n            }\n            IsolationLevel::RcCheckTs => unimplemented!(),\n        }\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::configure_max_frame_size", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn configure_max_frame_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, h2) = client::Builder::new()\n            .max_frame_size(16_384 * 2)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n\n        let req = async move {\n            let resp = client.get(\"https://example.com/\").await.expect(\"response\");\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let buf = util::concat(body).await.expect(\"body\");\n            assert_eq!(buf.len(), 16_385);\n        };\n\n        join(async move { h2.await.expect(\"client\") }, req).await;\n    };\n    // a good peer\n    srv.codec_mut().set_max_send_frame_size(16_384 * 2);\n\n    let srv = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.send_frame(frames::data(1, vec![0; 16_385]).eos()).await;\n    };\n    join(srv, h2).await;\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_read_returns_wouldblock_when_no_data", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn client_read_returns_wouldblock_when_no_data() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    assert!(matches!(client.reader().read(&mut [0u8; 1]),\n                     Err(err) if err.kind() == io::ErrorKind::WouldBlock));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "test": "fn valid_context_directory_recursive() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let a_context = get_file_context(dir.plus(\"a\")).unwrap();\n    let b_context = get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    // -P (default): do not traverse any symbolic links.\n    cmd.args(&[\"--verbose\", \"--recursive\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"la\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"a\")).unwrap(), a_context);\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap(),\n        b_context\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_obsolete_syntax_positive_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_obsolete_syntax_positive_lines() {\n    new_ucmd!()\n        .args(&[\"-3\"])\n        .pipe_in(\"a\\nb\\nc\\nd\\ne\\n\")\n        .succeeds()\n        .stdout_is(\"c\\nd\\ne\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_eof", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_line_bytes_no_eof() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"3\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n\");\n    assert_eq!(at.read(\"xab\"), \"222\");\n    assert_eq!(at.read(\"xac\"), \"2\\n\");\n    assert_eq!(at.read(\"xad\"), \"3\\n\");\n    assert_eq!(at.read(\"xae\"), \"4\");\n    assert!(!at.plus(\"xaf\").exists());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::errors_when_calling_macros_defined_in_file", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn errors_when_calling_macros_defined_in_file() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{% macro path_item(path) %}\n    <span class=\"path\" title=\"{{ path }}\">{{ path }}</span>\n{% endmacro path_item %}\n\n...\n\n<td>{{ self::path_item(path=hello) }}</td>\n        \"#,\n    )\n    .unwrap();\n    let mut context = Context::new();\n    context.insert(\"hello\", &true);\n    let result = tera.render(\"tpl\", &context);\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Invalid macro definition: `path_item`\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_f64", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_f64() {\n    let input: [u8; 40] = [\n        0x27, 0x6b, 0x0a, 0x2f, 0x2a, 0xee, 0x45,\n        0x43, // 0x4345EE2A2F0A6B27 12345678912345678\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0000000000000000 0\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n        0x80, // 0x8010000000000000 -2.2250738585072014e-308\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, // 0x0000000000000001 5e-324 (subnormal)\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,\n    ]; // 0xc000000000000000 -2\n    let expected_output = unindent(\n        \"\n            0000000        12345678912345678                        0\n            0000020 -2.2250738585072014e-308                   5e-324\n            0000040      -2.0000000000000000\n            0000050\n            \",\n    );\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-F\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error64_test", "code": "fn compute_error64(q: i32, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f64>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_error64(0, 9007199254740992), (1065 + f64::INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 9007199254740993), (1065 + f64::INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9007199254740994), (1065 + f64::INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 9007199254740995), (1065 + f64::INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 9007199254740996), (1065 + f64::INVALID_FP, 9223372036854779904));\n    assert_eq!(\n        compute_error64(0, 18014398509481984),\n        (1066 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481986),\n        (1066 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481988),\n        (1066 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481990),\n        (1066 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481992),\n        (1066 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test a much closer set of examples.\n    assert_eq!(\n        compute_error64(0, 9007199254740991),\n        (1064 + f64::INVALID_FP, 18446744073709549568)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776831),\n        (1075 + f64::INVALID_FP, 9223372036854776830)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776832),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776833),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(-42, 9123456727292927),\n        (925 + f64::INVALID_FP, 13021432563531497894)\n    );\n    assert_eq!(\n        compute_error64(-43, 91234567272929275),\n        (925 + f64::INVALID_FP, 13021432563531498606)\n    );\n    assert_eq!(\n        compute_error64(-42, 9123456727292928),\n        (925 + f64::INVALID_FP, 13021432563531499320)\n    );\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error64(-3, 9007199254740992000),\n        (1065 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740993000),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740994000),\n        (1065 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740995000),\n        (1065 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740996000),\n        (1065 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test from errors in atof.\n    assert_eq!(\n        compute_error64(-18, 1000000178813934326),\n        (1012 + f64::INVALID_FP, 9223373686122217470)\n    );\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error64(-342, 2470328229206232720),\n        (-64 + f64::INVALID_FP, 18446744073709551608)\n    );\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::namespace", "code": "pub fn read_resolved_event(&mut self) -> Result<(ResolveResult, Event<'i>)> {\n        let event = self.read_event_impl(());\n        self.resolve_event(event)\n    }", "test": "fn namespace() {\n    let mut r = NsReader::from_str(\"<a xmlns:myns='www1'><myns:b>in namespace!</myns:b></a>\");\n    r.trim_text(true);\n\n    // <a>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\n            \"expecting outer start element with no namespace, got {:?}\",\n            e\n        ),\n    }\n\n    // <b>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting inner start element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n    // \"in namespace!\"\n    match r.read_resolved_event() {\n        Ok((ns, Text(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\"expecting text content with no namespace, got {:?}\", e),\n    }\n    // </b>\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting inner end element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n\n    // </a>\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\"expecting outer end element with no namespace, got {:?}\", e),\n    }\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_swap_remove", "code": "pub fn swap_remove(&mut self, index: usize) -> A::Item {\n    assert!(\n      index < self.len(),\n      \"ArrayVec::swap_remove> index {} is out of bounds {}\",\n      index,\n      self.len\n    );\n    if index == self.len() - 1 {\n      self.pop().unwrap()\n    } else {\n      let i = self.pop().unwrap();\n      replace(&mut self[index], i)\n    }\n  }", "test": "fn TinyVec_swap_remove() {\n  let mut tv: TinyVec<[i32; 10]> = Default::default();\n  tv.push(1);\n  tv.push(2);\n  tv.push(3);\n  tv.push(4);\n  assert_eq!(tv.swap_remove(3), 4);\n  assert_eq!(&tv[..], &[1, 2, 3][..]);\n  assert_eq!(tv.swap_remove(0), 1);\n  assert_eq!(&tv[..], &[3, 2][..]);\n  assert_eq!(tv.swap_remove(0), 3);\n  assert_eq!(&tv[..], &[2][..]);\n  assert_eq!(tv.swap_remove(0), 2);\n  assert_eq!(&tv[..], &[][..]);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_limits_memory_only", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_limits_memory_only() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(10 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    // Test instance exports and host objects hitting the limit\n    for memory in IntoIterator::into_iter([\n        instance.get_memory(&mut store, \"m\").unwrap(),\n        Memory::new(&mut store, MemoryType::new(0, None))?,\n    ]) {\n        memory.grow(&mut store, 3)?;\n        memory.grow(&mut store, 5)?;\n        memory.grow(&mut store, 2)?;\n\n        assert_eq!(\n            memory\n                .grow(&mut store, 1)\n                .map_err(|e| e.to_string())\n                .unwrap_err(),\n            \"failed to grow memory by `1`\"\n        );\n    }\n\n    // Test instance exports and host objects *not* hitting the limit\n    for table in IntoIterator::into_iter([\n        instance.get_table(&mut store, \"t\").unwrap(),\n        Table::new(\n            &mut store,\n            TableType::new(ValType::FuncRef, 0, None),\n            Val::FuncRef(None),\n        )?,\n    ]) {\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n    }\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc2_without_key", "code": "fn test_txn_store_gc_multiple_keys(key_prefix_len: usize, n: usize) {\n    let prefix = String::from_utf8(vec![b'k'; key_prefix_len]).unwrap();\n    test_txn_store_gc_multiple_keys_cluster_storage(n, prefix.clone());\n    test_txn_store_gc_multiple_keys_single_storage(n, prefix);\n}", "test": "fn test_txn_store_gc2_without_key() {\n    test_txn_store_gc_multiple_keys(1, 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_none", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_none() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    for i in 1..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_bin_literal", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_mssql_bin_literal() {\n    let _ = ms_and_generic().one_statement_parses_to(\"SELECT 0xdeadBEEF\", \"SELECT X'deadBEEF'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_verbose_multi", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_verbose_multi() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n\n    ucmd.arg(\"-v\")\n        .arg(\"does_not_exist\")\n        .arg(DIR)\n        .fails()\n        .stdout_is(\n            \"rmdir: removing directory, 'does_not_exist'\\n\\\n             rmdir: removing directory, 'dir'\\n\",\n        )\n        .stderr_is(format!(\n            \"rmdir: failed to remove 'does_not_exist': {NOT_FOUND}\\n\"\n        ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_paging_scan_multi_ranges", "code": "pub fn get_record_range_one(&self, handle_id: i64) -> KeyRange {\n        self.get_record_range(handle_id, handle_id)\n    }", "test": "fn test_paging_scan_multi_ranges() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (3, Some(\"name:5\"), 5),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n    // set batch size and grow size to 1, so that only 1 row will be scanned in each\n    // batch.\n    fail::cfg(\"copr_batch_initial_size\", \"return(1)\").unwrap();\n    fail::cfg(\"copr_batch_grow_size\", \"return(1)\").unwrap();\n\n    // test multi ranges with gap\n    for desc in [true, false] {\n        for paging_size in [3, 5] {\n            let mut exp = [data[0], data[1], data[3], data[4]];\n            if desc {\n                exp.reverse();\n            }\n\n            let builder = DagSelect::from(&product)\n                .paging_size(paging_size)\n                .desc(desc);\n            let mut range1 = builder.key_ranges[0].clone();\n            range1.set_end(product.get_record_range_one(data[1].0).get_end().into());\n            let mut range2 = builder.key_ranges[0].clone();\n            range2.set_start(product.get_record_range_one(data[3].0).get_start().into());\n            let key_ranges = vec![range1.clone(), range2.clone()];\n\n            let req = builder.key_ranges(key_ranges).build();\n            let resp = handle_request(&endpoint, req);\n            let mut select_resp = SelectResponse::default();\n            select_resp.merge_from_bytes(resp.get_data()).unwrap();\n\n            let mut row_count = 0;\n            let spliter = DagChunkSpliter::new(select_resp.take_chunks().into(), 3);\n            for (row, (id, name, cnt)) in spliter.zip(exp) {\n                let name_datum = name.unwrap().as_bytes().into();\n                let expected_encoded = datum::encode_value(\n                    &mut EvalContext::default(),\n                    &[Datum::I64(id), name_datum, Datum::I64(cnt)],\n                )\n                .unwrap();\n                let result_encoded =\n                    datum::encode_value(&mut EvalContext::default(), &row).unwrap();\n                assert_eq!(result_encoded, &*expected_encoded);\n                row_count += 1;\n            }\n            let exp_len = if paging_size <= 4 {\n                paging_size\n            } else {\n                exp.len() as u64\n            };\n            assert_eq!(row_count, exp_len);\n\n            let res_range = resp.get_range();\n\n            let (res_start_key, res_end_key) = match desc {\n                true => (res_range.get_end(), res_range.get_start()),\n                false => (res_range.get_start(), res_range.get_end()),\n            };\n            if paging_size != 5 {\n                let start_key = match desc {\n                    true => range2.get_end(),\n                    false => range1.get_start(),\n                };\n                let end_id = match desc {\n                    true => data[1].0,\n                    false => data[3].0,\n                };\n                let end_key = product.get_record_range_one(end_id);\n                assert_eq!(res_start_key, start_key);\n                assert_ge!(res_end_key, end_key.get_start());\n                assert_le!(res_end_key, end_key.get_end());\n            } else {\n                // drained.\n                assert!(res_start_key.is_empty());\n                assert!(res_end_key.is_empty());\n            }\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_stdin_only_bytes", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_stdin_only_bytes() {\n    new_ucmd!()\n        .args(&[\"-c\"])\n        .pipe_in_fixture(\"lorem_ipsum.txt\")\n        .run()\n        .stdout_is(\"772\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_server_down_peers_with_hibernate_regions", "code": "fn test_down_peers<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.max_peer_down_duration = ReadableDuration::secs(1);\n    cluster.run();\n\n    // Kill 1, 2\n    for len in 1..3 {\n        let id = len;\n        cluster.stop_node(id);\n        wait_down_peers(cluster, len, Some(id));\n    }\n\n    // Restart 1, 2\n    cluster.run_node(1).unwrap();\n    cluster.run_node(2).unwrap();\n    wait_down_peers(cluster, 0, None);\n\n    cluster.stop_node(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    // max peer down duration is 500 millis, but we only report down time in\n    // seconds, so sleep 1 second to make the old down second is always larger\n    // than new down second by at lease 1 second.\n    sleep_ms(1000);\n\n    wait_down_peers(cluster, 1, Some(1));\n    let down_secs = cluster.get_down_peers()[&1].get_down_seconds();\n    let timer = Instant::now();\n    let leader = cluster.leader_of_region(1).unwrap();\n    let new_leader = if leader.get_id() == 2 {\n        new_peer(3, 3)\n    } else {\n        new_peer(2, 2)\n    };\n\n    cluster.must_transfer_leader(1, new_leader);\n    // new leader should reset all down peer list.\n    wait_down_peers(cluster, 0, None);\n    wait_down_peers(cluster, 1, Some(1));\n    assert!(\n        cluster.get_down_peers()[&1].get_down_seconds()\n            < down_secs + timer.saturating_elapsed().as_secs()\n    );\n\n    // Ensure that node will not reuse the previous peer heartbeats.\n    cluster.must_transfer_leader(1, leader);\n    wait_down_peers(cluster, 0, None);\n    wait_down_peers(cluster, 1, Some(1));\n    assert!(\n        cluster.get_down_peers()[&1].get_down_seconds() < timer.saturating_elapsed().as_secs() + 1\n    );\n}", "test": "fn test_server_down_peers_with_hibernate_regions() {\n    let mut cluster = new_server_cluster(0, 5);\n    // When hibernate_regions is enabled, down peers are not detected in time\n    // by design. So here use a short check interval to trigger region heartbeat\n    // more frequently.\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration::millis(500);\n    test_down_peers(&mut cluster);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_taproot_sig", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_taproot_sig() {\n    let s = include_str!(\"data/serde/taproot_sig_hex\");\n    let sig = taproot::Signature {\n        sig: secp256k1::schnorr::Signature::from_str(s.trim()).unwrap(),\n        hash_ty: TapSighashType::All,\n    };\n\n    let got = serialize(&sig).unwrap();\n    let want = include_bytes!(\"data/serde/taproot_sig_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_flush_does_nothing", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn server_flush_does_nothing() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    assert!(matches!(server.writer().flush(), Ok(())));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_empty_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iter_empty_engine() {\n    let db = default_engine();\n    iter_empty(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_async_apply_prewrite_1pc", "code": "fn test_async_apply_prewrite_1pc_impl<E: Engine, F: KvFormat>(\n    storage: &Storage<E, MockLockManager, F>,\n    ctx: Context,\n    key: &[u8],\n    value: &[u8],\n    start_ts: u64,\n    is_pessimistic: bool,\n) {\n    let on_handle_apply = \"on_handle_apply\";\n\n    let start_ts = TimeStamp::from(start_ts);\n\n    if is_pessimistic {\n        let (tx, rx) = channel();\n        storage\n            .sched_txn_command(\n                commands::AcquirePessimisticLock::new(\n                    vec![(Key::from_raw(key), false)],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    true,\n                    start_ts,\n                    None,\n                    false,\n                    0.into(),\n                    false,\n                    false,\n                    false,\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n        rx.recv_timeout(Duration::from_secs(5))\n            .unwrap()\n            .unwrap()\n            .unwrap();\n    }\n\n    // Prewrite and block it at apply phase.\n    fail::cfg(on_handle_apply, \"pause\").unwrap();\n    let (tx, rx) = channel();\n    if !is_pessimistic {\n        storage\n            .sched_txn_command(\n                commands::Prewrite::new(\n                    vec![Mutation::make_put(Key::from_raw(key), value.to_vec())],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    false,\n                    1,\n                    0.into(),\n                    0.into(),\n                    None,\n                    true,\n                    AssertionLevel::Off,\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n    } else {\n        storage\n            .sched_txn_command(\n                commands::PrewritePessimistic::new(\n                    vec![(\n                        Mutation::make_put(Key::from_raw(key), value.to_vec()),\n                        DoPessimisticCheck,\n                    )],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    start_ts,\n                    1,\n                    0.into(),\n                    0.into(),\n                    None,\n                    true,\n                    AssertionLevel::Off,\n                    vec![],\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n    }\n\n    let res = rx.recv_timeout(Duration::from_secs(5)).unwrap().unwrap();\n    assert_eq!(res.locks.len(), 0);\n    assert!(res.one_pc_commit_ts > start_ts);\n    let commit_ts = res.one_pc_commit_ts;\n\n    let err = block_on(storage.get(ctx.clone(), Key::from_raw(key), commit_ts.next())).unwrap_err();\n    expect_locked(err, key, start_ts);\n\n    fail::remove(on_handle_apply);\n    // The key may need some time to be applied.\n    for retry in 0.. {\n        let res = block_on(storage.get(ctx.clone(), Key::from_raw(key), commit_ts.next()));\n        match res {\n            Ok(v) => {\n                assert_eq!(v.0.unwrap().as_slice(), value);\n                break;\n            }\n            Err(e) => expect_locked(e, key, start_ts),\n        }\n\n        if retry > 20 {\n            panic!(\"the key is not applied for too long time\");\n        }\n        thread::sleep(Duration::from_millis(200));\n    }\n}", "test": "fn test_async_apply_prewrite_1pc() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster\n        .sim\n        .read()\n        .unwrap()\n        .storages\n        .get(&1)\n        .unwrap()\n        .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .async_apply_prewrite(true)\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n\n    test_async_apply_prewrite_1pc_impl(&storage, ctx.clone(), b\"key\", b\"value1\", 10, false);\n    test_async_apply_prewrite_1pc_impl(&storage, ctx, b\"key\", b\"value2\", 20, true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_multiple_files", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let target_dir = \"test_mv_multiple_files_dir\";\n    let file_a = \"test_mv_multiple_file_a\";\n    let file_b = \"test_mv_multiple_file_b\";\n\n    at.mkdir(target_dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a)\n        .arg(file_b)\n        .arg(target_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{target_dir}/{file_a}\")));\n    assert!(at.file_exists(format!(\"{target_dir}/{file_b}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_threshold", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_du_threshold() {\n    let ts = TestScenario::new(util_name!());\n\n    let threshold = if cfg!(windows) { \"7K\" } else { \"10K\" };\n\n    ts.ucmd()\n        .arg(format!(\"--threshold={threshold}\"))\n        .succeeds()\n        .stdout_contains(\"links\")\n        .stdout_does_not_contain(\"deeper_dir\");\n\n    ts.ucmd()\n        .arg(format!(\"--threshold=-{threshold}\"))\n        .succeeds()\n        .stdout_does_not_contain(\"links\")\n        .stdout_contains(\"deeper_dir\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/checkpoint.rs::test_encrypted_checkpoint", "code": "fn get_value_cf(&self, cf: &str, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_cf_opt(&ReadOptions::default(), cf, key)\n    }", "test": "fn test_encrypted_checkpoint() {\n    let dir = tempdir();\n    let root_path = dir.path();\n\n    let encryption_cfg = test_util::new_file_security_config(root_path);\n    let key_manager = Arc::new(\n        data_key_manager_from_config(&encryption_cfg, root_path.to_str().unwrap())\n            .unwrap()\n            .unwrap(),\n    );\n\n    let mut db_opts = DbOptions::default();\n    db_opts.set_key_manager(Some(key_manager));\n    let cf_opts: Vec<_> = ALL_CFS.iter().map(|cf| (*cf, CfOptions::new())).collect();\n\n    let path1 = root_path.join(\"1\").to_str().unwrap().to_owned();\n    let db1 = KvTestEngine::new_kv_engine_opt(&path1, db_opts.clone(), cf_opts.clone()).unwrap();\n    db1.put(b\"foo\", b\"bar\").unwrap();\n    db1.sync().unwrap();\n\n    let path2 = root_path.join(\"2\");\n    let mut checkpointer = db1.new_checkpointer().unwrap();\n    checkpointer.create_at(&path2, None, 0).unwrap();\n    let db2 =\n        KvTestEngine::new_kv_engine_opt(path2.to_str().unwrap(), db_opts.clone(), cf_opts.clone())\n            .unwrap();\n    assert_eq!(\n        db2.get_value_cf(CF_DEFAULT, b\"foo\").unwrap().unwrap(),\n        b\"bar\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_hibernate_feature_gate", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_hibernate_feature_gate() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.reset_version(\"4.0.0\");\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Wait for hibernation check.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 3\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n\n    // Ensure leader won't sleep if cluster version is small.\n    let awakened = Arc::new(AtomicBool::new(false));\n    let filter = Arc::new(AtomicBool::new(true));\n    let a = awakened.clone();\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .direction(Direction::Send)\n            .set_msg_callback(Arc::new(move |_| {\n                a.store(true, Ordering::SeqCst);\n            }))\n            .when(filter.clone()),\n    ));\n    thread::sleep(cluster.cfg.raft_store.raft_heartbeat_interval() * 2);\n    assert!(awakened.load(Ordering::SeqCst));\n\n    // Simulating all binaries are upgraded to 5.0.0.\n    cluster.pd_client.reset_version(\"5.0.0\");\n    filter.store(false, Ordering::SeqCst);\n    // Wait till leader peer goes to sleep.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 3\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n    awakened.store(false, Ordering::SeqCst);\n    filter.store(true, Ordering::SeqCst);\n    thread::sleep(cluster.cfg.raft_store.raft_heartbeat_interval() * 2);\n    // Leader can go to sleep as version requirement is met.\n    assert!(!awakened.load(Ordering::SeqCst));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::print_verbose", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn print_verbose() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--verbose\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"print_verbose\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname", "code": "pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    }", "test": "fn test_hostname() {\n    let ls_default_res = new_ucmd!().succeeds();\n    let ls_short_res = new_ucmd!().arg(\"-s\").succeeds();\n    let ls_domain_res = new_ucmd!().arg(\"-d\").succeeds();\n\n    assert!(ls_default_res.stdout().len() >= ls_short_res.stdout().len());\n    assert!(ls_default_res.stdout().len() >= ls_domain_res.stdout().len());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_reboot_minority_followers", "code": "fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };\n\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        // Once we see a response on the wire we know a prevote round is happening.\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with failure prevote notifier, got {:?}\", received);\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during failure.\",\n        );\n    }\n\n    // Let the cluster recover.\n    match failure_type {\n        FailureType::Partition(..) => {\n            cluster.clear_send_filters();\n        }\n        FailureType::Reboot(peers) => {\n            cluster.clear_send_filters();\n            peers.iter().for_each(|&peer| {\n                cluster.run_node(peer).unwrap();\n            });\n        }\n    };\n\n    // Prepare to listen.\n    let rx = if let Some((id, _)) = detect_during_recovery {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached recovery prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    if let Some(leader_id) = leader_after_failure_id.into() {\n        cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    };\n\n    // Once we see a response on the wire we know a prevote round is happening.\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with recovery prevote notifier, got {:?}\", received);\n\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during recovery.\",\n        );\n    };\n\n    cluster.must_put(b\"k3\", b\"v3\");\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n}", "test": "fn test_prevote_reboot_minority_followers() {\n    let mut cluster = new_node_cluster(0, 5);\n    // A prevote round will start, but nothing will succeed until recovery.\n    test_prevote(\n        &mut cluster,\n        FailureType::Reboot(&[4, 5]),\n        None,\n        (2, false),\n        (2, false),\n    );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_unary_ops_string_compare", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_unary_ops_string_compare() {\n    test_same(\"a=-1;\");\n    test(\"a = ~0\", \"a=-1;\");\n    test(\"a = ~1\", \"a=-2;\");\n    test(\"a = ~101\", \"a=-102;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_nil", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=nil\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/iloop.rs::loop_interrupt_from_afar", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn loop_interrupt_from_afar() -> anyhow::Result<()> {\n    // Create an instance which calls an imported function on each iteration of\n    // the loop so we can count the number of loop iterations we've executed so\n    // far.\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    static STOP: AtomicBool = AtomicBool::new(false);\n    let mut store = interruptable_store();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (import \"\" \"\" (func))\n\n            (func (export \"loop\")\n                (loop\n                    call 0\n                    br 0)\n            )\n        \"#,\n    )?;\n    let func = Func::wrap(&mut store, || {\n        HITS.fetch_add(1, SeqCst);\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n\n    // Use the engine to wait for it to enter the loop long enough and then we\n    // signal an interrupt happens.\n    let engine = store.engine().clone();\n    let thread = std::thread::spawn(move || {\n        while HITS.load(SeqCst) <= NUM_HITS && !STOP.load(SeqCst) {\n            // continue ...\n        }\n        println!(\"interrupting\");\n        engine.increment_epoch();\n    });\n\n    // Enter the infinitely looping function and assert that our interrupt\n    // handle does indeed actually interrupt the function.\n    let iloop = instance.get_typed_func::<(), ()>(&mut store, \"loop\")?;\n    let trap = iloop.call(&mut store, ()).unwrap_err().downcast::<Trap>()?;\n    STOP.store(true, SeqCst);\n    thread.join().unwrap();\n    assert!(HITS.load(SeqCst) > NUM_HITS);\n    assert_eq!(trap, Trap::Interrupt);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_arg_overrides_stdin", "code": "pub fn normalized_newlines_stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        let msg = msg.as_ref().replace(\"\\r\\n\", \"\\n\");\n        assert_eq!(self.stdout_str().replace(\"\\r\\n\", \"\\n\"), msg);\n        self\n    }", "test": "fn test_arg_overrides_stdin() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let input = \"foobarfoobar\"; // spell-checker:disable-line\n\n    at.touch(\"a\");\n\n    ucmd.arg(\"a\")\n        .pipe_in(input.as_bytes())\n        // the command might have exited before all bytes have been pipe in.\n        // in that case, we don't care about the error (broken pipe)\n        .ignore_stdin_write_error()\n        .succeeds()\n        .no_stderr()\n        .normalized_newlines_stdout_is(\"4294967295 0 a\\n\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ic", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_ic() {\n    // Test iterators that skip multiple, internal digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"__.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\"_.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"__.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__45__.56\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::empty_var_decl_undefined", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn empty_var_decl_undefined() {\n    run_test_actions([TestAction::assert_eq(\"var a; a\", JsValue::undefined())]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raft_storage.rs::test_engine_leader_change_twice", "code": "pub fn has_stale_command(&self) -> bool {\n        self.stale_command.is_some()\n    }", "test": "fn test_engine_leader_change_twice() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n\n    let region = cluster.get_region(b\"\");\n    let peers = region.get_peers();\n\n    cluster.must_transfer_leader(region.get_id(), peers[0].clone());\n    let engine = cluster.sim.rl().storages[&peers[0].get_id()].clone();\n\n    let term = cluster\n        .request(b\"\", vec![new_get_cmd(b\"\")], true, Duration::from_secs(5))\n        .get_header()\n        .get_current_term();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(peers[0].clone());\n    ctx.set_term(term);\n\n    // Not leader.\n    cluster.must_transfer_leader(region.get_id(), peers[1].clone());\n    engine\n        .put(&ctx, Key::from_raw(b\"a\"), b\"a\".to_vec())\n        .unwrap_err();\n    // Term not match.\n    cluster.must_transfer_leader(region.get_id(), peers[0].clone());\n    let res = engine.put(&ctx, Key::from_raw(b\"a\"), b\"a\".to_vec());\n    if let KvError(box KvErrorInner::Request(ref e)) = *res.as_ref().err().unwrap() {\n        assert!(e.has_stale_command());\n    } else {\n        panic!(\"expect stale command, but got {:?}\", res);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_safe_tombstone_gc", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_safe_tombstone_gc() {\n    let mut cluster = new_node_cluster(0, 5);\n\n    let tick = cluster.cfg.raft_store.raft_election_timeout_ticks;\n    let base_tick_interval = cluster.cfg.raft_store.raft_base_tick_interval.0;\n    let check_interval = base_tick_interval * (tick as u32 * 2 + 1);\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration(check_interval);\n    cluster.cfg.raft_store.abnormal_leader_missing_duration = ReadableDuration(check_interval * 2);\n    cluster.cfg.raft_store.max_leader_missing_duration = ReadableDuration(check_interval * 2);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r = cluster.run_conf_change();\n    pd_client.must_add_peer(r, new_peer(2, 2));\n    pd_client.must_add_peer(r, new_peer(3, 3));\n\n    cluster.add_send_filter(IsolationFilterFactory::new(4));\n\n    pd_client.must_add_peer(r, new_peer(4, 4));\n    pd_client.must_add_peer(r, new_peer(5, 5));\n    cluster.must_transfer_leader(r, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(5), b\"k1\", b\"v1\");\n\n    let (tx, rx) = channel::unbounded();\n    cluster.clear_send_filters();\n    cluster.add_send_filter(IsolationFilterFactory::new(5));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(r, 4)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend)\n            .set_msg_callback(Arc::new(move |msg| {\n                let _ = tx.send(msg.clone());\n            })),\n    ));\n\n    rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    pd_client.must_remove_peer(r, new_peer(4, 4));\n    let key = keys::region_state_key(r);\n    let mut state: Option<RegionLocalState> = None;\n    let timer = Instant::now();\n    while timer.saturating_elapsed() < Duration::from_secs(5) {\n        state = cluster.get_engine(4).get_msg_cf(CF_RAFT, &key).unwrap();\n        if state.is_some() {\n            break;\n        }\n        thread::sleep(Duration::from_millis(30));\n    }\n    if state.is_none() {\n        panic!(\"region on store 4 has not been tombstone after 5 seconds.\");\n    }\n    cluster.clear_send_filters();\n    cluster.add_send_filter(PartitionFilterFactory::new(vec![1, 2, 3], vec![4, 5]));\n\n    thread::sleep(base_tick_interval * tick as u32 * 3);\n    must_get_equal(&cluster.get_engine(5), b\"k1\", b\"v1\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_after_merge", "code": "fn to_vec(&self) -> Vec<Option<Bytes>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            x.push(self.get(i).map(|x| x.to_owned()));\n        }\n        x\n    }", "test": "fn test_stale_read_after_merge() {\n    let (mut cluster, pd_client, _) =\n        prepare_for_stale_read_before_run(new_peer(1, 1), Some(Box::new(configure_for_merge)));\n\n    cluster.must_split(&cluster.get_region(&[]), b\"key3\");\n    let source = pd_client.get_region(b\"key1\").unwrap();\n    let target = pd_client.get_region(b\"key5\").unwrap();\n\n    cluster.must_transfer_leader(target.get_id(), new_peer(1, 1));\n    let target_leader = PeerClient::new(&cluster, target.get_id(), new_peer(1, 1));\n    // Write `(key5, value1)`\n    target_leader.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key5\"[..], &b\"value1\"[..])],\n        b\"key5\".to_vec(),\n    );\n\n    pd_client.must_merge(source.get_id(), target.get_id());\n\n    let mut follower_client2 = PeerClient::new(&cluster, target.get_id(), new_peer(2, 2));\n    follower_client2.ctx.set_stale_read(true);\n    // We can read `(key5, value1)` with the newest ts\n    follower_client2.must_kv_read_equal(b\"key5\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_commas", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_ls_commas() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(at.plus_as_string(\"test-commas-1\"));\n    at.touch(at.plus_as_string(\"test-commas-2\"));\n    at.touch(at.plus_as_string(\"test-commas-3\"));\n    at.touch(at.plus_as_string(\"test-commas-4\"));\n\n    for option in COMMA_ARGS {\n        let result = scene.ucmd().arg(option).succeeds();\n        result.stdout_only(\"test-commas-1, test-commas-2, test-commas-3, test-commas-4\\n\");\n    }\n\n    for option in COMMA_ARGS {\n        scene\n            .ucmd()\n            .arg(\"-w=30\")\n            .arg(option)\n            .succeeds()\n            .stdout_only(\"test-commas-1, test-commas-2,\\ntest-commas-3, test-commas-4\\n\");\n    }\n    for option in COMMA_ARGS {\n        scene\n            .ucmd()\n            .arg(\"-w=45\")\n            .arg(option)\n            .succeeds()\n            .stdout_only(\"test-commas-1, test-commas-2, test-commas-3,\\ntest-commas-4\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/resolved_ts/tests/integrations/mod.rs::test_dynamic_change_advance_ts_interval", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_dynamic_change_advance_ts_interval() {\n    let mut suite = TestSuite::new(1);\n    let region = suite.cluster.get_region(&[]);\n\n    // `reolved-ts` should update with the interval of 10ms\n    suite.must_get_rts_ge(\n        region.id,\n        block_on(suite.cluster.pd_client.get_tso()).unwrap(),\n    );\n\n    // change the interval to 10min\n    suite.must_change_advance_ts_interval(1, Duration::from_secs(600));\n    // sleep to wait for previous update task finish\n    sleep_ms(200);\n\n    // `resolved-ts` should not be updated\n    for _ in 0..10 {\n        if let Some(ts) = suite.region_resolved_ts(region.id) {\n            if block_on(suite.cluster.pd_client.get_tso()).unwrap() <= ts {\n                panic!(\"unexpect update\");\n            }\n        }\n        sleep_ms(10)\n    }\n\n    // change the interval to 10ms\n    suite.must_change_advance_ts_interval(1, Duration::from_millis(10));\n    // `resolved-ts` should be updated immediately\n    suite.must_get_rts_ge(\n        region.id,\n        block_on(suite.cluster.pd_client.get_tso()).unwrap(),\n    );\n\n    suite.stop();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::var_regression", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn var_regression() {\n    let source = r#\"\n    void foo() {\n        a::b;\n        w.func(x,x);\n      }\n    \"#;\n\n    let needle = \"{\n        $y::$z;\n        _.func($x,$x);\n    }\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_no_equal", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_hex_suffix_no_equal() {\n    new_ucmd!()\n        .args(&[\"-n\", \"4\", \"--hex-suffixes\", \"9\", \"threebytes.txt\"])\n        .fails()\n        .stderr_contains(\"split: cannot open '9' for reading: No such file or directory\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_01", "code": "pub fn resume<T>(\n        self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        inputs: &[Value],\n        outputs: &mut [Value],\n    ) -> Result<ResumableCall, Error> {\n        self.engine\n            .resolve_func_type(self.host_func().ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(inputs, true)\n            })?;\n        self.engine\n            .resolve_func_type(self.func.ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(outputs, false)?;\n                func_type.prepare_outputs(outputs);\n                <Result<(), Error>>::Ok(()) // TODO: why do we need types here?\n            })?;\n        self.engine\n            .clone()\n            .resume_func(ctx.as_context_mut(), self, inputs, outputs)\n            .map_err(Into::into)\n            .map(ResumableCall::new)\n    }", "test": "fn resumable_call_smoldot_01() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (call $host_fn)\n            )\n        )\n        \"#,\n    );\n    let invocation = wasm_fn.call_resumable(&mut store, ()).unwrap_resumable();\n    match invocation.resume(&mut store, &[Value::I32(42)]).unwrap() {\n        TypedResumableCall::Finished(result) => assert_eq!(result, 42),\n        TypedResumableCall::Resumable(_) => panic!(\"expected TypeResumableCall::Finished\"),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_short_hex", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_short_hex() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\xa bar\"])\n        .succeeds()\n        .stdout_only(\"foo\\n bar\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_metrics.rs::test_raw_gc_keys_handled", "code": "fn get(&self, mut req: Get) -> PdFuture<GetResponse> {\n        let timer = Instant::now();\n        self.fill_cluster_id_for(req.inner.mut_header());\n        let executor = move |client: &Client, req: GetRequest| {\n            let handler = {\n                let inner = client.inner.rl();\n                let r = inner\n                    .meta_storage\n                    .get_async_opt(&req, call_option_inner(&inner));\n                futures::future::ready(r).err_into().try_flatten()\n            };\n            Box::pin(async move {\n                fail::fail_point!(\"meta_storage_get\", req.key.ends_with(b\"rejectme\"), |_| {\n                    Err(super::Error::Grpc(grpcio::Error::RemoteStopped))\n                });\n                let resp = handler.await?;\n                PD_REQUEST_HISTOGRAM_VEC\n                    .meta_storage_get\n                    .observe(timer.saturating_elapsed_secs());\n                Ok(resp)\n            }) as _\n        };\n\n        self.pd_client\n            .request(req.into(), executor, LEADER_CHANGE_RETRY)\n            .execute()\n    }", "test": "fn test_raw_gc_keys_handled() {\n    let store_id = 1;\n    GC_COMPACTION_FILTER_MVCC_DELETION_MET.reset();\n    GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED.reset();\n\n    let engine = TestEngineBuilder::new()\n        .api_version(ApiVersion::V2)\n        .build()\n        .unwrap();\n    let prefixed_engine = PrefixedEngine(engine.clone());\n\n    let (tx, _rx) = mpsc::channel();\n    let feature_gate = FeatureGate::default();\n    let mut gc_worker = GcWorker::new(\n        prefixed_engine,\n        tx,\n        GcConfig::default(),\n        feature_gate,\n        Arc::new(MockRegionInfoProvider::new(vec![])),\n    );\n    gc_worker.start(store_id).unwrap();\n\n    let mut r1 = Region::default();\n    r1.set_id(1);\n    r1.mut_region_epoch().set_version(1);\n    r1.set_start_key(b\"\".to_vec());\n    r1.set_end_key(b\"\".to_vec());\n    r1.mut_peers().push(Peer::default());\n    r1.mut_peers()[0].set_store_id(store_id);\n\n    let sp_provider = MockSafePointProvider(200);\n    let mut host = CoprocessorHost::<RocksEngine>::default();\n    let ri_provider = RegionInfoAccessor::new(&mut host);\n    let auto_gc_cfg = AutoGcConfig::new(sp_provider, ri_provider, store_id);\n    let safe_point = Arc::new(AtomicU64::new(500));\n\n    gc_worker.start_auto_gc(auto_gc_cfg, safe_point).unwrap();\n    host.on_region_changed(&r1, RegionChangeEvent::Create, StateRole::Leader);\n\n    let db = engine.kv_engine().unwrap().as_inner().clone();\n\n    let user_key_del = b\"r\\0aaaaaaaaaaa\";\n\n    // If it's deleted, it will call async scheduler GcTask.\n    let test_raws = vec![\n        (user_key_del, 9, true),\n        (user_key_del, 5, false),\n        (user_key_del, 1, false),\n    ];\n\n    let modifies = test_raws\n        .into_iter()\n        .map(|(key, ts, is_delete)| {\n            (\n                make_key(key, ts),\n                ApiV2::encode_raw_value(RawValue {\n                    user_value: &[0; 10][..],\n                    expire_ts: Some(TimeStamp::max().into_inner()),\n                    is_delete,\n                }),\n            )\n        })\n        .map(|(k, v)| Modify::Put(CF_DEFAULT, Key::from_encoded_slice(k.as_slice()), v))\n        .collect();\n\n    let ctx = Context {\n        api_version: ApiVersion::V2,\n        ..Default::default()\n    };\n\n    let batch = WriteData::from_modifies(modifies);\n\n    engine.write(&ctx, batch).unwrap();\n\n    let cf = get_cf_handle(&db, CF_DEFAULT).unwrap();\n    db.flush_cf(cf, true, false).unwrap();\n\n    db.compact_range_cf(cf, None, None);\n\n    thread::sleep(Duration::from_millis(100));\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_MVCC_DELETION_MET\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        1\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        1\n    );\n\n    GC_COMPACTION_FILTER_MVCC_DELETION_MET.reset();\n    GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED.reset();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit125_wasi_snapshot0", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit125_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit125_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    if cfg!(windows) {\n        assert_eq!(output.status.code().unwrap(), 1);\n    } else {\n        assert_eq!(output.status.code().unwrap(), 125);\n    }\n    Ok(())\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::read_isolation", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn read_isolation() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut write_table = write_txn.open_table(STR_TABLE).unwrap();\n        write_table.remove(\"hello\").unwrap();\n        write_table.insert(\"hello2\", \"world2\").unwrap();\n        write_table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\"world2\", table2.get(\"hello2\").unwrap().unwrap().value());\n    assert_eq!(\"world3\", table2.get(\"hello3\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert!(table.get(\"hello2\").unwrap().is_none());\n    assert!(table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_comma_separated_tabs_shortcut", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_comma_separated_tabs_shortcut() {\n    new_ucmd!()\n        .args(&[\"-a\", \"-3,9\"])\n        .pipe_in(\"a  b     c\")\n        .run()\n        .stdout_is(\"a\\tb\\tc\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::tree_balance", "code": "pub fn abort(mut self) -> Result {\n        // Set completed flag first, so that we don't go through the abort() path on drop, if this fails\n        self.completed = true;\n        self.abort_inner()\n    }", "test": "fn tree_balance() {\n    const EXPECTED_ORDER: usize = 9;\n    fn expected_height(mut elements: usize) -> u32 {\n        // Root may have only 2 entries\n        let mut height = 1;\n        elements /= 2;\n\n        // Leaves may have only a single entry\n        height += 1;\n\n        // Each internal node half-full, plus 1 to round up\n        height += (elements as f32).log((EXPECTED_ORDER / 2) as f32) as usize + 1;\n\n        height.try_into().unwrap()\n    }\n\n    let tmpfile = create_tempfile();\n\n    // One for the last table id counter, and one for the \"x\" -> TableDefinition entry\n    let num_internal_entries = 2;\n\n    // Pages are 4kb, so use a key size such that 9 keys will fit\n    let key_size = 410;\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let elements = (EXPECTED_ORDER / 2).pow(2) - num_internal_entries;\n\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in (0..elements).rev() {\n            let mut key = vec![0u8; key_size];\n            key[0..8].copy_from_slice(&(i as u64).to_le_bytes());\n            table.insert(key.as_slice(), b\"\".as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let expected = expected_height(elements + num_internal_entries);\n    let txn = db.begin_write().unwrap();\n    let height = txn.stats().unwrap().tree_height();\n    assert!(height <= expected, \"height={height} expected={expected}\",);\n\n    let reduce_to = EXPECTED_ORDER / 2 - num_internal_entries;\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..(elements - reduce_to) {\n            let mut key = vec![0u8; key_size];\n            key[0..8].copy_from_slice(&(i as u64).to_le_bytes());\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let expected = expected_height(reduce_to + num_internal_entries);\n    let txn = db.begin_write().unwrap();\n    let height = txn.stats().unwrap().tree_height();\n    txn.abort().unwrap();\n    assert!(height <= expected, \"height={height} expected={expected}\",);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_custom_backup_suffix_via_env", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_custom_backup_suffix_via_env() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let suffix = \"super-suffix-of-the-century\";\n\n    ucmd.arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}{suffix}\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_logical_or", "code": "pub(super) fn assert_to_string(value: impl Display, expected: &str) {\n    assert_eq!(value.to_string(), expected);\n}", "test": "pub fn test_logical_or() {\n    // https://github.com/steveklabnik/semver/issues/57\n    let err = req_err(\"=1.2.3 || =2.3.4\");\n    assert_to_string(err, \"expected comma after patch version number, found '|'\");\n\n    let err = req_err(\"1.1 || =1.2.3\");\n    assert_to_string(err, \"expected comma after minor version number, found '|'\");\n\n    let err = req_err(\"6.* || 8.* || >= 10.*\");\n    assert_to_string(err, \"expected comma after minor version number, found '|'\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/trailers.rs::recv_trailers_only", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn recv_trailers_only() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 5, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 0x88, 0, 0, 9, 1, 5, 0, 0, 0, 1, 0x40, 0x84, 0x42, 0x46,\n            0x9B, 0x51, 0x82, 0x3F, 0x5F,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let response = h2.run(response).await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let (_, mut body) = response.into_parts();\n\n    // Make sure there is no body\n    let chunk = h2.run(Box::pin(body.next())).await;\n    assert!(chunk.is_none());\n\n    let trailers = h2\n        .run(poll_fn(|cx| body.poll_trailers(cx)))\n        .await\n        .unwrap()\n        .unwrap();\n    assert_eq!(1, trailers.len());\n    assert_eq!(trailers[\"status\"], \"ok\");\n\n    h2.await.unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_file_notexisting", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_file_notexisting() {\n    // test chown username not_existing\n\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    scene\n        .ucmd()\n        .arg(&user_name)\n        .arg(\"--verbose\")\n        .arg(\"not_existing\")\n        .fails()\n        .stdout_contains(format!(\n            \"failed to change ownership of 'not_existing' to {user_name}\"\n        ));\n    // TODO: uncomment once message changed from \"cannot dereference\" to \"cannot access\"\n    // result.stderr_contains(\"cannot access 'not_existing': No such file or directory\");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::simple_cpp", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn simple_cpp() {\n    let source = r#\"\n    #include <iostream>\n    int main() {\n    std::cout << \"Hello World!\";\n    return 0;\n    }\"#;\n\n    let needle = \"_ $func() {std::cout << _;}\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_resolve_lock_deadline", "code": "pub fn send(&self, addr: u64, msg: N::Message) -> Result<(), TrySendError<N::Message>> {\n        match self.try_send(addr, msg) {\n            Either::Left(res) => res,\n            Either::Right(m) => Err(TrySendError::Disconnected(m)),\n        }\n    }", "test": "fn test_resolve_lock_deadline() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster.sim.read().unwrap().storages[&1].clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n\n    // One resolve lock batch is 256 keys. So we need to prewrite more than that.\n    let mutations = (1i32..300)\n        .map(|i| {\n            let data = i.to_le_bytes();\n            Mutation::make_put(Key::from_raw(&data), data.to_vec())\n        })\n        .collect();\n    let cmd = commands::Prewrite::new(\n        mutations,\n        1i32.to_le_bytes().to_vec(),\n        10.into(),\n        1,\n        false,\n        299,\n        15.into(),\n        20.into(),\n        None,\n        false,\n        AssertionLevel::Off,\n        ctx.clone(),\n    );\n    let (tx, rx) = channel();\n    storage\n        .sched_txn_command(\n            cmd,\n            Box::new(move |res: storage::Result<_>| {\n                tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    rx.recv().unwrap().unwrap();\n\n    // Resolve lock, this needs two rounds, two process_read and two process_write.\n    // So it needs more than 400ms. It will exceed the deadline.\n    ctx.max_execution_duration_ms = 300;\n    fail::cfg(\"txn_before_process_read\", \"1*sleep(100)->sleep(200)\").unwrap();\n    fail::cfg(\"txn_before_process_write\", \"1*sleep(100)->sleep(500)\").unwrap();\n    let (tx, rx) = channel();\n    let mut txn_status = HashMap::default();\n    txn_status.insert(TimeStamp::new(10), TimeStamp::new(0));\n    storage\n        .sched_txn_command(\n            commands::ResolveLockReadPhase::new(txn_status, None, ctx),\n            Box::new(move |res: storage::Result<_>| {\n                tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    assert!(matches!(\n        rx.recv().unwrap(),\n        Err(StorageError(box StorageErrorInner::DeadlineExceeded))\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_lines_with_size_suffix", "code": "pub fn stdout_is_fixture<T: AsRef<OsStr>>(&self, file_rel_path: T) -> &Self {\n        let contents = read_scenario_fixture(&self.tmpd, file_rel_path);\n        self.stdout_is(String::from_utf8(contents).unwrap())\n    }", "test": "fn test_lines_with_size_suffix() {\n    const FILE: &str = \"test_lines_with_size_suffix.txt\";\n    const EXPECTED_FILE: &str = \"test_lines_with_size_suffix_expected.txt\";\n    const LINES: usize = 3_000;\n    const N_ARG: usize = 2 * 1024;\n\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let mut big_input = at.make_file(FILE);\n    for i in 0..LINES {\n        writeln!(big_input, \"Line {i}\").expect(\"Could not write to FILE\");\n    }\n    big_input.flush().expect(\"Could not flush FILE\");\n\n    let mut big_expected = at.make_file(EXPECTED_FILE);\n    for i in (LINES - N_ARG)..LINES {\n        writeln!(big_expected, \"Line {i}\").expect(\"Could not write to EXPECTED_FILE\");\n    }\n    big_expected.flush().expect(\"Could not flush EXPECTED_FILE\");\n\n    ucmd.arg(FILE)\n        .arg(\"-n\")\n        .arg(\"2K\")\n        .run()\n        .stdout_is_fixture(EXPECTED_FILE);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix_no_equal", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_numeric_suffix_no_equal() {\n    new_ucmd!()\n        .args(&[\"-n\", \"4\", \"--numeric-suffixes\", \"9\", \"threebytes.txt\"])\n        .fails()\n        .stderr_contains(\"split: cannot open '9' for reading: No such file or directory\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::max_diagnostics_default", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn max_diagnostics_default() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    for i in 0..60 {\n        let file_path = PathBuf::from(format!(\"src/file_{i}.js\"));\n        fs.insert(file_path, UNFORMATTED.as_bytes());\n    }\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), (\"src\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut diagnostic_count = 0;\n    let mut filtered_messages = Vec::new();\n\n    for msg in console.out_buffer {\n        let MarkupBuf(nodes) = &msg.content;\n        let is_diagnostic = nodes.iter().any(|node| {\n            node.content\n                .contains(\"File content differs from formatting output\")\n                || node.content.contains(\"format\")\n                || node.content.contains(\"lint\")\n                || node.content.contains(\"ci\")\n        });\n\n        if is_diagnostic {\n            diagnostic_count += 1;\n        } else {\n            filtered_messages.push(msg);\n        }\n    }\n\n    console.out_buffer = filtered_messages;\n\n    for i in 0..60 {\n        let file_path = format!(\"src/file_{i}.js\");\n        fs.remove(Path::new(&file_path));\n    }\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"max_diagnostics_default\",\n        fs,\n        console,\n        result,\n    ));\n\n    assert_eq!(diagnostic_count, 20);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_upload_sst", "code": "pub fn send_upload_sst(\n    client: &ImportSstClient,\n    meta: &SstMeta,\n    data: &[u8],\n) -> Result<UploadResponse> {\n    let mut r1 = UploadRequest::default();\n    r1.set_meta(meta.clone());\n    let mut r2 = UploadRequest::default();\n    r2.set_data(data.to_vec());\n    let reqs: Vec<_> = vec![r1, r2]\n        .into_iter()\n        .map(|r| Result::Ok((r, WriteFlags::default())))\n        .collect();\n    let (mut tx, rx) = client.upload().unwrap();\n    let mut stream = stream::iter(reqs);\n    block_on(async move {\n        tx.send_all(&mut stream).await?;\n        tx.close().await?;\n        rx.await\n    })\n}", "test": "fn test_upload_sst() {\n    let (_cluster, ctx, _, import) = new_cluster_and_tikv_import_client();\n\n    let data = vec![1; 1024];\n    let crc32 = calc_data_crc32(&data);\n    let length = data.len() as u64;\n\n    // Mismatch crc32\n    let meta = new_sst_meta(0, length);\n    assert_to_string_contains!(send_upload_sst(&import, &meta, &data).unwrap_err(), \"crc32\");\n\n    let mut meta = new_sst_meta(crc32, length);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    // Can't upload the same uuid file again.\n    assert_to_string_contains!(\n        send_upload_sst(&import, &meta, &data).unwrap_err(),\n        \"FileExists\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_date", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_date() {\n    // Just test the date for the time 0.3 change\n    let args = [\n        \"-c\",\n        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n        \"%z\",\n        #[cfg(target_os = \"linux\")]\n        \"/bin/sh\",\n        #[cfg(target_vendor = \"apple\")]\n        \"%z\",\n        #[cfg(any(target_os = \"android\", target_vendor = \"apple\"))]\n        \"/bin/sh\",\n    ];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n    // Just test the date for the time 0.3 change\n    let args = [\n        \"-c\",\n        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n        \"%z\",\n        #[cfg(target_os = \"linux\")]\n        \"/dev/ptmx\",\n        #[cfg(target_vendor = \"apple\")]\n        \"%z\",\n        #[cfg(any(target_os = \"android\", target_vendor = \"apple\"))]\n        \"/dev/ptmx\",\n    ];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_reverse_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iter_reverse_snapshot() {\n    let db = default_engine();\n    iter_reverse(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_stdin_num_chunks", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_split_stdin_num_chunks() {\n    new_ucmd!()\n        .args(&[\"--number=1\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: -: cannot determine file size\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_negative_decimal_notation", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_negative_decimal_notation() {\n    new_ucmd!()\n        .args(&[\"-w\", \"-.1\", \".1\", \".11\"])\n        .succeeds()\n        .stdout_is(\"-0.1\\n00.0\\n00.1\\n\")\n        .no_stderr();\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/compilers/artifact.rs::artifact_serialization_roundtrip", "code": "pub fn serialize(&self) -> Result<Bytes, SerializeError> {\n        self.0.serialize()\n    }", "test": "fn artifact_serialization_roundtrip() {\n    let file_names = [\"bash.wasm\", \"cowsay.wasm\", \"python-3.11.3.wasm\"];\n\n    for file_name in file_names {\n        let path = PathBuf::from(\"tests/integration/cli/tests/wasm\").join(file_name);\n        let wasm_module = fs::read(path).unwrap();\n        let engine = Engine::default();\n        let module = Module::new(&engine, wasm_module).unwrap();\n        let serialized_bytes = module.serialize().unwrap();\n        let deserialized_module =\n            unsafe { Module::deserialize(&engine, serialized_bytes.clone()) }.unwrap();\n        let reserialized_bytes = deserialized_module.serialize().unwrap();\n        assert_eq!(serialized_bytes, reserialized_bytes);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_reject_proposal_during_leader_transfer", "code": "pub fn leader_of_region(&mut self, region_id: u64) -> Option<metapb::Peer> {\n        let timer = Instant::now_coarse();\n        let timeout = Duration::from_secs(5);\n        let mut store_ids = None;\n        while timer.saturating_elapsed() < timeout {\n            match self.voter_store_ids_of_region(region_id) {\n                None => thread::sleep(Duration::from_millis(10)),\n                Some(ids) => {\n                    store_ids = Some(ids);\n                    break;\n                }\n            }\n        }\n        let store_ids = store_ids?;\n        if let Some(l) = self.leaders.get(&region_id) {\n            // leader may be stopped in some tests.\n            if self.valid_leader_id(region_id, l.get_store_id()) {\n                return Some(l.clone());\n            }\n        }\n        self.reset_leader_of_region(region_id);\n        let mut leader = None;\n        let mut leaders = HashMap::default();\n\n        let node_ids = self.sim.rl().get_node_ids();\n        // For some tests, we stop the node but pd still has this information,\n        // and we must skip this.\n        let alive_store_ids: Vec<_> = store_ids\n            .iter()\n            .filter(|id| node_ids.contains(id))\n            .cloned()\n            .collect();\n        while timer.saturating_elapsed() < timeout {\n            for store_id in &alive_store_ids {\n                let l = match self.query_leader(*store_id, region_id, Duration::from_secs(1)) {\n                    None => continue,\n                    Some(l) => l,\n                };\n                leaders\n                    .entry(l.get_id())\n                    .or_insert((l, vec![]))\n                    .1\n                    .push(*store_id);\n            }\n            if let Some((_, (l, c))) = leaders.iter().max_by_key(|(_, (_, c))| c.len()) {\n                if c.contains(&l.get_store_id()) {\n                    leader = Some(l.clone());\n                    // Technically, correct calculation should use two quorum when in joint\n                    // state. Here just for simplicity.\n                    if c.len() > store_ids.len() / 2 {\n                        break;\n                    }\n                }\n            }\n            debug!(\"failed to detect leaders\"; \"leaders\" => ?leaders, \"store_ids\" => ?store_ids);\n            sleep_ms(10);\n            leaders.clear();\n        }\n\n        if let Some(l) = leader {\n            self.leaders.insert(region_id, l);\n        }\n\n        self.leaders.get(&region_id).cloned()\n    }", "test": "fn test_reject_proposal_during_leader_transfer() {\n    let mut cluster = new_node_cluster(0, 2);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n    let r = cluster.run_conf_change();\n    pd_client.must_add_peer(r, new_peer(2, 2));\n\n    // Don't allow leader transfer succeed if it is actually triggered.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(r, 2)\n            .msg_type(MessageType::MsgTimeoutNow)\n            .direction(Direction::Recv),\n    ));\n\n    cluster.must_put(b\"k\", b\"v\");\n    cluster.transfer_leader(r, new_peer(2, 2));\n    // The leader can't change to transferring state immediately due to\n    // pre-transfer-leader feature, so wait for a while.\n    sleep_ms(100);\n    assert_ne!(cluster.leader_of_region(r).unwrap(), new_peer(2, 2));\n\n    let force_delay_propose_batch_raft_command_fp = \"force_delay_propose_batch_raft_command\";\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"k\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        cb_receivers.assert_err();\n    }\n\n    cluster.clear_send_filters();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_command_with_no_args", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_command_with_no_args() {\n    new_ucmd!()\n        .args(&[\"-n\", \"19\", \"echo\"])\n        .run()\n        .stdout_is(\"\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::default_taken_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn default_taken_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n\n            switch (a) {\n                case 5:\n                    a = 150;\n                    break;\n                default:\n                    a = 70;\n            }\n\n            a;\n        \"#},\n        70,\n    )]);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::r#return", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn r#return() {\n    test_formatting(\n        r#\"\n        function say_hello(msg) {\n            if (msg === \"\") {\n                return 0;\n            }\n            console.log(\"hello \" + msg);\n            return;\n        }\n        say_hello(\"\");\n        say_hello(\"world\");\n        \"#,\n    );\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_connection_is_debug", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn client_connection_is_debug() {\n    let (client, _) = make_pair(KeyType::Rsa);\n    println!(\"{:?}\", client);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::guest_different_host_same", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "test": "fn guest_different_host_same() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n                (import \"t2\" (type $t2 (sub resource)))\n\n                (import \"f\" (func $f (param \"a\" (borrow $t1)) (param \"b\" (borrow $t2))))\n\n                (export $g1 \"g1\" (type $t1))\n                (export $g2 \"g2\" (type $t2))\n\n                (core func $f (canon lower (func $f)))\n                (core func $drop1 (canon resource.drop $t1))\n                (core func $drop2 (canon resource.drop $t2))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32 i32)))\n                    (import \"\" \"drop1\" (func $drop1 (param i32)))\n                    (import \"\" \"drop2\" (func $drop2 (param i32)))\n\n                    (func (export \"f\") (param i32 i32)\n                        ;; separate tables both have initial index of 0\n                        (if (i32.ne (local.get 0) (i32.const 0)) (then (unreachable)))\n                        (if (i32.ne (local.get 1) (i32.const 0)) (then (unreachable)))\n\n                        ;; host should end up getting the same resource\n                        (call $f (local.get 0) (local.get 1))\n\n                        ;; drop our borrows\n                        (call $drop1 (local.get 0))\n                        (call $drop2 (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                        (export \"drop1\" (func $drop1))\n                        (export \"drop2\" (func $drop2))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"a\" (borrow $g1)) (param \"b\" (borrow $g2))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |_, _| Ok(()))?;\n    linker.root().resource::<MyType>(\"t2\", |_, _| Ok(()))?;\n    linker.root().func_wrap(\n        \"f\",\n        |_cx, (r1, r2): (Resource<MyType>, Resource<MyType>)| {\n            assert!(!r1.owned());\n            assert!(!r2.owned());\n            assert_eq!(r1.rep(), 100);\n            assert_eq!(r2.rep(), 100);\n            Ok(())\n        },\n    )?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let f = i.get_typed_func::<(&Resource<MyType>, &Resource<MyType>), ()>(&mut store, \"f2\")?;\n\n    let t1 = i.get_resource(&mut store, \"g1\").unwrap();\n    let t2 = i.get_resource(&mut store, \"g2\").unwrap();\n    assert_eq!(t1, t2);\n    assert_eq!(t1, ResourceType::host::<MyType>());\n\n    let resource = Resource::new_own(100);\n    f.call(&mut store, (&resource, &resource))?;\n    f.post_return(&mut store)?;\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_number_new_form", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "test": "fn test_kill_with_signal_number_new_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"9\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(9));\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::func_calls", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn func_calls() {\n    let source = r#\"\n    void foo() {\n        a->bar(x);\n        b.bar(x);\n        b->bar->c(x);\n      }\n    \"#;\n\n    let needle = \"{\n        bar(x);\n    }\";\n\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 2);\n\n    let source = r#\"\n    void foo() {\n        std::memcpy(a,b,c);\n        memcpy(a,b,c);\n        b::c::d::e::memcpy(a,b,c);\n        a->func(a,b,c);\n      }\n    \"#;\n\n    let needle = \"{\n        memcpy(_);\n    }\";\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 3);\n\n    let needle = \"{\n        $func(_);\n    }\";\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 4);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_double_space", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_double_space() {\n    assert_eq!(\"test mess\", normalize_html(\"test  mess\"));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::files_max_size_parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn files_max_size_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--files-max-size=-1\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"files_max_size_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_no_argument", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_sleep_no_argument() {\n    new_ucmd!().fails().usage_error(\"missing operand\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_obsolete_syntax_small_file", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_obsolete_syntax_small_file() {\n    new_ucmd!()\n        .args(&[\"-10\"])\n        .pipe_in(\"a\\nb\\nc\\nd\\ne\\n\")\n        .succeeds()\n        .stdout_is(\"a\\nb\\nc\\nd\\ne\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_negative_byte_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_negative_byte_syntax() {\n    new_ucmd!()\n        .args(&[\"--bytes=-2\"])\n        .pipe_in(\"a\\n\")\n        .run()\n        .stdout_is(\"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_process", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_process() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-p\", \"--process\", \"--p\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::ignores_unknown_file", "code": "pub fn assert_cli_snapshot(payload: SnapshotPayload<'_>) {\n    let module_path = payload.module_path.to_owned();\n    let test_name = payload.test_name;\n    let cli_snapshot = CliSnapshot::from(payload);\n\n    let content = cli_snapshot.emit_content_snapshot();\n\n    let module_path = module_path.replace(\"::\", \"_\");\n    let snapshot_path = PathBuf::from(\"snapshots\").join(module_path);\n\n    insta::with_settings!({\n        prepend_module_to_snapshot => false,\n        snapshot_path => snapshot_path\n    }, {\n        insta::assert_snapshot!(test_name, content);\n\n    });\n}", "test": "fn ignores_unknown_file() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path1 = Path::new(\"test.txt\");\n    fs.insert(file_path1.into(), *b\"content\");\n\n    let file_path2 = Path::new(\"test.js\");\n    fs.insert(file_path2.into(), *b\"console.log('bar');\\n\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n                \"--files-ignore-unknown=true\",\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignores_unknown_file\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_offset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/+3\"])\n        .succeeds()\n        .stdout_only(\"24\\n117\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 12));\n    assert_eq!(at.read(\"xx01\"), generate(12, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_hyphen_values_at_start", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hyphen_values_at_start() {\n    new_ucmd!()\n        .arg(\"-E\")\n        .arg(\"-test\")\n        .arg(\"araba\")\n        .arg(\"-merci\")\n        .run()\n        .success()\n        .stdout_does_not_contain(\"-E\")\n        .stdout_is(\"-test araba -merci\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::wasi_misaligned_pointer", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn wasi_misaligned_pointer() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .arg(\"./tests/all/cli_tests/wasi_misaligned_pointer.wat\")\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"Pointer not aligned\"),\n        \"bad stderr: {stderr}\",\n    );\n    Ok(())\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_trailing_comma", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_trailing_comma() {\n    for (sql, canonical) in [\n        (\"SELECT a,\", \"SELECT a\"),\n        (\"SELECT 1,\", \"SELECT 1\"),\n        (\"SELECT 1,2,\", \"SELECT 1, 2\"),\n        (\"SELECT a, b,\", \"SELECT a, b\"),\n        (\"SELECT a, b AS c,\", \"SELECT a, b AS c\"),\n        (\"SELECT a, b AS c, FROM t\", \"SELECT a, b AS c FROM t\"),\n        (\"SELECT a, b, FROM t\", \"SELECT a, b FROM t\"),\n        (\"SELECT a, b, LIMIT 1\", \"SELECT a, b LIMIT 1\"),\n        (\"SELECT a, (SELECT 1, )\", \"SELECT a, (SELECT 1)\"),\n    ] {\n        bigquery().one_statement_parses_to(sql, canonical);\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::catch_trap_calling_across_stores", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn catch_trap_calling_across_stores() -> Result<()> {\n    let _ = env_logger::try_init();\n\n    let engine = Engine::default();\n\n    let mut child_store = Store::new(&engine, ());\n    let child_module = Module::new(\n        child_store.engine(),\n        r#\"\n            (module $child\n              (func $trap (export \"trap\")\n                unreachable\n              )\n            )\n        \"#,\n    )?;\n    let child_instance = Instance::new(&mut child_store, &child_module, &[])?;\n\n    struct ParentCtx {\n        child_store: Store<()>,\n        child_instance: Instance,\n    }\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\n        \"host\",\n        \"catch_child_trap\",\n        move |mut caller: Caller<'_, ParentCtx>| {\n            let mut ctx = caller.as_context_mut();\n            let data = ctx.data_mut();\n            let func = data\n                .child_instance\n                .get_typed_func::<(), ()>(&mut data.child_store, \"trap\")\n                .expect(\"trap function should be exported\");\n\n            let trap = func.call(&mut data.child_store, ()).unwrap_err();\n            assert!(\n                format!(\"{trap:?}\").contains(\"unreachable\"),\n                \"trap should contain 'unreachable', got: {trap:?}\"\n            );\n\n            let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n\n            assert_eq!(trace.len(), 1);\n            assert_eq!(trace[0].func_name(), Some(\"trap\"));\n            // For now, we only get stack frames for Wasm in this store, not\n            // across all stores.\n            //\n            // assert_eq!(trace[1].func_name(), Some(\"run\"));\n\n            Ok(())\n        },\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        ParentCtx {\n            child_store,\n            child_instance,\n        },\n    );\n\n    let parent_module = Module::new(\n        store.engine(),\n        r#\"\n            (module $parent\n              (func $host.catch_child_trap (import \"host\" \"catch_child_trap\"))\n              (func $run (export \"run\")\n                call $host.catch_child_trap\n              )\n            )\n        \"#,\n    )?;\n\n    let parent_instance = linker.instantiate(&mut store, &parent_module)?;\n\n    let func = parent_instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n    func.call(store, ())?;\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_invalid_external_storage", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_invalid_external_storage() {\n    let mut suite = TestSuite::new(1, 144 * 1024 * 1024, ApiVersion::V1);\n    // Put some data.\n    suite.must_kv_put(3, 1);\n\n    // Set backup directory read-only. TiKV fails to backup.\n    let tmp = Builder::new().tempdir().unwrap();\n    let f = File::open(tmp.path()).unwrap();\n    let mut perms = f.metadata().unwrap().permissions();\n    perms.set_readonly(true);\n    f.set_permissions(perms.clone()).unwrap();\n\n    let backup_ts = suite.alloc_ts();\n    let storage_path = tmp.path();\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        storage_path,\n    );\n\n    // Wait util the backup request is handled.\n    let resps = block_on(rx.collect::<Vec<_>>());\n    assert!(resps[0].has_error());\n\n    perms.set_readonly(false);\n    f.set_permissions(perms).unwrap();\n\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_follow_missing", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_follow_missing() {\n    // Ensure that --follow=name does not imply --retry.\n    // Ensure that --follow={descriptor,name} (without --retry) does *not wait* for the\n    // file to appear.\n    for follow_mode in &[\"--follow=descriptor\", \"--follow=name\"] {\n        new_ucmd!()\n            .arg(follow_mode)\n            .arg(\"missing\")\n            .run()\n            .no_stdout()\n            .stderr_is(\n                \"tail: cannot open 'missing' for reading: No such file or directory\\n\\\n                    tail: no files remaining\\n\",\n            )\n            .code_is(1);\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/regexes.rs::bad_regex_fails_at_runtime", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn bad_regex_fails_at_runtime() {\n  Test::new()\n    .justfile(\n      \"\n        default:\n          echo before\n          echo {{ if '' =~ '(' { 'a' } else { 'b' } }}\n          echo after\n      \",\n    )\n    .stderr(\n      \"\n        echo before\n        error: regex parse error:\n            (\n            ^\n        error: unclosed group\n      \",\n    )\n    .stdout(\"before\\n\")\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_root_preserve", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_root_preserve() {\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let result = scene\n        .ucmd()\n        .arg(\"--preserve-root\")\n        .arg(\"-R\")\n        .arg(user_name)\n        .arg(\"/\")\n        .fails();\n    result.stderr_contains(\"chown: it is dangerous to operate recursively\");\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::empty_match_captures_iter", "code": "pub fn end(&self) -> char {\n        self.end\n    }", "test": "fn empty_match_captures_iter() {\n    let re = regex!(r\".*?\");\n    let ms: Vec<_> = re.captures_iter(text!(\"abc\"))\n                       .map(|c| c.get(0).unwrap())\n                       .map(|m| (m.start(), m.end()))\n                       .collect();\n    assert_eq!(ms, vec![(0, 0), (1, 1), (2, 2), (3, 3)]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_snap.rs::test_server_huge_snapshot", "code": "fn test_huge_snapshot<T: Simulator>(cluster: &mut Cluster<T>, max_snapshot_file_size: u64) {\n    cluster.cfg.rocksdb.titan.enabled = true;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(1000);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.snap_apply_batch_size = ReadableSize(500);\n    cluster.cfg.raft_store.max_snapshot_file_raw_size = ReadableSize(max_snapshot_file_size);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    let first_value = vec![0; 10240];\n    // at least 4m data\n    for i in 0..400 {\n        let key = format!(\"{:03}\", i);\n        cluster.must_put(key.as_bytes(), &first_value);\n    }\n    let first_key: &[u8] = b\"000\";\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, first_key);\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k2\", b\"v2\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    must_get_equal(&engine_2, key, value);\n\n    // now snapshot must be applied on peer 2;\n    must_get_equal(&engine_2, first_key, &first_value);\n    let stale = Arc::new(AtomicBool::new(false));\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(LeadingDuplicatedSnapshotFilter::new(\n            Arc::clone(&stale),\n            false,\n        )),\n    );\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n    let mut i = 400;\n    loop {\n        i += 1;\n        let key = format!(\"{:03}\", i);\n        cluster.must_put(key.as_bytes(), &first_value);\n        if stale.load(Ordering::Relaxed) {\n            break;\n        }\n        if i > 1000 {\n            panic!(\"snapshot should be sent twice after {} kvs\", i);\n        }\n    }\n    cluster.must_put(b\"k3\", b\"v3\");\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k3\", b\"v3\");\n\n    // TODO: add more tests.\n}", "test": "fn test_server_huge_snapshot() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_huge_snapshot(&mut cluster, u64::MAX);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_format_created_seconds", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_format_created_seconds() {\n    let args = [\"-c\", \"%W\", \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    // note: using a regex instead of `split_whitespace()` in order to detect whitespace differences\n    let re = regex::Regex::new(r\"\\s\").unwrap();\n    let v_actual: Vec<&str> = re.split(&actual).collect();\n    let v_expect: Vec<&str> = re.split(&expect).collect();\n    assert!(!v_expect.is_empty());\n    // * allow for inequality if `stat` (aka, expect) returns \"0\" (unknown value)\n    assert!(\n        expect == \"0\"\n            || expect == \"0\\n\"\n            || v_actual\n                .iter()\n                .zip(v_expect.iter())\n                .all(|(a, e)| a == e || *e == \"0\" || *e == \"0\\n\")\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_line_bytes", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_semicolon_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \";\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_raw_tag", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_raw_tag() {\n    let inputs = vec![\n        (\"{% raw %}hey{% endraw %}\", \"hey\"),\n        (\"{% raw %}{{hey}}{% endraw %}\", \"{{hey}}\"),\n        (\"{% raw %}{% if true %}{% endraw %}\", \"{% if true %}\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_errors", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_mv_errors() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_errors_dir\";\n    let file_a = \"test_mv_errors_file_a\";\n    let file_b = \"test_mv_errors_file_b\";\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    // $ mv -T -t a b\n    // mv: cannot combine --target-directory (-t) and --no-target-directory (-T)\n    scene\n        .ucmd()\n        .arg(\"-T\")\n        .arg(\"-t\")\n        .arg(dir)\n        .arg(file_a)\n        .arg(file_b)\n        .fails()\n        .stderr_contains(\"cannot be used with\");\n\n    // $ at.touch file && at.mkdir dir\n    // $ mv -T file dir\n    // err == mv: cannot overwrite directory 'dir' with non-directory\n    scene\n        .ucmd()\n        .arg(\"-T\")\n        .arg(file_a)\n        .arg(dir)\n        .fails()\n        .stderr_is(format!(\n            \"mv: cannot overwrite directory '{dir}' with non-directory\\n\"\n        ));\n\n    // $ at.mkdir dir && at.touch file\n    // $ mv dir file\n    // err == mv: cannot overwrite non-directory 'file' with directory 'dir'\n    assert!(!scene\n        .ucmd()\n        .arg(dir)\n        .arg(file_a)\n        .fails()\n        .stderr_str()\n        .is_empty());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::grow_externref_tables_via_api", "code": "pub fn size(&self) -> u32 {\n        match self {\n            Table::Static { size, .. } => *size,\n            Table::Dynamic { elements, .. } => elements.len().try_into().unwrap(),\n        }\n    }", "test": "fn grow_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::ExternRef(None))?;\n\n    assert_eq!(table.size(&store), 10);\n    table.grow(&mut store, 3, Val::ExternRef(None))?;\n    assert_eq!(table.size(&store), 13);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_file_bytes_dictate_width", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_file_bytes_dictate_width() {\n    // This file has 10,001 bytes. Five digits are required to\n    // represent that. Even though the number of lines is 1 and the\n    // number of words is 0, each of those counts is formatted with\n    // five characters, filled with whitespace.\n    new_ucmd!()\n        .args(&[\"-lw\", \"onelongemptyline.txt\"])\n        .run()\n        .stdout_is(\"    1     0 onelongemptyline.txt\\n\");\n\n    // This file has zero bytes. Only one digit is required to\n    // represent that.\n    new_ucmd!()\n        .args(&[\"-lw\", \"emptyfile.txt\"])\n        .run()\n        .stdout_is(\"0 0 emptyfile.txt\\n\");\n\n    // lorem_ipsum.txt contains 772 bytes, and alice_in_wonderland.txt contains\n    // 302 bytes. The total is 1074 bytes, which has a width of 4\n    new_ucmd!()\n        .args(&[\"-lwc\", \"alice_in_wonderland.txt\", \"lorem_ipsum.txt\"])\n        .run()\n        .stdout_is(concat!(\n            \"   5   57  302 alice_in_wonderland.txt\\n\",\n            \"  13  109  772 lorem_ipsum.txt\\n\",\n            \"  18  166 1074 total\\n\",\n        ));\n\n    // . is a directory, so minimum_width should get set to 7\n    #[cfg(not(windows))]\n    const STDOUT: &str = concat!(\n        \"      0       0       0 emptyfile.txt\\n\",\n        \"      0       0       0 .\\n\",\n        \"      0       0       0 total\\n\",\n    );\n    #[cfg(windows)]\n    const STDOUT: &str = concat!(\n        \"      0       0       0 emptyfile.txt\\n\",\n        \"      0       0       0 total\\n\",\n    );\n    new_ucmd!()\n        .args(&[\"-lwc\", \"emptyfile.txt\", \".\"])\n        .run()\n        .stdout_is(STDOUT);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/private.rs::private_attribute_for_recipe", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn private_attribute_for_recipe() {\n  Test::new()\n    .justfile(\n      \"\n      [private]\n      foo:\n      \",\n    )\n    .args([\"--list\"])\n    .stdout(\n      \"\n      Available recipes:\n      \",\n    )\n    .run();\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake_ending_with_alert", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn server_complete_io_for_handshake_ending_with_alert() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    assert!(server.is_handshaking());\n\n    let mut pipe = OtherSession::new_fails(&mut client);\n    let rc = server.complete_io(&mut pipe);\n    assert!(rc.is_err(), \"server io failed due to handshake failure\");\n    assert!(!server.wants_write(), \"but server did send its alert\");\n    assert_eq!(\n        format!(\"{:?}\", pipe.last_error),\n        \"Some(AlertReceived(HandshakeFailure))\",\n        \"which was received by client\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_invalid_input_range_two", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_shuf_invalid_input_range_two() {\n    new_ucmd!()\n        .args(&[\"-i\", \"a-9\"])\n        .fails()\n        .stderr_contains(\"invalid input range: 'a'\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::call_signature_mismatch", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn call_signature_mismatch() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (func $foo\n                    i32.const 0\n                    call_indirect)\n                (func $bar (param i32))\n                (start $foo)\n\n                (table 1 anyfunc)\n                (elem (i32.const 0) 1)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let err = Instance::new(&mut store, &module, &[])\n        .err()\n        .unwrap()\n        .downcast::<Trap>()\n        .unwrap();\n    assert!(err\n        .to_string()\n        .contains(\"wasm trap: indirect call type mismatch\"));\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_stdin_num_kth_chunk", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_split_stdin_num_kth_chunk() {\n    new_ucmd!()\n        .args(&[\"--number=1/2\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: -: cannot determine file size\\n\");\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_works", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn test_wasmer_run_works() {\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"https://wasmer.io/python/python@0.1.0\")\n        .arg(format!(\"--mapdir=.:{}\", asset_path().display()))\n        .arg(\"test.py\")\n        .assert()\n        .success();\n\n    assert.stdout(\"hello\\n\");\n\n    // same test again, but this time with \"wasmer run ...\"\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(\"https://wasmer.io/python/python@0.1.0\")\n        .arg(format!(\"--mapdir=.:{}\", asset_path().display()))\n        .arg(\"test.py\")\n        .assert()\n        .success();\n\n    assert.stdout(\"hello\\n\");\n\n    // same test again, but this time without specifying the registry in the URL\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(\"python/python@0.1.0\")\n        .arg(format!(\"--mapdir=.:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"test.py\")\n        .assert()\n        .success();\n\n    assert.stdout(\"hello\\n\");\n\n    // same test again, but this time with only the command \"python\" (should be looked up locally)\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(\"_/python\")\n        .arg(format!(\"--mapdir=.:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"test.py\")\n        .assert()\n        .success();\n\n    assert.stdout(\"hello\\n\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_fn_call", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_fn_call() {\n    assert_err_msg(\"{{ a | slice( }}\", &[\"1:15\", \"expected an identifier (must start with a-z)\"]);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_kwargs_error", "code": "pub fn detail(&self) -> Option<&str> {\n        self.repr.detail.as_deref()\n    }", "test": "fn test_kwargs_error() {\n    let kwargs = Kwargs::from_iter([(\"foo\", Value::from(42))]);\n    let bar = kwargs.get::<Value>(\"bar\").unwrap_err();\n    assert_eq!(bar.detail(), Some(\"missing keyword argument 'bar'\"));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_var", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_var() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (var i of [1, 2, 3]) {\n                    result = i;\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 3),\n        TestAction::assert_eq(\"i\", 3),\n    ]);\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_hdr", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_hdr() {\n    truncate_images(\"hdr\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_pd_heartbeat.rs::test_region_heartbeat", "code": "pub fn get_leader(&self) -> &super::metapb::Peer {\n        self.leader.as_ref().unwrap_or_else(|| super::metapb::Peer::default_instance())\n    }", "test": "fn test_region_heartbeat() {\n    let region_id = 2;\n    let cluster = Cluster::with_node_count(1, None);\n    let router = &cluster.routers[0];\n\n    // When there is only one peer, it should campaign immediately.\n    let mut req = RaftCmdRequest::default();\n    req.mut_header().set_peer(new_peer(1, 3));\n    req.mut_status_request()\n        .set_cmd_type(StatusCmdType::RegionLeader);\n    let res = router.query(region_id, req.clone()).unwrap();\n    let status_resp = res.response().unwrap().get_status_response();\n    assert_eq!(\n        *status_resp.get_region_leader().get_leader(),\n        new_peer(1, 3)\n    );\n\n    for _ in 0..5 {\n        let resp = block_on(\n            cluster\n                .node(0)\n                .pd_client()\n                .get_region_leader_by_id(region_id),\n        )\n        .unwrap();\n        if let Some((region, peer)) = resp {\n            assert_eq!(region.get_id(), region_id);\n            assert_eq!(peer.get_id(), 3);\n            assert_eq!(peer.get_store_id(), 1);\n            return;\n        }\n        std::thread::sleep(std::time::Duration::from_millis(50));\n    }\n    panic!(\"failed to get region leader\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_non_witness_replica_read", "code": "fn read(&mut self, request: RaftCmdRequest, timeout: Duration) -> Result<RaftCmdResponse> {\n        let node_id = request.get_header().get_peer().get_store_id();\n        let timeout_f = GLOBAL_TIMER_HANDLE\n            .delay(std::time::Instant::now() + timeout)\n            .compat();\n        futures::executor::block_on(async move {\n            futures::select! {\n                res = self.async_read(node_id, request).fuse() => res,\n                e = timeout_f.fuse() => {\n                    Err(Error::Timeout(format!(\"request timeout for {:?}: {:?}\", timeout,e)))\n                },\n            }\n        })\n    }", "test": "fn test_non_witness_replica_read() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.check_request_snapshot_interval = ReadableDuration::millis(20);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    // nonwitness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    // witness -> nonwitness\n    fail::cfg(\"ignore request snapshot\", \"return\").unwrap();\n    cluster\n        .pd_client\n        .switch_witnesses(region.get_id(), vec![peer_on_store3.get_id()], vec![false]);\n    std::thread::sleep(Duration::from_millis(100));\n    // as we ignore request snapshot, so snapshot should still not applied yet\n\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k0\")],\n        false,\n    );\n    request.mut_header().set_peer(peer_on_store3.clone());\n    request.mut_header().set_replica_read(true);\n\n    let resp = cluster\n        .read(None, request, Duration::from_millis(100))\n        .unwrap();\n    assert_eq!(\n        resp.get_header().get_error().get_is_witness(),\n        &kvproto::errorpb::IsWitness {\n            region_id: region.get_id(),\n            ..Default::default()\n        }\n    );\n\n    // start requesting snapshot and give enough time for applying snapshot to\n    // complete\n    fail::remove(\"ignore request snapshot\");\n    std::thread::sleep(Duration::from_millis(500));\n\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k0\")],\n        false,\n    );\n    request.mut_header().set_peer(peer_on_store3);\n    request.mut_header().set_replica_read(true);\n\n    let resp = cluster\n        .read(None, request, Duration::from_millis(100))\n        .unwrap();\n    assert_eq!(resp.get_header().has_error(), false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_trailing_space_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_trailing_space_1() {\n    // super evil\n    new_ucmd!()\n        .args(&[\"-t1\"])\n        .pipe_in(\" abc d e  f  g \")\n        .run()\n        .stdout_is(\"\\tabc d e\\t\\tf\\t\\tg \");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_can_get_client_cert_after_resumption", "code": "pub fn peer_certificates(&self) -> Option<&[key::Certificate]> {\n        self.peer_certificates.as_deref()\n    }", "test": "fn server_can_get_client_cert_after_resumption() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let client_config = Arc::new(client_config);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&client_config, &server_config);\n            do_handshake(&mut client, &mut server);\n            let original_certs = server.peer_certificates();\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&client_config, &server_config);\n            do_handshake(&mut client, &mut server);\n            let resumed_certs = server.peer_certificates();\n            assert_eq!(original_certs, resumed_certs);\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_offset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%23%+3\"])\n        .succeeds()\n        .stdout_only(\"75\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(26, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_round_robin", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_round_robin() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    ucmd.args(&[\"-n\", \"r/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n3\\n5\\n\");\n    assert_eq!(file_read(\"xab\"), \"2\\n4\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::one_argument", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn one_argument() {\n    new_ucmd!().arg(\"a\").fails().no_stdout();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_calling_export.rs::test_returns_incorrect_type", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn test_returns_incorrect_type() -> Result<()> {\n    const WAT: &str = r#\"\n    (module\n        (import \"env\" \"evil\" (func $evil (result i32)))\n        (func (export \"run\") (result i32)\n            (call $evil)\n        )\n    )\n    \"#;\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), WAT)?;\n\n    let callback_func = Func::new(\n        &mut store,\n        FuncType::new(None, Some(ValType::I32)),\n        |_, _, results| {\n            // Evil! Returns I64 here instead of promised in the signature I32.\n            results[0] = Val::I64(228);\n            Ok(())\n        },\n    );\n\n    let imports = vec![callback_func.into()];\n    let instance = Instance::new(&mut store, &module, imports.as_slice())?;\n\n    let run_func = instance\n        .get_func(&mut store, \"run\")\n        .expect(\"expected a run func in the module\");\n\n    let mut result = [Val::I32(0)];\n    let trap = run_func\n        .call(&mut store, &[], &mut result)\n        .expect_err(\"the execution should fail\");\n    assert!(format!(\"{:?}\", trap).contains(\"function attempted to return an incompatible value\"));\n    Ok(())\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_meta_item_word", "code": "fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n}", "test": "fn test_meta_item_word() {\n    let meta = test(\"#[foo]\");\n\n    snapshot!(meta, @r###\"\n    Meta::Path {\n        segments: [\n            PathSegment {\n                ident: \"foo\",\n            },\n        ],\n    }\n    \"###);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_after_tab_as_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_after_tab_as_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w10\", \"-s\"])\n        .pipe_in(\"a\\tbbb\\n\")\n        .succeeds()\n        .stdout_is(\"a\\t\\nbbb\\n\");\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_null_comparison1", "code": "pub(crate) fn test_same(source_text: &str) {\n    test(source_text, source_text);\n}", "test": "fn test_null_comparison1() {\n    test_wcb(\"null == undefined\", \"true;\");\n    test_wcb(\"null == null\", \"true;\");\n    test_wcb(\"null == void 0\", \"true;\");\n\n    test_wcb(\"null == 0\", \"false;\");\n    test_wcb(\"null == 1\", \"false;\");\n    test_wcb(\"null == 0n\", \"false;\");\n    test_wcb(\"null == 1n\", \"false;\");\n    test_wcb(\"null == 'hi'\", \"false;\");\n    test_wcb(\"null == true\", \"false;\");\n    test_wcb(\"null == false\", \"false;\");\n\n    test_wcb(\"null === undefined\", \"false;\");\n    test_wcb(\"null === null\", \"true;\");\n    test_wcb(\"null === void 0\", \"false;\");\n    test_same(\"null===x;\");\n\n    test_same(\"null==this;\");\n    test_same(\"null==x;\");\n\n    test_wcb(\"null != undefined\", \"false;\");\n    test_wcb(\"null != null\", \"false;\");\n    test_wcb(\"null != void 0\", \"false;\");\n\n    test_wcb(\"null != 0\", \"true;\");\n    test_wcb(\"null != 1\", \"true;\");\n    test_wcb(\"null != 0n\", \"true;\");\n    test_wcb(\"null != 1n\", \"true;\");\n    test_wcb(\"null != 'hi'\", \"true;\");\n    test_wcb(\"null != true\", \"true;\");\n    test_wcb(\"null != false\", \"true;\");\n\n    test_wcb(\"null !== undefined\", \"true;\");\n    test_wcb(\"null !== void 0\", \"true;\");\n    test_wcb(\"null !== null\", \"false;\");\n\n    test_same(\"null!=this;\");\n    test_same(\"null!=x;\");\n\n    test_wcb(\"null < null\", \"false;\");\n    test_wcb(\"null > null\", \"false;\");\n    test_wcb(\"null >= null\", \"true;\");\n    test_wcb(\"null <= null\", \"true;\");\n\n    test_wcb(\"0 < null\", \"false;\");\n    test_wcb(\"0 > null\", \"false;\");\n    test_wcb(\"0 >= null\", \"true;\");\n    test_wcb(\"0n < null\", \"false;\");\n    test_wcb(\"0n > null\", \"false;\");\n    test_wcb(\"0n >= null\", \"true;\");\n    test_wcb(\"true > null\", \"true;\");\n    test_wcb(\"'hi' < null\", \"false;\");\n    test_wcb(\"'hi' >= null\", \"false;\");\n    test_wcb(\"null <= null\", \"true;\");\n\n    test_wcb(\"null < 0\", \"false;\");\n    test_wcb(\"null < 0n\", \"false;\");\n    test_wcb(\"null > true\", \"false;\");\n    test_wcb(\"null < 'hi'\", \"false;\");\n    test_wcb(\"null >= 'hi'\", \"false;\");\n    test_wcb(\"null <= null\", \"true;\");\n\n    test_wcb(\"null == null\", \"true;\");\n    test_wcb(\"0 == null\", \"false;\");\n    test_wcb(\"1 == null\", \"false;\");\n    test_wcb(\"'hi' == null\", \"false;\");\n    test_wcb(\"true == null\", \"false;\");\n    test_wcb(\"false == null\", \"false;\");\n    test_wcb(\"null === null\", \"true;\");\n    test_wcb(\"void 0 === null\", \"false;\");\n\n    test_wcb(\"null == NaN\", \"false;\");\n    test_wcb(\"NaN == null\", \"false;\");\n    test_wcb(\"null == Infinity\", \"false;\");\n    test_wcb(\"Infinity == null\", \"false;\");\n    test_wcb(\"null == -Infinity\", \"false;\");\n    test_wcb(\"-Infinity == null\", \"false;\");\n    test_wcb(\"({}) == null\", \"false;\");\n    test_wcb(\"null == ({})\", \"false;\");\n    test_wcb(\"([]) == null\", \"false;\");\n    test_wcb(\"null == ([])\", \"false;\");\n    test_wcb(\"(/a/g) == null\", \"false;\");\n    test_wcb(\"null == (/a/g)\", \"false;\");\n    test_wcb(\"(function(){}) == null\", \"false;\");\n    test_wcb(\"null == (function(){})\", \"false;\");\n\n    test_wcb(\"null != NaN\", \"true;\");\n    test_wcb(\"NaN != null\", \"true;\");\n    test_wcb(\"null != Infinity\", \"true;\");\n    test_wcb(\"Infinity != null\", \"true;\");\n    test_wcb(\"null != -Infinity\", \"true;\");\n    test_wcb(\"-Infinity != null\", \"true;\");\n    test_wcb(\"({}) != null\", \"true;\");\n    test_wcb(\"null != ({})\", \"true;\");\n    test_wcb(\"([]) != null\", \"true;\");\n    test_wcb(\"null != ([])\", \"true;\");\n    test_wcb(\"(/a/g) != null\", \"true;\");\n    test_wcb(\"null != (/a/g)\", \"true;\");\n    test_wcb(\"(function(){}) != null\", \"true;\");\n    test_wcb(\"null != (function(){})\", \"true;\");\n\n    test_same(\"({a:f()})==null;\");\n    test_same(\"null=={a:f()};\");\n    test_same(\"[f()]==null;\");\n    test_same(\"null==[f()];\");\n\n    test_same(\"this==null;\");\n    test_same(\"x==null;\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_split_region.rs::test_split_not_to_split_existing_region", "code": "pub fn get_engine(&self) -> &Engines<RocksEngine, ER> {\n        &self.engines\n    }", "test": "fn test_split_not_to_split_existing_region() {\n    let mut cluster = new_node_cluster(0, 4);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.right_derive_when_split = true;\n    cluster.cfg.raft_store.apply_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let mut region_a = pd_client.get_region(b\"k1\").unwrap();\n    // [-\u221e, k2), [k2, +\u221e)\n    //    b         a\n    cluster.must_split(&region_a, b\"k2\");\n\n    cluster.put(b\"k0\", b\"v0\").unwrap();\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n\n    let region_b = pd_client.get_region(b\"k0\").unwrap();\n    let peer_b_1 = find_peer(&region_b, 1).cloned().unwrap();\n    cluster.must_transfer_leader(region_b.get_id(), peer_b_1);\n\n    let peer_b_3 = find_peer(&region_b, 3).cloned().unwrap();\n    assert_eq!(peer_b_3.get_id(), 1003);\n    let on_handle_apply_1003_fp = \"on_handle_apply_1003\";\n    fail::cfg(on_handle_apply_1003_fp, \"pause\").unwrap();\n    // [-\u221e, k1), [k1, k2), [k2, +\u221e)\n    //    c         b          a\n    cluster.must_split(&region_b, b\"k1\");\n\n    pd_client.must_remove_peer(region_b.get_id(), peer_b_3);\n    pd_client.must_add_peer(region_b.get_id(), new_peer(4, 4));\n\n    let mut region_c = pd_client.get_region(b\"k0\").unwrap();\n    let peer_c_3 = find_peer(&region_c, 3).cloned().unwrap();\n    pd_client.must_remove_peer(region_c.get_id(), peer_c_3);\n    pd_client.must_add_peer(region_c.get_id(), new_peer(4, 5));\n    // [-\u221e, k2), [k2, +\u221e)\n    //     c        a\n    pd_client.must_merge(region_b.get_id(), region_c.get_id());\n\n    region_a = pd_client.get_region(b\"k2\").unwrap();\n    let peer_a_3 = find_peer(&region_a, 3).cloned().unwrap();\n    pd_client.must_remove_peer(region_a.get_id(), peer_a_3);\n    pd_client.must_add_peer(region_a.get_id(), new_peer(4, 6));\n    // [-\u221e, +\u221e)\n    //    c\n    pd_client.must_merge(region_a.get_id(), region_c.get_id());\n\n    region_c = pd_client.get_region(b\"k1\").unwrap();\n    // [-\u221e, k2), [k2, +\u221e)\n    //     d        c\n    cluster.must_split(&region_c, b\"k2\");\n\n    let peer_c_4 = find_peer(&region_c, 4).cloned().unwrap();\n    pd_client.must_remove_peer(region_c.get_id(), peer_c_4);\n    pd_client.must_add_peer(region_c.get_id(), new_peer(3, 7));\n\n    cluster.put(b\"k2\", b\"v2\").unwrap();\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n\n    fail::remove(on_handle_apply_1003_fp);\n\n    // If peer_c_3 is created, `must_get_none` will fail.\n    must_get_none(&cluster.get_engine(3), b\"k0\");\n}\n\n// Test if a peer "}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_all_commands", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_all_commands() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.delete(b\"a\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.delete_range(b\"c\", b\"e\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n    let d = db.engine.get_value(b\"d\").unwrap();\n    assert!(a.is_some());\n    assert!(b.is_none());\n    assert!(d.is_some());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys / 2 {\n        db.engine.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    db.engine.put(b\"a\", b\"\").unwrap();\n    for i in max_keys / 2..max_keys {\n        db.engine.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    db.engine.put(b\"d\", b\"\").unwrap();\n\n    wb.set_save_point();\n    for i in 0..max_keys / 2 {\n        wb.delete(&i.to_be_bytes()).unwrap();\n    }\n    wb.delete(b\"a\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.delete_range(b\"c\", b\"e\").unwrap();\n    wb.delete_range(&(max_keys / 3).to_be_bytes(), &(2 * max_keys).to_be_bytes())\n        .unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n    let d = db.engine.get_value(b\"d\").unwrap();\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n    assert!(a.is_some());\n    assert!(b.is_none());\n    assert!(d.is_some());\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_unpaired_linefeed", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn newline_escape_unpaired_linefeed() {\n  Test::new()\n    .justfile(\n      \"\n      default:\\\\\\ra\",\n    )\n    .stdout(\"\")\n    .stderr(\n      \"\n        error: Unpaired carriage return\n          |\n        1 | default:\\\\\\ra\n          |         ^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_garbage", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_garbage() {\n    let input = \"aGVsbG8sIHdvcmxkIQ==\\0\"; // spell-checker:disable-line\n    new_ucmd!()\n        .arg(\"-d\")\n        .pipe_in(input)\n        .fails()\n        .stderr_only(\"base64: error: invalid input\\n\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_infinite_symlink_expansion_to_dirs", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_infinite_symlink_expansion_to_dirs() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_infinite_symlink_expansion_to_dirs\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&subdir2_path, subdir1_path.join(\"symlink1\")).unwrap();\n        symlink(subdir1_path, subdir2_path.join(\"symlink2\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&subdir2_path, &subdir1_path.join(\"symlink1\")));\n        check_windows_symlink!(symlink_dir(subdir1_path, subdir2_path.join(\"symlink2\")));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_infinite_symlink_expansion_to_dirs\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_floats_with_nan", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_floats_with_nan() {\n    test_helper(\n        \"numeric_floats_with_nan\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_write_twice_3", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_write_twice_3() {\n    let db = default_engine();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    wb.put(b\"b\", b\"bb\").unwrap();\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n    assert_eq!(db.engine.get_value(b\"b\").unwrap().unwrap(), b\"bb\");\n\n    let db = multi_batch_write_engine();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n    for i in 0..128_usize {\n        let k = i.to_be_bytes();\n        let v = (2 * i + 1).to_be_bytes();\n        db.engine.put(&k, &v).unwrap();\n    }\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    for i in 128..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"b\", b\"bb\").unwrap();\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n    assert_eq!(db.engine.get_value(b\"b\").unwrap().unwrap(), b\"bb\");\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        assert_eq!(db.engine.get_value(&x).unwrap().unwrap(), &x);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_whitespace_with_char", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_whitespace_with_char() {\n    new_ucmd!()\n        .args(&[\"-c\", COMPLEX_SEQUENCE.sequence, \"-w\"])\n        .fails()\n        .code_is(1);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_headers_recv_data_single_frame", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn send_headers_recv_data_single_frame() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 16, 1, 5, 0, 0, 0, 1, 130, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25,\n            151, 33, 233, 132,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 136, 0, 0, 5, 0, 0, 0, 0, 0, 1, 104, 101, 108, 108, 111, 0,\n            0, 5, 0, 1, 0, 0, 0, 1, 119, 111, 114, 108, 100,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::OK);\n\n    // Take the body\n    let (_, body) = resp.into_parts();\n\n    // Wait for all the data frames to be received\n    let bytes: Vec<_> = h2.run(body.try_collect()).await.unwrap();\n\n    // Two data frames\n    assert_eq!(2, bytes.len());\n\n    assert_eq!(bytes[0], &b\"hello\"[..]);\n    assert_eq!(bytes[1], &b\"world\"[..]);\n\n    // The H2 connection is closed\n    h2.await.unwrap();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_invalid_utf8", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_raw_invalid_utf8() {\n    let j = &[b'\"', b'\\xCE', b'\\xF8', b'\"'];\n    let value_err = serde_json::from_slice::<Value>(j).unwrap_err();\n    let raw_value_err = serde_json::from_slice::<Box<RawValue>>(j).unwrap_err();\n\n    assert_eq!(\n        value_err.to_string(),\n        \"invalid unicode code point at line 1 column 4\",\n    );\n    assert_eq!(\n        raw_value_err.to_string(),\n        \"invalid unicode code point at line 1 column 4\",\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_backup_raw_meta", "code": "fn test_backup_raw_meta_impl(cur_api_version: ApiVersion, dst_api_version: ApiVersion) {\n    let suite = TestSuite::new(3, 144 * 1024 * 1024, cur_api_version);\n    let key_count: u64 = 60;\n    let cf = match cur_api_version {\n        ApiVersion::V1 | ApiVersion::V1ttl => String::from(CF_DEFAULT),\n        ApiVersion::V2 => String::from(\"\"),\n    };\n    let digest = crc64fast::Digest::new();\n    let mut admin_checksum: u64 = 0;\n    let mut admin_total_kvs: u64 = 0;\n    let mut admin_total_bytes: u64 = 0;\n\n    for i in 0..key_count {\n        let (k, v) = suite.gen_raw_kv(i);\n        admin_total_kvs += 1;\n        admin_total_bytes += (k.len() + v.len()) as u64;\n        admin_checksum =\n            checksum_crc64_xor(admin_checksum, digest.clone(), k.as_bytes(), v.as_bytes());\n        suite.must_raw_put(k.clone().into_bytes(), v.clone().into_bytes(), cf.clone());\n    }\n\n    let (store_checksum, store_kvs, store_bytes) =\n        suite.storage_raw_checksum(\"ra\".to_owned(), \"rz\".to_owned());\n\n    assert_eq!(admin_checksum, store_checksum);\n    assert_eq!(admin_total_kvs, store_kvs);\n    assert_eq!(admin_total_bytes, store_bytes);\n\n    // Push down backup request.\n    let tmp = Builder::new().tempdir().unwrap();\n    let storage_path = make_unique_dir(tmp.path());\n    let rx = suite.backup_raw(\n        \"ra\".to_owned().into_bytes(), // start\n        \"rz\".to_owned().into_bytes(), // end\n        cf,\n        &storage_path,\n        dst_api_version,\n    );\n    let resps1 = block_on(rx.collect::<Vec<_>>());\n    // Only leader can handle backup.\n    assert_eq!(resps1.len(), 1);\n    let files: Vec<_> = resps1[0].files.clone().into_iter().collect();\n    // Short value is piggybacked in write cf, so we get 1 sst at least.\n    assert!(!files.is_empty());\n    let mut checksum = 0;\n    let mut total_kvs = 0;\n    let mut total_bytes = 0;\n    for f in files {\n        checksum ^= f.get_crc64xor();\n        total_kvs += f.get_total_kvs();\n        total_bytes += f.get_total_bytes();\n    }\n    assert_eq!(total_kvs, key_count);\n    assert_eq!(total_kvs, admin_total_kvs);\n    assert_eq!(total_bytes, admin_total_bytes);\n    assert_eq!(checksum, admin_checksum);\n    // assert_eq!(total_size, 1619);\n    // the number changed when kv size change, should not be an test points.\n    // please update this number (must be > 0) when the test failed\n\n    suite.stop();\n}", "test": "fn test_backup_raw_meta() {\n    let raw_meta_test_cases = vec![\n        (ApiVersion::V1, ApiVersion::V1),\n        (ApiVersion::V1ttl, ApiVersion::V1ttl),\n        (ApiVersion::V2, ApiVersion::V2),\n    ];\n    for (cur_api_ver, dst_api_ver) in raw_meta_test_cases {\n        test_backup_raw_meta_impl(cur_api_ver, dst_api_ver);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_future_ts_not_update_max_ts", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_stale_read_future_ts_not_update_max_ts() {\n    let (_cluster, pd_client, mut leader_client) = prepare_for_stale_read(new_peer(1, 1));\n    leader_client.ctx.set_stale_read(true);\n\n    // Write `(key1, value1)`\n    leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Perform stale read with a future ts should return error\n    let read_ts = get_tso(&pd_client) + 10000000;\n    let resp = leader_client.kv_read(b\"key1\".to_vec(), read_ts);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    // The `max_ts` should not updated by the stale read request, so we can prewrite\n    // and commit `async_commit` transaction with a ts that smaller than the\n    // `read_ts`\n    let prewrite_ts = get_tso(&pd_client);\n    assert!(prewrite_ts < read_ts);\n    leader_client.must_kv_prewrite_async_commit(\n        vec![new_mutation(Op::Put, &b\"key2\"[..], &b\"value1\"[..])],\n        b\"key2\".to_vec(),\n        prewrite_ts,\n    );\n    let commit_ts = get_tso(&pd_client);\n    assert!(commit_ts < read_ts);\n    leader_client.must_kv_commit(vec![b\"key2\".to_vec()], prewrite_ts, commit_ts);\n    leader_client.must_kv_read_equal(b\"key2\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n\n    // Perform stale read with a future ts should return error\n    let read_ts = get_tso(&pd_client) + 10000000;\n    let resp = leader_client.kv_read(b\"key1\".to_vec(), read_ts);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    // The `max_ts` should not updated by the stale read request, so 1pc transaction\n    // with a ts that smaller than the `read_ts` should not be fallbacked to 2pc\n    let prewrite_ts = get_tso(&pd_client);\n    assert!(prewrite_ts < read_ts);\n    leader_client.must_kv_prewrite_one_pc(\n        vec![new_mutation(Op::Put, &b\"key3\"[..], &b\"value1\"[..])],\n        b\"key3\".to_vec(),\n        prewrite_ts,\n    );\n    // `key3` is write as 1pc transaction so we can read `key3` without commit\n    leader_client.must_kv_read_equal(b\"key3\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_quiet", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_mktemp_quiet() {\n    let scene = TestScenario::new(util_name!());\n\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(\"/definitely/not/exist/I/promise\")\n        .arg(\"-q\")\n        .fails()\n        .no_stdout()\n        .no_stderr();\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"-p\")\n        .arg(\"/definitely/not/exist/I/promise\")\n        .arg(\"-q\")\n        .fails()\n        .no_stdout()\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_negative_offset_option_suppress_matched", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_negative_offset_option_suppress_matched() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"--suppress-matched\", \"/10/-4\"])\n        .succeeds()\n        .stdout_only(\"10\\n128\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 6));\n    assert_eq!(at.read(\"xx01\"), generate(6, 10) + &generate(11, 51));\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_gif", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_gif() {\n    truncate_images(\"gif\")\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::standalone_backtrace", "code": "pub fn is_empty(&self) -> bool {\n        self.root.is_none()\n    }", "test": "fn standalone_backtrace() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let trace = WasmBacktrace::capture(&store);\n    assert!(trace.frames().is_empty());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"\" (func $host))\n                (func $foo (export \"f\") call $bar)\n                (func $bar call $host)\n            )\n        \"#,\n    )?;\n    let func = Func::wrap(&mut store, |cx: Caller<'_, ()>| {\n        let trace = WasmBacktrace::capture(&cx);\n        assert_eq!(trace.frames().len(), 2);\n        let frame1 = &trace.frames()[0];\n        let frame2 = &trace.frames()[1];\n        assert_eq!(frame1.func_index(), 2);\n        assert_eq!(frame1.func_name(), Some(\"bar\"));\n        assert_eq!(frame2.func_index(), 1);\n        assert_eq!(frame2.func_name(), Some(\"foo\"));\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n    let f = instance.get_typed_func::<(), ()>(&mut store, \"f\")?;\n    f.call(&mut store, ())?;\n    Ok(())\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/key_log_file_env.rs::exercise_key_log_file_for_client", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn exercise_key_log_file_for_client() {\n    serialized(|| {\n        let server_config = Arc::new(make_server_config(KeyType::Rsa));\n        env::set_var(\"SSLKEYLOGFILE\", \"./sslkeylogfile.txt\");\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n            client_config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n            do_handshake(&mut client, &mut server);\n            transfer(&mut client, &mut server);\n            server.process_new_packets().unwrap();\n        }\n    })\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/store_file_tests.rs::test_ttl_wilcard", "code": "pub fn get(&self, idx: usize) -> &[u8] {\n        &self.pkeys[idx]\n    }", "test": "async fn test_ttl_wilcard() {\n    let config = FileConfig {\n        zone_file_path: \"../../tests/test-data/test_configs/default/test.local.zone\".to_string(),\n    };\n\n    let zone_name = LowerName::from_str(\"test.local.\").unwrap();\n    let mut authority = FileAuthority::try_from_config(\n        Name::from(zone_name.clone()),\n        ZoneType::Primary,\n        false,\n        None,\n        &config,\n    )\n    .unwrap();\n\n    // This one pass.\n    let rrkey = RrKey {\n        record_type: RecordType::A,\n        name: LowerName::from(Name::from_ascii(\"simple.test.local.\").unwrap()),\n    };\n    assert_eq!(authority.records_get_mut().get(&rrkey).unwrap().ttl(), 120);\n    // // This one related to a wildcard don't pass arround $TTL\n    let name = LowerName::from(Name::from_ascii(\"x.wc.test.local.\").unwrap());\n    let rr = authority\n        .lookup(&name, RecordType::A, LookupOptions::default())\n        .await\n        .unwrap();\n    let data = rr\n        .into_iter()\n        .next()\n        .expect(\"A record not found in authority\");\n\n    assert_eq!(data.record_type(), RecordType::A);\n    assert_eq!(data.ttl(), 120);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_single_default_output", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_single_default_output() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let expected = at.read(\"sorted-simple.expected\");\n    ucmd.args(&[INPUT, OUTPUT]).run();\n    let found = at.read(OUTPUT);\n    assert_eq!(found, expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_node_stale_peer_without_data_left_derive_when_split", "code": "fn test_stale_peer_without_data<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let region = cluster.get_region(b\"\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.must_split(&region, b\"k2\");\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine3 = cluster.get_engine(3);\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    let new_region = if right_derive {\n        cluster.get_region(b\"k1\")\n    } else {\n        cluster.get_region(b\"k3\")\n    };\n    let new_region_id = new_region.get_id();\n    // Block peer (3, 4) at receiving snapshot, but not the heartbeat\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(new_region_id, 3).msg_type(MessageType::MsgSnapshot),\n    ));\n\n    pd_client.must_add_peer(new_region_id, new_peer(3, 4));\n\n    // Wait for the heartbeat broadcasted from peer (1, 1000) to peer (3, 4).\n    cluster.must_region_exist(new_region_id, 3);\n\n    // And then isolate peer (3, 4) from peer (1, 1000).\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_remove_peer(new_region_id, new_peer(3, 4));\n\n    cluster.must_remove_region(3, new_region_id);\n\n    // There must be no data on store 3 belongs to new region\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n    } else {\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    // Check whether peer(3, 4) is destroyed.\n    // Before peer 4 is destroyed, a tombstone mark will be written into the engine.\n    // So we could check the tombstone mark to make sure peer 4 is destroyed.\n    let state_key = keys::region_state_key(new_region_id);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // other region should not be affected.\n    if right_derive {\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n    }\n}", "test": "fn test_node_stale_peer_without_data_left_derive_when_split() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_stale_peer_without_data(&mut cluster, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_file_option", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_file_option() {\n    let out = new_ucmd!()\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .run()\n        .stdout_move_str();\n\n    assert_eq!(\n        out.lines()\n            .filter(|&line| line == \"FOO=bar\" || line == \"BAR=bamf this\")\n            .count(),\n        2\n    );\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_float_f32_rounding", "code": "pub fn compute_float32(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f32>(&num);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f32_rounding() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (151, 0));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (151, 2));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_slash", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_trailing_slash() {\n    new_ucmd!()\n        .arg(\"--tabs=1,/5\")\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          0         1\n        //          01234567890\n        .stdout_is(\" a   b    c\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::error_errors_with_message", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn error_errors_with_message() {\n  Test::new()\n    .justfile(\"x := error ('Thing Not Supported')\")\n    .args([\"--evaluate\"])\n    .status(1)\n    .stderr(\"error: Call to function `error` failed: Thing Not Supported\\n  |\\n1 | x := error ('Thing Not Supported')\\n  |      ^^^^^\\n\")\n    .run();\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cli/tests/integration_test.rs::stdin_json", "code": "pub fn display<'a>(&'a self, source_code: SourceCode<'a>) -> DisplayDocument {\n        DisplayDocument {\n            elements: self.elements.as_slice(),\n            source_code,\n        }\n    }", "test": "fn stdin_json() {\n    let args = [\n        \"-\",\n        \"--isolated\",\n        \"--no-cache\",\n        \"--output-format\",\n        \"json\",\n        \"--stdin-filename\",\n        \"F401.py\",\n    ];\n\n    let directory = path_dedot::CWD.to_str().unwrap();\n    let binding = Path::new(directory).join(\"F401.py\");\n    let file_path = binding.display();\n\n    insta::with_settings!({filters => vec![\n        (file_path.to_string().as_str(), \"/path/to/F401.py\"),\n    ]}, {\n        assert_cmd_snapshot!(Command::new(get_cargo_bin(BIN_NAME))\n            .args(args)\n            .pass_stdin(\"import os\\n\"));\n    });\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_force_replace_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_force_replace_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_force_replace_file_a\";\n    let file_b = \"test_mv_force_replace_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"--force\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_dir_to_file_not_affirmative", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_interactive_dir_to_file_not_affirmative() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"test_mv_interactive_dir_to_file_not_affirmative_dir\";\n    let file = \"test_mv_interactive_dir_to_file_not_affirmative_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(dir)\n        .arg(file)\n        .arg(\"-i\")\n        .pipe_in(\"n\")\n        .fails()\n        .no_stdout();\n\n    assert!(at.dir_exists(dir));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_const_array", "code": "fn concat() {\n    run_test_actions([\n        TestAction::run_harness(),\n        // Empty ++ Empty\n        TestAction::assert(\"arrayEquals([].concat([]), [])\"),\n        // Empty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([].concat([1]), [1])\"),\n        // NonEmpty ++ Empty\n        TestAction::assert(\"arrayEquals([1].concat([]), [1])\"),\n        // NonEmpty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([1].concat([1]), [1, 1])\"),\n    ]);\n}", "test": "fn for_in_const_array() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let arr = [\"a\", \"b\"];\n                for (const i in arr) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['0', '1'])\"),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_default_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "test": "fn test_kill_with_default_signal() {\n    let mut target = Target::new();\n    new_ucmd!().arg(format!(\"{}\", target.pid())).succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGTERM));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::var_decl_hoisting_2_variables_hoisting_3", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn var_decl_hoisting_2_variables_hoisting_3() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let y = x;\n            x = 5;\n\n            var x = 10;\n            y;\n        \"#},\n        JsValue::undefined(),\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_ignore_initial_plus_slash_combination", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_ignore_initial_plus_slash_combination() {\n    new_ucmd!()\n        .args(&[\"--tabs=+/3\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"   a  b  c\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/os_attributes.rs::os_family", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn os_family() {\n  Test::new()\n    .justfile(\n      \"\n      [unix]\n      foo:\n        echo bar\n\n      [windows]\n      foo:\n        echo baz\n    \",\n    )\n    .stdout(if cfg!(unix) {\n      \"bar\\n\"\n    } else if cfg!(windows) {\n      \"baz\\n\"\n    } else {\n      panic!(\"unexpected os family\")\n    })\n    .stderr(if cfg!(unix) {\n      \"echo bar\\n\"\n    } else if cfg!(windows) {\n      \"echo baz\\n\"\n    } else {\n      panic!(\"unexpected os family\")\n    })\n    .run();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ilc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_ilc() {\n    // Test iterators that skip multiple, internal or leading digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"45__.56\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::closed_streams_are_released", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn closed_streams_are_released() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::get(\"https://example.com/\").body(()).unwrap();\n\n        // Send request\n        let (response, _) = client.send_request(request, true).unwrap();\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::NO_CONTENT);\n\n        // There are no active streams\n        assert_eq!(0, client.num_active_streams());\n\n        // The response contains a handle for the body. This keeps the\n        // stream wired.\n        assert_eq!(1, client.num_wired_streams());\n\n        let (_, body) = response.into_parts();\n        assert!(body.is_end_stream());\n        drop(body);\n\n        // The stream state is now free\n        assert_eq!(0, client.num_wired_streams());\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(204).eos()).await;\n    };\n    join(srv, h2).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "image-rs-image-gif/image-rs-image-gif-80fd8c0/tests/check_testimages.rs::render_images", "code": "pub fn checksum(&self) -> u32 {\n        self.crc ^ 0xFFFFFFFF\n    }", "test": "fn render_images() {\n    process_images(|path| {\n        let mut decoder = gif::DecodeOptions::new();\n        decoder.set_color_output(gif::ColorOutput::RGBA);\n        let file = File::open(path)?;\n        let mut decoder = decoder.read_info(file)?;\n        let mut crc = Crc32::new();\n        while let Some(frame) = decoder.read_next_frame()? {\n            // First sanity check:\n            assert_eq!(\n                frame.buffer.len(), \n                frame.width as usize\n                * frame.height as usize\n                * 4\n            );\n            crc.update(&*frame.buffer);\n        }\n        Ok(crc.checksum())\n    })\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_line_num_range_with_up_to_match2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_line_num_range_with_up_to_match2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"/12/-15\"])\n        .fails()\n        .stderr_is(\"csplit: '/12/-15': line number out of range\\n\")\n        .stdout_is(\"18\\n0\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"/12/-15\", \"-k\"])\n        .fails()\n        .stderr_is(\"csplit: '/12/-15': line number out of range\\n\")\n        .stdout_is(\"18\\n0\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), generate(10, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_get", "code": "pub fn get_ok(&self, key: &[u8], ts: impl Into<TimeStamp>, expect: &[u8]) {\n        let key = Key::from_raw(key);\n        assert_eq!(\n            self.store\n                .get(self.ctx.clone(), &key, ts.into())\n                .unwrap()\n                .0\n                .unwrap(),\n            expect\n        );\n    }", "test": "fn test_txn_store_get() {\n    let store = AssertionStorage::default();\n    // not exist\n    store.get_none(b\"x\", 10);\n    // after put\n    store.put_ok(b\"x\", b\"x\", 5, 10);\n    store.get_none(b\"x\", 9);\n    store.get_ok(b\"x\", 10, b\"x\");\n    store.get_ok(b\"x\", 11, b\"x\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_vec_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn vec_vec_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<Vec<&str>>> = TableDefinition::new(\"x\");\n\n    let value = vec![vec![\"hello\", \"world\"], vec![\"this\", \"is\", \"a\", \"test\"]];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_symbolic", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_mode_symbolic() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let mode_arg = \"--mode=o+wx\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(file).arg(dir).arg(mode_arg).succeeds().no_stderr();\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_003_u32, PermissionsExt::mode(&permissions));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_no_flag", "code": "fn collect(&self) -> Vec<String> {\n        read_dir(Path::new(&self.directory.subdir))\n            .unwrap()\n            .filter_map(|entry| {\n                let path = entry.unwrap().path();\n                let name = self\n                    .directory\n                    .minus_as_string(path.as_path().to_str().unwrap_or(\"\"));\n                if self.regex.is_match(&name) {\n                    Some(name)\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }", "test": "fn test_no_flag() {\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &[])).stdout_move_str();\n    let v_actual: Vec<&str> = actual.split_whitespace().collect();\n    let v_expect: Vec<&str> = expect.split_whitespace().collect();\n    assert_eq!(v_actual, v_expect);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_server_read_leader_with_unapplied_log", "code": "fn test_read_leader_with_unapplied_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // if peer 2 is unreachable, leader will not send MsgAppend to peer 2, and the\n    // leader will send MsgAppend with committed information to peer 2 after\n    // network recovered, and peer 2 will apply the entry regardless of we add\n    // an filter, so we put k0/v0 to make sure the network is reachable.\n    let (k0, v0) = (b\"k0\", b\"v0\");\n    cluster.must_put(k0, v0);\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), k0, v0);\n    }\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv)\n            .allow(1),\n    ));\n\n    // Make peer 2's msg won't be replicated when it becomes leader,\n    // so the uncommitted entries won't be applied immediately.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Send),\n    ));\n\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it's still follower.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgHeartbeat)\n            .direction(Direction::Recv),\n    ));\n\n    let (k, v) = (b\"k\", b\"v\");\n    cluster.must_put(k, v);\n\n    // peer 1 must have committed, but peer 2 has not.\n    must_get_equal(&cluster.get_engine(1), k, v);\n\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    // leader's term not equal applied index's term, if we read local, we may get\n    // old value in this situation we need use raft read\n    must_get_none(&cluster.get_engine(2), k);\n\n    // internal read will use raft read no matter read_quorum is false or true,\n    // cause applied index's term not equal leader's term, and will failed with\n    // timeout\n    let req = get_with_timeout(cluster, k, false, Duration::from_secs(10)).unwrap();\n    assert!(\n        req.get_header().get_error().has_stale_command(),\n        \"read should be dropped immediately, but got {:?}\",\n        req\n    );\n\n    // recover network\n    cluster.clear_send_filters();\n\n    assert_eq!(cluster.get(k).unwrap(), v);\n}", "test": "fn test_server_read_leader_with_unapplied_log() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_read_leader_with_unapplied_log(&mut cluster);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::insert_79_custom_std_headers", "code": "pub fn as_str(&self) -> &str {\n        match self.0 {\n            Options => \"OPTIONS\",\n            Get => \"GET\",\n            Post => \"POST\",\n            Put => \"PUT\",\n            Delete => \"DELETE\",\n            Head => \"HEAD\",\n            Trace => \"TRACE\",\n            Connect => \"CONNECT\",\n            Patch => \"PATCH\",\n            ExtensionInline(ref inline) => inline.as_str(),\n            ExtensionAllocated(ref allocated) => allocated.as_str(),\n        }\n    }", "test": "fn insert_79_custom_std_headers() {\n    let mut h = HeaderMap::new();\n    let hdrs = custom_std(79);\n\n    for (i, hdr) in hdrs.iter().enumerate() {\n        h.insert(hdr.clone(), hdr.as_str().parse().unwrap());\n\n        for j in 0..(i + 1) {\n            assert_eq!(h[&hdrs[j]], hdrs[j].as_str());\n        }\n\n        for j in (i + 1)..hdrs.len() {\n            assert!(h.get(&hdrs[j]).is_none());\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_no_such_directory", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_no_such_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.touch(at.plus_as_string(\"a\"));\n\n    ucmd.arg(\"a\")\n        .fails()\n        .stderr_is(\"chroot: cannot change root directory to 'a': no such directory\\n\")\n        .code_is(125);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_decimal_scientific_notation_trailing_zeros_end", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_decimal_scientific_notation_trailing_zeros_end() {\n    new_ucmd!()\n        .args(&[\"-w\", \"1e-1\", \"1e-2\", \".1100\"])\n        .succeeds()\n        .stdout_is(\"0.10\\n0.11\\n\")\n        .no_stderr();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/options.rs::single_default_extension", "code": "pub fn extensions(mut self, extensions: Extensions) -> Self {\n        self.extensions = extensions;\n\n        self\n    }", "test": "fn single_default_extension() {\n    let ron = Options::default().with_default_extension(Extensions::IMPLICIT_SOME);\n\n    let de: Struct = ron.from_str(\"(42,(4.2))\").unwrap();\n    let ser = ron.to_string(&de).unwrap();\n\n    assert_eq!(ser, \"(42,(4.2))\");\n\n    let de: Struct = ron.from_str(\"#![enable(implicit_some)](42,(4.2))\").unwrap();\n    let ser = ron.to_string(&de).unwrap();\n\n    assert_eq!(ser, \"(42,(4.2))\");\n\n    let de: Struct = ron\n        .from_str(\"#![enable(implicit_some)]#![enable(unwrap_newtypes)](42,4.2)\")\n        .unwrap();\n    let ser = ron.to_string(&de).unwrap();\n\n    assert_eq!(ser, \"(42,(4.2))\");\n\n    let de: Struct = ron\n        .from_str(\"#![enable(implicit_some)]#![enable(unwrap_newtypes)](42,4.2)\")\n        .unwrap();\n    let ser = ron\n        .to_string_pretty(\n            &de,\n            PrettyConfig::default().extensions(Extensions::UNWRAP_NEWTYPES),\n        )\n        .unwrap();\n\n    assert_eq!(ser, \"#![enable(unwrap_newtypes)]\\n(42, 4.2)\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc3", "code": "pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    }", "test": "fn test_txn_store_gc3() {\n    let key = \"k\";\n    let store = AssertionStorage::default();\n    store.test_txn_store_gc3(key.as_bytes()[0]);\n    let (mut cluster, mut raft_store) =\n        AssertionStorageApiV1::new_raft_storage_with_store_count(3, key);\n    raft_store.test_txn_store_gc3_for_cluster(&mut cluster, key.as_bytes()[0]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple3_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn tuple3_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8, u16), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5, 6), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(\n        table.get(&(\"hello\", 5, 6)).unwrap().unwrap().value(),\n        (0, 123)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_treat_minus_as_filename", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_tee_treat_minus_as_filename() {\n    // Ensure tee treats '-' as the name of a file, as mandated by POSIX.\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    let content = \"tee_sample_content\";\n    let file = \"-\";\n\n    ucmd.arg(\"-\").pipe_in(content).succeeds().stdout_is(content);\n\n    assert!(at.file_exists(file));\n    assert_eq!(at.read(file), content);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::shl_limbs_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn shl_limbs_test() {\n    let mut x = VecType::from_u32(0xD2210408);\n    bigint::shl_limbs(&mut x, 2);\n    let expected: VecType = if LIMB_BITS == 32 {\n        vec_from_u32(&[0, 0, 0xD2210408])\n    } else {\n        vec_from_u32(&[0, 0, 0, 0, 0xD2210408])\n    };\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_decode", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_decode() {\n    for decode_param in [\"-d\", \"--decode\", \"--dec\"] {\n        let input = \"JBSWY3DPFQQFO33SNRSCC===\\n\"; // spell-checker:disable-line\n        new_ucmd!()\n            .arg(decode_param)\n            .pipe_in(input)\n            .succeeds()\n            .stdout_only(\"Hello, World!\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_no_deref_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_no_deref_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let dir1 = \"foo\";\n    let dir2 = \"bar\";\n    let link = \"baz\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    scene\n        .ucmd()\n        .args(&[\"-s\", dir2, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir2);\n\n    // try the normal behavior\n    scene\n        .ucmd()\n        .args(&[\"-sf\", dir1, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(\"baz/foo\"));\n    assert_eq!(at.resolve_link(\"baz/foo\"), dir1);\n\n    // Doesn't work without the force\n    scene.ucmd().args(&[\"-sn\", dir1, link]).fails();\n\n    // Try with the no-deref\n    scene.ucmd().args(&[\"-sfn\", dir1, link]).succeeds();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_local_read_renew_lease", "code": "fn rl(&self) -> RwLockReadGuard<'_, T> {\n        self.read().unwrap()\n    }", "test": "fn test_node_local_read_renew_lease() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(500);\n    let (base_tick_ms, election_ticks) = (50, 10);\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10));\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let key = b\"k\";\n    cluster.must_put(key, b\"v0\");\n    for id in 2..=3 {\n        cluster.pd_client.must_add_peer(region_id, new_peer(id, id));\n        must_get_equal(&cluster.get_engine(id), key, b\"v0\");\n    }\n\n    // Write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    let peer = new_peer(1, 1);\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // election_timeout_ticks * base_tick_interval * 3\n    let hibernate_wait = election_ticks * Duration::from_millis(base_tick_ms) * 3;\n    let request_wait = Duration::from_millis(base_tick_ms);\n    let max_renew_lease_time = 3;\n    let round = hibernate_wait.as_millis() / request_wait.as_millis();\n    for i in 0..round {\n        // Issue a read request and check the value on response.\n        must_read_on_peer(&mut cluster, peer.clone(), region.clone(), key, b\"v1\");\n        // Plus 1 to prevent case failure when test machine is too slow.\n        assert_le!(detector.ctx.rl().len(), max_renew_lease_time + 1, \"{}\", i);\n        thread::sleep(request_wait);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_f32", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_f32() {\n    let input: [u8; 28] = [\n        0x52, 0x06, 0x9e, 0xbf, // 0xbf9e0652 -1.2345679\n        0x4e, 0x61, 0x3c, 0x4b, // 0x4b3c614e 12345678\n        0x0f, 0x9b, 0x94, 0xfe, // 0xfe949b0f -9.876543E37\n        0x00, 0x00, 0x00, 0x80, // 0x80000000 -0.0\n        0xff, 0xff, 0xff, 0x7f, // 0x7fffffff NaN\n        0xc2, 0x16, 0x01, 0x00, // 0x000116c2 1e-40\n        0x00, 0x00, 0x7f, 0x80,\n    ]; // 0x807f0000 -1.1663108E-38\n    let expected_output = unindent(\n        \"\n            0000000     -1.2345679       12345678  -9.8765427e37             -0\n            0000020            NaN          1e-40 -1.1663108e-38\n            0000034\n            \",\n    );\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-f\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_early_apply.rs::test_update_internal_apply_index", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_update_internal_apply_index() {\n    let mut cluster = new_node_cluster(0, 4);\n    cluster.pd_client.disable_default_operator();\n    // So compact log will not be triggered automatically.\n    configure_for_request_snapshot(&mut cluster);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(3, 3));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    let filter = RegionPacketFilter::new(1, 3)\n        .msg_type(MessageType::MsgAppendResponse)\n        .direction(Direction::Recv);\n    cluster.add_send_filter(CloneFilterFactory(filter));\n    let last_index = cluster.raft_local_state(1, 1).get_last_index();\n    cluster.async_remove_peer(1, new_peer(4, 4)).unwrap();\n    cluster.async_put(b\"k2\", b\"v2\").unwrap();\n    let mut snaps = Vec::new();\n    for id in 1..3 {\n        cluster.wait_last_index(1, id, last_index + 2, Duration::from_secs(3));\n        snaps.push((id, cluster.get_raft_engine(id).dump_all_data(id)));\n    }\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n\n    // Simulate data lost in raft cf.\n    for (id, mut batch) in snaps {\n        cluster.stop_node(id);\n        delete_old_data(&cluster.get_raft_engine(id), id);\n        cluster\n            .get_raft_engine(id)\n            .consume(&mut batch, true /* sync */)\n            .unwrap();\n        cluster.run_node(id).unwrap();\n    }\n\n    let region = cluster.get_region(b\"k1\");\n    // Issues a heartbeat to followers so they will re-commit the logs.\n    let resp = read_on_peer(\n        &mut cluster,\n        new_peer(3, 3),\n        region,\n        b\"k1\",\n        true,\n        Duration::from_secs(3),\n    )\n    .unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    cluster.stop_node(3);\n    cluster.must_put(b\"k3\", b\"v3\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_long_redirection_to_root", "code": "pub fn get_root_path() -> &'static str {\n    if cfg!(windows) {\n        \"C:\\\\\"\n    } else {\n        \"/\"\n    }\n}", "test": "fn test_long_redirection_to_root() {\n    // Create a 255-character path to root\n    let dir = path_concat!(\"..\", ..85);\n    let actual = new_ucmd!()\n        .arg(\"-n\")\n        .arg(\"-m\")\n        .arg(dir)\n        .run()\n        .stdout_move_str();\n    let expect = get_root_path();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    assert_eq!(actual, expect);\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/wgsl-errors.rs::reserved_identifier_prefix", "code": "fn check(&self, expr: Handle<Expression>) -> Result<(), ConstantEvaluatorError> {\n        if let Some(ref function_local_data) = self.function_local_data {\n            if !function_local_data.expression_constness.is_const(expr) {\n                log::debug!(\"check: SubexpressionsAreNotConstant\");\n                return Err(ConstantEvaluatorError::SubexpressionsAreNotConstant);\n            }\n        }\n        Ok(())\n    }", "test": "fn reserved_identifier_prefix() {\n    check(\n        \"var __bad;\",\n        r###\"error: Identifier starts with a reserved prefix: '__bad'\n  \u250c\u2500 wgsl:1:5\n  \u2502\n1 \u2502 var __bad;\n  \u2502     ^^^^^ invalid identifier\n\n\"###,\n    );\n}\n\n#[test]\n"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_multiple_tabs_args", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_multiple_tabs_args() {\n    new_ucmd!()\n        .args(&[\"--tabs=3\", \"--tabs=6\", \"--tabs=9\"])\n        .pipe_in(\"a\\tb\\tc\\td\\te\")\n        .succeeds()\n        .stdout_is(\"a  b  c  d e\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_post_handshake", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_respects_buffer_limit_post_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    // this test will vary in behaviour depending on the default suites\n    do_handshake(&mut client, &mut server);\n    server.set_buffer_limit(Some(48));\n\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        6\n    );\n\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_find_region_by_key", "code": "pub fn stop(&mut self) {\n        self.handle.stop_observing();\n    }", "test": "fn test_region_collection_find_region_by_key() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n        .sim\n        .wl()\n        .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        let region = engine.find_region_by_key(b\"\").unwrap();\n        assert_eq!(region, regions[0]);\n\n        let region = engine.find_region_by_key(b\"k2\").unwrap();\n        assert_eq!(region, regions[1]);\n\n        let region = engine.find_region_by_key(b\"k99\").unwrap();\n        assert_eq!(region, *regions.last().unwrap());\n    }\n\n    for (_, p) in region_info_providers {\n        p.stop();\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bigfloat_tests.rs::simple_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn simple_test() {\n    let x = Bigfloat::new();\n    assert_eq!(x.exp, 0);\n\n    let y = Bigfloat::from_float(ExtendedFloat80 {\n        mant: 1 << 63,\n        exp: -63,\n    });\n    assert_eq!(y.exp, -63);\n\n    let x = Bigfloat::from_u32(1);\n    assert_eq!(&*x.data, &[1]);\n\n    let mut x = Bigfloat::from_u64(1);\n    assert_eq!(&*x.data, &[1]);\n\n    x.pow(10, 10);\n    assert_eq!(&*x.data, &[9765625]);\n    assert_eq!(x.exp, 10);\n\n    x.shl_bits(1);\n    assert_eq!(&*x.data, &[19531250]);\n    assert_eq!(x.exp, 10);\n\n    x.shl_limbs(1);\n    assert_eq!(&*x.data, &[0, 19531250]);\n    assert_eq!(x.exp, 10);\n\n    assert_eq!(x.leading_zeros(), LIMB_BITS as u32 - 25);\n\n    // y has a 0 for 32-bit limbs, no 0s for 64-bit limbs.\n    x *= &y;\n    let expected = if LIMB_BITS == 32 {\n        vec_from_u32(&[0, 0, 0, 9765625])\n    } else {\n        vec_from_u32(&[0, 0, 0, 0, 9765625])\n    };\n    assert!(x.data == expected, \"failed\");\n    assert_eq!(x.exp, -53);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::is_send", "code": "fn require_sync<T: Sync + Send>(_: &T) {}", "test": "fn is_send() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &[u8]> = TableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    {\n        let table = txn.open_table(definition).unwrap();\n        require_send(&table);\n        require_sync(&txn);\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(definition).unwrap();\n    require_sync(&table);\n    require_sync(&txn);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_number_format_rn", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_number_format_rn() {\n    for arg in [\"-nrn\", \"--number-format=rn\"] {\n        new_ucmd!()\n            .arg(arg)\n            .pipe_in(\"test\")\n            .succeeds()\n            .stdout_is(\"     1\\ttest\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_invalid_option", "code": "fn expect_error(input: &[&str]) {\n    assert!(!new_ucmd!()\n        .args(input)\n        .fails()\n        .no_stdout()\n        .stderr_str()\n        .is_empty());\n}", "test": "fn test_invalid_option() {\n    let path = \"/foo/bar/baz\";\n    expect_error(&[\"-q\", path]);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::unary_with_big_int", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn unary_with_big_int() {\n    test(\"-(1n)\", \"-1n;\");\n    test(\"- -1n\", \"1n;\");\n    test_wcb(\"!1n\", \"false;\");\n    test(\"~0n\", \"-1n;\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_cascade_merge_with_apply_yield", "code": "pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    }", "test": "fn test_node_merge_cascade_merge_with_apply_yield() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k5\");\n    let region = pd_client.get_region(b\"k5\").unwrap();\n    cluster.must_split(&region, b\"k9\");\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    let r1 = pd_client.get_region(b\"k1\").unwrap();\n    let r2 = pd_client.get_region(b\"k5\").unwrap();\n    let r3 = pd_client.get_region(b\"k9\").unwrap();\n\n    pd_client.must_merge(r2.get_id(), r1.get_id());\n    let yield_apply_first_region_fp = \"yield_apply_first_region\";\n    fail::cfg(yield_apply_first_region_fp, \"80%3*return()\").unwrap();\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v2\");\n    }\n\n    pd_client.must_merge(r3.get_id(), r1.get_id());\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v3\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_set_goal_not_contain_width", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fmt_set_goal_not_contain_width() {\n    for param in [\"-g\", \"--goal\"] {\n        new_ucmd!()\n            .args(&[\"one-word-per-line.txt\", param, \"74\"])\n            .succeeds()\n            .stdout_is(\"this is a file with one word per line\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_recursive_multiple", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_recursive_multiple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_recursive_directory\";\n    let file_a = \"test_rm_recursive_directory/test_rm_recursive_file_a\";\n    let file_b = \"test_rm_recursive_directory/test_rm_recursive_file_b\";\n\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"-r\")\n        .arg(\"-r\")\n        .arg(\"-r\")\n        .arg(dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_optional_args", "code": "pub fn empty_state(&self) -> State<'_, '_> {\n        State::new_for_env(self)\n    }", "test": "fn test_optional_args() {\n    fn add(val: u32, a: u32, b: Option<u32>) -> Result<u32, Error> {\n        // ensure we really get our value as first argument\n        assert_eq!(val, 23);\n        let mut sum = val + a;\n        if let Some(b) = b {\n            sum += b;\n        }\n        Ok(sum)\n    }\n\n    let mut env = crate::Environment::new();\n    env.add_filter(\"add\", add);\n    let state = env.empty_state();\n    assert_eq!(\n        state.apply_filter(\"add\", args!(23, 42)).unwrap(),\n        Value::from(65)\n    );\n    assert_eq!(\n        state\n            .apply_filter(\"add\", args!(23, 42, Value::UNDEFINED))\n            .unwrap(),\n        Value::from(65)\n    );\n    assert_eq!(\n        state.apply_filter(\"add\", args!(23, 42, 1)).unwrap(),\n        Value::from(66)\n    );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_exponent_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_exponent_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.exponent(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.exponent(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.exponent(b'^');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_b_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_adjacently_b_ser() {\n    let v = EnumStructAdjacently::VariantB { foo: 1, bar: 2 };\n    let e = \"(type:VariantB,content:(foo:1,bar:2))\";\n    test_ser(&v, e);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_delimited_identifiers", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_delimited_identifiers() {\n    // check that quoted identifiers in any position remain quoted after serialization\n    let select = snowflake().verified_only_select(\n        r#\"SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"\"#,\n    );\n    // check FROM\n    match only(select.from).relation {\n        TableFactor::Table {\n            name,\n            alias,\n            args,\n            with_hints,\n            version,\n            partitions: _,\n        } => {\n            assert_eq!(vec![Ident::with_quote('\"', \"a table\")], name.0);\n            assert_eq!(Ident::with_quote('\"', \"alias\"), alias.unwrap().name);\n            assert!(args.is_none());\n            assert!(with_hints.is_empty());\n            assert!(version.is_none());\n        }\n        _ => panic!(\"Expecting TableFactor::Table\"),\n    }\n    // check SELECT\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::CompoundIdentifier(vec![\n            Ident::with_quote('\"', \"alias\"),\n            Ident::with_quote('\"', \"bar baz\"),\n        ]),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::with_quote('\"', \"myfun\")]),\n            args: vec![],\n            filter: None,\n            null_treatment: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[1]),\n    );\n    match &select.projection[2] {\n        SelectItem::ExprWithAlias { expr, alias } => {\n            assert_eq!(&Expr::Identifier(Ident::with_quote('\"', \"simple id\")), expr);\n            assert_eq!(&Ident::with_quote('\"', \"column alias\"), alias);\n        }\n        _ => panic!(\"Expected ExprWithAlias\"),\n    }\n\n    snowflake().verified_stmt(r#\"CREATE TABLE \"foo\" (\"bar\" \"int\")\"#);\n    snowflake().verified_stmt(r#\"ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)\"#);\n    //TODO verified_stmt(r#\"UPDATE foo SET \"bar\" = 5\"#);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_read_lock_after_become_follower", "code": "pub fn has_stale_command(&self) -> bool {\n        self.stale_command.is_some()\n    }", "test": "fn test_read_lock_after_become_follower() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(3, 3));\n\n    let start_ts = block_on(cluster.pd_client.get_tso()).unwrap();\n\n    // put kv after get start ts, then this commit will cause a\n    // PessimisticLockNotFound if the pessimistic lock get missing.\n    cluster.must_put(b\"key\", b\"value\");\n\n    let leader = cluster.leader_of_region(region_id).unwrap();\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    let for_update_ts = block_on(cluster.pd_client.get_tso()).unwrap();\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts,\n                ttl: 1000,\n                for_update_ts,\n                min_commit_ts: for_update_ts,\n                last_change_ts: start_ts.prev(),\n                versions_to_last_change: 1,\n            },\n        )])\n        .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(3);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let mut req = PrewriteRequest::default();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_region_epoch(cluster.get_region_epoch(region_id));\n    ctx.set_peer(leader);\n    req.set_context(ctx);\n    req.set_primary_lock(b\"key\".to_vec());\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.set_key(b\"key\".to_vec());\n    mutation.set_value(b\"value2\".to_vec());\n    req.mut_mutations().push(mutation);\n    req.set_start_version(start_ts.into_inner());\n    req.set_lock_ttl(20000);\n\n    // Pause the command before it executes prewrite.\n    fail::cfg(\"txn_before_process_write\", \"pause\").unwrap();\n    let (tx, resp_rx) = mpsc::channel();\n    thread::spawn(move || tx.send(client.kv_prewrite(&req).unwrap()).unwrap());\n\n    thread::sleep(Duration::from_millis(200));\n    resp_rx.try_recv().unwrap_err();\n\n    // And pause applying the write on the leader.\n    fail::cfg(\"on_apply_write_cmd\", \"pause\").unwrap();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    thread::sleep(Duration::from_millis(200));\n\n    // Transfer leader will not make the command fail.\n    fail::remove(\"txn_before_process_write\");\n    let resp = resp_rx.recv().unwrap();\n    // The term has changed, so we should get a stale command error instead a\n    // PessimisticLockNotFound.\n    assert!(resp.get_region_error().has_stale_command());\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_formatter/tests/fixtures.rs::format", "code": "fn clone(&self) -> Self {\n        *self\n    }", "test": "fn format() {\n    let test_file = |input_path: &Path| {\n        let content = fs::read_to_string(input_path).unwrap();\n\n        let options = PyFormatOptions::from_extension(input_path);\n        let printed =\n            format_module_source(&content, options.clone()).expect(\"Formatting to succeed\");\n        let formatted_code = printed.as_code();\n\n        ensure_stability_when_formatting_twice(formatted_code, options.clone(), input_path);\n\n        let mut snapshot = format!(\"## Input\\n{}\", CodeFrame::new(\"py\", &content));\n\n        let options_path = input_path.with_extension(\"options.json\");\n        if let Ok(options_file) = fs::File::open(options_path) {\n            let reader = BufReader::new(options_file);\n            let options: Vec<PyFormatOptions> =\n                serde_json::from_reader(reader).expect(\"Options to be a valid Json file\");\n\n            writeln!(snapshot, \"## Outputs\").unwrap();\n\n            for (i, options) in options.into_iter().enumerate() {\n                let printed =\n                    format_module_source(&content, options.clone()).expect(\"Formatting to succeed\");\n                let formatted_code = printed.as_code();\n\n                ensure_stability_when_formatting_twice(formatted_code, options.clone(), input_path);\n\n                writeln!(\n                    snapshot,\n                    \"### Output {}\\n{}{}\",\n                    i + 1,\n                    CodeFrame::new(\"\", &DisplayPyOptions(&options)),\n                    CodeFrame::new(\"py\", &formatted_code)\n                )\n                .unwrap();\n            }\n        } else {\n            let printed =\n                format_module_source(&content, options.clone()).expect(\"Formatting to succeed\");\n            let formatted = printed.as_code();\n\n            ensure_stability_when_formatting_twice(formatted, options.clone(), input_path);\n\n            // We want to capture the differences in the preview style in our fixtures\n            let options_preview = options.with_preview(PreviewMode::Enabled);\n            let printed_preview = format_module_source(&content, options_preview.clone())\n                .expect(\"Formatting to succeed\");\n            let formatted_preview = printed_preview.as_code();\n\n            ensure_stability_when_formatting_twice(\n                formatted_preview,\n                options_preview.clone(),\n                input_path,\n            );\n\n            if formatted == formatted_preview {\n                writeln!(snapshot, \"## Output\\n{}\", CodeFrame::new(\"py\", &formatted)).unwrap();\n            } else {\n                // Having both snapshots makes it hard to see the difference, so we're keeping only\n                // diff.\n                writeln!(\n                    snapshot,\n                    \"## Output\\n{}\\n## Preview changes\\n{}\",\n                    CodeFrame::new(\"py\", &formatted),\n                    CodeFrame::new(\n                        \"diff\",\n                        TextDiff::from_lines(formatted, formatted_preview)\n                            .unified_diff()\n                            .header(\"Stable\", \"Preview\")\n                    )\n                )\n                .unwrap();\n            }\n        }\n\n        insta::with_settings!({\n            omit_expression => true,\n            input_file => input_path,\n            prepend_module_to_snapshot => false,\n        }, {\n            insta::assert_snapshot!(snapshot);\n        });\n    };\n\n    insta::glob!(\n        \"../resources\",\n        \"test/fixtures/ruff/**/*.{py,pyi}\",\n        test_file\n    );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::options_test", "code": "pub const fn max_significant_digits(mut self, max_significant_digits: OptionUsize) -> Self {\n        self.max_significant_digits = max_significant_digits;\n        self\n    }", "test": "fn options_test() {\n    let mut opts = Options::new();\n\n    unsafe {\n        opts.set_max_significant_digits(num::NonZeroUsize::new(10));\n        opts.set_min_significant_digits(num::NonZeroUsize::new(5));\n        opts.set_positive_exponent_break(num::NonZeroI32::new(9));\n        opts.set_negative_exponent_break(num::NonZeroI32::new(-9));\n        opts.set_round_mode(options::RoundMode::Truncate);\n        opts.set_trim_floats(true);\n        opts.set_exponent(b'^');\n        opts.set_decimal_point(b',');\n        opts.set_nan_string(Some(b\"nan\"));\n        opts.set_inf_string(Some(b\"Infinity\"));\n    }\n\n    assert_eq!(opts.max_significant_digits().unwrap().get(), 10);\n    assert_eq!(opts.min_significant_digits().unwrap().get(), 5);\n    assert_eq!(opts.positive_exponent_break().unwrap().get(), 9);\n    assert_eq!(opts.negative_exponent_break().unwrap().get(), -9);\n    assert_eq!(opts.round_mode(), options::RoundMode::Truncate);\n    assert_eq!(opts.trim_floats(), true);\n    assert_eq!(opts.exponent(), b'^');\n    assert_eq!(opts.decimal_point(), b',');\n    assert_eq!(opts.nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(opts.inf_string(), Some(\"Infinity\".as_bytes()));\n    assert!(opts.is_valid());\n\n    assert_eq!(Options::builder(), OptionsBuilder::new());\n    assert_eq!(opts.rebuild().build(), Ok(opts));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::instantiate", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn instantiate() -> Result<(), Error> {\n    let mut store = Store::<State>::default();\n    store.call_hook(State::call_hook);\n\n    let m = Module::new(store.engine(), \"(module)\")?;\n    Instance::new(&mut store, &m, &[])?;\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    let m = Module::new(store.engine(), \"(module (func) (start 0))\")?;\n    Instance::new(&mut store, &m, &[])?;\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_sync.rs::test_async_host_func_pending", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn test_async_host_func_pending() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    atoms::add_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let result_location: i32 = 0;\n\n    // This input triggers the host func pending forever\n    let input: i32 = TRIGGER_PENDING as i32;\n    let trap = shim_inst\n        .get_func(&mut store, \"double_int_return_float_shim\")\n        .unwrap()\n        .call(\n            &mut store,\n            &[input.into(), result_location.into()],\n            &mut [Val::I32(0)],\n        )\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"Cannot wait on pending future\"),\n        \"expected get a pending future Trap from dummy executor, got: {}\",\n        trap\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server_encryption.rs::test_node_snapshot_encryption", "code": "fn drop(&mut self) {\n        self.scheduler.stop();\n    }", "test": "fn test_node_snapshot_encryption() {\n    let mut cluster = new_node_cluster(0, 2);\n    test_snapshot_encryption(&mut cluster);\n    let _path = cluster.take_path();\n    drop(cluster);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_complex_url", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "test": "fn test_wasmer_run_complex_url() {\n    let wasm_test_path = fixtures::qjs();\n    let wasm_test_path = wasm_test_path.canonicalize().unwrap_or(wasm_test_path);\n    let mut wasm_test_path = format!(\"{}\", wasm_test_path.display());\n    if wasm_test_path.starts_with(r#\"\\\\?\\\"#) {\n        wasm_test_path = wasm_test_path.replacen(r#\"\\\\?\\\"#, \"\", 1);\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        wasm_test_path = wasm_test_path.replace(\"D:\\\\\", \"D://\");\n        wasm_test_path = wasm_test_path.replace(\"C:\\\\\", \"C://\");\n        wasm_test_path = wasm_test_path.replace(\"c:\\\\\", \"c://\");\n        wasm_test_path = wasm_test_path.replace(\"\\\\\", \"/\");\n        // wasmer run used to fail on c:\\Users\\username\\wapm_packages\\ ...\n        assert!(\n            wasm_test_path.contains(\"://\"),\n            \"wasm_test_path path is not complex enough\"\n        );\n    }\n\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(wasm_test_path)\n        .arg(\"--\")\n        .arg(\"-q\")\n        .assert()\n        .success();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/options_tests.rs::options_tests", "code": "pub const fn is_valid(&self) -> bool {\n        if !is_valid_ascii(self.exponent) {\n            false\n        } else if !is_valid_ascii(self.decimal_point) {\n            false\n        } else if !self.nan_str_is_valid() {\n            false\n        } else if !self.inf_str_is_valid() {\n            false\n        } else if !self.infinity_string_is_valid() {\n            false\n        } else {\n            true\n        }\n    }", "test": "fn options_tests() {\n    const X: Options = Options::new();\n    assert!(X.is_valid());\n    assert_eq!(X, Options::default());\n    assert!(OptionsBuilder::new().build().is_ok());\n    assert!(OptionsBuilder::default().build().is_ok());\n    assert!(OptionsBuilder::default().is_valid());\n    assert_eq!(X.rebuild(), Options::builder());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_clear_stale_data.rs::test_server_clear_stale_data", "code": "fn test_clear_stale_data<T: Simulator>(cluster: &mut Cluster<T>) {\n    // Disable compaction at level 0.\n    cluster\n        .cfg\n        .rocksdb\n        .defaultcf\n        .level0_file_num_compaction_trigger = 100;\n    cluster\n        .cfg\n        .rocksdb\n        .writecf\n        .level0_file_num_compaction_trigger = 100;\n    cluster\n        .cfg\n        .rocksdb\n        .lockcf\n        .level0_file_num_compaction_trigger = 100;\n    cluster\n        .cfg\n        .rocksdb\n        .raftcf\n        .level0_file_num_compaction_trigger = 100;\n\n    cluster.run();\n\n    let n = 6;\n    // Choose one node.\n    let node_id = *cluster.get_node_ids().iter().next().unwrap();\n    let db = cluster.get_engine(node_id);\n\n    // Split into `n` regions.\n    for i in 0..n {\n        let region = cluster.get_region(&[i]);\n        cluster.must_split(&region, &[i + 1]);\n    }\n\n    // Generate `n` files in db at level 6.\n    let level = 6;\n    init_db_with_sst_files(&db, level, n);\n    check_db_files_at_level(&db, level, u64::from(n));\n    for i in 0..n {\n        check_kv_in_all_cfs(&db, i, true);\n    }\n\n    // Remove some peers from the node.\n    cluster.pd_client.disable_default_operator();\n    for i in 0..n {\n        if i % 2 == 0 {\n            continue;\n        }\n        let region = cluster.get_region(&[i]);\n        let peer = find_peer(&region, node_id).unwrap().clone();\n        cluster.pd_client.must_remove_peer(region.get_id(), peer);\n    }\n\n    // Restart the node.\n    cluster.stop_node(node_id);\n    cluster.run_node(node_id).unwrap();\n\n    // Keys in removed peers should not exist.\n    for i in 0..n {\n        check_kv_in_all_cfs(&db, i, i % 2 == 0);\n    }\n    check_db_files_at_level(&db, level, u64::from(n) / 2);\n}", "test": "fn test_server_clear_stale_data() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_clear_stale_data(&mut cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_disk_full_for_txn_operations", "code": "fn test_disk_full_txn_behaviors(usage: DiskUsage) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // To ensure all replicas are not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n\n    // Test normal prewrite is not allowed.\n    let pd_client = cluster.pd_client.clone();\n    let lead_client = PeerClient::new(&cluster, 1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k3\", b\"v3\")],\n        b\"k3\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::NotAllowedOnFull,\n    );\n    assert!(res.get_region_error().has_disk_full());\n    assert_region_leader_changed(&mut cluster, 1, 1);\n\n    fail::remove(get_fp(usage, 1));\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&pd_client);\n    lead_client.must_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k4\", b\"v4\")],\n        b\"k4\".to_vec(),\n        prewrite_ts,\n    );\n\n    // Test commit is allowed.\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n    let commit_ts = get_tso(&pd_client);\n    lead_client.must_kv_commit(vec![b\"k4\".to_vec()], prewrite_ts, commit_ts);\n    lead_client.must_kv_read_equal(b\"k4\".to_vec(), b\"v4\".to_vec(), commit_ts);\n\n    // Test prewrite is allowed with a special `DiskFullOpt` flag.\n    let prewrite_ts = get_tso(&pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k5\", b\"v5\")],\n        b\"k5\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    let commit_ts = get_tso(&pd_client);\n    lead_client.must_kv_commit(vec![b\"k5\".to_vec()], prewrite_ts, commit_ts);\n    assert!(!res.get_region_error().has_disk_full());\n\n    fail::remove(get_fp(usage, 1));\n    let lead_client = PeerClient::new(&cluster, 1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&pd_client);\n    lead_client.must_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k6\", b\"v6\")],\n        b\"k6\".to_vec(),\n        prewrite_ts,\n    );\n\n    // Test rollback must be allowed.\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n    PeerClient::new(&cluster, 1, new_peer(1, 1))\n        .must_kv_rollback(vec![b\"k6\".to_vec()], prewrite_ts);\n\n    fail::remove(get_fp(usage, 1));\n    let start_ts = get_tso(&pd_client);\n    lead_client.must_kv_pessimistic_lock(b\"k7\".to_vec(), start_ts);\n\n    // Test pessimistic commit is allowed.\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k7\", b\"v7\")],\n        b\"k7\".to_vec(),\n        start_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    lead_client.must_kv_commit(vec![b\"k7\".to_vec()], start_ts, get_tso(&pd_client));\n\n    fail::remove(get_fp(usage, 1));\n    let lock_ts = get_tso(&pd_client);\n    lead_client.must_kv_pessimistic_lock(b\"k8\".to_vec(), lock_ts);\n\n    // Test pessmistic rollback is allowed.\n    fail::cfg(get_fp(usage, 1), \"return\").unwrap();\n    lead_client.must_kv_pessimistic_rollback(b\"k8\".to_vec(), lock_ts);\n\n    fail::remove(get_fp(usage, 1));\n}", "test": "fn test_disk_full_for_txn_operations() {\n    test_disk_full_txn_behaviors(DiskUsage::AlmostFull);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit125_wasi_snapshot1", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit125_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit125_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    if cfg!(windows) {\n        assert_eq!(output.status.code().unwrap(), 1);\n    } else {\n        assert_eq!(output.status.code().unwrap(), 125);\n    }\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_empty_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_empty_lines() {\n    new_ucmd!().pipe_in(\"\\n\").succeeds().stdout_is(\"\\n\");\n\n    new_ucmd!()\n        .arg(\"-w1\")\n        .pipe_in(\"0\\n1\\n\\n2\\n\\n\\n\")\n        .succeeds()\n        .stdout_is(\"0\\n1\\n\\n2\\n\\n\\n\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_in_parent_in_macro", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_location_in_parent_in_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"parent\", \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\': error while rendering macro `macros::hello` (error happened in \\'parent\\').\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_custom_backup_suffix_hyphen_value", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_custom_backup_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_custom_backup_suffix\";\n    let link = \"test_symlink_custom_backup_suffix_link\";\n    let suffix = \"-v\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let arg = &format!(\"--suffix={suffix}\");\n    ucmd.args(&[\"-b\", arg, \"-s\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}{suffix}\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_ignore_garbage", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_ignore_garbage() {\n    for ignore_garbage_param in [\"-i\", \"--ignore-garbage\", \"--ig\"] {\n        let input = \"JBSWY\\x013DPFQ\\x02QFO33SNRSCC===\\n\"; // spell-checker:disable-line\n        new_ucmd!()\n            .arg(\"-d\")\n            .arg(ignore_garbage_param)\n            .pipe_in(input)\n            .succeeds()\n            .stdout_only(\"Hello, World!\");\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::stream_close_by_trailers_frame_releases_capacity", "code": "pub fn capacity(&self) -> usize {\n        self.inner.capacity() as usize\n    }", "test": "async fn stream_close_by_trailers_frame_releases_capacity() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let window_size = frame::DEFAULT_INITIAL_WINDOW_SIZE as usize;\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Send request\n        let (resp1, mut s1) = client.send_request(request, false).unwrap();\n\n        // This effectively reserves the entire connection window\n        s1.reserve_capacity(window_size);\n\n        // The capacity should be immediately available as nothing else is\n        // happening on the stream.\n        assert_eq!(s1.capacity(), window_size);\n\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Create a second stream\n        let (resp2, mut s2) = client.send_request(request, false).unwrap();\n\n        // Request capacity\n        s2.reserve_capacity(5);\n\n        // There should be no available capacity (as it is being held up by\n        // the previous stream\n        assert_eq!(s2.capacity(), 0);\n\n        // Closing the previous stream by sending a trailers frame will\n        // release the capacity to s2\n        s1.send_trailers(Default::default()).unwrap();\n\n        // The capacity should be available\n        assert_eq!(s2.capacity(), 5);\n\n        // Send the frame\n        s2.send_data(\"hello\".into(), true).unwrap();\n\n        // Drive both streams to prevent the handles from being dropped\n        // (which will send a RST_STREAM) before the connection is closed.\n        h2.drive(resp1).await.unwrap();\n        h2.drive(resp2).await.unwrap();\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        // Get the first frame\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames::headers(3).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(3).response(200)).await;\n        srv.recv_frame(frames::headers(1).eos()).await;\n        srv.recv_frame(frames::data(3, &b\"hello\"[..]).eos()).await;\n    };\n    join(srv, h2).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_command_where_command_takes_n_flag", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_command_where_command_takes_n_flag() {\n    new_ucmd!()\n        .args(&[\"-n\", \"19\", \"echo\", \"-n\", \"a\"])\n        .run()\n        .stdout_is(\"a\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_create_stage() {\n    let sql = \"CREATE STAGE s1.s2\";\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage {\n            or_replace,\n            temporary,\n            if_not_exists,\n            name,\n            comment,\n            ..\n        } => {\n            assert!(!or_replace);\n            assert!(!temporary);\n            assert!(!if_not_exists);\n            assert_eq!(\"s1.s2\", name.to_string());\n            assert!(comment.is_none());\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n\n    let extended_sql = concat!(\n        \"CREATE OR REPLACE TEMPORARY STAGE IF NOT EXISTS s1.s2 \",\n        \"COMMENT='some-comment'\"\n    );\n    match snowflake().verified_stmt(extended_sql) {\n        Statement::CreateStage {\n            or_replace,\n            temporary,\n            if_not_exists,\n            name,\n            stage_params,\n            comment,\n            ..\n        } => {\n            assert!(or_replace);\n            assert!(temporary);\n            assert!(if_not_exists);\n            assert!(stage_params.url.is_none());\n            assert!(stage_params.endpoint.is_none());\n            assert_eq!(\"s1.s2\", name.to_string());\n            assert_eq!(\"some-comment\", comment.unwrap());\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(\n        snowflake().verified_stmt(extended_sql).to_string(),\n        extended_sql\n    );\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::hi64_test", "code": "pub fn hi64(&self) -> (u64, bool) {\n        bigint::hi64(&self.data)\n    }", "test": "fn hi64_test() {\n    assert_eq!(VecType::from_u64(0xA).hi64(), (0xA000000000000000, false));\n    assert_eq!(VecType::from_u64(0xAB).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xAB00000000).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xA23456789A).hi64(), (0xA23456789A000000, false));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_cdc_rawkv_scan", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_cdc_rawkv_scan() {\n    let mut suite = TestSuite::new(3, ApiVersion::V2);\n\n    let (k1, v1) = (b\"rkey1\".to_vec(), b\"value1\".to_vec());\n    suite.must_kv_put(1, k1, v1);\n\n    let (k2, v2) = (b\"rkey2\".to_vec(), b\"value2\".to_vec());\n    suite.must_kv_put(1, k2, v2);\n\n    let ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.flush_causal_timestamp_for_region(1);\n\n    let (k3, v3) = (b\"rkey3\".to_vec(), b\"value3\".to_vec());\n    suite.must_kv_put(1, k3.clone(), v3.clone());\n\n    let (k4, v4) = (b\"rkey4\".to_vec(), b\"value4\".to_vec());\n    suite.must_kv_put(1, k4.clone(), v4.clone());\n\n    let mut req = suite.new_changedata_request(1);\n    req.set_kv_api(ChangeDataRequestKvApi::RawKv);\n    req.set_checkpoint_ts(ts.into_inner());\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(1));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let mut events = receive_event(false).events.to_vec();\n    if events.len() == 1 {\n        events.extend(receive_event(false).events.into_iter());\n    }\n    assert_eq!(events.len(), 2, \"{:?}\", events);\n\n    match events.remove(0).event.unwrap() {\n        // Batch size is set to 3.\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 2, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Committed, \"{:?}\", es);\n            assert_eq!(e.key, k3, \"{:?}\", es);\n            assert_eq!(e.value, v3, \"{:?}\", es);\n\n            let e = &es.entries[1];\n            assert_eq!(e.get_type(), EventLogType::Committed, \"{:?}\", es);\n            assert_eq!(e.key, k4, \"{:?}\", es);\n            assert_eq!(e.value, v4, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    match events.pop().unwrap().event.unwrap() {\n        // Then it outputs Initialized event.\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 1, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    event_feed_wrap.replace(None);\n    suite.stop();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::trailing_include", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn trailing_include() {\n  Test::new()\n    .justfile(\n      \"\n      b:\n      !include ./include.justfile\n      \",\n    )\n    .arg(\"--unstable\")\n    .status(EXIT_FAILURE)\n    .stderr(\"error: Expected character `=`\\n  |\\n2 | !include ./include.justfile\\n  |  ^\\n\")\n    .run();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_value_in_set", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn missing_value_in_set() {\n    assert_err_msg(\n        \"{% set a =  %}\",\n        &[\"1:13\", \"expected a value that can be negated or an array of values\"],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_backup_huge_range_and_import", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_backup_huge_range_and_import() {\n    let mut suite = TestSuite::new(3, 100, ApiVersion::V1);\n    // 3 version for each key.\n    // make sure we will have two batch files\n    let key_count = 1024 * 3 / 2;\n    suite.must_kv_put(key_count, 3);\n\n    // Push down backup request.\n    let tmp = Builder::new().tempdir().unwrap();\n    let backup_ts = suite.alloc_ts();\n    let storage_path = make_unique_dir(tmp.path());\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &storage_path,\n    );\n    let mut resps1 = block_on(rx.collect::<Vec<_>>());\n    resps1.sort_by(|r1, r2| r1.start_key.cmp(&r2.start_key));\n\n    // Only leader can handle backup.\n    // ... But the response may be split into two parts (when meeting huge region).\n    assert_eq!(resps1.len(), 2, \"{:?}\", resps1);\n    let mut files1 = resps1\n        .iter()\n        .flat_map(|x| x.files.iter())\n        .cloned()\n        .collect::<Vec<_>>();\n    // Short value is piggybacked in write cf, so we get 1 sst at least.\n    assert!(!resps1[0].get_files().is_empty());\n\n    // Sort the files for avoiding race conditions. (would this happen?)\n    files1.sort_by(|f1, f2| f1.start_key.cmp(&f2.start_key));\n\n    assert_eq!(resps1[0].start_key, b\"\".to_vec());\n    assert_eq!(resps1[0].end_key, resps1[1].start_key);\n    assert_eq!(resps1[1].end_key, b\"\".to_vec());\n\n    assert_eq!(files1.len(), 2);\n    assert_ne!(files1[0].start_key, files1[0].end_key);\n    assert_ne!(files1[1].start_key, files1[1].end_key);\n    assert_eq!(files1[0].end_key, files1[1].start_key);\n\n    // Use importer to restore backup files.\n    let backend = make_local_backend(&storage_path);\n    let storage = create_storage(&backend, Default::default()).unwrap();\n    let region = suite.cluster.get_region(b\"\");\n    let mut sst_meta = SstMeta::default();\n    sst_meta.region_id = region.get_id();\n    sst_meta.set_region_epoch(region.get_region_epoch().clone());\n    let mut metas = vec![];\n    for f in files1.clone().into_iter() {\n        let mut reader = storage.read(&f.name);\n        let mut content = vec![];\n        block_on(reader.read_to_end(&mut content)).unwrap();\n        let mut m = sst_meta.clone();\n        m.crc32 = calc_crc32_bytes(&content);\n        m.length = content.len() as _;\n        // set different uuid for each file\n        m.set_uuid(uuid::Uuid::new_v4().as_bytes().to_vec());\n        m.cf_name = name_to_cf(&f.name).to_owned();\n        metas.push((m, content));\n    }\n\n    for (m, c) in &metas {\n        for importer in suite.cluster.sim.rl().importers.values() {\n            let mut f = importer.create(m).unwrap();\n            f.append(c).unwrap();\n            f.finish().unwrap();\n        }\n\n        // Make ingest command.\n        let mut ingest = Request::default();\n        ingest.set_cmd_type(CmdType::IngestSst);\n        ingest.mut_ingest_sst().set_sst(m.clone());\n        let mut header = RaftRequestHeader::default();\n        let leader = suite.context.get_peer().clone();\n        header.set_peer(leader);\n        header.set_region_id(suite.context.get_region_id());\n        header.set_region_epoch(suite.context.get_region_epoch().clone());\n        let mut cmd = RaftCmdRequest::default();\n        cmd.set_header(header);\n        cmd.mut_requests().push(ingest);\n        let resp = suite\n            .cluster\n            .call_command_on_leader(cmd, Duration::from_secs(5))\n            .unwrap();\n        assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    }\n\n    // Backup file should have same contents.\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &make_unique_dir(tmp.path()),\n    );\n    let resps3 = block_on(rx.collect::<Vec<_>>());\n    assert_same_files(\n        files1,\n        resps3\n            .iter()\n            .flat_map(|x| x.files.iter())\n            .cloned()\n            .collect(),\n    );\n\n    suite.stop();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/to_string_pretty.rs::test_struct_names", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_struct_names() {\n    let value = Point { x: 1.0, y: 2.0 };\n    let struct_name = to_string_pretty(&value, PrettyConfig::default().struct_names(true));\n    assert_eq!(\n        struct_name,\n        Ok(\"Point(\\n    x: 1.0,\\n    y: 2.0,\\n)\".to_string())\n    );\n    let no_struct_name = to_string(&value);\n    assert_eq!(no_struct_name, Ok(\"(x:1.0,y:2.0)\".to_string()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_negative_zero_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_negative_zero_lines() {\n    new_ucmd!()\n        .arg(\"--lines=-0\")\n        .pipe_in(\"a\\nb\\n\")\n        .succeeds()\n        .stdout_is(\"a\\nb\\n\");\n    new_ucmd!()\n        .arg(\"--lines=-0\")\n        .pipe_in(\"a\\nb\")\n        .succeeds()\n        .stdout_is(\"a\\nb\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_reject_proposal_during_region_merge", "code": "pub fn recv_timeout(&mut self, dur: Duration) -> Result<T, RecvTimeoutError> {\n        let fut = self.next();\n        match block_on_timeout(fut, dur) {\n            Ok(Some(v)) => Ok(v),\n            Ok(None) => Err(RecvTimeoutError::Disconnected),\n            Err(_) => Err(RecvTimeoutError::Timeout),\n        }\n    }", "test": "fn test_reject_proposal_during_region_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k\", b\"v\");\n\n    let r = cluster.get_region(b\"\");\n    cluster.must_split(&r, b\"k\");\n    // Let the new region catch up.\n    cluster.must_put(b\"a\", b\"v\");\n    cluster.must_put(b\"k\", b\"v\");\n\n    let prepare_merge_fp = \"apply_before_prepare_merge\";\n    let commit_merge_fp = \"apply_before_commit_merge\";\n\n    // Pause on applying so that prepare-merge is not finished.\n    fail::cfg(prepare_merge_fp, \"pause\").unwrap();\n    // Try to merge region.\n    let (merge_tx, merge_rx) = mpsc::channel();\n    let cb = Callback::read(Box::new(move |resp: ReadResponse<RocksSnapshot>| {\n        merge_tx.send(resp.response).unwrap()\n    }));\n    let source = cluster.get_region(b\"\");\n    let target = cluster.get_region(b\"k\");\n    cluster.merge_region(source.get_id(), target.get_id(), cb);\n    merge_rx\n        .recv_timeout(Duration::from_millis(100))\n        .unwrap_err();\n\n    // Try to put a key on the source region.\n    let force_delay_propose_batch_raft_command_fp = \"force_delay_propose_batch_raft_command\";\n    let mut receivers = vec![];\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"a\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        // The write request should be blocked until prepare-merge is finished.\n        cb_receivers.assert_not_ready();\n        receivers.push(cb_receivers);\n    }\n\n    // Pause on the second phase of region merge.\n    fail::cfg(commit_merge_fp, \"pause\").unwrap();\n\n    // prepare-merge is finished.\n    fail::remove(prepare_merge_fp);\n    assert!(\n        !merge_rx\n            .recv_timeout(Duration::from_secs(5))\n            .unwrap()\n            .get_header()\n            .has_error()\n    );\n    // The write request fails due to epoch not match.\n    for mut r in receivers {\n        r.assert_err();\n    }\n\n    // Write request is rejected because the source region is merging.\n    // It's not handled by epoch checker now.\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"a\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        cb_receivers.assert_err();\n    }\n\n    // Try to put a key on the target region.\n    let mut receivers = vec![];\n    for i in 0..2 {\n        if i == 1 {\n            // Test another path of calling proposed callback.\n            fail::cfg(force_delay_propose_batch_raft_command_fp, \"2*return\").unwrap();\n        }\n        let write_req = make_write_req(&mut cluster, b\"k\");\n        let (cb, mut cb_receivers) = make_cb(&write_req);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, write_req, cb)\n            .unwrap();\n        // The write request should be blocked until commit-merge is finished.\n        cb_receivers.assert_not_ready();\n        receivers.push(cb_receivers);\n    }\n\n    // Wait for region merge done.\n    fail::remove(commit_merge_fp);\n    pd_client.check_merged_timeout(source.get_id(), Duration::from_secs(5));\n    // The write request fails due to epoch not match.\n    for mut r in receivers {\n        r.assert_err();\n    }\n\n    // New write request can succeed.\n    let write_req = make_write_req(&mut cluster, b\"k\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    cb_receivers.assert_ok();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::normalize_test", "code": "fn check_normalize(mant: u64, exp: i32, shift: u32, r_mant: u64, r_exp: i32) {\n    let mut x = ExtendedFloat { mant, exp };\n    assert_eq!(x.normalize(), shift);\n    assert_eq!(\n        x,\n        ExtendedFloat {\n            mant: r_mant,\n            exp: r_exp\n        }\n    );\n}", "test": "fn normalize_test() {\n    // F32\n    // 0\n    check_normalize(0, 0, 0, 0, 0);\n\n    // min value\n    check_normalize(1, -149, 63, 9223372036854775808, -212);\n\n    // 1.0e-40\n    check_normalize(71362, -149, 47, 10043308644012916736, -196);\n\n    // 1.0e-20\n    check_normalize(12379400, -90, 40, 13611294244890214400, -130);\n\n    // 1.0\n    check_normalize(8388608, -23, 40, 9223372036854775808, -63);\n\n    // 1e20\n    check_normalize(11368684, 43, 40, 12500000250510966784, 3);\n\n    // max value\n    check_normalize(16777213, 104, 40, 18446740775174668288, 64);\n\n    // F64\n\n    // min value\n    check_normalize(1, -1074, 63, 9223372036854775808, -1137);\n\n    // 1.0e-250\n    check_normalize(6448907850777164, -883, 11, 13207363278391631872, -894);\n\n    // 1.0e-150\n    check_normalize(7371020360979573, -551, 11, 15095849699286165504, -562);\n\n    // 1.0e-45\n    check_normalize(6427752177035961, -202, 11, 13164036458569648128, -213);\n\n    // 1.0e-40\n    check_normalize(4903985730770844, -185, 11, 10043362776618688512, -196);\n\n    // 1.0e-20\n    check_normalize(6646139978924579, -119, 11, 13611294676837537792, -130);\n\n    // 1.0\n    check_normalize(4503599627370496, -52, 11, 9223372036854775808, -63);\n\n    // 1e20\n    check_normalize(6103515625000000, 14, 11, 12500000000000000000, 3);\n\n    // 1e40\n    check_normalize(8271806125530277, 80, 11, 16940658945086007296, 69);\n\n    // 1e150\n    check_normalize(5503284107318959, 446, 11, 11270725851789228032, 435);\n\n    // 1e250\n    check_normalize(6290184345309700, 778, 11, 12882297539194265600, 767);\n\n    // max value\n    check_normalize(9007199254740991, 971, 11, 18446744073709549568, 960);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_table_properties.rs::test_skip_gc_by_check", "code": "fn get(&self, _: &[u8]) -> Option<&[u8]> {\n        None\n    }", "test": "fn test_skip_gc_by_check() {\n    GC_COMPACTION_FILTER_PERFORM.reset();\n    GC_COMPACTION_FILTER_SKIP.reset();\n\n    let mut cfg = DbConfig::default();\n    cfg.defaultcf.disable_auto_compactions = true;\n    cfg.defaultcf.dynamic_level_bytes = false;\n    cfg.defaultcf.num_levels = 7;\n    let dir = tempfile::TempDir::new().unwrap();\n    let builder = TestEngineBuilder::new().path(dir.path());\n    let engine = builder\n        .api_version(ApiVersion::V2)\n        .build_with_cfg(&cfg)\n        .unwrap();\n    let raw_engine = engine.get_rocksdb();\n    let mut gc_runner = TestGcRunner::new(0);\n\n    do_write(&engine, false, 5);\n    engine.get_rocksdb().flush_cfs(&[], true).unwrap();\n\n    // The min_mvcc_ts ts > gc safepoint, check_need_gc return false, don't call\n    // dofilter\n    gc_runner\n        .safe_point(TimeStamp::new(1).into_inner())\n        .gc_raw(&raw_engine);\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        1\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        1\n    );\n\n    // TEST 2:When is_bottommost_level = false,\n    // write data to level2\n    do_write(&engine, false, 5);\n    engine.get_rocksdb().flush_cfs(&[], true).unwrap();\n\n    do_gc(&raw_engine, 2, &mut gc_runner, &dir);\n\n    do_write(&engine, false, 5);\n    engine.get_rocksdb().flush_cfs(&[], true).unwrap();\n\n    // Set ratio_threshold, let (props.num_versions as f64 > props.num_rows as\n    // f64 * ratio_threshold) return false\n    gc_runner.ratio_threshold = Option::Some(f64::MAX);\n\n    // is_bottommost_level = false\n    do_gc(&raw_engine, 1, &mut gc_runner, &dir);\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        3\n    );\n\n    // The check_need_gc return false, GC_COMPACTION_FILTER_SKIP will add 1.\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        2\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_backspace_is_not_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_backspace_is_not_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w10\", \"-s\"])\n        .pipe_in(\"foobar\\x086789abcdef\")\n        .succeeds()\n        .stdout_is(\"foobar\\x086789a\\nbcdef\"); // spell-checker:disable-line\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_gnu_repeating_options", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_gnu_repeating_options() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n    scene.ucmd().arg(\"-w\").arg(\"-w\").arg(\"file\").succeeds();\n    scene\n        .ucmd()\n        .arg(\"-w\")\n        .arg(\"-w\")\n        .arg(\"-w\")\n        .arg(\"file\")\n        .succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_input_range_and_file_not_allowed", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_shuf_input_range_and_file_not_allowed() {\n    new_ucmd!()\n        .args(&[\"-i\", \"0-9\", \"file\"])\n        .fails()\n        .stderr_contains(\"cannot be used with\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_output_is_random_permutation", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_output_is_random_permutation() {\n    let input_seq = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let input = input_seq\n        .iter()\n        .map(ToString::to_string)\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    let result = new_ucmd!().pipe_in(input.as_bytes()).succeeds();\n    result.no_stderr();\n\n    let mut result_seq: Vec<i32> = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .map(|x| x.parse().unwrap())\n        .collect();\n    result_seq.sort_unstable();\n    assert_ne!(result.stdout_str(), input, \"Output is not randomized\");\n    assert_eq!(result_seq, input_seq, \"Output is not a permutation\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_option_prefix", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_option_prefix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--prefix\", \"dog\", \"numbers50.txt\", \"13\", \"%25%\", \"/0$/\"])\n        .succeeds()\n        .stdout_only(\"27\\n15\\n63\\n\");\n\n    let count = glob(&at.plus_as_string(\"dog*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"dog00\"), generate(1, 13));\n    assert_eq!(at.read(\"dog01\"), generate(25, 30));\n    assert_eq!(at.read(\"dog02\"), generate(30, 51));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_duckdb.rs::test_create_table_macro", "code": "pub fn verified_query(&self, sql: &str) -> Query {\n        match self.verified_stmt(sql) {\n            Statement::Query(query) => *query,\n            _ => panic!(\"Expected Query\"),\n        }\n    }", "test": "fn test_create_table_macro() {\n    let query = \"SELECT col1_value AS column1, col2_value AS column2 UNION ALL SELECT 'Hello' AS col1_value, 456 AS col2_value\";\n    let macro_ = duckdb().verified_stmt(\n        &(\"CREATE OR REPLACE TEMPORARY MACRO dynamic_table(col1_value, col2_value) AS TABLE \"\n            .to_string()\n            + query),\n    );\n    let expected = Statement::CreateMacro {\n        or_replace: true,\n        temporary: true,\n        name: ObjectName(vec![Ident::new(\"dynamic_table\")]),\n        args: Some(vec![\n            MacroArg::new(\"col1_value\"),\n            MacroArg::new(\"col2_value\"),\n        ]),\n        definition: MacroDefinition::Table(duckdb().verified_query(query)),\n    };\n    assert_eq!(expected, macro_);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_block", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_block() {\n    let segwit = include_bytes!(\n        \"data/testnet_block_000000000000045e0b1660b6445b5e5c5ab63c9a4f956be7e1e69be04fa4497b.raw\"\n    );\n    let block: Block = deserialize(segwit).unwrap();\n    let got = serialize(&block).unwrap();\n    let want = include_bytes!(\"data/serde/block_bincode\");\n    assert_eq!(got, want)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_option_elide_empty_file2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_option_elide_empty_file2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-\", \"-z\", \"/a/-1\", \"{*}\"])\n        .pipe_in(\"\\na\\n\")\n        .succeeds()\n        .stdout_only(\"3\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), \"\\na\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_combined_with_number", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_obs_lines_within_combined_with_number() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n        .ucmd()\n        .args(&[\"-3dxen\", \"4\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: cannot split in more than one way\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-dxe30n\", \"4\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: cannot split in more than one way\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_total_only", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_total_only() {\n    new_ucmd!()\n        .args(&[\"lorem_ipsum.txt\", \"--total=only\"])\n        .run()\n        .stdout_is(\"13 109 772\\n\");\n\n    new_ucmd!()\n        .args(&[\"lorem_ipsum.txt\", \"moby_dick.txt\", \"--total=only\"])\n        .run()\n        .stdout_is(\"31 313 1887\\n\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::wrong_types", "code": "pub fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: TableDefinition<K, V>,\n    ) -> Result<Table<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Normal)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(Table::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn wrong_types() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u32, u32> = TableDefinition::new(\"x\");\n    let wrong_definition: TableDefinition<u64, u64> = TableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    txn.open_table(definition).unwrap();\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    assert!(matches!(\n        txn.open_table(wrong_definition),\n        Err(TableError::TableTypeMismatch { .. })\n    ));\n    txn.abort().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    txn.open_table(definition).unwrap();\n    assert!(matches!(\n        txn.open_table(wrong_definition),\n        Err(TableError::TableTypeMismatch { .. })\n    ));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/folding.rs::addition_folding", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn addition_folding() {\n    test(\"1 + 1\", \"2;\");\n    test(\"1 + 1 + 1\", \"3;\");\n    test(\"0 + true\", \"1;\");\n    test(\"x+''\", \"x+'';\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_si_to_iec", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_si_to_iec() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--to=iec\", \"15334263563K\"])\n        .run()\n        .stdout_is(\"14T\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_do_not_remove_suffix", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_do_not_remove_suffix() {\n    new_ucmd!()\n        .args(&[\"/foo/bar/baz\", \"baz\"])\n        .succeeds()\n        .stdout_only(\"baz\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_i", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_ls_i() {\n    new_ucmd!().arg(\"-i\").succeeds();\n    new_ucmd!().arg(\"-il\").succeeds();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_externally_a_de", "code": "fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n}", "test": "fn test_externally_a_de() {\n    let s = \"VariantA(foo:1,bar:2,different:3)\";\n    let e = EnumStructExternally::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    test_de(s, e);\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/rayon-0.rs::decoding_in_global_pool", "code": "pub fn decode(&mut self) -> Result<Vec<u8>> {\n        WorkerScope::with(|worker| self.decode_internal(false, worker))\n    }", "test": "fn decoding_in_global_pool() {\n    let path = Path::new(\"tests\").join(\"reftest\").join(\"images\").join(\"mozilla\").join(\"jpg-progressive.jpg\");\n\n    rayon::ThreadPoolBuilder::new()\n        .num_threads(1)\n        .build_global()\n        .unwrap();\n\n    let mut decoder = Decoder::new(File::open(&path).unwrap());\n    let _ = decoder.decode().unwrap();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/slash_operator.rs::no_lhs_un_parenthesized", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn no_lhs_un_parenthesized() {\n  Test::new()\n    .justfile(\n      \"\n      foo x=/ 'a' / 'b':\n        echo {{x}}\n    \",\n    )\n    .stderr(\n      \"\n      error: Expected backtick, identifier, '(', or string, but found '/'\n        |\n      1 | foo x=/ 'a' / 'b':\n        |       ^\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_negative_scientific_notation", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_negative_scientific_notation() {\n    new_ucmd!()\n        .args(&[\"-w\", \"-1e-3\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0.001\\n00.999\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-1.e-3\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0.001\\n00.999\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-1.0e-4\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0.00010\\n00.99990\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-.1e2\", \"10\", \"100\"])\n        .succeeds()\n        .stdout_is(\n            \"-010\n0000\n0010\n0020\n0030\n0040\n0050\n0060\n0070\n0080\n0090\n0100\n\",\n        )\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.1e2\", \"10\", \"100\"])\n        .succeeds()\n        .stdout_is(\n            \"-010\n0000\n0010\n0020\n0030\n0040\n0050\n0060\n0070\n0080\n0090\n0100\n\",\n        )\n        .no_stderr();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_end_newline", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_end_newline() {\n    assert_eq!(\"test\", normalize_html(\"test\\n\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_for_file", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_date_for_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_date_for_file\";\n    at.touch(file);\n    ucmd.arg(\"--file\").arg(file).succeeds();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::identifiers", "code": "fn identifiers(p: &QueryTreePy) -> PyResult<Vec<String>> {\n    Ok(p.qt.identifiers())\n}", "test": "fn identifiers() {\n    let needle = \"{int x = func(bar); xonk(foo);}\";\n    let tree = weggli::parse(needle, false);\n\n    let mut c = tree.walk();\n    let qt = build_query_tree(needle, &mut c, false, None);\n\n    let identifiers = qt.identifiers();\n\n    assert_eq!(identifiers, [\"int\", \"x\", \"func\", \"bar\", \"xonk\", \"foo\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_mktemp_t", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_mktemp_mktemp_t() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE6)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE7)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(TEST_TEMPLATE8)\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"invalid suffix\")\n        .stderr_contains(\"contains directory separator\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_group_by_all", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_select_group_by_all() {\n    let sql = \"SELECT id, fname, lname, SUM(order) FROM customer GROUP BY ALL\";\n    let select = verified_only_select(sql);\n    assert_eq!(GroupByExpr::All, select.group_by);\n\n    one_statement_parses_to(\n        \"SELECT id, fname, lname, SUM(order) FROM customer GROUP BY ALL\",\n        \"SELECT id, fname, lname, SUM(order) FROM customer GROUP BY ALL\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::recursive_errors", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn recursive_errors() {\n    for args in [\n        &[\"--verbose\", \"-P\"] as &[&str],\n        &[\"--verbose\", \"-H\"],\n        &[\"--verbose\", \"-L\"],\n        &[\"--verbose\", \"--recursive\", \"-P\", \"--dereference\"],\n        &[\"--verbose\", \"--recursive\", \"-H\", \"--no-dereference\"],\n        &[\"--verbose\", \"--recursive\", \"-L\", \"--no-dereference\"],\n    ] {\n        new_ucmd!().args(args).fails();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_file_is_not_executable", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_file_is_not_executable() {\n    #[cfg(unix)]\n    let (at, mut ucmd) = at_and_ucmd!();\n    #[cfg(not(unix))]\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    // WSL creates executable files by default, so if we are on unix, make sure\n    // to set make it non-executable.\n    // Files on other targets are non-executable by default.\n    #[cfg(unix)]\n    {\n        use std::os::unix::fs::PermissionsExt;\n        let metadata = std::fs::metadata(at.plus(\"regular_file\")).unwrap();\n        let mut permissions = metadata.permissions();\n\n        // The conversion is useless on some platforms and casts from u16 to\n        // u32 on others\n        #[allow(clippy::useless_conversion)]\n        permissions.set_mode(permissions.mode() & !u32::from(libc::S_IXUSR));\n        std::fs::set_permissions(at.plus(\"regular_file\"), permissions).unwrap();\n    }\n    ucmd.args(&[\"!\", \"-x\", \"regular_file\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_dont_overflow", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_dont_overflow() {\n    new_ucmd!()\n        .args(&[\"9223372036854775808d\", \"sleep\", \"0\"])\n        .succeeds()\n        .code_is(0)\n        .no_stderr()\n        .no_stdout();\n    new_ucmd!()\n        .args(&[\"-k\", \"9223372036854775808d\", \"10\", \"sleep\", \"0\"])\n        .succeeds()\n        .code_is(0)\n        .no_stderr()\n        .no_stdout();\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::errors_if_recv_frame_exceeds_max_frame_size", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn errors_if_recv_frame_exceeds_max_frame_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, h2) = client::handshake(io).await.unwrap();\n        let req = async move {\n            let resp = client.get(\"https://example.com/\").await.expect(\"response\");\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let res = util::concat(body).await;\n            let err = res.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"connection error detected: frame with invalid size\"\n            );\n        };\n\n        // client should see a conn error\n        let conn = async move {\n            let err = h2.await.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"connection error detected: frame with invalid size\"\n            );\n        };\n        join(conn, req).await;\n    };\n\n    // a bad peer\n    srv.codec_mut().set_max_send_frame_size(16_384 * 4);\n\n    let srv = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.send_frame(frames::data(1, vec![0; 16_385]).eos()).await;\n        srv.recv_frame(frames::go_away(0).frame_size()).await;\n    };\n\n    join(srv, h2).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_early_apply.rs::test_multi_early_apply", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_multi_early_apply() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    // So compact log will not be triggered automatically.\n    configure_for_request_snapshot(&mut cluster);\n\n    cluster.run_conf_change();\n    // Check mixed regions can be scheduled correctly.\n    let r1 = cluster.get_region(b\"k1\");\n    cluster.must_split(&r1, b\"k2\");\n    cluster.pd_client.must_add_peer(r1.get_id(), new_peer(2, 2));\n    // Put key value to cache leader.\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(1), b\"k0\", b\"v0\");\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n\n    let store_1_fp = \"raft_before_save_on_store_1\";\n\n    let executed = AtomicBool::new(false);\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .direction(Direction::Send)\n            .msg_type(MessageType::MsgAppend)\n            // Just for callback, so never filter.\n            .when(Arc::new(AtomicBool::new(false)))\n            .set_msg_callback(Arc::new(move |_| {\n                if !executed.swap(true, Ordering::SeqCst) {\n                    fail::cfg(store_1_fp, \"pause\").unwrap();\n                }\n            })),\n    ));\n    cluster.async_put(b\"k4\", b\"v4\").unwrap();\n    // Sleep a while so that follower will send append response.\n    sleep_ms(100);\n    cluster.async_put(b\"k11\", b\"v22\").unwrap();\n    // Now the store thread of store 1 pauses on `store_1_fp`.\n    // Set `store_1_fp` again to make this store thread does not pause on it.\n    // Then leader 1 will receive the append response and commit the log.\n    fail::cfg(store_1_fp, \"pause\").unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k4\", b\"v4\");\n    must_get_none(&cluster.get_engine(1), b\"k11\");\n    fail::remove(store_1_fp);\n    must_get_equal(&cluster.get_engine(1), b\"k11\", b\"v22\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_titan.rs::test_turnoff_titan", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_turnoff_titan() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.rocksdb.defaultcf.disable_auto_compactions = true;\n    cluster.cfg.rocksdb.defaultcf.num_levels = 1;\n    configure_for_enable_titan(&mut cluster, ReadableSize::kb(0));\n    cluster.run();\n    assert_eq!(cluster.must_get(b\"k1\"), None);\n\n    let size = 5;\n    for i in 0..size {\n        cluster\n            .put(\n                format!(\"k{:02}0\", i).as_bytes(),\n                format!(\"v{}\", i).as_bytes(),\n            )\n            .unwrap();\n    }\n    cluster.must_flush_cf(CF_DEFAULT, true);\n    for i in 0..size {\n        cluster\n            .put(\n                format!(\"k{:02}1\", i).as_bytes(),\n                format!(\"v{}\", i).as_bytes(),\n            )\n            .unwrap();\n    }\n    cluster.must_flush_cf(CF_DEFAULT, true);\n    for i in cluster.get_node_ids().into_iter() {\n        let engine = cluster.get_engine(i);\n        let db = engine.as_inner();\n        assert_eq!(\n            db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap(),\n            2\n        );\n        assert_eq!(\n            db.get_property_int(\"rocksdb.num-files-at-level1\").unwrap(),\n            0\n        );\n        assert_eq!(\n            db.get_property_int(\"rocksdb.titandb.num-live-blob-file\")\n                .unwrap(),\n            2\n        );\n        assert_eq!(\n            db.get_property_int(\"rocksdb.titandb.num-obsolete-blob-file\")\n                .unwrap(),\n            0\n        );\n    }\n    cluster.shutdown();\n\n    // try reopen db when titan isn't properly turned off.\n    configure_for_disable_titan(&mut cluster);\n    cluster.pre_start_check().unwrap_err();\n\n    configure_for_enable_titan(&mut cluster, ReadableSize::kb(0));\n    cluster.pre_start_check().unwrap();\n    cluster.start().unwrap();\n    assert_eq!(cluster.must_get(b\"k1\"), None);\n    for i in cluster.get_node_ids().into_iter() {\n        let db = cluster.get_engine(i);\n        let opt = vec![(\"blob_run_mode\", \"kFallback\")];\n        db.set_options_cf(CF_DEFAULT, &opt).unwrap();\n    }\n    cluster.compact_data();\n    let mut all_check_pass = true;\n    for _ in 0..10 {\n        // wait for gc completes.\n        sleep_ms(10);\n        all_check_pass = true;\n        for i in cluster.get_node_ids().into_iter() {\n            let engine = cluster.get_engine(i);\n            let db = engine.as_inner();\n            if db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap() != 0 {\n                all_check_pass = false;\n                break;\n            }\n            if db.get_property_int(\"rocksdb.num-files-at-level1\").unwrap() != 1 {\n                all_check_pass = false;\n                break;\n            }\n            if db\n                .get_property_int(\"rocksdb.titandb.num-live-blob-file\")\n                .unwrap()\n                != 0\n            {\n                all_check_pass = false;\n                break;\n            }\n        }\n        if all_check_pass {\n            break;\n        }\n    }\n    if !all_check_pass {\n        panic!(\"unexpected titan gc results\");\n    }\n    cluster.shutdown();\n\n    configure_for_disable_titan(&mut cluster);\n    // wait till files are purged, timeout set to purge_obsolete_files_period.\n    for _ in 1..100 {\n        sleep_ms(10);\n        if cluster.pre_start_check().is_ok() {\n            return;\n        }\n    }\n    cluster.pre_start_check().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_default", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_default() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_default_file\";\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_analyze_for_columns", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_analyze_for_columns() {\n    let analyze =\n        r#\"ANALYZE TABLE db.table_name PARTITION (a = '1234', b) COMPUTE STATISTICS FOR COLUMNS\"#;\n    hive().verified_stmt(analyze);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::unary", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn unary() {\n    test(\"+(x--)\", \"+x--;\");\n    test(\"-(x++)\", \"-x++;\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::unary_void", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn unary_void() {\n    run_test_actions([\n        TestAction::assert_eq(\"{ const a = 0; void a }\", JsValue::undefined()),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                let a = 0;\n                const test = () => a = 42;\n                const b = void test() + '';\n                a + b\n            \"#},\n            \"42undefined\",\n        ),\n    ]);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_itc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_itc() {\n    // Test iterators that skip multiple, internal or trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__45.56\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::write_digits_f64_test", "code": "fn write_digits_f64(buffer: &mut [u8], value: u64, expected: &str) {\n    let count = unsafe { f64::write_digits(buffer, value) };\n    let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n    assert_eq!(actual, expected);\n}", "test": "fn write_digits_f64_test() {\n    let mut buffer = [b'\\x00'; 32];\n    write_digits_f64(&mut buffer, 0, \"0\");\n    write_digits_f64(&mut buffer, 1, \"1\");\n    write_digits_f64(&mut buffer, 11, \"11\");\n    write_digits_f64(&mut buffer, 23, \"23\");\n    write_digits_f64(&mut buffer, 4294967295, \"4294967295\");\n    write_digits_f64(&mut buffer, 4294967296, \"4294967296\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_preserve_no_args", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_cp_preserve_no_args() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let src_file = \"a\";\n    let dst_file = \"b\";\n\n    // Prepare the source file\n    at.touch(src_file);\n    #[cfg(unix)]\n    at.set_mode(src_file, 0o0500);\n\n    // Copy\n    ucmd.arg(src_file)\n        .arg(dst_file)\n        .arg(\"--preserve\")\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        // Assert that the mode, ownership, and timestamps are preserved\n        // NOTICE: the ownership is not modified on the src file, because that requires root permissions\n        let metadata_src = at.metadata(src_file);\n        let metadata_dst = at.metadata(dst_file);\n        assert_metadata_eq!(metadata_src, metadata_dst);\n    }\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::decorators", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn decorators() {\n    let source = r#\"\n@decorator\ndef a():\n    pass\n\n@test\nclass A:\n    pass\n\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/no_cd.rs::linewise", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn linewise() {\n  Test::new()\n    .justfile(\n      \"\n      [no-cd]\n      foo:\n        cat bar\n    \",\n    )\n    .current_dir(\"foo\")\n    .tree(tree! {\n      foo: {\n        bar: \"hello\",\n      }\n    })\n    .stderr(\"cat bar\\n\")\n    .stdout(\"hello\")\n    .run();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::assign_to_array_decl", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn assign_to_array_decl() {\n    run_test_actions([\n        TestAction::assert_native_error(\n            \"[1] = [2]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 5\",\n        ),\n        TestAction::assert_native_error(\n            \"[3, 5] = [7, 8]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 8\",\n        ),\n        TestAction::assert_native_error(\n            \"[6, 8] = [2]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 8\",\n        ),\n        TestAction::assert_native_error(\n            \"[6] = [2, 9]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 5\",\n        ),\n    ]);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::env", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn env() {\n  Test::new()\n    .arg(\"--choose\")\n    .env(\"JUST_CHOOSER\", \"head -n1\")\n    .justfile(\n      \"\n        foo:\n          echo foo\n\n        bar:\n          echo bar\n      \",\n    )\n    .stderr(\"echo bar\\n\")\n    .stdout(\"bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_no_value", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_separator_no_value() {\n    new_ucmd!()\n        .args(&[\"-t\"])\n        .ignore_stdin_write_error()\n        .pipe_in(\"a\\n\")\n        .fails()\n        .stderr_contains(\n            \"error: a value is required for '--separator <SEP>' but none was supplied\",\n        );\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_sample", "code": "fn read_event(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"read_event\");\n    group.bench_function(\"trim_text = false\", |b| {\n        b.iter(|| {\n            let mut r = Reader::from_str(SAMPLE);\n            r.check_end_names(false);\n            let mut count = criterion::black_box(0);\n            loop {\n                match r.read_event() {\n                    Ok(Event::Start(_)) | Ok(Event::Empty(_)) => count += 1,\n                    Ok(Event::Eof) => break,\n                    _ => (),\n                }\n            }\n            assert_eq!(\n                count, 1550,\n                \"Overall tag count in ./tests/documents/sample_rss.xml\"\n            );\n        })\n    });\n\n    group.bench_function(\"trim_text = true\", |b| {\n        b.iter(|| {\n            let mut r = Reader::from_str(SAMPLE);\n            r.trim_text(true).check_end_names(false);\n            let mut count = criterion::black_box(0);\n            loop {\n                match r.read_event() {\n                    Ok(Event::Start(_)) | Ok(Event::Empty(_)) => count += 1,\n                    Ok(Event::Eof) => break,\n                    _ => (),\n                }\n            }\n            assert_eq!(\n                count, 1550,\n                \"Overall tag count in ./tests/documents/sample_rss.xml\"\n            );\n        });\n    });\n    group.finish();\n}", "test": "fn test_sample() {\n    let src = include_str!(\"documents/sample_rss.xml\");\n    let mut r = Reader::from_str(src);\n    let mut count = 0;\n    loop {\n        match r.read_event().unwrap() {\n            Start(_) => count += 1,\n            Decl(e) => println!(\"{:?}\", e.version()),\n            Eof => break,\n            _ => (),\n        }\n    }\n    println!(\"{}\", count);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::version_negotiate_client", "code": "pub(crate) fn poll(&mut self) -> Option<StreamEvent> {\n        if let Some(dir) = Dir::iter().find(|&i| mem::replace(&mut self.opened[i as usize], false))\n        {\n            return Some(StreamEvent::Opened { dir });\n        }\n\n        if self.write_limit() > 0 {\n            while let Some(id) = self.connection_blocked.pop() {\n                let stream = match self.send.get_mut(&id) {\n                    None => continue,\n                    Some(s) => s,\n                };\n\n                debug_assert!(stream.connection_blocked);\n                stream.connection_blocked = false;\n\n                // If it's no longer sensible to write to a stream (even to detect an error) then don't\n                // report it.\n                if stream.is_writable() && stream.max_data > stream.offset() {\n                    return Some(StreamEvent::Writable { id });\n                }\n            }\n        }\n\n        self.events.pop_front()\n    }", "test": "fn version_negotiate_client() {\n    let _guard = subscribe();\n    let server_addr = \"[::2]:7890\".parse().unwrap();\n    let cid_generator_factory: fn() -> Box<dyn ConnectionIdGenerator> =\n        || Box::new(RandomConnectionIdGenerator::new(0));\n    let mut client = Endpoint::new(\n        Arc::new(EndpointConfig {\n            connection_id_generator_factory: Arc::new(cid_generator_factory),\n            ..Default::default()\n        }),\n        None,\n        true,\n    );\n    let (_, mut client_ch) = client\n        .connect(client_config(), server_addr, \"localhost\")\n        .unwrap();\n    let now = Instant::now();\n    let opt_event = client.handle(\n        now,\n        server_addr,\n        None,\n        None,\n        // Version negotiation packet for reserved version\n        hex!(\n            \"80 00000000 04 00000000 04 00000000\n             0a1a2a3a\"\n        )[..]\n            .into(),\n    );\n    if let Some((_, DatagramEvent::ConnectionEvent(event))) = opt_event {\n        client_ch.handle_event(event);\n    }\n    assert_matches!(\n        client_ch.poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::VersionMismatch,\n        })\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::pass_guest_back_as_borrow", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn pass_guest_back_as_borrow() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n\n                (core func $new (canon resource.new $t))\n\n                (core module $m\n                    (import \"\" \"new\" (func $new (param i32) (result i32)))\n\n                    (func (export \"mk\") (result i32)\n                        (call $new (i32.const 100))\n                    )\n\n                    (func (export \"take\") (param i32)\n                        (if (i32.ne (local.get 0) (i32.const 100)) (then (unreachable)))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"new\" (func $new))\n                    ))\n                ))\n\n                (func (export \"mk\") (result (own $t))\n                    (canon lift (core func $i \"mk\")))\n                (func (export \"take\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"take\")))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let mk = i.get_typed_func::<(), (ResourceAny,)>(&mut store, \"mk\")?;\n    let take = i.get_typed_func::<(&ResourceAny,), ()>(&mut store, \"take\")?;\n\n    let (resource,) = mk.call(&mut store, ())?;\n    mk.post_return(&mut store)?;\n    take.call(&mut store, (&resource,))?;\n    take.post_return(&mut store)?;\n\n    resource.resource_drop(&mut store)?;\n\n    // Should not be valid to use `resource` again\n    let err = take.call(&mut store, (&resource,)).unwrap_err();\n    assert_eq!(err.to_string(), \"unknown handle index 0\");\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_lines_short_concatenated_with_value", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_lines_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-l1000\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_existing_target", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_existing_target() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_EXISTING_FILE)\n        .succeeds();\n\n    // Check the content of the destination file\n    assert_eq!(at.read(TEST_EXISTING_FILE), \"Hello, World!\\n\");\n\n    // No backup should have been created\n    assert!(!at.file_exists(format!(\"{TEST_EXISTING_FILE}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_not_older_than_src", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_older_dest_not_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_not_older_file1\";\n    let new = \"test_cp_arg_update_dest_not_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_exceeds_chain_limit", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_exceeds_chain_limit() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n    .network(Network::Signet)\n    .build();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"--chain signet wallet inscribe --file degenerate.png --fee-rate 1\")\n    .write(\"degenerate.png\", [1; 1025])\n    .rpc_server(&rpc_server)\n    .expected_exit_code(1)\n    .expected_stderr(\n      \"error: content size of 1025 bytes exceeds 1024 byte limit for signet inscriptions\\n\",\n    )\n    .run_and_extract_stdout();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::conditional", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn conditional() {\n    test(\"a ? b : c\", \"a?b:c;\");\n    test(\"a ? (b, c) : (d, e)\", \"a?(b,c):(d,e);\");\n    test(\"a ? b : c ? b : c\", \"a?b:c?b:c;\");\n    test(\"(a ? b : c) ? b : c\", \"a?b:c?b:c;\");\n    test(\"a, b ? c : d\", \"a,b?c:d;\");\n    test(\"(a, b) ? c : d\", \"(a,b)?c:d;\");\n    test(\"a = b ? c : d\", \"a=b?c:d;\");\n    test(\"(a = b) ? c : d\", \"(a=b)?c:d;\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::concurrent_connections_full", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn concurrent_connections_full() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig {\n            concurrent_connections: 0,\n            ..server_config()\n        },\n    );\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::ConnectionClosed(frame::ConnectionClose {\n                error_code: TransportErrorCode::CONNECTION_REFUSED,\n                ..\n            }),\n        })\n    );\n    assert_eq!(pair.server.connections.len(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::trailing_comma_parse_errors", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn trailing_comma_parse_errors() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--trailing-comma\"), (\"NONE\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"trailing_comma_parse_errors\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_succeed_and_not_become_leader", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_when_warmup_succeed_and_not_become_leader() {\n    let mut cluster = run_cluster_and_warm_up_cache_for_store2();\n\n    let (sx, rx) = channel::unbounded();\n    fail::cfg_callback(\"worker_async_fetch_raft_log\", move || {\n        sx.send(true).unwrap()\n    })\n    .unwrap();\n    fail::cfg(\"entry_cache_warmed_up_state_is_stale\", \"return\").unwrap();\n\n    // Since the warmup state is stale, the peer should exit warmup state,\n    // and the entry cache should be compacted during post_apply.\n    let applied_index = cluster.apply_state(1, 2).applied_index;\n    cluster.must_put(b\"kk1\", b\"vv1\");\n    cluster.wait_applied_index(1, 2, applied_index + 1);\n    // The peer should warm up cache again when it receives a new TransferLeaderMsg.\n    cluster.transfer_leader(1, new_peer(2, 2));\n    assert!(rx.recv_timeout(Duration::from_millis(500)).unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::_beyond_file() {\n    ", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "kip_beyond_file() {\n    new_ucmd!()\n        .args(&[\"bs=1\", \"skip=5\", \"count=0\", \"status=noxfer\"])\n        .pipe_in(\"abcd\")\n        .succeeds()\n        .no_stdout()\n        .stderr_contains(\n            \"'standard input': cannot skip to specified offset\\n0+0 records in\\n0+0 records out\\n\",\n        );\n}\n\n#[test]"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::remove_previous_ws_if_single_opening_tag_requires_it", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn remove_previous_ws_if_single_opening_tag_requires_it() {\n    let ws = WS { left: true, right: false };\n    let ast = vec![\n        Node::Text(\"hey \".to_string()),\n        Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"hey\".to_string()), // it removed the trailing space\n            Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n        ]\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_for_point_get_with_pk", "code": "pub fn get_ok(&self, key: &[u8], ts: impl Into<TimeStamp>, expect: &[u8]) {\n        let key = Key::from_raw(key);\n        assert_eq!(\n            self.store\n                .get(self.ctx.clone(), &key, ts.into())\n                .unwrap()\n                .0\n                .unwrap(),\n            expect\n        );\n    }", "test": "fn test_txn_store_for_point_get_with_pk() {\n    let store = AssertionStorage::default();\n\n    store.put_ok(b\"b\", b\"v2\", 1, 2);\n    store.put_ok(b\"primary\", b\"v1\", 2, 3);\n    store.put_ok(b\"secondary\", b\"v3\", 3, 4);\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"v3\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"new_key\"), b\"new_key\".to_vec()),\n        ],\n        b\"primary\",\n        5,\n    );\n    store.get_ok(b\"primary\", 4, b\"v1\");\n    store.get_ok(b\"primary\", TimeStamp::max(), b\"v1\");\n    store.get_err(b\"primary\", 6);\n\n    store.get_ok(b\"secondary\", 4, b\"v3\");\n    store.get_err(b\"secondary\", 6);\n    store.get_err(b\"secondary\", TimeStamp::max());\n\n    store.get_err(b\"new_key\", 6);\n    store.get_ok(b\"b\", 6, b\"v2\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_snap.rs::test_inspected_snapshot", "code": "pub fn fetch(&self) -> u32 {\n        self.cached_avg.load(Ordering::Relaxed)\n    }", "test": "fn test_inspected_snapshot() {\n    let mut cluster = new_server_cluster(1, 3);\n    cluster.cfg.prefer_mem = false;\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(8);\n    cluster.cfg.raft_store.merge_max_log_gap = 3;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.stop_node(3);\n    (0..10).for_each(|_| cluster.must_put(b\"k2\", b\"v2\"));\n    // Sleep for a while to ensure all logs are compacted.\n    sleep_ms(100);\n\n    let stats = cluster\n        .io_rate_limiter\n        .as_ref()\n        .unwrap()\n        .statistics()\n        .unwrap();\n    assert_eq!(stats.fetch(IoType::Replication, IoOp::Read), 0);\n    assert_eq!(stats.fetch(IoType::Replication, IoOp::Write), 0);\n    // Make sure snapshot read hits disk\n    cluster.flush_data();\n    // Let store 3 inform leader to generate a snapshot.\n    cluster.run_node(3).unwrap();\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n    assert_ne!(stats.fetch(IoType::Replication, IoOp::Read), 0);\n    assert_ne!(stats.fetch(IoType::Replication, IoOp::Write), 0);\n\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n    assert_eq!(stats.fetch(IoType::LoadBalance, IoOp::Read), 0);\n    assert_eq!(stats.fetch(IoType::LoadBalance, IoOp::Write), 0);\n    pd_client.must_add_peer(1, new_peer(2, 2));\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n    assert_ne!(stats.fetch(IoType::LoadBalance, IoOp::Read), 0);\n    assert_ne!(stats.fetch(IoType::LoadBalance, IoOp::Write), 0);\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::default_namespace", "code": "pub fn read_resolved_event(&mut self) -> Result<(ResolveResult, Event<'i>)> {\n        let event = self.read_event_impl(());\n        self.resolve_event(event)\n    }", "test": "fn default_namespace() {\n    let mut r = NsReader::from_str(r#\"<a ><b xmlns=\"www1\"></b></a>\"#);\n    r.trim_text(true);\n\n    // <a>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\n            \"expecting outer start element with no namespace, got {:?}\",\n            e\n        ),\n    }\n\n    // <b>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting inner start element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n    // </b>\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting inner end element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n\n    // </a> very important: a should not be in any namespace. The default namespace only applies to\n    // the sub-document it is defined on.\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\"expecting outer end element with no namespace, got {:?}\", e),\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::property_accessor_member_expression_bracket_notation_on_function", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn property_accessor_member_expression_bracket_notation_on_function() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            function asd () {};\n            asd['name'];\n        \"#},\n        \"asd\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_additional_suffix_no_slash", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_additional_suffix_no_slash() {\n    new_ucmd!()\n        .args(&[\"--additional-suffix\", \"a/b\"])\n        .fails()\n        .usage_error(\"invalid suffix 'a/b', contains directory separator\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_into_self", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_mv_into_self() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir1 = \"dir1\";\n    let dir2 = \"dir2\";\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n\n    scene\n        .ucmd()\n        .arg(dir1)\n        .arg(dir2)\n        .arg(dir2)\n        .fails()\n        .stderr_contains(\"mv: cannot move 'dir2' to a subdirectory of itself, 'dir2/dir2'\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/debugger.rs::test_compact", "code": "fn to_vec(&self) -> Vec<Option<Bytes>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            x.push(self.get(i).map(|x| x.to_owned()));\n        }\n        x\n    }", "test": "fn test_compact() {\n    let (split_key, _) = gen_mvcc_put_kv(b\"k10\", b\"\", 1.into(), 2.into());\n    let (split_key2, _) = gen_mvcc_put_kv(b\"k20\", b\"\", 1.into(), 2.into());\n    let regions = vec![\n        (1, b\"\".to_vec(), split_key.clone()),\n        (1000, split_key.clone(), split_key2.clone()),\n        (1002, split_key2.clone(), b\"\".to_vec()),\n    ];\n\n    let check_compact = |from: Vec<u8>, to: Vec<u8>, regions_compacted: HashSet<u64>| {\n        let count = 1;\n        let mut cluster = test_raftstore_v2::new_node_cluster(0, count);\n        cluster.cfg.raft_store.right_derive_when_split = false;\n        cluster.run();\n\n        let region = cluster.get_region(b\"\");\n        cluster.must_split(&region, &split_key);\n        let region = cluster.get_region(&split_key);\n        cluster.must_split(&region, &split_key2);\n\n        for i in 0..30 {\n            let (k, v) = (format!(\"k{:02}\", i), format!(\"value{}\", i));\n            let (k, v) = gen_mvcc_put_kv(k.as_bytes(), v.as_bytes(), 1.into(), 2.into());\n            cluster.must_put_cf(CF_WRITE, &k, &v);\n        }\n        for (registry, _) in &cluster.engines {\n            registry.for_each_opened_tablet(|_, db: &mut CachedTablet<_>| {\n                if let Some(db) = db.latest() {\n                    db.flush_cf(CF_WRITE, true).unwrap();\n                }\n                true\n            })\n        }\n\n        for i in 0..30 {\n            let k = format!(\"k{:02}\", i);\n            let k = gen_delete_k(k.as_bytes(), 2.into());\n            cluster.must_delete_cf(CF_WRITE, &k);\n        }\n        for (registry, _) in &cluster.engines {\n            registry.for_each_opened_tablet(|_, db: &mut CachedTablet<_>| {\n                if let Some(db) = db.latest() {\n                    db.flush_cf(CF_WRITE, true).unwrap();\n                }\n                true\n            })\n        }\n\n        let mut tablet_size_before_compact = HashMap::default();\n        for (registry, _) in &cluster.engines {\n            registry.for_each_opened_tablet(|region_id, db: &mut CachedTablet<_>| {\n                if let Some(db) = db.latest() {\n                    let cf_handle = get_cf_handle(db.as_inner(), CF_WRITE).unwrap();\n                    let approximate_size = db\n                        .as_inner()\n                        .get_approximate_sizes_cf(cf_handle, &[Range::new(b\"\", DATA_MAX_KEY)])[0];\n                    tablet_size_before_compact.insert(region_id, approximate_size);\n                }\n                true\n            })\n        }\n\n        let debugger = DebuggerImplV2::new(\n            cluster.engines[0].0.clone(),\n            cluster.raft_engines.get(&1).unwrap().clone(),\n            ConfigController::default(),\n        );\n\n        debugger\n            .compact(Db::Kv, CF_WRITE, &from, &to, 1, Some(\"skip\").into())\n            .unwrap();\n\n        let mut tablet_size_after_compact = HashMap::default();\n        for (registry, _) in &cluster.engines {\n            registry.for_each_opened_tablet(|region_id, db: &mut CachedTablet<_>| {\n                if let Some(db) = db.latest() {\n                    let cf_handle = get_cf_handle(db.as_inner(), CF_WRITE).unwrap();\n                    let approximate_size = db\n                        .as_inner()\n                        .get_approximate_sizes_cf(cf_handle, &[Range::new(b\"\", DATA_MAX_KEY)])[0];\n                    tablet_size_after_compact.insert(region_id, approximate_size);\n                }\n                true\n            })\n        }\n        for (id, &size) in &tablet_size_after_compact {\n            if regions_compacted.contains(id) {\n                assert!(size == 0);\n                continue;\n            }\n\n            assert_eq!(tablet_size_before_compact[id], size);\n        }\n    };\n\n    // compact the middle region\n    let region = regions[1].clone();\n    let mut regions_compacted = HashSet::default();\n    regions_compacted.insert(region.0);\n    let from = keys::data_key(&region.1);\n    let to = keys::data_end_key(&region.2);\n    check_compact(from, to, regions_compacted);\n\n    // compact first two regions\n    let region1 = regions[0].clone();\n    let region2 = regions[1].clone();\n    let mut regions_compacted = HashSet::default();\n    regions_compacted.insert(region1.0);\n    regions_compacted.insert(region2.0);\n    let from = keys::data_key(&region1.1);\n    let to = keys::data_end_key(&region2.2);\n    check_compact(from, to, regions_compacted);\n\n    // compact all regions by specifying specific keys\n    let region1 = regions[0].clone();\n    let region2 = regions[2].clone();\n    let mut regions_compacted = HashSet::default();\n    let _ = regions\n        .iter()\n        .map(|(id, ..)| regions_compacted.insert(*id))\n        .collect::<Vec<_>>();\n    let from = keys::data_key(&region1.1);\n    let to = keys::data_end_key(&region2.2);\n    check_compact(from, to, regions_compacted.clone());\n\n    // compact all regions\n    check_compact(b\"\".to_vec(), b\"\".to_vec(), regions_compacted.clone());\n    check_compact(b\"z\".to_vec(), b\"z\".to_vec(), regions_compacted.clone());\n    check_compact(b\"z\".to_vec(), b\"{\".to_vec(), regions_compacted);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_option_with_detected_negative_argument", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_option_with_detected_negative_argument() {\n    new_ucmd!()\n        .arg(\"-s,\")\n        .args(&[\"-1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-1,0,1,2\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/undefined_variables.rs::unknown_variable_in_unary_call", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn unknown_variable_in_unary_call() {\n  Test::new()\n    .justfile(\n      \"\n    foo x=env_var(a):\n  \",\n    )\n    .stderr(\n      \"\n      error: Variable `a` not defined\n        |\n      1 | foo x=env_var(a):\n        |               ^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_keyword", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse_keyword() {\n    parse(\"abstract\").unwrap_err();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::formatting_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn formatting_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"formatting_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_borrowed_key", "code": "pub fn from_str(s: &'a str) -> Self {\n        Deserializer::new(read::StrRead::new(s))\n    }", "test": "fn test_borrowed_key() {\n    let map: BTreeMap<&str, ()> = from_str(\"{\\\"borrowed\\\":null}\").unwrap();\n    let expected = treemap! { \"borrowed\" => () };\n    assert_eq!(map, expected);\n\n    #[derive(Deserialize, Debug, Ord, PartialOrd, Eq, PartialEq)]\n    struct NewtypeStr<'a>(&'a str);\n\n    let map: BTreeMap<NewtypeStr, ()> = from_str(\"{\\\"borrowed\\\":null}\").unwrap();\n    let expected = treemap! { NewtypeStr(\"borrowed\") => () };\n    assert_eq!(map, expected);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::include_succeeds_with_unstable", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn include_succeeds_with_unstable() {\n  Test::new()\n    .tree(tree! {\n      \"include.justfile\": \"\n        b:\n          @echo B\n      \",\n    })\n    .justfile(\n      \"\n        !include ./include.justfile\n\n        a: b\n          @echo A\n      \",\n    )\n    .arg(\"--unstable\")\n    .test_round_trip(false)\n    .arg(\"a\")\n    .stdout(\"B\\nA\\n\")\n    .run();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::large_values", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn large_values() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; 1024];\n    let value = vec![0u8; 2_000_000];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..5 {\n            key[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..5 {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_loop_iteration_variable_does_not_leak", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_loop_iteration_variable_does_not_leak() {\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            for (let i = 0;false;) {}\n            i\n        \"#},\n        JsNativeErrorKind::Reference,\n        \"i is not defined\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uptime.rs::test_failed", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_failed() {\n    new_ucmd!().arg(\"will-fail\").fails();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_read_only", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible_type", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_compatible_type() {\n    new_ucmd!().arg(\"-aT\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_decimal_scientific_notation_trailing_zeros_increment", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_decimal_scientific_notation_trailing_zeros_increment() {\n    new_ucmd!()\n        .args(&[\"-w\", \"1e-1\", \"0.0100\", \".11\"])\n        .succeeds()\n        .stdout_is(\"0.1000\\n0.1100\\n\")\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_option_suppress_matched", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_option_suppress_matched() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"--suppress-matched\", \"%0$%\"])\n        .succeeds()\n        .stdout_only(\"120\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(11, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_trigger_snapshot", "code": "pub fn call_command_on_leader(\n        &mut self,\n        mut request: RaftCmdRequest,\n        timeout: Duration,\n    ) -> Result<RaftCmdResponse> {\n        let timer = Instant::now();\n        let region_id = request.get_header().get_region_id();\n        loop {\n            let leader = match self.leader_of_region(region_id) {\n                None => return Err(Error::NotLeader(region_id, None)),\n                Some(l) => l,\n            };\n            request.mut_header().set_peer(leader);\n            let resp = match self.call_command(request.clone(), timeout) {\n                e @ Err(_) => return e,\n                Ok(resp) => resp,\n            };\n            if self.refresh_leader_if_needed(&resp, region_id)\n                && timer.saturating_elapsed() < timeout\n            {\n                warn!(\n                    \"{:?} is no longer leader, let's retry\",\n                    request.get_header().get_peer()\n                );\n                continue;\n            }\n            return Ok(resp);\n        }\n    }", "test": "fn test_force_leader_trigger_snapshot() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 10;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(90);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(8);\n    cluster.cfg.raft_store.merge_max_log_gap = 3;\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(10);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // Isolate node 2\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Compact logs to force requesting snapshot after clearing send filters.\n    let state = cluster.truncated_state(region.get_id(), 1);\n    // Write some data to trigger snapshot.\n    for i in 100..150 {\n        let key = format!(\"k{}\", i);\n        let value = format!(\"v{}\", i);\n        cluster.must_put(key.as_bytes(), value.as_bytes());\n    }\n    cluster.wait_log_truncated(region.get_id(), 1, state.get_index() + 40);\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    // Recover the isolation of 2, but still don't permit snapshot\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 2)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgSnapshot),\n    );\n    cluster.sim.wl().add_recv_filter(2, recv_filter);\n    cluster.clear_send_filters();\n\n    // wait election timeout\n    sleep_ms(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 5,\n    );\n    cluster.enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n\n    sleep_ms(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 3,\n    );\n    let cmd = new_change_peer_request(\n        ConfChangeType::RemoveNode,\n        find_peer(&region, 3).unwrap().clone(),\n    );\n    let req = new_admin_request(region.get_id(), region.get_region_epoch(), cmd);\n    // Though it has a force leader now, but the command can't committed because the\n    // log is not replicated to all the alive peers.\n    assert!(\n        cluster\n            .call_command_on_leader(req, Duration::from_millis(1000))\n            .unwrap()\n            .get_header()\n            .has_error() /* error \"there is a pending conf change\" indicating no committed log\n                          * after being the leader */\n    );\n\n    // Permit snapshot message, snapshot should be applied and advance commit index\n    // now.\n    cluster.sim.wl().clear_recv_filters(2);\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n    cluster.must_transfer_leader(region.get_id(), find_peer(&region, 1).unwrap().clone());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_month_default", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_month_default() {\n    test_helper(\"month_default\", &[\"-M\", \"--month-sort\", \"--sort=month\"]);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_during_finish", "code": "pub fn accept(&self) -> Accept<'_> {\n        Accept {\n            endpoint: self,\n            notify: self.inner.shared.incoming.notified(),\n        }\n    }", "test": "fn stop_during_finish() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    info!(\"stopping and finishing stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive_server();\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive_client();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Stopped { id, error_code: ERROR })) if id == s\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_regular_file", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_trailing_slash_regular_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"regfile\");\n    scene\n        .ucmd()\n        .args(&[\"-ev\", \"./regfile/\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(NOT_A_DIRECTORY)\n        .no_stdout();\n    scene\n        .ucmd()\n        .args(&[\"-e\", \"./regfile\"])\n        .succeeds()\n        .stdout_contains(\"regfile\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_base32_encode_file", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_base32_encode_file() {\n    new_ucmd!()\n        .arg(\"input-simple.txt\")\n        .succeeds()\n        .stdout_only(\"JBSWY3DPFQQFO33SNRSCCCQ=\\n\"); // spell-checker:disable-line\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_int", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_int() {\n    let thing = 256;\n    let yaml = indoc! {\"\n        256\n    \"};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/tempdir.rs::test_tempdir_is_set", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn test_tempdir_is_set() {\n  Test::new()\n    .justfile(\n      \"\n      set tempdir := '.'\n      foo:\n          #!/usr/bin/env bash\n          cat just*/foo\n      \",\n    )\n    .shell(false)\n    .tree(tree! {\n      foo: {\n      }\n    })\n    .current_dir(\"foo\")\n    .stdout(if cfg!(windows) {\n      \"\n\n\n\n\n      cat just*/foo\n      \"\n    } else {\n      \"\n      #!/usr/bin/env bash\n\n\n      cat just*/foo\n      \"\n    })\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_increase_pool", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_increase_pool() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 1;\n    cluster.pd_client.disable_default_operator();\n    let fp1 = \"poll\";\n\n    // Pause at the entrance of the apply-0, apply-low-0, rafstore-1-0 threads\n    fail::cfg(fp1, \"3*pause\").unwrap();\n    let _ = cluster.run_conf_change();\n\n    // Request cann't be handled as all pollers have been paused\n    put_with_timeout(&mut cluster, b\"k1\", b\"k1\", Duration::from_secs(1)).unwrap();\n    must_get_none(&cluster.get_engine(1), b\"k1\");\n\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-pool-size\".to_owned(), \"2\".to_owned());\n            change.insert(\"raftstore.apply_pool_size\".to_owned(), \"2\".to_owned());\n            change\n        };\n\n        // Update config, expand from 1 to 2\n        cfg_controller.update(change).unwrap();\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .apply_batch_system\n                .pool_size,\n            2\n        );\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .store_batch_system\n                .pool_size,\n            2\n        );\n    }\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n\n    fail::remove(fp1);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::multiple_subqueries", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn multiple_subqueries() {\n    let source = r\"\n        int uvc_xu_ctrl_query(struct uvc_video_chain *chain,\n            struct uvc_xu_control_query *xqry)\n        {\n            struct uvc_entity *entity;\n            struct uvc_control *ctrl;\n            unsigned int i;\n            bool found;\n            u32 reqflags;\n            u16 size;\n            u8 *data = NULL;\n            int ret;\n        \n            /* Find the extension unit. */\n            found = false;\n            a=b;\n        \n            /* Find the control and perform delayed initialization if needed. */\n            found = false;\n            for (i = 0; i < entity->ncontrols; ++i) {\n                ctrl = &entity->controls[i];\n                if (ctrl->index == xqry->selector - 1) {\n                    found = true;\n                    break;\n                }\n            }\n        \n            if (!found) {\n                return -ENOENT;\n            }\n        \n            if (mutex_lock_interruptible(&chain->ctrl_mutex))\n                return -ERESTARTSYS;\n        \n            ret = uvc_ctrl_init_xu_ctrl(chain->dev, ctrl);\n            if (ret < 0) {\n                ret = -ENOENT;\n                goto done;\n            }\n        \n            /* Validate the required buffer size and flags for the request */\n            reqflags = 0;\n            size = ctrl->info.size;\n\n            data = kmalloc(size, GFP_KERNEL);\n        }\";\n\n    let needle = \"{u16 $size; $size = _; kmalloc($size);}\";\n\n    let matches = parse_and_match(needle, source);\n    assert_eq!(1, matches);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_return_error_from_highest_priority_nameserver", "code": "pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }", "test": "fn test_return_error_from_highest_priority_nameserver() {\n    let query = Query::query(Name::from_str(\"www.example.\").unwrap(), RecordType::A);\n\n    const ERROR_RESPONSE_CODES: [ResponseCode; 4] = [\n        ResponseCode::ServFail,\n        ResponseCode::Refused,\n        ResponseCode::FormErr,\n        ResponseCode::NotImp,\n    ];\n    let name_servers = ERROR_RESPONSE_CODES\n        .iter()\n        .map(|response_code| {\n            let mut error_message = message(query.clone(), vec![], vec![], vec![]);\n            error_message.set_response_code(*response_code);\n            let response = ResolveError::from_response(\n                DnsResponse::from_message(error_message).unwrap(),\n                true,\n            )\n            .expect_err(\"error code should result in resolve error\");\n            mock_nameserver(vec![Err(response)], ResolverOpts::default())\n        })\n        .collect();\n    let pool = mock_nameserver_pool(name_servers, vec![], None, ResolverOpts::default());\n\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n    let error = block_on(future).expect_err(\n        \"DNS query should result in a `ResolveError` since all name servers return error responses\",\n    );\n    let expected_response_code = ERROR_RESPONSE_CODES.first().unwrap();\n    match error.kind() {\n        ResolveErrorKind::NoRecordsFound { response_code, .. }\n            if response_code == expected_response_code => {}\n        kind => panic!(\n            \"got unexpected kind of resolve error; expected `NoRecordsFound` error with response \\\n            code `{:?}`, got {:#?}\",\n            expected_response_code, kind,\n        ),\n    }\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_ico", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_ico() {\n    truncate_images(\"ico\")\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_fifo_error_size_only", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_fifo_error_size_only() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkfifo(\"fifo\");\n    ucmd.args(&[\"-s\", \"0\", \"fifo\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"cannot open 'fifo' for writing: No such device or address\");\n}"}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/tests.rs::display_wrapper_matches_normal_encode", "code": "pub fn encode<T: AsRef<[u8]>>(input: T) -> String {\n    STANDARD.encode(input)\n}", "test": "fn display_wrapper_matches_normal_encode() {\n    let mut bytes = Vec::<u8>::with_capacity(256);\n\n    for i in 0..255 {\n        bytes.push(i);\n    }\n    bytes.push(255);\n\n    assert_eq!(\n        STANDARD.encode(&bytes),\n        format!(\"{}\", display::Base64Display::new(&bytes, &STANDARD))\n    );\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_3_others", "code": "fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n}", "test": "fn remove_entry_multi_3_others() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n    headers.insert(VARY, \"*\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 3);\n    assert_eq!(headers.len(), 3);\n\n    let vias = remove_all_values(&mut headers, VIA);\n    assert_eq!(vias.len(), 2);\n    assert_eq!(headers.len(), 1);\n\n    let varies = remove_all_values(&mut headers, VARY);\n    assert_eq!(varies.len(), 1);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_readd_peer", "code": "fn test_readd_peer<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    pd_client.must_add_peer(r1, new_peer(2, 4));\n\n    cluster.clear_send_filters();\n    cluster.must_put(b\"k4\", b\"v4\");\n    let engine = cluster.get_engine(2);\n    must_get_equal(&engine, b\"k4\", b\"v4\");\n\n    // Stale gc message should be ignored.\n    let epoch = pd_client.get_region_epoch(r1);\n    let mut gc_msg = RaftMessage::default();\n    gc_msg.set_region_id(r1);\n    gc_msg.set_from_peer(new_peer(1, 1));\n    gc_msg.set_to_peer(new_peer(2, 2));\n    gc_msg.set_region_epoch(epoch);\n    gc_msg.set_is_tombstone(true);\n    cluster.send_raft_msg(gc_msg).unwrap();\n    // Fixme: find a better way to check if the message is ignored.\n    thread::sleep(Duration::from_secs(1));\n    must_get_equal(&engine, b\"k4\", b\"v4\");\n}", "test": "fn test_server_readd_peer() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_readd_peer(&mut cluster);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::range_query_reversed", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn range_query_reversed() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.range(3..7).unwrap().rev();\n    for i in (3..7u64).rev() {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    // Test reversing multiple times\n    let mut iter = table.range(3..7).unwrap();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(3, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(6, key.value());\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(5, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(4, key.value());\n\n    assert!(iter.next().is_none());\n}"}
{"test_id": "yamafaktory-jql/yamafaktory-jql-d2dde2f/crates/jql-runner/tests/integration.rs::check_token_integration", "code": "pub fn token(tokens: &[Token], json: &Value) -> Result<Value, JqlRunnerError> {\n    let groups = split(tokens);\n\n    let result = groups\n        .par_iter()\n        .try_fold_with(vec![], |mut acc: Vec<Value>, group| {\n            acc.push(group_runner(group, json)?);\n\n            Ok::<Vec<Value>, JqlRunnerError>(acc)\n        })\n        .try_reduce(Vec::new, |mut a, b| {\n            a.extend(b);\n\n            Ok(a)\n        });\n\n    result.map(|group| {\n        if groups.len() == 1 {\n            json!(group[0])\n        } else {\n            json!(group)\n        }\n    })\n}", "test": "fn check_token_integration() {\n    assert_eq!(\n        token(\n            &[\n                Token::KeySelector(\"a\"),\n                Token::GroupSeparator,\n                Token::KeySelector(\"b\")\n            ],\n            &json!({ \"a\": 1, \"b\": 2 })\n        ),\n        Ok(json!([1, 2]))\n    );\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/depth_limit.rs::depth_limit", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn depth_limit() {\n    let data = Config {\n        float: (2.18, -1.1),\n        tuple: TupleStruct((), false),\n        map: vec![(8, '1')].into_iter().collect(),\n        nested: Nested {\n            a: \"a\".to_owned(),\n            b: 'b',\n        },\n        var: Variant::A(!0, \"\"),\n        array: vec![(); 3],\n    };\n\n    let pretty = ron::ser::PrettyConfig::new()\n        .depth_limit(1)\n        .separate_tuple_members(true)\n        .enumerate_arrays(true)\n        .new_line(\"\\n\".to_string());\n    let s = ron::ser::to_string_pretty(&data, pretty);\n\n    assert_eq!(s, Ok(EXPECTED.to_string()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_conflicts_overriding", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_conflicts_overriding() {\n    new_ucmd!().arg(\"-hH\").succeeds();\n    new_ucmd!().arg(\"-Hh\").succeeds();\n    new_ucmd!().args(&[\"--no-sync\", \"--sync\"]).succeeds();\n    new_ucmd!().args(&[\"--sync\", \"--no-sync\"]).succeeds();\n    new_ucmd!().args(&[\"-k\", \"--block-size=3000\"]).succeeds();\n    new_ucmd!().args(&[\"--block-size=3000\", \"-k\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_m", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_m() {\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &[\"-m\"])).stdout_move_str();\n    ts.ucmd().arg(\"-m\").succeeds().stdout_is(expected_stdout);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/regression.rs::regression_test_4", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn regression_test_4() {\n    let original = r##\"|  Title A  |  Title B  |\n| --------- | --------- |\n| Content   | Content   |\n\n|  Title A  |  Title B  |  Title C  |  Title D  |\n| --------- | --------- | --------- | ---------:|\n| Content   | Content   | Conent    | Content   |\n\"##;\n    let expected = r##\"<table><thead><tr><th>Title A  </th><th>Title B  </th></tr></thead><tbody>\n<tr><td>Content   </td><td>Content   </td></tr>\n</tbody></table>\n<table><thead><tr><th>Title A  </th><th>Title B  </th><th>Title C  </th><th style=\"text-align: right\">Title D  </th></tr></thead><tbody>\n<tr><td>Content   </td><td>Content   </td><td>Conent    </td><td style=\"text-align: right\">Content   </td></tr>\n</tbody></table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_i", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_i() {\n    // Test iterators that skip single, internal-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"__.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\"_.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"__.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4_5__.56\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_read.rs::test_snap_without_read_index", "code": "pub fn read(&self) -> Option<&ReadResponse> {\n        match self {\n            QueryResult::Read(r) => Some(r),\n            _ => None,\n        }\n    }", "test": "fn test_snap_without_read_index() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let region_id = 2;\n    let mut req = router.new_request_for(region_id);\n    let mut request_inner = Request::default();\n    request_inner.set_cmd_type(CmdType::Snap);\n    req.mut_requests().push(request_inner);\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    // When it becomes leader, it will get a lease automatically because of empty\n    // entry.\n    assert_eq!(resp.read_index, 0);\n\n    // run with header read_quorum\n    req.mut_header().set_read_quorum(true);\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    // even the lease is valid, it should run read index\n    assert_eq!(resp.read_index, 6);\n\n    // TODO: add more test when write is implemented.\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_double_equal_is_string_comparison_op", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_double_equal_is_string_comparison_op() {\n    // undocumented but part of the GNU test suite\n    new_ucmd!().args(&[\"t\", \"==\", \"t\"]).succeeds();\n    new_ucmd!().args(&[\"t\", \"==\", \"f\"]).run().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_renew_lease", "code": "fn test_renew_lease<T: Simulator>(cluster: &mut Cluster<T>) {\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    // Use large election timeout to make leadership stable.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    // Override max leader lease to 2 seconds.\n    let max_lease = Duration::from_secs(2);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n    cluster.cfg.raft_store.renew_leader_lease_advance_duration = ReadableDuration::secs(0);\n\n    let node_id = 1u64;\n    let store_id = 1u64;\n    let peer = new_peer(store_id, node_id);\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let key = b\"k\";\n    cluster.must_put(key, b\"v0\");\n    for id in 2..=cluster.engines.len() as u64 {\n        cluster.pd_client.must_add_peer(region_id, new_peer(id, id));\n        must_get_equal(&cluster.get_engine(id), key, b\"v0\");\n    }\n\n    // Write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n    let state = cluster.raft_local_state(region_id, store_id);\n    let last_index = state.get_last_index();\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    assert_eq!(detector.ctx.rl().len(), 0);\n\n    let mut expect_lease_read = 0;\n\n    if cluster.engines.len() > 1 {\n        // Wait for the leader lease to expire.\n        thread::sleep(max_lease);\n\n        // Issue a read request and check the value on response.\n        must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n\n        // Check if the leader does a index read and renewed its lease.\n        assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n        expect_lease_read += 1;\n        assert_eq!(detector.ctx.rl().len(), expect_lease_read);\n    }\n\n    // Wait for the leader lease to expire.\n    thread::sleep(max_lease);\n\n    // Issue a write request.\n    cluster.must_put(key, b\"v2\");\n\n    // Check if the leader has renewed its lease so that it can do lease read.\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n    let state = cluster.raft_local_state(region_id, store_id);\n    assert_eq!(state.get_last_index(), last_index + 1);\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer, region, key, b\"v2\");\n\n    // Check if the leader does a local read.\n    assert_eq!(detector.ctx.rl().len(), expect_lease_read);\n}", "test": "fn test_node_renew_lease() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_renew_lease(&mut cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_propose_before_split_and_merge", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_propose_before_split_and_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k\", b\"v\");\n\n    let force_delay_propose_batch_raft_command_fp = \"force_delay_propose_batch_raft_command\";\n    fail::cfg(force_delay_propose_batch_raft_command_fp, \"return\").unwrap();\n\n    let write_req = make_write_req(&mut cluster, b\"k1\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    // Proposed cb is called.\n    cb_receivers.assert_proposed_ok();\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n\n    cb_receivers.assert_applied_ok();\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v\");\n\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k2\");\n    let left_peer1 = find_peer(&left, 1).unwrap().to_owned();\n    let right_peer2 = find_peer(&right, 2).unwrap().to_owned();\n\n    cluster.must_transfer_leader(left.get_id(), left_peer1);\n    cluster.must_transfer_leader(right.get_id(), right_peer2);\n\n    let write_req = make_write_req(&mut cluster, b\"k0\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    // Proposed cb is called.\n    cb_receivers.assert_proposed_ok();\n\n    let write_req2 = make_write_req(&mut cluster, b\"k2\");\n    let (cb2, mut cb_receivers2) = make_cb(&write_req2);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(2, write_req2, cb2)\n        .unwrap();\n    // Proposed cb is called.\n    cb_receivers2.assert_proposed_ok();\n\n    pd_client.must_merge(left.get_id(), right.get_id());\n\n    // Write request should succeed.\n    cb_receivers.assert_applied_ok();\n    must_get_equal(&cluster.get_engine(1), b\"k0\", b\"v\");\n\n    cb_receivers2.assert_applied_ok();\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_resolve.rs::test_joint_confchange", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_joint_confchange() {\n    let mut cluster = new_server_cluster(1, 3);\n    cluster.cfg.cdc.min_ts_interval = ReadableDuration::millis(100);\n    cluster.cfg.cdc.hibernate_regions_compatible = true;\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let receive_resolved_ts = |receive_event: &(dyn Fn(bool) -> ChangeDataEvent + Send)| {\n        let mut last_resolved_ts = 0;\n        let mut i = 0;\n        loop {\n            let event = receive_event(true);\n            if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n                let ts = resolved_ts.ts;\n                assert!(ts >= last_resolved_ts);\n                last_resolved_ts = ts;\n                i += 1;\n            }\n            if i > 10 {\n                break;\n            }\n        }\n    };\n\n    let deregister_fp = \"cdc_before_handle_deregister\";\n    fail::cfg(deregister_fp, \"return\").unwrap();\n\n    suite.cluster.must_put(b\"k1\", b\"v1\");\n    (1..=3).for_each(|i| must_get_equal(&suite.cluster.get_engine(i), b\"k1\", b\"v1\"));\n\n    let region = suite.cluster.get_region(b\"k1\");\n    let peers = region.get_peers();\n    assert_eq!(peers.len(), 3);\n    suite\n        .cluster\n        .must_transfer_leader(region.get_id(), peers[0].clone());\n\n    let req = suite.new_changedata_request(region.get_id());\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.get_id()));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    receive_resolved_ts(&receive_event);\n\n    suite.cluster.stop_node(peers[1].get_store_id());\n    receive_resolved_ts(&receive_event);\n    suite.cluster.run_node(peers[1].get_store_id()).unwrap();\n\n    let confchanges = vec![(\n        ConfChangeType::AddLearnerNode,\n        new_learner_peer(peers[2].store_id, peers[2].id),\n    )];\n    suite\n        .cluster\n        .pd_client\n        .must_joint_confchange(region.get_id(), confchanges);\n    receive_resolved_ts(&receive_event);\n\n    suite.cluster.stop_node(peers[1].get_store_id());\n    let update_region_fp = \"change_peer_after_update_region\";\n    fail::cfg(update_region_fp, \"pause\").unwrap();\n    let confchanges = vec![\n        (\n            ConfChangeType::AddLearnerNode,\n            new_learner_peer(peers[1].store_id, peers[1].id),\n        ),\n        (ConfChangeType::AddNode, peers[2].clone()),\n    ];\n    suite\n        .cluster\n        .pd_client\n        .joint_confchange(region.get_id(), confchanges);\n    sleep_ms(500);\n    let (tx, rx) = std::sync::mpsc::channel();\n    std::thread::spawn(move || {\n        receive_resolved_ts(&receive_event);\n        tx.send(()).unwrap();\n    });\n    rx.recv_timeout(Duration::from_secs(2)).unwrap_err();\n\n    fail::remove(update_region_fp);\n    fail::remove(deregister_fp);\n\n    event_feed_wrap.replace(None);\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_command_with_args", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_command_with_args() {\n    new_ucmd!()\n        .args(&[\"1700\", \"echo\", \"-n\", \"abcd\"])\n        .succeeds()\n        .stdout_only(\"abcd\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::switch", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn switch() {\n    test_formatting(\n        r#\"\n        let a = 3;\n        let b = \"unknown\";\n        switch (a) {\n            case 0:\n                b = \"Mon\";\n                break;\n            case 1:\n                b = \"Tue\";\n                break;\n            case 2:\n                b = \"Wed\";\n                break;\n            case 3:\n                b = \"Thurs\";\n                break;\n            case 4:\n                b = \"Fri\";\n                break;\n            case 5:\n                b = \"Sat\";\n                break;\n            case 6:\n                b = \"Sun\";\n                break;\n            default:\n                b = \"Unknown\";\n        }\n        b;\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_no_clobber_conflicting_options", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_mv_backup_no_clobber_conflicting_options() {\n    new_ucmd!()\n        .arg(\"--backup\")\n        .arg(\"--no-clobber\")\n        .arg(\"file1\")\n        .arg(\"file2\")\n        .fails()\n        .usage_error(\"options --backup and --no-clobber are mutually exclusive\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_macro_definitions", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn handle_ws_both_sides_for_macro_definitions() {\n    let start_ws = WS { left: true, right: true };\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![Node::MacroDefinition(\n        start_ws,\n        MacroDefinition {\n            name: \"something\".to_string(),\n            args: HashMap::new(),\n            body: vec![\n                Node::Text(\"\\n  \".to_string()),\n                Node::Text(\"hey\".to_string()),\n                Node::Text(\"  \".to_string()),\n            ],\n        },\n        end_ws,\n    )];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![Node::MacroDefinition(\n            start_ws,\n            MacroDefinition {\n                name: \"something\".to_string(),\n                args: HashMap::new(),\n                body: vec![Node::Text(\"hey\".to_string())],\n            },\n            end_ws,\n        ),]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tty.rs::test_close_stdin_silent", "code": "pub fn wait(self) -> io::Result<CmdResult> {\n        let (bin_path, util_name, tmpd) = (\n            self.bin_path.clone(),\n            self.util_name.clone(),\n            self.tmpd.clone(),\n        );\n\n        #[allow(deprecated)]\n        let output = self.wait_with_output()?;\n\n        Ok(CmdResult {\n            bin_path,\n            util_name,\n            tmpd,\n            exit_status: Some(output.status),\n            stdout: output.stdout,\n            stderr: output.stderr,\n        })\n    }", "test": "fn test_close_stdin_silent() {\n    let mut child = new_ucmd!().arg(\"-s\").run_no_wait();\n    child.close_stdin();\n    child.wait().unwrap().code_is(1).no_stdout();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_implicit_join", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_implicit_join() {\n    let sql = \"SELECT * FROM t1, t2\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        vec![\n            TableWithJoins {\n                relation: TableFactor::Table {\n                    name: ObjectName(vec![\"t1\".into()]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![],\n            },\n            TableWithJoins {\n                relation: TableFactor::Table {\n                    name: ObjectName(vec![\"t2\".into()]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![],\n            },\n        ],\n        select.from,\n    );\n\n    let sql = \"SELECT * FROM t1a NATURAL JOIN t1b, t2a NATURAL JOIN t2b\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        vec![\n            TableWithJoins {\n                relation: TableFactor::Table {\n                    name: ObjectName(vec![\"t1a\".into()]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: ObjectName(vec![\"t1b\".into()]),\n                        alias: None,\n                        args: None,\n                        with_hints: vec![],\n                        version: None,\n                        partitions: vec![],\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::Natural),\n                }],\n            },\n            TableWithJoins {\n                relation: TableFactor::Table {\n                    name: ObjectName(vec![\"t2a\".into()]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: ObjectName(vec![\"t2b\".into()]),\n                        alias: None,\n                        args: None,\n                        with_hints: vec![],\n                        version: None,\n                        partitions: vec![],\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::Natural),\n                }],\n            },\n        ],\n        select.from,\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_set_variable_in_global_context_in_forloop", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn can_set_variable_in_global_context_in_forloop() {\n    let mut context = Context::new();\n    context.insert(\"tags\", &vec![1, 2, 3]);\n    context.insert(\"default\", &\"default\");\n\n    let result = render_template(\n        r#\"\n{%- for i in tags -%}\n{%- set default = 1 -%}\n{%- set_global global_val = i -%}\n{%- endfor -%}\n{{ default }}{{ global_val }}\"#,\n        &context,\n    );\n\n    assert_eq!(result.unwrap(), \"default3\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_multiple_arguments", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_multiple_arguments() {\n    new_ucmd!()\n        .arg(\"call_graph.txt\")\n        .arg(\"invalid_file\")\n        .fails()\n        .stderr_contains(\"unexpected argument 'invalid_file' found\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/sst.rs::delete", "code": "fn valid(&self) -> Result<bool> {\n        self.0.valid().map_err(r2e)\n    }", "test": "fn delete() -> Result<()> {\n    let tempdir = tempdir();\n    let sst_path = tempdir\n        .path()\n        .join(\"test-data.sst\")\n        .to_string_lossy()\n        .to_string();\n    let sst_builder = <KvTestEngine as SstExt>::SstWriterBuilder::new();\n    let mut sst_writer = sst_builder.build(&sst_path)?;\n\n    sst_writer.delete(b\"k1\")?;\n    sst_writer.finish()?;\n\n    let sst_reader = <KvTestEngine as SstExt>::SstReader::open(&sst_path)?;\n    let mut iter = sst_reader.iter(IterOptions::default()).unwrap();\n\n    iter.seek_to_first()?;\n\n    assert_eq!(iter.valid()?, false);\n\n    iter.prev().unwrap_err();\n    iter.next().unwrap_err();\n    recover_safe(|| {\n        iter.key();\n    })\n    .unwrap_err();\n    recover_safe(|| {\n        iter.value();\n    })\n    .unwrap_err();\n\n    assert_eq!(iter.seek_to_first()?, false);\n    assert_eq!(iter.seek_to_last()?, false);\n    assert_eq!(iter.seek(b\"foo\")?, false);\n    assert_eq!(iter.seek_for_prev(b\"foo\")?, false);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_existing_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_existing_file\";\n    let link = \"test_symlink_existing_file_link\";\n\n    at.touch(file);\n\n    ucmd.args(&[\"-s\", file, link]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_undefined.rs::test_chainable_undefined", "code": "pub fn undefined_behavior(&self) -> UndefinedBehavior {\n        self.env.undefined_behavior()\n    }", "test": "fn test_chainable_undefined() {\n    let mut env = Environment::new();\n    env.set_undefined_behavior(UndefinedBehavior::Chainable);\n    env.add_filter(\"test\", |state: &State, value: String| -> String {\n        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Chainable);\n        assert_eq!(value, \"\");\n        value\n    });\n\n    assert_eq!(render!(in env, \"<{{ true.missing_attribute }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"<{{ undefined.missing_attribute }}>\"), \"<>\");\n    assert_eq!(\n        render!(in env, \"<{% for x in undefined %}...{% endfor %}>\"),\n        \"<>\"\n    );\n    assert_eq!(render!(in env, \"<{{ undefined }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ undefined is undefined }}\"), \"true\");\n    assert_eq!(render!(in env, \"{{ undefined|list }}\"), \"[]\");\n    assert_eq!(render!(in env, \"<{{ undefined|test }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ 42 in undefined }}\"), \"false\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/nested.rs::thread_options_through_inner", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "test": "fn thread_options_through_inner() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n  (component $c\n    (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n    (core module $libc\n        (memory (export \"memory\") 1)\n        {REALLOC_AND_FREE}\n    )\n    (core instance $libc (instantiate $libc))\n\n    (core func $host_lower\n        (canon lower\n            (func $host)\n            (memory $libc \"memory\")\n            (realloc (func $libc \"realloc\"))\n        )\n    )\n\n    (core module $m\n        (import \"\" \"host\" (func $host (param i32 i32)))\n        (import \"libc\" \"memory\" (memory 1))\n        (func (export \"run\") (param i32) (result i32)\n            i32.const 42\n            i32.const 100\n            call $host\n            i32.const 100\n        )\n        (export \"memory\" (memory 0))\n    )\n    (core instance $m (instantiate $m\n        (with \"\" (instance (export \"host\" (func $host_lower))))\n        (with \"libc\" (instance $libc))\n    ))\n\n    (func (export \"run\") (param \"a\" u32) (result string)\n        (canon lift\n            (core func $m \"run\")\n            (memory $m \"memory\")\n        )\n    )\n  )\n  (instance $c (instantiate $c (with \"hostfn\" (func $host))))\n  (export \"run\" (func $c \"run\"))\n)\n    \"#\n    );\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"hostfn\", |_, (param,): (u32,)| Ok((param.to_string(),)))?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let result = instance\n        .get_typed_func::<(u32,), (WasmStr,)>(&mut store, \"run\")?\n        .call(&mut store, (43,))?\n        .0;\n    assert_eq!(result.to_str(&store)?, \"42\");\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_no_args_files", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_no_args_files() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_simple_backup_file_a\";\n    let file_b = \"test_install_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_bool_lit", "code": "fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n}", "test": "fn test_bool_lit() {\n    let meta = test(\"#[foo(true)]\");\n\n    snapshot!(meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`true`),\n    }\n    \"###);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_by_index", "code": "pub fn get_item_by_index(&self, idx: usize) -> Result<Value, Error> {\n        self.get_item(&Value(ValueRepr::U64(idx as _)))\n    }", "test": "fn test_value_by_index() {\n    let val = Value::from(vec![1u32, 2, 3]);\n    assert_eq!(val.get_item_by_index(0).unwrap(), Value::from(1));\n    assert!(val.get_item_by_index(4).unwrap().is_undefined());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_joint_consensus_conf_change", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_joint_consensus_conf_change() {\n    let mut cluster = new_node_cluster(0, 4);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    assert_eq!(cluster.get(b\"k1\"), Some(b\"v1\".to_vec()));\n\n    // add multiple nodes\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddNode, new_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n            (ConfChangeType::AddLearnerNode, new_learner_peer(4, 4)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n\n    // remove multiple nodes\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(3, 3)),\n            (ConfChangeType::RemoveNode, new_learner_peer(4, 4)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    assert_eq!(\n        find_peer(&pd_client.get_region(b\"\").unwrap(), 3).unwrap(),\n        &new_learner_peer(3, 3)\n    );\n    must_get_none(&cluster.get_engine(4), b\"k1\");\n\n    // replace node\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::RemoveNode, new_learner_peer(3, 3)),\n            (ConfChangeType::AddNode, new_peer(4, 5)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_respects_buffer_limit_pre_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        12\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_fuel.rs::test_macro_fuel", "code": "pub fn fuel(&self) -> Option<u64> {\n        self.fuel\n    }", "test": "fn test_macro_fuel() {\n    let mut env = Environment::new();\n    assert_eq!(env.fuel(), None);\n    env.set_fuel(Some(100));\n    assert_eq!(env.fuel(), Some(100));\n    env.add_template(\n        \"test\",\n        \"\n        {% macro x() %}{% for item in range(5) %}...{% endfor %}{% endmacro %}\n        {% for count in range(macros) %}{{ x() }}{% endfor %}\n    \",\n    )\n    .unwrap();\n    let t = env.get_template(\"test\").unwrap();\n\n    // this should succeed\n    t.render(context!(macros => 3)).unwrap();\n\n    // but running more macros should not\n    let err = t.render(context!(macros => 5)).unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::OutOfFuel);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_negative_arg_is_a_string", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_negative_arg_is_a_string() {\n    new_ucmd!().arg(\"-12345\").succeeds();\n    new_ucmd!().arg(\"--qwert\").succeeds(); // spell-checker:disable-line\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_catch_up_logs_no_need", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_merge_catch_up_logs_no_need() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 25;\n    cluster.cfg.raft_store.raft_log_gc_threshold = 12;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(12);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(100);\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_on_store1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    // put some keys to trigger compact raft log\n    for i in 2..20 {\n        cluster.must_put(format!(\"k1{}\", i).as_bytes(), b\"v\");\n    }\n\n    // let the peer of left region on store 3 falls behind.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n\n    // make sure the peer is isolated.\n    cluster.must_put(b\"k11\", b\"v11\");\n    must_get_none(&cluster.get_engine(3), b\"k11\");\n\n    // propose merge but not let apply index make progress.\n    fail::cfg(\"apply_after_prepare_merge\", \"pause\").unwrap();\n    pd_client.merge_region(left.get_id(), right.get_id());\n    must_get_none(&cluster.get_engine(3), b\"k11\");\n\n    // wait to trigger compact raft log\n    thread::sleep(Duration::from_millis(100));\n\n    // let source region not merged\n    fail::cfg(\"before_handle_catch_up_logs_for_merge\", \"pause\").unwrap();\n    fail::cfg(\"after_handle_catch_up_logs_for_merge\", \"pause\").unwrap();\n    // due to `before_handle_catch_up_logs_for_merge` failpoint, we already pass\n    // `apply_index < catch_up_logs.merge.get_commit()` so now can let apply\n    // index make progress.\n    fail::remove(\"apply_after_prepare_merge\");\n\n    // make sure all the logs are committed, including the compact command\n    cluster.clear_send_filters();\n    thread::sleep(Duration::from_millis(50));\n\n    // let merge process continue\n    fail::remove(\"before_handle_catch_up_logs_for_merge\");\n    fail::remove(\"after_handle_catch_up_logs_for_merge\");\n    thread::sleep(Duration::from_millis(50));\n\n    // the source region should be merged and the peer should be destroyed.\n    assert!(pd_client.check_merged(left.get_id()));\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v11\");\n    cluster.must_region_not_exist(left.get_id(), 3);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_raw_tag", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn handle_ws_both_sides_for_raw_tag() {\n    let start_ws = WS { left: true, right: false };\n    let end_ws = WS { left: true, right: true };\n    let ast =\n        vec![Node::Raw(start_ws, \"  hey \".to_string(), end_ws), Node::Text(\"  hey\".to_string())];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            // it removed only the space at the end\n            Node::Raw(start_ws, \"  hey\".to_string(), end_ws),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printf.rs::basic_literal", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn basic_literal() {\n    new_ucmd!()\n        .args(&[\"hello world\"])\n        .succeeds()\n        .stdout_only(\"hello world\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_demote_failed_voters", "code": "pub fn sleep_ms(ms: u64) {\n    std::thread::sleep(Duration::from_millis(ms));\n}", "test": "fn test_unsafe_recovery_demote_failed_voters() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n    let peer_on_store2 = find_peer(&region, nodes[2]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store2.clone());\n    cluster.stop_node(nodes[1]);\n    cluster.stop_node(nodes[2]);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), nodes[0], vec![nodes[1], nodes[2]]);\n\n    let to_be_removed: Vec<metapb::Peer> = region\n        .get_peers()\n        .iter()\n        .filter(|&peer| peer.get_store_id() != nodes[0])\n        .cloned()\n        .collect();\n    let mut plan = pdpb::RecoveryPlan::default();\n    let mut demote = pdpb::DemoteFailedVoters::default();\n    demote.set_region_id(region.get_id());\n    demote.set_failed_voters(to_be_removed.into());\n    plan.mut_demotes().push(demote);\n    pd_client.must_set_unsafe_recovery_plan(nodes[0], plan);\n    cluster.must_send_store_heartbeat(nodes[0]);\n\n    let mut demoted = true;\n    for _ in 0..10 {\n        let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n        demoted = true;\n        for peer in region.get_peers() {\n            if peer.get_id() != nodes[0] && peer.get_role() == metapb::PeerRole::Voter {\n                demoted = false;\n            }\n        }\n        if demoted {\n            break;\n        }\n        sleep_ms(200);\n    }\n    assert!(demoted);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_double_space_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_double_space_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_double_line.log.expected\";\n    for arg in [\"-d\", \"--double-space\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[arg, test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_dead", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_dead() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-d\", \"--dead\", \"--de\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n    }\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_read_config", "code": "pub fn get_listen_port(&self) -> u16 {\n        self.listen_port.unwrap_or(DEFAULT_PORT)\n    }", "test": "fn test_read_config() {\n    let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"../..\".to_owned());\n    let path: PathBuf =\n        PathBuf::from(server_path).join(\"tests/test-data/test_configs/example.toml\");\n\n    if !path.exists() {\n        panic!(\"can't locate example.toml and other configs: {:?}\", path)\n    }\n\n    println!(\"reading config\");\n    let config: Config = Config::read_config(&path).unwrap();\n\n    assert_eq!(config.get_listen_port(), 53);\n    assert_eq!(config.get_listen_addrs_ipv4(), Ok(Vec::<Ipv4Addr>::new()));\n    assert_eq!(config.get_listen_addrs_ipv6(), Ok(Vec::<Ipv6Addr>::new()));\n    assert_eq!(config.get_tcp_request_timeout(), Duration::from_secs(5));\n    assert_eq!(config.get_log_level(), tracing::Level::INFO);\n    assert_eq!(config.get_directory(), Path::new(\"/var/named\"));\n    assert_eq!(\n        config.get_zones(),\n        [\n            ZoneConfig::new(\n                \"localhost\".into(),\n                ZoneType::Primary,\n                \"default/localhost.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.0.127.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/127.0.0.1.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.\\\n                 ip6.arpa\"\n                    .into(),\n                ZoneType::Primary,\n                \"default/ipv6_1.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"255.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/255.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/0.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"example.com\".into(),\n                ZoneType::Primary,\n                \"example.com.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            )\n        ]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_basics", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_du_basics() {\n    new_ucmd!().succeeds().no_stderr();\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_context_merge() {\n    let one = context!(a => 1);\n    let two = context!(b => 2, a => 42);\n    let ctx = context![..one, ..two];\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(1));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n\n    let two = context!(b => 2, a => 42);\n    let ctx = context!(a => 1, ..two);\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(1));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::read_isolation2", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn read_isolation2() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    {\n        let mut write_table = write_txn.open_table(STR_TABLE).unwrap();\n        write_table.remove(\"hello\").unwrap();\n        write_table.insert(\"hello2\", \"world2\").unwrap();\n        write_table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\"world2\", table2.get(\"hello2\").unwrap().unwrap().value());\n    assert_eq!(\"world3\", table2.get(\"hello3\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert!(table.get(\"hello2\").unwrap().is_none());\n    assert!(table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_pessimistic_lock_resumable_blocked_twice", "code": "fn test_pessimistic_lock_resumable_blocked_twice_impl(canceled_when_resumed: bool) {\n    let lock_mgr = MockLockManager::new();\n    let storage = TestStorageBuilderApiV1::new(lock_mgr.clone())\n        .wake_up_delay_duration(100)\n        .build()\n        .unwrap();\n    let (tx, rx) = channel();\n\n    let empty = PessimisticLockResults(vec![PessimisticLockKeyResult::Empty]);\n\n    fail::cfg(\"lock_waiting_queue_before_delayed_notify_all\", \"pause\").unwrap();\n    let (first_resume_tx, first_resume_rx) = channel();\n    let (first_resume_continue_tx, first_resume_continue_rx) = channel();\n    let first_resume_tx = Mutex::new(first_resume_tx);\n    let first_resume_continue_rx = Mutex::new(first_resume_continue_rx);\n    fail::cfg_callback(\n        \"acquire_pessimistic_lock_resumed_before_process_write\",\n        move || {\n            // Notify that the failpoint is reached, and block until it receives a continue\n            // signal.\n            first_resume_tx.lock().unwrap().send(()).unwrap();\n            first_resume_continue_rx.lock().unwrap().recv().unwrap();\n        },\n    )\n    .unwrap();\n\n    let key = Key::from_raw(b\"key\");\n\n    // Lock the key.\n    storage\n        .sched_txn_command(\n            new_acquire_pessimistic_lock_command(vec![(key.clone(), false)], 10, 10, false, false),\n            expect_pessimistic_lock_res_callback(tx, empty.clone()),\n        )\n        .unwrap();\n    rx.recv_timeout(Duration::from_secs(1)).unwrap();\n\n    // Another non-resumable request blocked.\n    let (tx_blocked_1, rx_blocked_1) = channel();\n    storage\n        .sched_txn_command(\n            new_acquire_pessimistic_lock_command(vec![(key.clone(), false)], 11, 11, false, false),\n            expect_fail_callback(tx_blocked_1, 0, |e| match e {\n                Error(box ErrorInner::Txn(TxnError(box TxnErrorInner::Mvcc(mvcc::Error(\n                    box mvcc::ErrorInner::WriteConflict { .. },\n                ))))) => (),\n                e => panic!(\"unexpected error chain: {:?}\", e),\n            }),\n        )\n        .unwrap();\n    rx_blocked_1\n        .recv_timeout(Duration::from_millis(50))\n        .unwrap_err();\n\n    let tokens_before = lock_mgr.get_all_tokens();\n    // Another resumable request blocked, and is queued behind the above one.\n    let (tx_blocked_2, rx_blocked_2) = channel();\n    storage\n        .sched_txn_command(\n            new_acquire_pessimistic_lock_command(vec![(key.clone(), false)], 12, 12, false, false)\n                .allow_lock_with_conflict(true),\n            if !canceled_when_resumed {\n                expect_pessimistic_lock_res_callback(tx_blocked_2, empty.clone())\n            } else {\n                expect_value_with_checker_callback(\n                    tx_blocked_2,\n                    0,\n                    |res: storage::Result<PessimisticLockResults>| {\n                        let res = res.unwrap().0;\n                        assert_eq!(res.len(), 1);\n                        let e = res[0].unwrap_err();\n                        match e.inner() {\n                            ErrorInner::Txn(TxnError(box TxnErrorInner::Mvcc(mvcc::Error(\n                                box mvcc::ErrorInner::KeyIsLocked(_),\n                            )))) => (),\n                            e => panic!(\"unexpected error chain: {:?}\", e),\n                        }\n                    },\n                )\n            },\n        )\n        .unwrap();\n    rx_blocked_2\n        .recv_timeout(Duration::from_millis(50))\n        .unwrap_err();\n    // Find the lock wait token of the above request.\n    let tokens_after = lock_mgr.get_all_tokens();\n    let token_of_12 = {\n        use std::ops::Sub;\n        let diff = tokens_after.sub(&tokens_before);\n        assert_eq!(diff.len(), 1);\n        diff.into_iter().next().unwrap()\n    };\n\n    // Release the lock, so that the former (non-resumable) request will be woken\n    // up, and the other one (resumable) will be woken up after delaying for\n    // `wake_up_delay_duration`.\n    delete_pessimistic_lock(&storage, key.clone(), 10, 10);\n    rx_blocked_1.recv_timeout(Duration::from_secs(1)).unwrap();\n\n    // The key should be unlocked at this time.\n    must_have_locks(&storage, 100, b\"\", b\"\\xff\\xff\\xff\", &[]);\n\n    // Simulate the transaction at ts=11 retries the pessimistic lock request, and\n    // succeeds.\n    let (tx, rx) = channel();\n    storage\n        .sched_txn_command(\n            new_acquire_pessimistic_lock_command(vec![(key.clone(), false)], 11, 11, false, false),\n            expect_pessimistic_lock_res_callback(tx, empty),\n        )\n        .unwrap();\n    rx.recv_timeout(Duration::from_secs(1)).unwrap();\n\n    // Remove `pause` in delayed wake up, so that the request of txn 12 can be woken\n    // up.\n    fail::remove(\"lock_waiting_queue_before_delayed_notify_all\");\n    first_resume_rx.recv().unwrap();\n\n    if canceled_when_resumed {\n        lock_mgr.simulate_timeout(token_of_12);\n    }\n\n    fail::remove(\"acquire_pessimistic_lock_resumed_before_process_write\");\n    first_resume_continue_tx.send(()).unwrap();\n\n    if canceled_when_resumed {\n        rx_blocked_2.recv_timeout(Duration::from_secs(1)).unwrap();\n        must_have_locks(\n            &storage,\n            100,\n            b\"\",\n            b\"\\xff\\xff\\xff\",\n            &[(&key.to_raw().unwrap(), Op::PessimisticLock, 11, 11)],\n        );\n    } else {\n        rx_blocked_2\n            .recv_timeout(Duration::from_millis(100))\n            .unwrap_err();\n        must_have_locks(\n            &storage,\n            100,\n            b\"\",\n            b\"\\xff\\xff\\xff\",\n            &[(&key.to_raw().unwrap(), Op::PessimisticLock, 11, 11)],\n        );\n        delete_pessimistic_lock(&storage, key.clone(), 11, 11);\n        rx_blocked_2.recv_timeout(Duration::from_secs(1)).unwrap();\n        must_have_locks(\n            &storage,\n            100,\n            b\"\",\n            b\"\\xff\\xff\\xff\",\n            &[(&key.to_raw().unwrap(), Op::PessimisticLock, 12, 12)],\n        );\n    }\n}", "test": "fn test_pessimistic_lock_resumable_blocked_twice() {\n    test_pessimistic_lock_resumable_blocked_twice_impl(false);\n    test_pessimistic_lock_resumable_blocked_twice_impl(true);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_remove_leader_with_uncommitted_log", "code": "fn test_remove_leader_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // stop peer 2 replicate messages.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv),\n    ));\n    // peer 2 can't step to leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgRequestVote)\n            .direction(Direction::Send),\n    ));\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.remove_peer(1, new_peer(1, 1));\n\n    // wait for the leader receive the remove order.\n    sleep_ms(1000);\n\n    let region = cluster.get_region(b\"\");\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let mut put = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        reqs,\n        false,\n    );\n    debug!(\"requesting: {:?}\", put);\n    put.mut_header().set_peer(new_peer(1, 1));\n    cluster.clear_send_filters();\n    let resp = cluster.call_command(put, Duration::from_secs(5)).unwrap();\n    assert!(resp.get_header().has_error());\n    assert!(\n        resp.get_header().get_error().has_region_not_found(),\n        \"{:?} should have region not found\",\n        resp\n    );\n}", "test": "fn test_node_remove_leader_with_uncommitted_log() {\n    let mut cluster = new_node_cluster(0, 2);\n    test_remove_leader_with_uncommitted_log(&mut cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/delete_range.rs::delete_range_cf_bad_cf", "code": "fn delete_range_cf(&mut self, cf: &str, begin_key: &[u8], end_key: &[u8]) -> Result<()> {\n        panic!()\n    }", "test": "fn delete_range_cf_bad_cf() {\n    let db = default_engine();\n    recover_safe(|| {\n        db.engine.delete_range_cf(\"bogus\", b\"a\", b\"b\").unwrap();\n    })\n    .unwrap_err();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_projection_nested_type", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_projection_nested_type() {\n    let sql = \"SELECT customer.address.state FROM foo\";\n    let _ast = verified_only_select(sql);\n    //TODO: add assertions\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::eq", "code": "pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }", "test": "fn eq() {\n    let mut a = HeaderMap::new();\n    let mut b = HeaderMap::new();\n\n    assert_eq!(a, b);\n\n    a.insert(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world\".parse().unwrap(),\n    );\n    assert_ne!(a, b);\n\n    b.insert(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world\".parse().unwrap(),\n    );\n    assert_eq!(a, b);\n\n    a.insert(\"foo\".parse::<HeaderName>().unwrap(), \"bar\".parse().unwrap());\n    a.append(\"foo\".parse::<HeaderName>().unwrap(), \"baz\".parse().unwrap());\n    assert_ne!(a, b);\n\n    b.insert(\"foo\".parse::<HeaderName>().unwrap(), \"bar\".parse().unwrap());\n    assert_ne!(a, b);\n\n    b.append(\"foo\".parse::<HeaderName>().unwrap(), \"baz\".parse().unwrap());\n    assert_eq!(a, b);\n\n    a.append(\"a\".parse::<HeaderName>().unwrap(), \"a\".parse().unwrap());\n    a.append(\"a\".parse::<HeaderName>().unwrap(), \"b\".parse().unwrap());\n    b.append(\"a\".parse::<HeaderName>().unwrap(), \"b\".parse().unwrap());\n    b.append(\"a\".parse::<HeaderName>().unwrap(), \"a\".parse().unwrap());\n\n    assert_ne!(a, b);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_cannot_be_zero", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_tabs_cannot_be_zero() {\n    new_ucmd!()\n        .arg(\"--tabs=0\")\n        .fails()\n        .stderr_contains(\"tab size cannot be 0\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::object_field_set", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn object_field_set() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let m = {};\n            m['key'] = 22;\n            m['key']\n        \"#},\n        22,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_negative_number_as_separator", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_negative_number_as_separator() {\n    new_ucmd!()\n        .arg(\"-s\")\n        .args(&[\"-1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"1-12\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_final_stats_noxfer", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_final_stats_noxfer() {\n    new_ucmd!()\n        .args(&[\"status=noxfer\"])\n        .succeeds()\n        .stderr_only(\"0+0 records in\\n0+0 records out\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent_mode_check_existing_parent", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mkdir_parent_mode_check_existing_parent() {\n    let _guard = TEST_MUTEX.lock();\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"a\");\n\n    let default_umask: mode_t = 0o160;\n    let original_umask = unsafe { umask(default_umask) };\n\n    ucmd.arg(\"-p\")\n        .arg(\"a/b/c\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert!(at.dir_exists(\"a\"));\n    // parent dirs that already exist do not get their permissions modified\n    assert_eq!(\n        at.metadata(\"a\").permissions().mode() as mode_t,\n        (!original_umask & 0o777) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b\"));\n    assert_eq!(\n        at.metadata(\"a/b\").permissions().mode() as mode_t,\n        ((!default_umask & 0o777) | 0o300) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b/c\"));\n    assert_eq!(\n        at.metadata(\"a/b/c\").permissions().mode() as mode_t,\n        (!default_umask & 0o777) + 0o40000\n    );\n\n    unsafe {\n        umask(original_umask);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::cap_two", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn cap_two() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch_with_cap(2);\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(2);\n\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&123_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&255_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n}"}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::deflate_encoder_empty_read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "test": "fn deflate_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::DeflateEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_table_create", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_table_create() {\n    let sql = r#\"CREATE TABLE IF NOT EXISTS db.table (a BIGINT, b STRING, c TIMESTAMP) PARTITIONED BY (d STRING, e TIMESTAMP) STORED AS ORC LOCATION 's3://...' TBLPROPERTIES (\"prop\" = \"2\", \"asdf\" = '1234', 'asdf' = \"1234\", \"asdf\" = 2)\"#;\n    let iof = r#\"CREATE TABLE IF NOT EXISTS db.table (a BIGINT, b STRING, c TIMESTAMP) PARTITIONED BY (d STRING, e TIMESTAMP) STORED AS INPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat' OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat' LOCATION 's3://...'\"#;\n\n    hive().verified_stmt(sql);\n    hive().verified_stmt(iof);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::efficient_storage", "code": "pub(crate) fn stats(&self) -> Result<BtreeStats> {\n        btree_stats(\n            self.get_root().map(|(p, _)| p),\n            self.mem,\n            K::fixed_width(),\n            V::fixed_width(),\n        )\n    }", "test": "fn efficient_storage() {\n    let tmpfile = create_tempfile();\n    let expected_max_size = 1024 * 1024;\n    // Write enough values that big_key.len() * entries > db_size to check that duplicate key data is not stored\n    // and entries * sizeof(u32) > page_size to validate that large numbers of values can be stored per key\n    let entries = 10000;\n    let db = Database::create(tmpfile.path()).unwrap();\n    let table_def: MultimapTableDefinition<&[u8], u32> = MultimapTableDefinition::new(\"x\");\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(table_def).unwrap();\n        let big_key = [0u8; 1000];\n        for i in 0..entries {\n            table.insert(big_key.as_slice(), &i).unwrap();\n        }\n    }\n    assert!(write_txn.stats().unwrap().stored_bytes() <= expected_max_size);\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(table_def).unwrap();\n    assert_eq!(table.len().unwrap(), entries as u64);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_select_star_except_no_parens", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_select_star_except_no_parens() {\n    clickhouse().one_statement_parses_to(\n        \"SELECT * EXCEPT prev_status FROM anomalies\",\n        \"SELECT * EXCEPT (prev_status) FROM anomalies\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_with_invalid_chars", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_tabs_with_invalid_chars() {\n    new_ucmd!()\n        .arg(\"--tabs=x\")\n        .fails()\n        .stderr_contains(\"tab size contains invalid character(s): 'x'\");\n    new_ucmd!()\n        .arg(\"--tabs=1x2\")\n        .fails()\n        .stderr_contains(\"tab size contains invalid character(s): 'x2'\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_set_time_zone_alias", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_set_time_zone_alias() {\n    match verified_stmt(\"SET TIME ZONE 'UTC'\") {\n        Statement::SetTimeZone { local, value } => {\n            assert!(!local);\n            assert_eq!(value, Expr::Value(Value::SingleQuotedString(\"UTC\".into())));\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_hyphen_value", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hyphen_value() {\n    new_ucmd!().arg(\"-abc\").succeeds().stdout_is(\"-abc\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_invalid_range", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_invalid_range() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n    let mut req = new_analyze_index_req(&product, 3, product[\"name\"].index, 4, 32, 0, 1);\n    let mut key_range = KeyRange::default();\n    key_range.set_start(b\"xxx\".to_vec());\n    key_range.set_end(b\"zzz\".to_vec());\n    req.set_ranges(vec![key_range].into());\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_other_error().is_empty());\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/status_code.rs::is_informational", "code": "fn is_informational() {\n    assert!(status_code(100).is_informational());\n    assert!(status_code(199).is_informational());\n\n    assert!(!status_code(200).is_informational());\n}", "test": "fn is_informational() {\n    assert!(status_code(100).is_informational());\n    assert!(status_code(199).is_informational());\n\n    assert!(!status_code(200).is_informational());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_read.rs::test_local_read", "code": "pub fn read(&self) -> Option<&ReadResponse> {\n        match self {\n            QueryResult::Read(r) => Some(r),\n            _ => None,\n        }\n    }", "test": "fn test_local_read() {\n    let mut cluster = Cluster::default();\n    let router = &mut cluster.routers[0];\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let region_id = 2;\n    let mut req = router.new_request_for(region_id);\n    let mut request_inner = Request::default();\n    request_inner.set_cmd_type(CmdType::Snap);\n    req.mut_requests().push(request_inner);\n\n    block_on(async { router.snapshot(req.clone()).await.unwrap() });\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    // The read index will be 0 as the retry process in the `get_snapshot` will\n    // renew the lease.\n    assert_eq!(resp.read_index, 0);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::builder_test", "code": "pub const fn get_lossy(&self) -> bool {\n        self.lossy\n    }", "test": "fn builder_test() {\n    let mut builder = OptionsBuilder::default();\n\n    builder = builder.lossy(true);\n    builder = builder.exponent(b'^');\n    builder = builder.decimal_point(b',');\n    builder = builder.nan_string(Some(b\"nan\"));\n    builder = builder.inf_string(Some(b\"Infinity\"));\n    builder = builder.infinity_string(Some(b\"Infiniiiiiity\"));\n\n    assert_eq!(builder.get_lossy(), true);\n    assert_eq!(builder.get_exponent(), b'^');\n    assert_eq!(builder.get_decimal_point(), b',');\n    assert_eq!(builder.get_nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(builder.get_inf_string(), Some(\"Infinity\".as_bytes()));\n    assert_eq!(builder.get_infinity_string(), Some(\"Infiniiiiiity\".as_bytes()));\n\n    assert!(builder.is_valid());\n    assert_eq!(builder.build(), Ok(unsafe { builder.build_unchecked() }));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::attempt_to_leave_during_malloc", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn attempt_to_leave_during_malloc() -> Result<()> {\n    let component = r#\"\n(component\n  (import \"thunk\" (func $thunk))\n  (import \"ret-string\" (func $ret_string (result string)))\n\n  (core module $host_shim\n    (table (export \"table\") 2 funcref)\n    (func $shim_thunk (export \"thunk\")\n      i32.const 0\n      call_indirect)\n    (func $shim_ret_string (export \"ret-string\") (param i32)\n      local.get 0\n      i32.const 1\n      call_indirect (param i32))\n  )\n  (core instance $host_shim (instantiate $host_shim))\n\n  (core module $m\n    (import \"host\" \"thunk\" (func $thunk))\n    (import \"host\" \"ret-string\" (func $ret_string (param i32)))\n\n    (memory (export \"memory\") 1)\n\n    (func $realloc (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n      call $thunk\n      unreachable)\n\n    (func $run (export \"run\")\n      i32.const 8\n      call $ret_string)\n\n    (func (export \"take-string\") (param i32 i32)\n        unreachable)\n  )\n  (core instance $m (instantiate $m (with \"host\" (instance $host_shim))))\n\n  (core module $host_shim_filler_inner\n    (import \"shim\" \"table\" (table 2 funcref))\n    (import \"host\" \"thunk\" (func $thunk))\n    (import \"host\" \"ret-string\" (func $ret_string (param i32)))\n    (elem (i32.const 0) $thunk $ret_string)\n  )\n\n  (core func $thunk_lower\n    (canon lower (func $thunk) (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n\n  (core func $ret_string_lower\n    (canon lower (func $ret_string) (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n\n  (core instance (instantiate $host_shim_filler_inner\n    (with \"shim\" (instance $host_shim))\n    (with \"host\" (instance\n      (export \"thunk\" (func $thunk_lower))\n      (export \"ret-string\" (func $ret_string_lower))\n    ))\n  ))\n\n  (func (export \"run\")\n    (canon lift (core func $m \"run\"))\n  )\n  (func (export \"take-string\") (param \"a\" string)\n    (canon lift (core func $m \"take-string\") (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n)\n    \"#;\n\n    let engine = super::engine();\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\"thunk\", |_, _: ()| -> Result<()> {\n        panic!(\"should not get here\")\n    })?;\n    linker\n        .root()\n        .func_wrap(\"ret-string\", |_, _: ()| -> Result<_> {\n            Ok((\"hello\".to_string(),))\n        })?;\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n\n    // Assert that during a host import if we return values to wasm that a trap\n    // happens if we try to leave the instance.\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"run\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{trap:?}\").contains(\"cannot leave component instance\"),\n        \"bad trap: {trap:?}\",\n    );\n\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 4);\n\n    // This was our entry point...\n    assert_eq!(trace[3].module().name(), Some(\"m\"));\n    assert_eq!(trace[3].func_name(), Some(\"run\"));\n\n    // ... which called an imported function which ends up being originally\n    // defined by the shim instance. The shim instance then does an indirect\n    // call through a table which goes to the `canon.lower`'d host function\n    assert_eq!(trace[2].module().name(), Some(\"host_shim\"));\n    assert_eq!(trace[2].func_name(), Some(\"shim_ret_string\"));\n\n    // ... and the lowered host function will call realloc to allocate space for\n    // the result\n    assert_eq!(trace[1].module().name(), Some(\"m\"));\n    assert_eq!(trace[1].func_name(), Some(\"realloc\"));\n\n    // ... but realloc calls the shim instance and tries to exit the\n    // component, triggering a dynamic trap\n    assert_eq!(trace[0].module().name(), Some(\"host_shim\"));\n    assert_eq!(trace[0].func_name(), Some(\"shim_thunk\"));\n\n    // In addition to the above trap also ensure that when we enter a wasm\n    // component if we try to leave while lowering then that's also a dynamic\n    // trap.\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(&str,), ()>(&mut store, \"take-string\")?\n        .call(&mut store, (\"x\",))\n        .unwrap_err();\n    assert!(\n        format!(\"{trap:?}\").contains(\"cannot leave component instance\"),\n        \"bad trap: {trap:?}\",\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_short_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_short_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_short_overwrite_file1\";\n    let new = \"test_cp_arg_update_short_overwrite_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), \"new content\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_chars() {\n    new_ucmd!()\n        .arg(\"-m\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"442\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_leader_crash", "code": "fn test_multi_leader_crash<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key1, value1) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key1, value1);\n\n    let last_leader = cluster.leader_of_region(1).unwrap();\n    cluster.stop_node(last_leader.get_store_id());\n\n    sleep_ms(800);\n    cluster.reset_leader_of_region(1);\n    let new_leader = cluster\n        .leader_of_region(1)\n        .expect(\"leader should be elected.\");\n    assert_ne!(new_leader, last_leader);\n\n    assert_eq!(cluster.get(key1), Some(value1.to_vec()));\n\n    let (key2, value2) = (b\"k2\", b\"v2\");\n\n    cluster.must_put(key2, value2);\n    cluster.must_delete(key1);\n    must_get_none(&cluster.engines[&last_leader.get_store_id()].kv, key2);\n    must_get_equal(\n        &cluster.engines[&last_leader.get_store_id()].kv,\n        key1,\n        value1,\n    );\n\n    // week up\n    cluster.run_node(last_leader.get_store_id()).unwrap();\n\n    must_get_equal(\n        &cluster.engines[&last_leader.get_store_id()].kv,\n        key2,\n        value2,\n    );\n    must_get_none(&cluster.engines[&last_leader.get_store_id()].kv, key1);\n}", "test": "fn test_multi_server_leader_crash() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_leader_crash(&mut cluster)\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_on_healthy_region", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_on_healthy_region() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(30);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 5;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(40);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    // try to enter force leader, it can't succeed due to quorum isn't lost\n    cluster.enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // make sure it leaves pre force leader state.\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 3,\n    ));\n    // put and get can propose successfully.\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    // try to exit force leader, it will be ignored silently as it's not in the\n    // force leader state\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_end_matches", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_end_matches() {\n  assert_eval_eq(\"trim_end_matches('foo', 'o')\", \"f\");\n  assert_eval_eq(\"trim_end_matches('fabab', 'ab')\", \"f\");\n  assert_eval_eq(\"trim_end_matches('fbaabab', 'ab')\", \"fba\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::r#await", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn r#await() {\n    // TODO: `let a = await fn()` is invalid syntax as of writing. It should be tested here once implemented.\n    test_formatting(\n        r#\"\n            async function f() {\n                await function_call();\n            }\n            \"#,\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_cache", "code": "pub fn get_is_cache_hit(&self) -> bool {\n        self.is_cache_hit\n    }", "test": "fn test_cache() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_cluster, raft_engine, ctx) = new_raft_engine(1, \"\");\n\n    let (_, endpoint, _) =\n        init_data_with_engine_and_commit(ctx.clone(), raft_engine, &product, &data, true);\n\n    let req = DagSelect::from(&product).build_with(ctx, &[0]);\n    let resp = handle_request(&endpoint, req.clone());\n\n    assert!(!resp.get_is_cache_hit());\n    let cache_version = resp.get_cache_last_version();\n\n    // Cache version must be >= 5 because Raft apply index must be >= 5.\n    assert!(cache_version >= 5);\n\n    // Send the request again using is_cache_enabled == false (default) and a\n    // matching version. The request should be processed as usual.\n\n    let mut req2 = req.clone();\n    req2.set_cache_if_match_version(cache_version);\n    let resp2 = handle_request(&endpoint, req2);\n\n    assert!(!resp2.get_is_cache_hit());\n    assert_eq!(\n        resp.get_cache_last_version(),\n        resp2.get_cache_last_version()\n    );\n    assert_eq!(resp.get_data(), resp2.get_data());\n\n    // Send the request again using is_cached_enabled == true and a matching\n    // version. The request should be skipped.\n\n    let mut req3 = req.clone();\n    req3.set_is_cache_enabled(true);\n    req3.set_cache_if_match_version(cache_version);\n    let resp3 = handle_request(&endpoint, req3);\n\n    assert!(resp3.get_is_cache_hit());\n    assert!(resp3.get_data().is_empty());\n\n    // Send the request using a non-matching version. The request should be\n    // processed.\n\n    let mut req4 = req;\n    req4.set_is_cache_enabled(true);\n    req4.set_cache_if_match_version(cache_version + 1);\n    let resp4 = handle_request(&endpoint, req4);\n\n    assert!(!resp4.get_is_cache_hit());\n    assert_eq!(\n        resp.get_cache_last_version(),\n        resp4.get_cache_last_version()\n    );\n    assert_eq!(resp.get_data(), resp4.get_data());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/read_consistency.rs::iterator_with_writes_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iterator_with_writes_snapshot() {\n    let db = default_engine();\n    iterator_with_writes(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_life.rs::test_destroy_by_larger_id", "code": "pub fn get_msg_type(&self) -> MessageType {\n        self.msg_type\n    }", "test": "fn test_destroy_by_larger_id() {\n    let mut cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    let test_region_id = 4;\n    let test_peer_id = 6;\n    let init_term = 5;\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(test_region_id);\n    msg.set_to_peer(new_peer(1, test_peer_id));\n    msg.mut_region_epoch().set_conf_ver(1);\n    msg.set_from_peer(new_peer(2, 8));\n    let raft_message = msg.mut_message();\n    raft_message.set_msg_type(MessageType::MsgHeartbeat);\n    raft_message.set_from(6);\n    raft_message.set_term(init_term);\n    // Create the peer.\n    router.send_raft_message(msg.clone()).unwrap();\n    // There must be heartbeat response.\n    let hb = cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    assert_eq!(\n        hb.get_message().get_msg_type(),\n        MessageType::MsgHeartbeatResponse\n    );\n\n    let timeout = Duration::from_secs(3);\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.raft_status.id, test_peer_id);\n\n    // Smaller ID should be ignored.\n    let mut smaller_id_msg = msg;\n    smaller_id_msg.set_to_peer(new_peer(1, test_peer_id - 1));\n    smaller_id_msg.mut_message().set_term(init_term + 1);\n    router.send_raft_message(smaller_id_msg.clone()).unwrap();\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.raft_status.id, test_peer_id);\n    assert_eq!(meta.raft_status.hard_state.term, init_term);\n    cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap_err();\n\n    // Smaller ID tombstone message should trigger report.\n    let mut smaller_id_tombstone_msg = smaller_id_msg.clone();\n    smaller_id_tombstone_msg.set_is_tombstone(true);\n    router.send_raft_message(smaller_id_tombstone_msg).unwrap();\n    let report = cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    assert_valid_report(&report, test_region_id, test_peer_id - 1);\n\n    // Larger ID should trigger destroy.\n    let mut larger_id_msg = smaller_id_msg;\n    larger_id_msg.set_to_peer(new_peer(1, test_peer_id + 1));\n    router.send_raft_message(larger_id_msg).unwrap();\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.raft_status.id, test_peer_id + 1);\n    assert_eq!(meta.raft_status.hard_state.term, init_term + 1);\n\n    // New peer should survive restart.\n    cluster.restart(0);\n    let router = &cluster.routers[0];\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.raft_status.id, test_peer_id + 1);\n    assert_eq!(meta.raft_status.hard_state.term, init_term + 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_zero_terminated_negative_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_zero_terminated_negative_lines() {\n    new_ucmd!()\n        .args(&[\"-z\", \"-n\", \"-1\"])\n        .pipe_in(\"x\\0y\\0z\\0\")\n        .run()\n        .stdout_is(\"x\\0y\\0\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query_nonet", "code": "fn block_on<F: Future>(&mut self, future: F) -> F::Output {\n        async_std::task::block_on(future)\n    }", "test": "fn test_query_nonet() {\n    // env_logger::init();\n\n    let authority = create_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let client = AsyncClient::new(stream, sender, None);\n    let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    io_loop.block_on(test_query(&mut client));\n    io_loop.block_on(test_query(&mut client));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_lines_number", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_split_lines_number() {\n    // Test if stdout/stderr for '--lines' option is correct\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"2\", \"file\"])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"0\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: invalid number of lines: 0\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-0\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: invalid number of lines: 0\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"2fb\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: invalid number of lines: '2fb'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: invalid number of lines: 'file'\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_read_index_stale_in_suspect_lease", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_read_index_stale_in_suspect_lease() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    // Increase the election tick to make this test case running reliably.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    let max_lease = Duration::from_secs(2);\n    // Stop log compaction to transfer leader with filter easier.\n    configure_for_request_snapshot(&mut cluster);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n\n    cluster.pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let r1 = cluster.get_region(b\"k1\");\n    // Put and test again to ensure that peer 3 get the latest writes by message\n    // append instead of snapshot, so that transfer leader to peer 3 can 100%\n    // success.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n    // Ensure peer 3 is ready to become leader.\n    let resp_ch = async_read_on_peer(&mut cluster, new_peer(3, 3), r1.clone(), b\"k2\", true, true);\n    let resp = block_on_timeout(resp_ch, Duration::from_secs(3)).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    assert_eq!(\n        resp.get_responses()[0].get_get().get_value(),\n        b\"v2\",\n        \"{:?}\",\n        resp\n    );\n    let old_leader = cluster.leader_of_region(r1.get_id()).unwrap();\n\n    // Use a macro instead of a closure to avoid any capture of local variables.\n    macro_rules! read_on_old_leader {\n        () => {{\n            let (tx, rx) = mpsc::sync_channel(1);\n            let mut read_request = new_request(\n                r1.get_id(),\n                r1.get_region_epoch().clone(),\n                vec![new_get_cmd(b\"k1\")],\n                true, // read quorum\n            );\n            read_request.mut_header().set_peer(new_peer(1, 1));\n            let sim = cluster.sim.wl();\n            sim.async_command_on_node(\n                old_leader.get_id(),\n                read_request,\n                Callback::read(Box::new(move |resp| tx.send(resp.response).unwrap())),\n            )\n            .unwrap();\n            rx\n        }};\n    }\n\n    // Delay all raft messages to peer 1.\n    let dropped_msgs = Arc::new(Mutex::new(Vec::new()));\n    let filter = Box::new(\n        RegionPacketFilter::new(r1.id, old_leader.store_id)\n            .direction(Direction::Recv)\n            .skip(MessageType::MsgTransferLeader)\n            .reserve_dropped(Arc::clone(&dropped_msgs)),\n    );\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(old_leader.get_id(), filter);\n\n    let resp1 = read_on_old_leader!();\n\n    cluster.must_transfer_leader(r1.get_id(), new_peer(3, 3));\n\n    let resp2 = read_on_old_leader!();\n\n    // Unpark all pending messages and clear all filters.\n    let router = cluster.sim.wl().get_router(old_leader.get_id()).unwrap();\n    'LOOP: loop {\n        for raft_msg in mem::take::<Vec<_>>(dropped_msgs.lock().unwrap().as_mut()) {\n            let msg_type = raft_msg.get_message().get_msg_type();\n            if msg_type == MessageType::MsgHeartbeatResponse {\n                router.send_raft_message(raft_msg).unwrap();\n                continue;\n            }\n            cluster.sim.wl().clear_recv_filters(old_leader.get_id());\n            break 'LOOP;\n        }\n    }\n\n    let resp1 = resp1.recv().unwrap();\n    assert!(\n        resp1.get_header().get_error().has_stale_command()\n            || resp1.get_responses()[0].get_get().get_value() == b\"v1\"\n    );\n\n    // Response 2 should contains an error.\n    let resp2 = resp2.recv().unwrap();\n    assert!(resp2.get_header().get_error().has_stale_command());\n    drop(cluster);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_byte_buf_de_multiple", "code": "pub fn to_vec<T>(value: &T) -> Result<Vec<u8>>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut writer = Vec::with_capacity(128);\n    tri!(to_writer(&mut writer, value));\n    Ok(writer)\n}", "test": "fn test_byte_buf_de_multiple() {\n    let s: Vec<ByteBuf> = from_str(r#\"[\"ab\\nc\", \"cd\\ne\"]\"#).unwrap();\n    let a = ByteBuf::from(b\"ab\\nc\".to_vec());\n    let b = ByteBuf::from(b\"cd\\ne\".to_vec());\n    assert_eq!(vec![a, b], s);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_stdin_larger_than_128_bytes", "code": "fn next(&mut self) -> Option<Self::Item> {\n        if self.first_iteration {\n            self.first_iteration = false;\n        } else {\n            self.number.increment().ok()?;\n        }\n        // The first and third parts are just taken directly from the\n        // struct parameters unchanged.\n        Some(format!(\n            \"{}{}{}\",\n            self.prefix, self.number, self.additional_suffix\n        ))\n    }", "test": "fn test_stdin_larger_than_128_bytes() {\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    let result = ucmd.arg(\"larger_than_2056_bytes.txt\").succeeds();\n\n    let mut stdout_split = result.stdout_str().split(' ');\n\n    let cksum: i64 = stdout_split.next().unwrap().parse().unwrap();\n    let bytes_cnt: i64 = stdout_split.next().unwrap().parse().unwrap();\n\n    assert_eq!(cksum, 945_881_979);\n    assert_eq!(bytes_cnt, 2058);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_force() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_force_a\";\n    let file_b = \"test_rm_force_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    ucmd.arg(\"-f\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/no_cd.rs::shebang", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn shebang() {\n  Test::new()\n    .justfile(\n      \"\n      [no-cd]\n      foo:\n        #!/bin/sh\n        cat bar\n    \",\n    )\n    .current_dir(\"foo\")\n    .tree(tree! {\n      foo: {\n        bar: \"hello\",\n      }\n    })\n    .stdout(\"hello\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_pseudofloat_not_equal", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_pseudofloat_not_equal() {\n    // string comparison; test(1) doesn't support comparison of actual floats\n    new_ucmd!().args(&[\"123.45\", \"!=\", \"123.450\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_multiple", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_force_multiple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_force_a\";\n    let file_b = \"test_rm_force_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    ucmd.arg(\"-f\")\n        .arg(\"-f\")\n        .arg(\"-f\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_cast_time_format", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_cast_time_format() {\n    let sql = r\"SELECT CAST(TIME '21:30:00' AS STRING FORMAT 'PM') AS date_time_to_string\";\n    bigquery_and_generic().verified_only_select(sql);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::map_access", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn map_access() {\n    let rename = r#\"SELECT a.b[\"asdf\"] FROM db.table WHERE a = 2\"#;\n    hive().verified_stmt(rename);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601_hour", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_8601_hour() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}[+-]\\d{2}:\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!()\n            .arg(format!(\"{param}=hour\"))\n            .succeeds()\n            .stdout_matches(&re);\n        new_ucmd!()\n            .arg(format!(\"{param}=hours\"))\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::no_actual_wasm_code", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn no_actual_wasm_code() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"f\" (func $f))\n\n            (core func $f_lower\n                (canon lower (func $f))\n            )\n            (core module $m\n                (import \"\" \"\" (func $f))\n                (export \"f\" (func $f))\n            )\n            (core instance $i (instantiate $m\n                (with \"\" (instance\n                    (export \"\" (func $f_lower))\n                ))\n            ))\n            (func (export \"thunk\")\n                (canon lift\n                    (core func $i \"f\")\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"f\",\n        |mut store: StoreContextMut<'_, u32>, _: ()| -> Result<()> {\n            *store.data_mut() += 1;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_typed_func::<(), ()>(&mut store, \"thunk\")?;\n\n    assert_eq!(*store.data(), 0);\n    thunk.call(&mut store, ())?;\n    assert_eq!(*store.data(), 1);\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = 0;\n    let mut linker = Linker::new(&engine);\n    linker.root().func_new(\n        &component,\n        \"f\",\n        |mut store: StoreContextMut<'_, u32>, _, _| {\n            *store.data_mut() += 1;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_func(&mut store, \"thunk\").unwrap();\n\n    assert_eq!(*store.data(), 0);\n    thunk.call(&mut store, &[], &mut [])?;\n    assert_eq!(*store.data(), 1);\n\n    Ok(())\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::fallback_from_subdir_verbose_message", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn fallback_from_subdir_verbose_message() {\n  Test::new()\n    .justfile(\"bar:\\n echo bar\")\n    .write(\n      \"sub/justfile\",\n      unindent(\n        \"\n        set fallback\n\n        @foo:\n          echo foo\n      \",\n      ),\n    )\n    .args([\"--verbose\", \"sub/bar\"])\n    .stderr(path(\n      \"\n      Trying ../justfile\n      ===> Running recipe `bar`...\n      echo bar\n      \",\n    ))\n    .stdout(\"bar\\n\")\n    .run();\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_resize", "code": "pub fn resize(&mut self, new_len: usize, new_val: A::Item)\n  where\n    A::Item: Clone,\n  {\n    self.resize_with(new_len, || new_val.clone())\n  }", "test": "fn TinyVec_resize() {\n  let mut tv: TinyVec<[i32; 10]> = Default::default();\n  tv.resize(20, 5);\n  assert_eq!(&tv[..], &[5; 20]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_unique_ints", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_unique_ints() {\n    test_helper(\"numeric_unsorted_ints_unique\", &[\"-nu\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/snapshot_basic.rs::snapshot_get_value_cf_after_put", "code": "fn get_value_cf(&self, cf: &str, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_cf_opt(&ReadOptions::default(), cf, key)\n    }", "test": "fn snapshot_get_value_cf_after_put() {\n    let db = engine_cfs(ALL_CFS);\n\n    db.engine.put_cf(CF_WRITE, b\"a\", b\"aa\").unwrap();\n\n    let snap = db.engine.snapshot();\n\n    db.engine.put_cf(CF_WRITE, b\"a\", b\"aaa\").unwrap();\n\n    let value = snap.get_value_cf(CF_WRITE, b\"a\").unwrap();\n    let value = value.unwrap();\n    assert_eq!(value, b\"aa\");\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_index", "code": "pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.locations();\n        self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n            text: text,\n            locs: locs,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }", "test": "fn capture_index() {\n    let re = regex!(r\"^(?P<name>.+)$\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n    assert_eq!(&cap[0], t!(\"abc\"));\n    assert_eq!(&cap[1], t!(\"abc\"));\n    assert_eq!(&cap[\"name\"], t!(\"abc\"));\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_wasi_works", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn run_wasi_works() {\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::qjs())\n        .arg(\"--\")\n        .arg(\"-e\")\n        .arg(\"print(3 * (4 + 5))\")\n        .assert()\n        .success();\n\n    assert.stdout(\"27\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_not_and_not_succeeds", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_not_and_not_succeeds() {\n    new_ucmd!().args(&[\"!\", \"-a\", \"!\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_gnu_invalid_mode", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_gnu_invalid_mode() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n    scene.ucmd().arg(\"u+gr\").arg(\"file\").fails();\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic.rs::expr_test", "code": "fn expr(input: &[u8]) -> IResult<&[u8], i64> {\n  let (input, init) = term(input)?;\n  fold_many0(\n    pair(one_of(\"+-\"), term),\n    move || init,\n    |acc, (op, val)| {\n      if op == '+' {\n        acc + val\n      } else {\n        acc - val\n      }\n    },\n  )(input)\n}", "test": "fn expr_test() {\n  assert_eq!(expr(\" 1 +  2 \"), Ok((\"\", 3)));\n  assert_eq!(expr(\" 12 + 6 - 4+  3\"), Ok((\"\", 17)));\n  assert_eq!(expr(\" 1 + 2*3 + 4\"), Ok((\"\", 11)));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_closes_uncleanly", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn client_closes_uncleanly() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that unclean EOF reporting does not overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        transfer(&mut client, &mut server);\n        transfer_eof(&mut server);\n        let io_state = server.process_new_packets().unwrap();\n        assert!(!io_state.peer_has_closed());\n        check_read(&mut server.reader(), b\"from-client!\");\n\n        check_read_err(\n            &mut server.reader() as &mut dyn io::Read,\n            io::ErrorKind::UnexpectedEof,\n        );\n\n        // may still transmit pending frames\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        check_read(&mut client.reader(), b\"from-server!\");\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_wasmtime_simple_fail_no_args", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "test": "fn run_wasmtime_simple_fail_no_args() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/simple.wat\")?;\n    assert!(\n        run_wasmtime(&[\n            \"run\",\n            \"-Ccache=n\",\n            \"--invoke\",\n            \"simple\",\n            wasm.path().to_str().unwrap(),\n        ])\n        .is_err(),\n        \"shall fail\"\n    );\n    Ok(())\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::no_true_case_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn no_true_case_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            switch (a) {\n                case 5:\n                    a = 15;\n                    break;\n            }\n\n            a;\n        \"#},\n        10,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_precedence_of_block_size_arg_over_env", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "test": "fn test_precedence_of_block_size_arg_over_env() {\n    let output = new_ucmd!()\n        .args(&[\"-B\", \"999\", \"--output=size\"])\n        .env(\"DF_BLOCK_SIZE\", \"111\")\n        .succeeds()\n        .stdout_move_str();\n    let header = output.lines().next().unwrap().trim().to_string();\n\n    assert_eq!(header, \"999B-blocks\");\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_attribute_equal", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn test_attribute_equal() {\n    let src = \"<a att1=\\\"a=b\\\"/>\";\n    let mut r = Reader::from_str(src);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Empty(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"att1\"),\n                    value: Cow::Borrowed(b\"a=b\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        e => panic!(\"Expecting Empty event, got {:?}\", e),\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::string_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn string_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = \"hello\";\n\n            switch (a) {\n                case \"hello\":\n                    a = \"world\";\n                    break;\n                default:\n                    a = \"hi\";\n            }\n\n            a;\n        \"#},\n        \"world\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_x_multiplier", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_x_multiplier() {\n    // \"2x3\" means 2 * 3, which is 6.\n    new_ucmd!()\n        .args(&[\"bs=2x3\", \"count=1\"])\n        .pipe_in(\"abcdefghi\")\n        .succeeds()\n        .stdout_is(\"abcdef\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake_eof", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn server_complete_io_for_handshake_eof() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    let mut input = io::Cursor::new(Vec::new());\n\n    assert!(server.is_handshaking());\n    let err = server\n        .complete_io(&mut input)\n        .unwrap_err();\n    assert_eq!(io::ErrorKind::UnexpectedEof, err.kind());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_failed", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_rm_failed() {\n    let (_at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_rm_one_file\"; // Doesn't exist\n\n    ucmd.arg(file).fails().stderr_contains(&format!(\n        \"cannot remove '{file}': No such file or directory\"\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_strip_trailing_slashes", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_strip_trailing_slashes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    //using --strip-trailing-slashes option\n    ucmd.arg(\"--strip-trailing-slashes\")\n        .arg(format!(\"{TEST_HELLO_WORLD_SOURCE}/\"))\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_HELLO_WORLD_DEST), \"Hello, World!\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_show_nonprinting", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_show_nonprinting() {\n    for same_param in [\"-v\", \"--show-nonprinting\", \"--show-non\"] {\n        new_ucmd!()\n            .args(&[same_param])\n            .pipe_in(\"\\t\\0\\n\")\n            .succeeds()\n            .stdout_only(\"\\t^@\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_offset_option_suppress_matched", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_offset_option_suppress_matched() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"--suppress-matched\", \"/10/+4\"])\n        .succeeds()\n        .stdout_only(\"27\\n111\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10) + &generate(11, 14));\n    assert_eq!(at.read(\"xx01\"), generate(14, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_preserve_no_args_before_opts", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_cp_preserve_no_args_before_opts() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let src_file = \"a\";\n    let dst_file = \"b\";\n\n    // Prepare the source file\n    at.touch(src_file);\n    #[cfg(unix)]\n    at.set_mode(src_file, 0o0500);\n\n    // Copy\n    ucmd.arg(\"--preserve\")\n        .arg(src_file)\n        .arg(dst_file)\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        // Assert that the mode, ownership, and timestamps are preserved\n        // NOTICE: the ownership is not modified on the src file, because that requires root permissions\n        let metadata_src = at.metadata(src_file);\n        let metadata_dst = at.metadata(dst_file);\n        assert_metadata_eq!(metadata_src, metadata_dst);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_width", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fmt_width() {\n    for param in [\"-w\", \"--width\"] {\n        new_ucmd!()\n            .args(&[\"one-word-per-line.txt\", param, \"10\"])\n            .succeeds()\n            .stdout_is(\"this is\\na file\\nwith one\\nword per\\nline\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source = \"create_leading_test_file\";\n    let target = \"dir1/dir2/dir3/test_file\";\n\n    at.touch(source);\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source)\n        .arg(at.plus(target))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(target));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_long_redirection_to_current_dir", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_realpath_long_redirection_to_current_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    // Create a 256-character path to current directory\n    let dir = path_concat!(\".\", ..128);\n    let expect = at.root_dir_resolved() + \"\\n\";\n    ucmd.arg(dir).succeeds().stdout_is(expect);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer_key", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_integer_key() {\n    // map with integer keys\n    let map = treemap!(\n        1 => 2,\n        -1 => 6,\n    );\n    let j = r#\"{\"-1\":6,\"1\":2}\"#;\n    test_encode_ok(&[(&map, j)]);\n    test_parse_ok(vec![(j, map)]);\n\n    test_parse_err::<BTreeMap<i32, ()>>(&[\n        (\n            r#\"{\"x\":null}\"#,\n            \"invalid value: expected key to be a number in quotes at line 1 column 2\",\n        ),\n        (\n            r#\"{\" 123\":null}\"#,\n            \"invalid value: expected key to be a number in quotes at line 1 column 2\",\n        ),\n        (r#\"{\"123 \":null}\"#, \"expected `\\\"` at line 1 column 6\"),\n    ]);\n\n    let err = from_value::<BTreeMap<i32, ()>>(json!({\" 123\":null})).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"invalid value: expected key to be a number in quotes\",\n    );\n\n    let err = from_value::<BTreeMap<i32, ()>>(json!({\"123 \":null})).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"invalid value: expected key to be a number in quotes\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_literal", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_date_format_literal() {\n    new_ucmd!().arg(\"+%%s\").succeeds().stdout_is(\"%s\\n\");\n    new_ucmd!().arg(\"+%%N\").succeeds().stdout_is(\"%N\\n\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_u128_max", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_u128_max() {\n    assert_eq!(\n        std::u128::MAX,\n        from_str(&to_string(&std::u128::MAX).unwrap()).unwrap()\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_start_match", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_start_match() {\n  assert_eval_eq(\"trim_start_match('oof', 'o')\", \"of\");\n  assert_eval_eq(\"trim_start_match('ababf', 'ab')\", \"abf\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pwd.rs::test_symlinked_default_posix", "code": "fn clone<P>(source: P, dest: P, fallback: CloneFallback) -> std::io::Result<()>\nwhere\n    P: AsRef<Path>,\n{\n    let src_file = File::open(&source)?;\n    let dst_file = File::create(&dest)?;\n    let src_fd = src_file.as_raw_fd();\n    let dst_fd = dst_file.as_raw_fd();\n    let result = unsafe { libc::ioctl(dst_fd, FICLONE!(), src_fd) };\n    if result == 0 {\n        return Ok(());\n    }\n    match fallback {\n        CloneFallback::Error => Err(std::io::Error::last_os_error()),\n        CloneFallback::FSCopy => std::fs::copy(source, dest).map(|_| ()),\n    }\n}", "test": "fn test_symlinked_default_posix() {\n    let mut env = symlinked_env();\n    env.ucmd\n        .env(\"POSIXLY_CORRECT\", \"1\")\n        .succeeds()\n        .stdout_is(env.symdir.clone() + \"\\n\");\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/snapshots.rs::convert_glsl_variations_check", "code": "fn check_targets(\n    input: &Input,\n    module: &mut naga::Module,\n    targets: Targets,\n    source_code: Option<&str>,\n) {\n    let params = input.read_parameters();\n    let name = &input.file_name;\n\n    let capabilities = if params.god_mode {\n        naga::valid::Capabilities::all()\n    } else {\n        naga::valid::Capabilities::default()\n    };\n\n    #[cfg(feature = \"serialize\")]\n    {\n        if targets.contains(Targets::IR) {\n            let config = ron::ser::PrettyConfig::default().new_line(\"\\n\".to_string());\n            let string = ron::ser::to_string_pretty(module, config).unwrap();\n            input.write_output_file(\"ir\", \"ron\", string);\n        }\n    }\n\n    let info = naga::valid::Validator::new(naga::valid::ValidationFlags::all(), capabilities)\n        .validate(module)\n        .expect(&format!(\n            \"Naga module validation failed on test '{}'\",\n            name.display()\n        ));\n\n    #[cfg(feature = \"compact\")]\n    let info = {\n        naga::compact::compact(module);\n\n        #[cfg(feature = \"serialize\")]\n        {\n            if targets.contains(Targets::IR) {\n                let config = ron::ser::PrettyConfig::default().new_line(\"\\n\".to_string());\n                let string = ron::ser::to_string_pretty(module, config).unwrap();\n                input.write_output_file(\"ir\", \"compact.ron\", string);\n            }\n        }\n\n        naga::valid::Validator::new(naga::valid::ValidationFlags::all(), capabilities)\n            .validate(module)\n            .expect(&format!(\n                \"Post-compaction module validation failed on test '{}'\",\n                name.display()\n            ))\n    };\n\n    #[cfg(feature = \"serialize\")]\n    {\n        if targets.contains(Targets::ANALYSIS) {\n            let config = ron::ser::PrettyConfig::default().new_line(\"\\n\".to_string());\n            let string = ron::ser::to_string_pretty(&info, config).unwrap();\n            input.write_output_file(\"analysis\", \"info.ron\", string);\n        }\n    }\n\n    #[cfg(all(feature = \"deserialize\", feature = \"spv-out\"))]\n    {\n        let debug_info = if cfg!(feature = \"span\") {\n            source_code.map(|code| naga::back::spv::DebugInfo {\n                source_code: code,\n                file_name: name.as_ref(),\n            })\n        } else {\n            None\n        };\n\n        if targets.contains(Targets::SPIRV) {\n            write_output_spv(\n                input,\n                module,\n                &info,\n                debug_info,\n                &params.spv,\n                params.bounds_check_policies,\n            );\n        }\n    }\n    #[cfg(all(feature = \"deserialize\", feature = \"msl-out\"))]\n    {\n        if targets.contains(Targets::METAL) {\n            write_output_msl(\n                input,\n                module,\n                &info,\n                &params.msl,\n                &params.msl_pipeline,\n                params.bounds_check_policies,\n            );\n        }\n    }\n    #[cfg(all(feature = \"deserialize\", feature = \"glsl-out\"))]\n    {\n        if targets.contains(Targets::GLSL) {\n            for ep in module.entry_points.iter() {\n                if params.glsl_exclude_list.contains(&ep.name) {\n                    continue;\n                }\n                write_output_glsl(\n                    input,\n                    module,\n                    &info,\n                    ep.stage,\n                    &ep.name,\n                    &params.glsl,\n                    params.bounds_check_policies,\n                    params.glsl_multiview,\n                );\n            }\n        }\n    }\n    #[cfg(feature = \"dot-out\")]\n    {\n        if targets.contains(Targets::DOT) {\n            let string = naga::back::dot::write(module, Some(&info), Default::default()).unwrap();\n            input.write_output_file(\"dot\", \"dot\", string);\n        }\n    }\n    #[cfg(all(feature = \"deserialize\", feature = \"hlsl-out\"))]\n    {\n        if targets.contains(Targets::HLSL) {\n            write_output_hlsl(input, module, &info, &params.hlsl);\n        }\n    }\n    #[cfg(all(feature = \"deserialize\", feature = \"wgsl-out\"))]\n    {\n        if targets.contains(Targets::WGSL) {\n            write_output_wgsl(input, module, &info, &params.wgsl);\n        }\n    }\n}", "test": "fn convert_glsl_variations_check() {\n    let input = Input::new(None, \"variations\", \"glsl\");\n    let source = input.read_source();\n    let mut parser = naga::front::glsl::Frontend::default();\n    let mut module = parser\n        .parse(\n            &naga::front::glsl::Options {\n                stage: naga::ShaderStage::Fragment,\n                defines: Default::default(),\n            },\n            &source,\n        )\n        .unwrap();\n    check_targets(&input, &mut module, Targets::GLSL, None);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_failed_merge_before_succeed_merge", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_failed_merge_before_succeed_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.merge_max_log_gap = 30;\n    cluster.cfg.raft_store.store_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k5\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let mut right = pd_client.get_region(b\"k5\").unwrap();\n    let left_peer_1 = find_peer(&left, 1).cloned().unwrap();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1);\n\n    let left_peer_3 = find_peer(&left, 3).cloned().unwrap();\n    assert_eq!(left_peer_3.get_id(), 1003);\n\n    // Prevent sched_merge_tick to propose CommitMerge\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return\").unwrap();\n\n    // To minimize peers log gap for merging\n    cluster.must_put(b\"k11\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k11\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v2\");\n    // Make peer 1003 can't receive PrepareMerge and RollbackMerge log\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n\n    // Change right region's epoch to make this merge failed\n    cluster.must_split(&right, b\"k8\");\n    fail::remove(schedule_merge_fp);\n    // Wait for left region to rollback merge\n    cluster.must_put(b\"k12\", b\"v2\");\n    // Prevent apply fsm applying the `PrepareMerge` and `RollbackMerge` log after\n    // cleaning send filter.\n    let before_handle_normal_1003_fp = \"before_handle_normal_1003\";\n    fail::cfg(before_handle_normal_1003_fp, \"return\").unwrap();\n    cluster.clear_send_filters();\n\n    right = pd_client.get_region(b\"k5\").unwrap();\n    let right_peer_1 = find_peer(&right, 1).cloned().unwrap();\n    cluster.must_transfer_leader(right.get_id(), right_peer_1);\n    // Add some data for checking data integrity check at a later time\n    for i in 0..5 {\n        cluster.must_put(format!(\"k2{}\", i).as_bytes(), b\"v3\");\n    }\n    // Do a really succeed merge\n    pd_client.must_merge(left.get_id(), right.get_id());\n    // Wait right region to send CatchUpLogs to left region.\n    sleep_ms(100);\n    // After executing CatchUpLogs in source peer fsm, the committed log will send\n    // to apply fsm in the end of this batch. So even the first\n    // `on_ready_prepare_merge` is executed after CatchUplogs, the latter\n    // committed logs is still sent to apply fsm if CatchUpLogs and\n    // `on_ready_prepare_merge` is in different batch.\n    //\n    // In this case, the data is complete because the wrong up-to-date msg from the\n    // first `on_ready_prepare_merge` is sent after all committed log.\n    // Sleep a while to wait apply fsm to send `on_ready_prepare_merge` to peer fsm.\n    let after_send_to_apply_1003_fp = \"after_send_to_apply_1003\";\n    fail::cfg(after_send_to_apply_1003_fp, \"sleep(300)\").unwrap();\n\n    fail::remove(before_handle_normal_1003_fp);\n    // Wait `after_send_to_apply_1003` timeout\n    sleep_ms(300);\n    fail::remove(after_send_to_apply_1003_fp);\n    // Check the data integrity\n    for i in 0..5 {\n        must_get_equal(&cluster.get_engine(3), format!(\"k2{}\", i).as_bytes(), b\"v3\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_whoami.rs::test_normal_compare_env", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_normal_compare_env() {\n    let whoami = whoami();\n    if whoami == \"nobody\" {\n        println!(\"test skipped:\");\n    } else if !is_ci() {\n        new_ucmd!().succeeds().stdout_is(format!(\"{whoami}\\n\"));\n    } else {\n        println!(\"test skipped:\");\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_can_get_client_cert", "code": "fn get_client_chain(&self) -> Vec<rustls::Certificate> {\n        rustls_pemfile::certs(&mut io::BufReader::new(\n            fs::File::open(self.path_for(\"client.fullchain\")).unwrap(),\n        ))\n        .unwrap()\n        .iter()\n        .map(|v| rustls::Certificate(v.clone()))\n        .collect()\n    }", "test": "fn server_can_get_client_cert() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            do_handshake(&mut client, &mut server);\n\n            let certs = server.peer_certificates();\n            assert_eq!(certs, Some(kt.get_client_chain().as_slice()));\n        }\n    }\n}"}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/write.rs::write_flush_behaviour", "code": "pub fn get_ref(&self) -> &Stream {\n        &self.stream\n    }", "test": "fn write_flush_behaviour() {\n    const SEND_ME_LEN: usize = 10;\n    const BATCH_ME_LEN: usize = 11;\n    const WRITE_BUFFER_SIZE: usize = 600;\n\n    let mut ws = WebSocket::from_raw_socket(\n        MockWrite::default(),\n        tungstenite::protocol::Role::Server,\n        Some(WebSocketConfig { write_buffer_size: WRITE_BUFFER_SIZE, ..<_>::default() }),\n    );\n\n    assert_eq!(ws.get_ref().written_bytes, 0);\n    assert_eq!(ws.get_ref().write_count, 0);\n    assert_eq!(ws.get_ref().flush_count, 0);\n\n    // `send` writes & flushes immediately\n    ws.send(Message::Text(\"Send me!\".into())).unwrap();\n    assert_eq!(ws.get_ref().written_bytes, SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 1);\n    assert_eq!(ws.get_ref().flush_count, 1);\n\n    // send a batch of messages\n    for msg in (0..100).map(|_| Message::Text(\"Batch me!\".into())) {\n        ws.write(msg).unwrap();\n    }\n    // after 55 writes the out_buffer will exceed write_buffer_size=600\n    // and so do a single underlying write (not flushing).\n    assert_eq!(ws.get_ref().written_bytes, 55 * BATCH_ME_LEN + SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 2);\n    assert_eq!(ws.get_ref().flush_count, 1);\n\n    // flushing will perform a single write for the remaining out_buffer & flush.\n    ws.flush().unwrap();\n    assert_eq!(ws.get_ref().written_bytes, 100 * BATCH_ME_LEN + SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 3);\n    assert_eq!(ws.get_ref().flush_count, 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_strip_slashes", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_strip_slashes() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_strip_slashes_dir\";\n    let file = \"test_mv_strip_slashes_file\";\n    let mut source = file.to_owned();\n    source.push('/');\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    scene.ucmd().arg(&source).arg(dir).fails();\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n\n    scene\n        .ucmd()\n        .arg(\"--strip-trailing-slashes\")\n        .arg(source)\n        .arg(dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_suppress_error_option", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_with_suppress_error_option() {\n    let test_file_path = \"test_num_page.log\";\n    let mut scenario = new_ucmd!();\n    scenario\n        .args(&[\"--pages=20:5\", \"-r\", test_file_path])\n        .fails()\n        .stderr_is(\"\")\n        .stdout_is(\"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_number_width_zero", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_number_width_zero() {\n    for arg in [\"-w0\", \"--number-width=0\"] {\n        new_ucmd!()\n            .arg(arg)\n            .fails()\n            .stderr_contains(\"Invalid line number field width: \u20180\u2019: Numerical result out of range\");\n    }\n}\n\n#["}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_no_match7", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_no_match7() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/+5\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/nope/+5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/+5\", \"-k\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/nope/+5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_transfer_leader.rs::test_transfer_leader", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_transfer_leader() {\n    let mut cluster = Cluster::with_node_count(3, None);\n    let region_id = 2;\n    let router0 = &cluster.routers[0];\n\n    let mut req = router0.new_request_for(region_id);\n    let admin_req = req.mut_admin_request();\n    admin_req.set_cmd_type(AdminCmdType::ChangePeer);\n    admin_req\n        .mut_change_peer()\n        .set_change_type(ConfChangeType::AddNode);\n    let store_id = cluster.node(1).id();\n    let peer1 = new_peer(store_id, 10);\n    admin_req.mut_change_peer().set_peer(peer1.clone());\n    let req_clone = req.clone();\n    let resp = router0.admin_command(region_id, req_clone).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    let epoch = req.get_header().get_region_epoch();\n    let new_conf_ver = epoch.get_conf_ver() + 1;\n    let leader_peer = req.get_header().get_peer().clone();\n    let meta = router0\n        .must_query_debug_info(region_id, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(meta.region_state.epoch.version, epoch.get_version());\n    assert_eq!(meta.region_state.epoch.conf_ver, new_conf_ver);\n    assert_eq!(meta.region_state.peers, vec![leader_peer, peer1.clone()]);\n    let peer0_id = meta.raft_status.id;\n\n    // So heartbeat will create a learner.\n    cluster.dispatch(region_id, vec![]);\n    let router1 = &cluster.routers[1];\n    let meta = router1\n        .must_query_debug_info(region_id, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(peer0_id, meta.raft_status.soft_state.leader_id);\n    assert_eq!(meta.raft_status.id, peer1.id, \"{:?}\", meta);\n    assert_eq!(meta.region_state.epoch.version, epoch.get_version());\n    assert_eq!(meta.region_state.epoch.conf_ver, new_conf_ver);\n    cluster.dispatch(region_id, vec![]);\n\n    // Ensure follower has latest entries before transfer leader.\n    put_data(region_id, &mut cluster, 0, 1, b\"key1\");\n\n    // Perform transfer leader\n    must_transfer_leader(&cluster, region_id, 0, 1, peer1);\n\n    // Before transfer back to peer0, put some data again.\n    put_data(region_id, &mut cluster, 1, 0, b\"key2\");\n\n    // Perform transfer leader\n    let store_id = cluster.node(0).id();\n    must_transfer_leader(&cluster, region_id, 1, 0, new_peer(store_id, peer0_id));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_server_pending_peers", "code": "fn test_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n\n    let region_worker_fp = \"region_apply_snap\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let region_id = cluster.run_conf_change();\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n\n    // To ensure peer 2 is not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n\n    fail::cfg(region_worker_fp, \"sleep(2000)\").unwrap();\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    sleep_ms(1000);\n    let pending_peers = pd_client.get_pending_peers();\n    // Region worker is not started, snapshot should not be applied yet.\n    assert_eq!(pending_peers[&3], new_peer(3, 3));\n    // But it will be applied finally.\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    sleep_ms(100);\n    let pending_peers = pd_client.get_pending_peers();\n    assert!(pending_peers.is_empty());\n}", "test": "fn test_server_pending_peers() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_pending_peers(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_empty_file", "code": "pub fn normalized_newlines_stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        let msg = msg.as_ref().replace(\"\\r\\n\", \"\\n\");\n        assert_eq!(self.stdout_str().replace(\"\\r\\n\", \"\\n\"), msg);\n        self\n    }", "test": "fn test_empty_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.touch(\"a\");\n\n    ucmd.arg(\"a\")\n        .succeeds()\n        .no_stderr()\n        .normalized_newlines_stdout_is(\"4294967295 0 a\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_binding_finally", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch_binding_finally() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw 20;\n            } catch(err) {\n                a = err;\n            } finally {\n                a = 30;\n            }\n\n            a;\n        \"#},\n        30,\n    )]);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/config.rs::c_flags", "code": "fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        }", "test": "fn c_flags() {\n    let temp = setup_wasmer_dir();\n    let wasmer_dir = temp.path();\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--bindir\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"bin\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--cflags\")\n        .assert()\n        .success()\n        .stdout(contains(format!(\n            \"-I{}\\n\",\n            wasmer_dir.join(\"include\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--includedir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"include\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libdir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"lib\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libs\")\n        .assert()\n        .stdout(contains(format!(\n            \"-L{} -lwasmer\\n\",\n            wasmer_dir.join(\"lib\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--prefix\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir));\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--pkg-config\")\n        .output()\n        .unwrap();\n\n    let pkg_config = vec![\n        format!(\"prefix={}\", wasmer_dir.display()),\n        format!(\"exec_prefix={}\", wasmer_dir.join(\"bin\").display()),\n        format!(\"includedir={}\", wasmer_dir.join(\"include\").display()),\n        format!(\"libdir={}\", wasmer_dir.join(\"lib\").display()),\n        format!(\"\"),\n        format!(\"Name: wasmer\"),\n        format!(\"Description: The Wasmer library for running WebAssembly\"),\n        format!(\"Version: {}\", env!(\"CARGO_PKG_VERSION\")),\n        format!(\"Cflags: -I{}\", wasmer_dir.join(\"include\").display()),\n        format!(\"Libs: -L{} -lwasmer\", wasmer_dir.join(\"lib\").display()),\n    ]\n    .join(\"\\n\");\n\n    assert!(output.status.success());\n    let stderr = std::str::from_utf8(&output.stdout)\n        .unwrap()\n        .replace(\"\\r\\n\", \"\\n\");\n    assert_eq!(stderr.trim(), pkg_config.trim());\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--config-path\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"wasmer.toml\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_target_dir_from_dir", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_target_dir_from_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_ln_target_dir_dir\";\n    let from_dir = \"test_ln_target_dir_from_dir\";\n    let filename_a = \"test_ln_target_dir_file_a\";\n    let filename_b = \"test_ln_target_dir_file_b\";\n    let file_a = &format!(\"{from_dir}/{filename_a}\");\n    let file_b = &format!(\"{from_dir}/{filename_b}\");\n\n    at.mkdir(from_dir);\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-t\", dir, file_a, file_b])\n        .succeeds()\n        .no_stderr();\n\n    let file_a_link = &format!(\"{dir}/{filename_a}\");\n    assert!(at.is_symlink(file_a_link));\n    assert_eq!(&at.resolve_link(file_a_link), file_a);\n\n    let file_b_link = &format!(\"{dir}/{filename_b}\");\n    assert!(at.is_symlink(file_b_link));\n    assert_eq!(&at.resolve_link(file_b_link), file_b);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sum.rs::test_invalid_file", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_invalid_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"a\");\n\n    ucmd.arg(\"a\").fails().stderr_is(\"sum: a: Is a directory\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_d_flag", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_d_flag() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(\"-d1\").succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-d1\"]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_d_flag(result.stdout_str());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_use_concat_to_push_to_array", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn can_use_concat_to_push_to_array() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- set ids = [] -%}\n{% for i in range(end=5) -%}\n{%- set_global ids = ids | concat(with=i) -%}\n{%- endfor -%}\n{{ids}}\"#,\n    )\n    .unwrap();\n    let context = Context::new();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"[0, 1, 2, 3, 4]\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_notrunc_does_not_truncate", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_notrunc_does_not_truncate() {\n    // Set up test if needed (eg. after failure)\n    let fname = \"this-file-exists-notrunc.txt\";\n    let fpath = fixture_path!(fname);\n    match fpath.metadata() {\n        Ok(m) if m.len() == 256 => {}\n        _ => build_test_file!(&fpath, &build_ascii_block(256)),\n    }\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", \"conv=notrunc\", of!(&fname), \"if=null.txt\"])\n        .run()\n        .no_stdout()\n        .no_stderr()\n        .success();\n\n    assert_eq!(256, fix.metadata(fname).len());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_elements", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_elements() {\n    test_formatting(\n        r#\"\n        class A {\n            a;\n            b = 1;\n            c() {}\n            d(a, b, c) {\n                return a + b + c;\n            }\n            set e(value) {}\n            get e() {}\n            set(a, b) {}\n            get(a, b) {}\n        }\n        \"#,\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::strict_mode_with", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn strict_mode_with() {\n    // Checks as per https://tc39.es/ecma262/#sec-with-statement-static-semantics-early-errors\n    // that a with statement is an error in strict mode code.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            function f(x, o) {\n                with (o) {\n                    console.log(x);\n                }\n            }\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"with statement not allowed in strict mode at line 3, col 5\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_follow_name_stdin", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_follow_name_stdin() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n    at.touch(\"FILE1\");\n    at.touch(\"FILE2\");\n    ts.ucmd()\n        .arg(\"--follow=name\")\n        .arg(\"-\")\n        .run()\n        .stderr_is(\"tail: cannot follow '-' by name\\n\")\n        .code_is(1);\n    ts.ucmd()\n        .arg(\"--follow=name\")\n        .arg(\"FILE1\")\n        .arg(\"-\")\n        .arg(\"FILE2\")\n        .run()\n        .stderr_is(\"tail: cannot follow '-' by name\\n\")\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_is_not_empty", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_is_not_empty() {\n    new_ucmd!().args(&[\"-s\", \"non_empty_file\"]).succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_split_delay", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_split_delay() {\n    let mut cluster = new_server_cluster(0, 4);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(20);\n    cluster.pd_client.disable_default_operator();\n    cluster.run_conf_change();\n    cluster.pd_client.must_add_peer(1, new_peer(2, 2));\n    cluster.pd_client.must_add_peer(1, new_peer(3, 3));\n\n    cluster.pd_client.must_add_peer(1, new_learner_peer(4, 4));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n\n    // Suppose there is only one way partition.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 4).direction(Direction::Recv),\n    ));\n    let idx = cluster.truncated_state(1, 1).get_index();\n    // Trigger a log compaction.\n    for i in 0..cluster.cfg.raft_store.raft_log_gc_count_limit() * 2 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), format!(\"v{}\", i).as_bytes());\n    }\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k3\");\n    cluster.wait_log_truncated(1, 1, idx + 1);\n    // Wait till leader peer goes to sleep again.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(4), b\"k2\", b\"v2\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::cid_retirement", "code": "pub fn is_closed(&self) -> bool {\n        self.state.is_closed()\n    }", "test": "fn cid_retirement() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    // Server retires current active remote CIDs\n    pair.server_conn_mut(server_ch)\n        .rotate_local_cid(1, Instant::now());\n    pair.drive();\n    // Any unexpected behavior may trigger TransportError::CONNECTION_ID_LIMIT_ERROR\n    assert!(!pair.client_conn_mut(client_ch).is_closed());\n    assert!(!pair.server_conn_mut(server_ch).is_closed());\n    assert_matches!(pair.client_conn_mut(client_ch).active_rem_cid_seq(), 1);\n\n    use crate::cid_queue::CidQueue;\n    use crate::LOC_CID_COUNT;\n    let mut active_cid_num = CidQueue::LEN as u64;\n    active_cid_num = active_cid_num.min(LOC_CID_COUNT);\n\n    let next_retire_prior_to = active_cid_num + 1;\n    pair.client_conn_mut(client_ch).ping();\n    // Server retires all valid remote CIDs\n    pair.server_conn_mut(server_ch)\n        .rotate_local_cid(next_retire_prior_to, Instant::now());\n    pair.drive();\n    assert!(!pair.client_conn_mut(client_ch).is_closed());\n    assert!(!pair.server_conn_mut(server_ch).is_closed());\n    assert_matches!(\n        pair.client_conn_mut(client_ch).active_rem_cid_seq(),\n        _next_retire_prior_to\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/dnssec_client_handle_tests.rs::test_nsec_query_example_nonet", "code": "fn with_nonet<F>(test: F)\nwhere\n    F: Fn(DnssecDnsHandle<MemoizeClientHandle<AsyncClient>>, Runtime),\n{\n    let succeeded = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));\n    let succeeded_clone = succeeded.clone();\n    let join = std::thread::Builder::new()\n        .name(\"thread_killer\".to_string())\n        .spawn(move || {\n            let succeeded = succeeded_clone;\n            for _ in 0..15 {\n                std::thread::sleep(std::time::Duration::from_secs(1));\n                if succeeded.load(std::sync::atomic::Ordering::Relaxed) {\n                    return;\n                }\n            }\n\n            println!(\"Thread Killer has been awoken, killing process\");\n            std::process::exit(-1);\n        })\n        .unwrap();\n\n    let authority = create_secure_example();\n\n    let trust_anchor = {\n        let signers = block_on(authority.secure_keys());\n        let public_key = signers\n            .first()\n            .expect(\"expected a key in the authority\")\n            .key()\n            .to_public_key()\n            .expect(\"could not convert keypair to public_key\");\n\n        let mut trust_anchor = TrustAnchor::new();\n        trust_anchor.insert_trust_anchor(&public_key);\n\n        trust_anchor\n    };\n\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let client = AsyncClient::new(stream, sender, None);\n\n    let (client, bg) = io_loop\n        .block_on(client)\n        .expect(\"failed to create new client\");\n\n    hickory_proto::spawn_bg(&io_loop, bg);\n    let client = MemoizeClientHandle::new(client);\n    let secure_client = DnssecDnsHandle::with_trust_anchor(client, trust_anchor);\n\n    test(secure_client, io_loop);\n    succeeded.store(true, std::sync::atomic::Ordering::Relaxed);\n    join.join().unwrap();\n}", "test": "fn test_nsec_query_example_nonet() {\n    with_nonet(test_nsec_query_example);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_no_match6", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_no_match6() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%-5\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%-5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/undefined_variables.rs::unknown_variable_in_ternary_call", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn unknown_variable_in_ternary_call() {\n  Test::new()\n    .justfile(\n      \"\n    foo x=replace(a, b, c):\n  \",\n    )\n    .stderr(\n      \"\n      error: Variable `a` not defined\n        |\n      1 | foo x=replace(a, b, c):\n        |               ^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_restart_in_joint_state", "code": "pub fn is_in_joint(&self, region_id: u64) -> bool {\n        let region = block_on(self.get_region_by_id(region_id))\n            .unwrap()\n            .expect(\"region not exist\");\n        region.get_peers().iter().any(|p| {\n            p.get_role() == PeerRole::IncomingVoter || p.get_role() == PeerRole::DemotingVoter\n        })\n    }", "test": "fn test_restart_in_joint_state() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_learner_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Enter joint\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n        ],\n    );\n    assert!(pd_client.is_in_joint(region_id));\n\n    cluster.stop_node(1);\n    sleep_ms(50);\n\n    cluster.run_node(1).unwrap();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // Still in joint state\n    assert!(pd_client.is_in_joint(region_id));\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n\n    // Joint confchange finished\n    let region = cluster.get_region(b\"k2\");\n    must_has_peer(&region, 1, PeerRole::Voter);\n    must_has_peer(&region, 2, PeerRole::Learner);\n    must_has_peer(&region, 3, PeerRole::Voter);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_recv_data", "code": "pub fn capacity(&self, stream: &mut store::Ptr) -> WindowSize {\n        stream.capacity(self.prioritize.max_buffer_size())\n    }", "test": "async fn send_recv_data() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        .write(&[\n            // POST /\n            0, 0, 16, 1, 4, 0, 0, 0, 1, 131, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25, 151,\n            33, 233, 132,\n        ])\n        .write(&[\n            // DATA\n            0, 0, 5, 0, 1, 0, 0, 0, 1, 104, 101, 108, 108, 111,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            // HEADERS\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 136, // DATA\n            0, 0, 5, 0, 1, 0, 0, 0, 1, 119, 111, 114, 108, 100,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::Builder::new().handshake(mock).await.unwrap();\n\n    let request = Request::builder()\n        .method(Method::POST)\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    // Reserve send capacity\n    stream.reserve_capacity(5);\n\n    assert_eq!(stream.capacity(), 5);\n\n    // Send the data\n    stream.send_data(\"hello\".as_bytes(), true).unwrap();\n\n    // Get the response\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::OK);\n\n    // Take the body\n    let (_, body) = resp.into_parts();\n\n    // Wait for all the data frames to be received\n    let bytes: Vec<_> = h2.run(body.try_collect()).await.unwrap();\n\n    // One byte chunk\n    assert_eq!(1, bytes.len());\n\n    assert_eq!(bytes[0], &b\"world\"[..]);\n\n    // The H2 connection is closed\n    h2.await.unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_early_apply.rs::test_early_apply_yield_followed_with_many_entries", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_early_apply_yield_followed_with_many_entries() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n\n    configure_for_merge(&mut cluster.cfg);\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k2\");\n\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n\n    let left_peer_1 = find_peer(&left, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1);\n\n    let right_peer_2 = find_peer(&right, 2).unwrap().to_owned();\n    cluster.must_transfer_leader(right.get_id(), right_peer_2);\n\n    let before_handle_normal_3_fp = \"before_handle_normal_3\";\n    fail::cfg(before_handle_normal_3_fp, \"pause\").unwrap();\n\n    // Put another key before CommitMerge to make write-to-kv-db really happen\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    cluster.pd_client.must_merge(left.get_id(), right.get_id());\n\n    let large_val = vec![b'a'; 1024 * 1024];\n    // The size of these entries should be larger than MAX_COMMITTED_SIZE_PER_READY\n    for i in 0..50 {\n        cluster.must_put(format!(\"k1{}\", i).as_bytes(), large_val.as_slice());\n    }\n    cluster.must_put(b\"k150\", b\"v150\");\n\n    let after_handle_catch_up_logs_for_merge_1003_fp = \"after_handle_catch_up_logs_for_merge_1003\";\n    fail::cfg(after_handle_catch_up_logs_for_merge_1003_fp, \"return\").unwrap();\n\n    fail::remove(before_handle_normal_3_fp);\n\n    // Wait for apply state writting to kv db\n    sleep_ms(200);\n\n    cluster.shutdown();\n\n    fail::remove(after_handle_catch_up_logs_for_merge_1003_fp);\n\n    cluster.start().unwrap();\n\n    must_get_equal(&cluster.get_engine(3), b\"k150\", b\"v150\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::comments_are_ignored", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn comments_are_ignored() {\n    let inputs = vec![\n        (\"Hello {# comment #}world\", \"Hello world\"),\n        (\"Hello {# comment {# nested #}world\", \"Hello world\"),\n        (\"My name {# was {{ name }} #}is No One.\", \"My name is No One.\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_short_format_i", "code": "fn collect(&self) -> Vec<String> {\n        read_dir(Path::new(&self.directory.subdir))\n            .unwrap()\n            .filter_map(|entry| {\n                let path = entry.unwrap().path();\n                let name = self\n                    .directory\n                    .minus_as_string(path.as_path().to_str().unwrap_or(\"\"));\n                if self.regex.is_match(&name) {\n                    Some(name)\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }", "test": "fn test_short_format_i() {\n    // allow whitespace variation\n    // * minor whitespace differences occur between platform built-in outputs; specifically, the number of trailing TABs may be variant\n    let args = [\"-i\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    let v_actual: Vec<&str> = actual.split_whitespace().collect();\n    let v_expect: Vec<&str> = expect.split_whitespace().collect();\n    assert_eq!(v_actual, v_expect);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_linked_func_async", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "test": "async fn call_linked_func_async() -> Result<(), Error> {\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n\n    let f = Func::wrap4_async(\n        &mut store,\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            Box::new(async move {\n                // Calling this func will switch context into wasm, then back to host:\n                assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n                assert_eq!(\n                    caller.data().calls_into_host,\n                    caller.data().returns_from_host + 1\n                );\n                assert_eq!(\n                    caller.data().calls_into_wasm,\n                    caller.data().returns_from_wasm + 1\n                );\n                assert_eq!(a, 1);\n                assert_eq!(b, 2);\n                assert_eq!(c, 3.0);\n                assert_eq!(d, 4.0);\n            })\n        },\n    );\n\n    let mut linker = Linker::new(&engine);\n\n    linker.define(&mut store, \"host\", \"f\", f)?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call_async(&mut store, &[], &mut []).await?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    export\n        .typed::<(), ()>(&store)?\n        .call_async(&mut store, ())\n        .await?;\n\n    assert_eq!(store.data().calls_into_host, 2);\n    assert_eq!(store.data().returns_from_host, 2);\n    assert_eq!(store.data().calls_into_wasm, 2);\n    assert_eq!(store.data().returns_from_wasm, 2);\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_single_primary_column", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_single_primary_column() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    let req = new_analyze_column_req(&product, 1, 3, 3, 3, 4, 32);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeColumnsResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let hist = analyze_resp.get_pk_hist();\n    assert_eq!(hist.get_buckets().len(), 2);\n    assert_eq!(hist.get_ndv(), 4);\n    let collectors = analyze_resp.get_collectors().to_vec();\n    assert_eq!(collectors.len(), 0);\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-migrated.rs::test_namespaces", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "test": "fn test_namespaces() {\n    #[derive(PartialEq, Serialize, Deserialize, Debug)]\n    struct Envelope {\n        subject: String,\n    }\n    let s = r#\"\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <gesmes:Envelope xmlns:gesmes=\"http://www.gesmes.org/xml/2002-08-01\" xmlns=\"http://www.ecb.int/vocabulary/2002-08-01/eurofxref\">\n        <gesmes:subject>Reference rates</gesmes:subject>\n    </gesmes:Envelope>\"#;\n    test_parse_ok(&[(\n        s,\n        Envelope {\n            subject: \"Reference rates\".to_string(),\n        },\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_lost_majority", "code": "fn test_multi_lost_majority<T: Simulator>(cluster: &mut Cluster<T>, count: usize) {\n    cluster.run();\n    let leader = cluster.leader_of_region(1);\n\n    let half = (count as u64 + 1) / 2;\n    for i in 1..=half {\n        cluster.stop_node(i);\n    }\n    if let Some(leader) = leader {\n        if leader.get_store_id() > half {\n            cluster.stop_node(leader.get_store_id());\n        }\n    }\n    cluster.reset_leader_of_region(1);\n    sleep_ms(600);\n\n    assert!(cluster.leader_of_region(1).is_none());\n}", "test": "fn test_multi_server_lost_majority() {\n    let mut tests = vec![4, 5];\n    for count in tests.drain(..) {\n        let mut cluster = new_server_cluster(0, count);\n        test_multi_lost_majority(&mut cluster, count)\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_str_utils", "code": "fn purify(&self) -> &Self {\n        let mut line = self;\n        for (n, _) in self\n            .as_bytes()\n            .iter()\n            .enumerate()\n            .filter(|(_, c)| **c == b'#')\n        {\n            // Ignore the content after '#'\n            // only if it is preceded by at least one whitespace\n            match self[..n].chars().last() {\n                Some(c) if c.is_whitespace() => {\n                    line = &self[..n - c.len_utf8()];\n                    break;\n                }\n                None => {\n                    // n == 0\n                    line = &self[..0];\n                    break;\n                }\n                _ => (),\n            }\n        }\n        line.trim()\n    }", "test": "fn test_str_utils() {\n    let s = \"  asd#zcv #hk\\t\\n  \";\n    assert_eq!(\"asd#zcv\", s.purify());\n\n    let s = \"con256asd\";\n    assert!(s.fnmatch(\"*[2][3-6][5-9]?sd\")); // spell-checker:disable-line\n\n    let s = \"zxc \\t\\nqwe jlk    hjl\"; // spell-checker:disable-line\n    let (k, v) = s.split_two();\n    assert_eq!(\"zxc\", k);\n    assert_eq!(\"qwe jlk    hjl\", v);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_month_stable", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_month_stable() {\n    test_helper(\"month_stable\", &[\"-Ms\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_backup_arg_first", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_backup_arg_first() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/info.rs::json_with_satoshi_index", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn json_with_satoshi_index() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  CommandBuilder::new(\"--index-sats info\")\n    .rpc_server(&rpc_server)\n    .stdout_regex(\n      r#\"\\{\n  \"blocks_indexed\": 1,\n  \"branch_pages\": \\d+,\n  \"fragmented_bytes\": \\d+,\n  \"index_file_size\": \\d+,\n  \"index_path\": \".*\\.redb\",\n  \"leaf_pages\": \\d+,\n  \"metadata_bytes\": \\d+,\n  \"outputs_traversed\": 1,\n  \"page_size\": \\d+,\n  \"sat_ranges\": 1,\n  \"stored_bytes\": \\d+,\n  \"transactions\": \\[\n    \\{\n      \"starting_block_count\": 0,\n      \"starting_timestamp\": \\d+\n    \\}\n  \\],\n  \"tree_height\": \\d+,\n  \"utxos_indexed\": 2\n\\}\n\"#,\n    )\n    .run_and_extract_stdout();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_backup_and_import", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_backup_and_import() {\n    let mut suite = TestSuite::new(3, 144 * 1024 * 1024, ApiVersion::V1);\n    // 3 version for each key.\n    let key_count = 60;\n    suite.must_kv_put(key_count, 3);\n\n    // Push down backup request.\n    let tmp = Builder::new().tempdir().unwrap();\n    let backup_ts = suite.alloc_ts();\n    let storage_path = make_unique_dir(tmp.path());\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &storage_path,\n    );\n    let resps1 = block_on(rx.collect::<Vec<_>>());\n    // Only leader can handle backup.\n    assert_eq!(resps1.len(), 1);\n    let files1 = resps1[0].files.clone();\n    // Short value is piggybacked in write cf, so we get 1 sst at least.\n    assert!(!resps1[0].get_files().is_empty());\n\n    // Delete all data, there should be no backup files.\n    suite.cluster.must_delete_range_cf(CF_DEFAULT, b\"\", b\"\");\n    suite.cluster.must_delete_range_cf(CF_WRITE, b\"\", b\"\");\n    // Backup file should have same contents.\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &make_unique_dir(tmp.path()),\n    );\n    let resps2 = block_on(rx.collect::<Vec<_>>());\n    assert!(resps2[0].get_files().is_empty(), \"{:?}\", resps2);\n\n    // Use importer to restore backup files.\n    let backend = make_local_backend(&storage_path);\n    let storage = create_storage(&backend, Default::default()).unwrap();\n    let region = suite.cluster.get_region(b\"\");\n    let mut sst_meta = SstMeta::default();\n    sst_meta.region_id = region.get_id();\n    sst_meta.set_region_epoch(region.get_region_epoch().clone());\n    sst_meta.set_uuid(uuid::Uuid::new_v4().as_bytes().to_vec());\n    let mut metas = vec![];\n    for f in files1.clone().into_iter() {\n        let mut reader = storage.read(&f.name);\n        let mut content = vec![];\n        block_on(reader.read_to_end(&mut content)).unwrap();\n        let mut m = sst_meta.clone();\n        m.crc32 = calc_crc32_bytes(&content);\n        m.length = content.len() as _;\n        m.cf_name = name_to_cf(&f.name).to_owned();\n        metas.push((m, content));\n    }\n\n    for (m, c) in &metas {\n        for importer in suite.cluster.sim.rl().importers.values() {\n            let mut f = importer.create(m).unwrap();\n            f.append(c).unwrap();\n            f.finish().unwrap();\n        }\n\n        // Make ingest command.\n        let mut ingest = Request::default();\n        ingest.set_cmd_type(CmdType::IngestSst);\n        ingest.mut_ingest_sst().set_sst(m.clone());\n        let mut header = RaftRequestHeader::default();\n        let leader = suite.context.get_peer().clone();\n        header.set_peer(leader);\n        header.set_region_id(suite.context.get_region_id());\n        header.set_region_epoch(suite.context.get_region_epoch().clone());\n        let mut cmd = RaftCmdRequest::default();\n        cmd.set_header(header);\n        cmd.mut_requests().push(ingest);\n        let resp = suite\n            .cluster\n            .call_command_on_leader(cmd, Duration::from_secs(5))\n            .unwrap();\n        assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    }\n\n    // Backup file should have same contents.\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &make_unique_dir(tmp.path()),\n    );\n    let resps3 = block_on(rx.collect::<Vec<_>>());\n    assert_same_files(files1.into_vec(), resps3[0].files.clone().into_vec());\n\n    suite.stop();\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::unit_struct_cache_key", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "test": "fn unit_struct_cache_key() {\n    #[derive(CacheKey, Hash)]\n    struct UnitStruct;\n\n    let mut key = CacheKeyHasher::new();\n\n    UnitStruct.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    UnitStruct.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_with_data", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_with_data() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client.recv_frame(frames::headers(1).response(200)).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client.recv_frame(frames::headers(2).response(200)).await;\n        client.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n        client.recv_frame(frames::data(2, &b\"\\x00\"[..]).eos()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Start response to stream 1\n        let mut s1_tx = {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream.send_response(rsp, false).unwrap()\n        };\n\n        // Promise stream 2, push response headers and send data\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            let mut push_tx = stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, false)\n                .unwrap();\n            // Make sure nothing can queue our pushed stream before we have the PushPromise sent\n            push_tx.send_data(vec![0; 1].into(), true).unwrap();\n            push_tx.reserve_capacity(1);\n        }\n\n        // End response for stream 1\n        s1_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_carriage_return", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_carriage_return() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\r\"])\n        .succeeds()\n        .stdout_only(\"\\r\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_set_bad_signal_name", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_kill_set_bad_signal_name() {\n    // spell-checker:disable-line\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"IAMNOTASIGNAL\") // spell-checker:disable-line\n        .fails()\n        .stderr_contains(\"unknown signal\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::connection_close_sends_acks", "code": "pub fn stats(&self) -> ConnectionStats {\n        let mut stats = self.stats;\n        stats.path.rtt = self.path.rtt.get();\n        stats.path.cwnd = self.path.congestion.window();\n\n        stats\n    }", "test": "fn connection_close_sends_acks() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, _server_ch) = pair.connect();\n\n    let client_acks = pair.client_conn_mut(client_ch).stats().frame_rx.acks;\n\n    pair.client_conn_mut(client_ch).ping();\n    pair.drive_client();\n\n    let time = pair.time;\n    pair.server_conn_mut(client_ch)\n        .close(time, VarInt(42), Bytes::new());\n\n    pair.drive();\n\n    let client_acks_2 = pair.client_conn_mut(client_ch).stats().frame_rx.acks;\n    assert!(\n        client_acks_2 > client_acks,\n        \"Connection close should send pending ACKs\"\n    );\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_a_de", "code": "fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n}", "test": "fn test_internally_a_de() {\n    let s = \"(type:\\\"VariantA\\\",foo:1,bar:2,different:3)\";\n    let e = EnumStructInternally::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    test_de(s, e);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_5", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_5() {\n    let original = r##\"[^ipsum]: How much wood would a woodchuck chuck.\n\nIf a woodchuck could chuck wood.\n\n\n# Forms of entertainment that aren't childish\n\"##;\n    let expected = r##\"<div class=\"footnote-definition\" id=\"ipsum\"><sup class=\"footnote-definition-label\">1</sup>\n<p>How much wood would a woodchuck chuck.</p>\n</div>\n<p>If a woodchuck could chuck wood.</p>\n<h1>Forms of entertainment that aren't childish</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_no_env", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_no_env() {\n    // no SHELL and TERM\n    new_ucmd!().fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_floats", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_floats() {\n    new_ucmd!()\n        .args(&[\"-w\", \"9.0\", \"10.0\"])\n        .succeeds()\n        .stdout_is(\"09.0\\n10.0\\n\")\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_suffix_must_end_in_x", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_suffix_must_end_in_x() {\n    new_ucmd!()\n        .args(&[\"--suffix=\", \"aXXXb\"])\n        .fails()\n        .stderr_is(\"mktemp: with --suffix, template 'aXXXb' must end in X\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_storage_error", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_storage_error() {\n    let data = vec![(1, Some(\"name:0\"), 2), (2, Some(\"name:4\"), 3)];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"kv_cursor_seek\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"kv cursor seek error\"));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::default_filter_works", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn default_filter_works() {\n    let mut context = Context::new();\n    let i: Option<usize> = None;\n    context.insert(\"existing\", \"hello\");\n    context.insert(\"null\", &i);\n\n    let inputs = vec![\n        (r#\"{{ existing | default(value=\"hey\") }}\"#, \"hello\"),\n        (r#\"{{ val | default(value=1) }}\"#, \"1\"),\n        (r#\"{{ val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ obj.val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ obj.val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ not admin | default(value=false) }}\"#, \"true\"),\n        (r#\"{{ not admin | default(value=true) }}\"#, \"false\"),\n        (r#\"{{ null | default(value=true) }}\"#, \"true\"),\n        (r#\"{{ null | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/escaped.rs::test_escaped", "code": "fn esc(s: &str) -> IResult<&str, &str, (&str, ErrorKind)> {\n  escaped(digit1, '\\\\', one_of(\"\\\"n\\\\\"))(s)\n}", "test": "fn test_escaped() {\n  assert_eq!(esc(\"abcd\"), Err(Err::Error((\"abcd\", ErrorKind::Escaped))));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/mod.rs::threaded_environment", "code": "pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    }", "test": "fn threaded_environment() {\n    let cwd = env::current_dir().unwrap();\n    let resolver = Arc::new(Resolver::default());\n    for _ in 0..2 {\n        _ = thread::spawn({\n            let cwd = cwd.clone();\n            let resolver = Arc::clone(&resolver);\n            move || {\n                _ = resolver.resolve(cwd, \".\");\n            }\n        })\n        .join();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_no_header_trailer_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_no_header_trailer_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_no_ht.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"-t\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_paths.rs::test_paths_and_base_url", "code": "pub fn resolve_path_alias(&self, specifier: &str) -> Vec<PathBuf> {\n        if specifier.starts_with(|s| s == '/' || s == '.') {\n            return vec![];\n        }\n\n        let base_url_iter = self\n            .compiler_options\n            .base_url\n            .as_ref()\n            .map_or_else(Vec::new, |base_url| vec![base_url.normalize_with(specifier)]);\n\n        let Some(paths_map) = &self.compiler_options.paths else { return base_url_iter };\n\n        let paths = paths_map.get(specifier).map_or_else(\n            || {\n                let mut longest_prefix_length = 0;\n                let mut longest_suffix_length = 0;\n                let mut best_key: Option<&String> = None;\n\n                for key in paths_map.keys() {\n                    if let Some((prefix, suffix)) = key.split_once('*') {\n                        if (best_key.is_none() || prefix.len() > longest_prefix_length)\n                            && specifier.starts_with(prefix)\n                            && specifier.ends_with(suffix)\n                        {\n                            longest_prefix_length = prefix.len();\n                            longest_suffix_length = suffix.len();\n                            best_key.replace(key);\n                        }\n                    }\n                }\n\n                best_key.and_then(|key| paths_map.get(key)).map_or_else(Vec::new, |paths| {\n                    paths\n                        .iter()\n                        .map(|path| {\n                            path.replace(\n                                '*',\n                                &specifier[longest_prefix_length\n                                    ..specifier.len() - longest_suffix_length],\n                            )\n                        })\n                        .collect::<Vec<_>>()\n                })\n            },\n            Clone::clone,\n        );\n\n        paths\n            .into_iter()\n            .map(|p| self.compiler_options.paths_base.normalize_with(p))\n            .chain(base_url_iter)\n            .collect()\n    }", "test": "fn test_paths_and_base_url() {\n    let path = Path::new(\"/foo/tsconfig.json\");\n    let mut tsconfig_json = serde_json::json!({\n        \"compilerOptions\": {\n            \"baseUrl\": \"./src\",\n            \"paths\": {\n                \"*\": [\"generated/*\"],\n                \"bar/*\": [\"test/*\"],\n                \"bar/baz/*\": [\"baz/*\", \"yo/*\"],\n                \"@/components/*\": [\"components/*\"]\n            }\n        }\n    })\n    .to_string();\n    let tsconfig = TsConfig::parse(path, &mut tsconfig_json).unwrap();\n\n    let data = [\n        (\"test\", vec![\"/foo/src/generated/test\", \"/foo/src/test\"]),\n        (\"test/hello\", vec![\"/foo/src/generated/test/hello\", \"/foo/src/test/hello\"]),\n        (\"bar/hi\", vec![\"/foo/src/test/hi\", \"/foo/src/bar/hi\"]),\n        (\"bar/baz/hi\", vec![\"/foo/src/baz/hi\", \"/foo/src/yo/hi\", \"/foo/src/bar/baz/hi\"]),\n        (\"@/components/button\", vec![\"/foo/src/components/button\", \"/foo/src/@/components/button\"]),\n        (\"./jquery\", vec![]),\n    ];\n\n    for (specifier, expected) in data {\n        let paths = tsconfig.resolve_path_alias(specifier);\n        let expected = expected.into_iter().map(PathBuf::from).collect::<Vec<_>>();\n        assert_eq!(paths, expected, \"{specifier}\");\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_referenced_names_empty_bug", "code": "pub fn is_empty(&self) -> bool {\n        self.instructions.is_empty()\n    }", "test": "fn test_referenced_names_empty_bug() {\n    let c = CodeGenerator::new(\"<unknown>\", \"\");\n    let instructions = c.finish().0;\n    let rv = instructions.get_referenced_names(0);\n    assert!(rv.is_empty());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_server.rs::test_mismatch_store_node", "code": "fn get_store(&self, store_id: u64) -> Result<metapb::Store> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC.get_store.start_coarse_timer();\n\n        let mut req = pdpb::GetStoreRequest::default();\n        req.set_header(self.header());\n        req.set_store_id(store_id);\n\n        let mut resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.get_store_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        let store = resp.take_store();\n        if store.get_state() != metapb::StoreState::Tombstone {\n            Ok(store)\n        } else {\n            Err(Error::StoreTombstone(format!(\"{:?}\", store)))\n        }\n    }", "test": "fn test_mismatch_store_node() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n    let node_ids = cluster.get_node_ids();\n    let mut iter = node_ids.iter();\n    let node1_id = *iter.next().unwrap();\n    let node2_id = *iter.next().unwrap();\n    let node3_id = *iter.next().unwrap();\n    let pd_client = cluster.pd_client.clone();\n    must_get_equal(&cluster.get_engine(node1_id), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(node2_id), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(node3_id), b\"k1\", b\"v1\");\n    let node1_addr = pd_client\n        .get_store(node1_id)\n        .unwrap()\n        .get_address()\n        .to_string();\n    let node2_addr = pd_client\n        .get_store(node2_id)\n        .unwrap()\n        .get_address()\n        .to_string();\n    let node3_addr = cluster\n        .pd_client\n        .get_store(node3_id)\n        .unwrap()\n        .get_address()\n        .to_string();\n    cluster.stop_node(node2_id);\n    cluster.stop_node(node3_id);\n    // run node2\n    cluster.cfg.server.addr = node3_addr.clone();\n    cluster.run_node(node2_id).unwrap();\n    let filter = RegionPacketFilter::new(1, node2_id)\n        .direction(Direction::Send)\n        .msg_type(MessageType::MsgRequestPreVote);\n    cluster.add_send_filter(CloneFilterFactory(filter));\n    // run node3\n    cluster.cfg.server.addr = node2_addr.clone();\n    cluster.run_node(node3_id).unwrap();\n    let filter = RegionPacketFilter::new(1, node3_id)\n        .direction(Direction::Send)\n        .msg_type(MessageType::MsgRequestPreVote);\n    cluster.add_send_filter(CloneFilterFactory(filter));\n    sleep_ms(600);\n    fail::cfg(\"mock_store_refresh_interval_secs\", \"return(0)\").unwrap();\n    cluster.must_put(b\"k2\", b\"v2\");\n    assert_eq!(\n        node1_addr,\n        pd_client.get_store(node1_id).unwrap().get_address()\n    );\n    assert_eq!(\n        node3_addr,\n        pd_client.get_store(node2_id).unwrap().get_address()\n    );\n    assert_eq!(\n        node2_addr,\n        cluster.pd_client.get_store(node3_id).unwrap().get_address()\n    );\n    must_get_equal(&cluster.get_engine(node3_id), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(node2_id), b\"k2\", b\"v2\");\n    fail::remove(\"mock_store_refresh_interval_secs\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_suffix_param", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_suffix_param() {\n    for suffix_param in [\"-s\", \"--suffix\", \"--suf\"] {\n        let path = \"/foo/bar/baz.exe\";\n        new_ucmd!()\n            .args(&[suffix_param, \".exe\", path, path])\n            .succeeds()\n            .stdout_only(\"baz\\nbaz\\n\"); // spell-checker:disable-line\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_leader_change_with_log_overlap", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_node_leader_change_with_log_overlap() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // So peer 3 won't replicate any message of the region but still can vote.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // peer 1 and peer 2 must have k1, but peer 3 must not.\n    for i in 1..3 {\n        let engine = cluster.get_engine(i);\n        must_get_equal(&engine, b\"k1\", b\"v1\");\n    }\n\n    let engine3 = cluster.get_engine(3);\n    must_get_none(&engine3, b\"k1\");\n\n    // now only peer 1 and peer 2 can step to leader.\n    // Make peer 1's msg won't be replicated,\n    // so the proposed entries won't be committed.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Send),\n    ));\n    let put_msg = vec![new_put_cmd(b\"k2\", b\"v2\")];\n    let region = cluster.get_region(b\"\");\n    let mut put_req = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        put_msg,\n        false,\n    );\n    put_req.mut_header().set_peer(new_peer(1, 1));\n    let called = Arc::new(AtomicBool::new(false));\n    let called_ = Arc::clone(&called);\n    cluster\n        .sim\n        .rl()\n        .get_node_router(1)\n        .send_command(\n            put_req,\n            Callback::write(Box::new(move |resp: WriteResponse| {\n                called_.store(true, Ordering::SeqCst);\n                assert!(resp.response.get_header().has_error());\n                assert!(resp.response.get_header().get_error().has_stale_command());\n            })),\n            RaftCmdExtraOpts::default(),\n        )\n        .unwrap();\n\n    // Now let peer(1, 1) steps down. Can't use transfer leader here, because\n    // it still has pending proposed entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgHeartbeat)\n            .direction(Direction::Send),\n    ));\n    // make sure k2 has not been committed.\n    must_get_none(&cluster.get_engine(1), b\"k2\");\n\n    // Here just use `must_transfer_leader` to wait for peer (2, 2) becomes leader.\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n\n    cluster.clear_send_filters();\n\n    for _ in 0..50 {\n        sleep_ms(100);\n        if called.load(Ordering::SeqCst) {\n            return;\n        }\n    }\n    panic!(\"callback has not been called after 5s.\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_infinity", "code": "pub fn run(&mut self) -> CmdResult {\n        self.run_no_wait().wait().unwrap()\n    }", "test": "fn test_infinity() {\n    run(&[\"infinity\"], b\"1\\n2\\n3\\n\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/359_deserialize_seed.rs::test_deserialize_seed", "code": "pub fn from_str_seed<'a, S, T>(&self, s: &'a str, seed: S) -> SpannedResult<T>\n    where\n        S: de::DeserializeSeed<'a, Value = T>,\n    {\n        self.from_bytes_seed(s.as_bytes(), seed)\n    }", "test": "fn test_deserialize_seed() {\n    // Test adapted from David Tolnay's serde-yaml:\n    // https://github.com/dtolnay/serde-yaml/blob/8a806e316302fd2e6541dccee6d166dd51b689d6/tests/test_de.rs#L357-L392\n\n    struct Seed(i64);\n\n    impl<'de> serde::de::DeserializeSeed<'de> for Seed {\n        type Value = i64;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<i64, D::Error>\n        where\n            D: serde::de::Deserializer<'de>,\n        {\n            struct Visitor(i64);\n\n            impl<'de> serde::de::Visitor<'de> for Visitor {\n                type Value = i64;\n\n                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n                    write!(formatter, \"an integer\")\n                }\n\n                fn visit_i64<E: serde::de::Error>(self, v: i64) -> Result<i64, E> {\n                    Ok(v * self.0)\n                }\n\n                fn visit_u64<E: serde::de::Error>(self, v: u64) -> Result<i64, E> {\n                    Ok(v as i64 * self.0)\n                }\n            }\n\n            deserializer.deserialize_any(Visitor(self.0))\n        }\n    }\n\n    let cases = [(\"3\", 5, 15), (\"6\", 7, 42), (\"-5\", 9, -45)];\n\n    for &(ron, seed, expected) in &cases {\n        let deserialized = ron::Options::default()\n            .from_str_seed(ron, Seed(seed))\n            .unwrap();\n\n        assert_eq!(expected, deserialized);\n    }\n\n    assert_eq!(\n        ron::Options::default().from_str_seed(\"'a'\", Seed(42)),\n        Err(ron::error::SpannedError {\n            code: ron::Error::InvalidValueForType {\n                expected: String::from(\"an integer\"),\n                found: String::from(\"the string \\\"a\\\"\"),\n            },\n            position: ron::error::Position { line: 1, col: 4 },\n        })\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/backup/mod.rs::test_backup_in_flashback", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_backup_in_flashback() {\n    let mut suite = TestSuite::new(3, 144 * 1024 * 1024, ApiVersion::V1);\n    suite.must_kv_put(3, 1);\n    // Prepare the flashback.\n    let region = suite.cluster.get_region(b\"key_0\");\n    suite.cluster.must_send_wait_flashback_msg(\n        region.get_id(),\n        kvproto::raft_cmdpb::AdminCmdType::PrepareFlashback,\n    );\n    // Start the backup.\n    let tmp = Builder::new().tempdir().unwrap();\n    let backup_ts = suite.alloc_ts();\n    let storage_path = make_unique_dir(tmp.path());\n    let rx = suite.backup(\n        vec![],   // start\n        vec![],   // end\n        0.into(), // begin_ts\n        backup_ts,\n        &storage_path,\n    );\n    let resp = block_on(rx.collect::<Vec<_>>());\n    assert!(!resp[0].has_error());\n    // Finish the flashback.\n    suite.cluster.must_send_wait_flashback_msg(\n        region.get_id(),\n        kvproto::raft_cmdpb::AdminCmdType::FinishFlashback,\n    );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_paths.rs::test_base_url", "code": "pub fn resolve_path_alias(&self, specifier: &str) -> Vec<PathBuf> {\n        if specifier.starts_with(|s| s == '/' || s == '.') {\n            return vec![];\n        }\n\n        let base_url_iter = self\n            .compiler_options\n            .base_url\n            .as_ref()\n            .map_or_else(Vec::new, |base_url| vec![base_url.normalize_with(specifier)]);\n\n        let Some(paths_map) = &self.compiler_options.paths else { return base_url_iter };\n\n        let paths = paths_map.get(specifier).map_or_else(\n            || {\n                let mut longest_prefix_length = 0;\n                let mut longest_suffix_length = 0;\n                let mut best_key: Option<&String> = None;\n\n                for key in paths_map.keys() {\n                    if let Some((prefix, suffix)) = key.split_once('*') {\n                        if (best_key.is_none() || prefix.len() > longest_prefix_length)\n                            && specifier.starts_with(prefix)\n                            && specifier.ends_with(suffix)\n                        {\n                            longest_prefix_length = prefix.len();\n                            longest_suffix_length = suffix.len();\n                            best_key.replace(key);\n                        }\n                    }\n                }\n\n                best_key.and_then(|key| paths_map.get(key)).map_or_else(Vec::new, |paths| {\n                    paths\n                        .iter()\n                        .map(|path| {\n                            path.replace(\n                                '*',\n                                &specifier[longest_prefix_length\n                                    ..specifier.len() - longest_suffix_length],\n                            )\n                        })\n                        .collect::<Vec<_>>()\n                })\n            },\n            Clone::clone,\n        );\n\n        paths\n            .into_iter()\n            .map(|p| self.compiler_options.paths_base.normalize_with(p))\n            .chain(base_url_iter)\n            .collect()\n    }", "test": "fn test_base_url() {\n    let path = Path::new(\"/foo/tsconfig.json\");\n    let mut tsconfig_json = serde_json::json!({\n        \"compilerOptions\": {\n            \"baseUrl\": \"./src\"\n        }\n    })\n    .to_string();\n    let tsconfig = TsConfig::parse(path, &mut tsconfig_json).unwrap();\n\n    let data = [\n        (\"foo\", vec![\"/foo/src/foo\"]),\n        (\"components/button\", vec![\"/foo/src/components/button\"]),\n        (\"./jquery\", vec![]),\n    ];\n\n    for (specifier, expected) in data {\n        let paths = tsconfig.resolve_path_alias(specifier);\n        let expected = expected.into_iter().map(PathBuf::from).collect::<Vec<_>>();\n        assert_eq!(paths, expected, \"{specifier}\");\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::finish_stream_flow_control_reordered", "code": "pub(crate) fn next(&mut self) -> Option<(ResetToken, Range<u64>)> {\n        let (i, cid_data) = self.iter().nth(1)?;\n        self.buffer[self.cursor] = None;\n\n        let orig_offset = self.offset;\n        self.offset += i as u64;\n        self.cursor = (self.cursor + i) % Self::LEN;\n        Some((cid_data.1.unwrap(), orig_offset..self.offset))\n    }", "test": "fn finish_stream_flow_control_reordered() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive_client(); // Send stream data\n    pair.server.drive(pair.time, pair.client.addr); // Receive\n\n    // Issue flow control credit\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    let _ = chunks.finalize();\n\n    pair.server.drive(pair.time, pair.client.addr);\n    pair.server.delay_outbound(); // Delay it\n\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive_client(); // Send FIN\n    pair.server.drive(pair.time, pair.client.addr); // Acknowledge\n    pair.server.finish_delay(); // Add flow control packets after\n    pair.drive();\n\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Finished { id })) if id == s\n    );\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Ok(None));\n    let _ = chunks.finalize();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_init_list_0", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_init_list_0() {\n    new_ucmd!()\n        .args(&[\"-t2,4\"])\n        .pipe_in(\" 1\\n  2\\n   3\\n    4\\n\")\n        .run()\n        .stdout_is(\" 1\\n\\t2\\n\\t 3\\n\\t\\t4\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_negative_padding", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_negative_padding() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--padding=-8\"])\n        .pipe_in(\"1K\\n1.1M\\n0.1G\")\n        .run()\n        .stdout_is(\"1000    \\n1100000 \\n100000000\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_dir_follow", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_dir_follow() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n    at.mkdir(\"DIR\");\n    for mode in &[\"--follow=descriptor\", \"--follow=name\"] {\n        ts.ucmd()\n            .arg(mode)\n            .arg(\"DIR\")\n            .run()\n            .no_stdout()\n            .stderr_is(\n                \"tail: error reading 'DIR': Is a directory\\n\\\n                    tail: DIR: cannot follow end of this type of file; giving up on this name\\n\\\n                    tail: no files remaining\\n\",\n            )\n            .code_is(1);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc2_with_many_keys", "code": "fn test_txn_store_gc_multiple_keys(key_prefix_len: usize, n: usize) {\n    let prefix = String::from_utf8(vec![b'k'; key_prefix_len]).unwrap();\n    test_txn_store_gc_multiple_keys_cluster_storage(n, prefix.clone());\n    test_txn_store_gc_multiple_keys_single_storage(n, prefix);\n}", "test": "fn test_txn_store_gc2_with_many_keys() {\n    test_txn_store_gc_multiple_keys(1, DEFAULT_GC_BATCH_KEYS + 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_column_across_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_column_across_option() {\n    let test_file_path = \"column.log\";\n    let expected_test_file_path = \"column_across.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"--pages=3:5\", \"--column=3\", \"-a\", \"-n\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::generator", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn generator() {\n    test(\"function* foo() {}\", \"function*foo(){}\");\n    test(\"(function* () {})\", \"(function*(){});\");\n    test(\"(function* foo() {})\", \"(function*foo(){});\");\n\n    test(\"class Foo { *foo() {} }\", \"class Foo{*foo(){}}\");\n    test(\"class Foo { static *foo() {} }\", \"class Foo{static *foo(){}}\");\n    test(\"class Foo { *[foo]() {} }\", \"class Foo{*[foo](){}}\");\n    test(\"class Foo { static *[foo]() {} }\", \"class Foo{static *[foo](){}}\");\n\n    test(\"(class { *foo() {} })\", \"(class{*foo(){}});\");\n    test(\"(class { static *foo() {} })\", \"(class{static *foo(){}});\");\n    test(\"(class { *[foo]() {} })\", \"(class{*[foo](){}});\");\n    test(\"(class { static *[foo]() {} })\", \"(class{static *[foo](){}});\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_number_option_with_custom_separator_char_and_width", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_number_option_with_custom_separator_char_and_width() {\n    let test_file_path = \"test_num_page.log\";\n    let expected_test_file_path = \"test_num_page_char_one.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"-nc1\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_sort_self_loop", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_sort_self_loop() {\n    new_ucmd!()\n        .pipe_in(\"first first\\nfirst second second second\")\n        .succeeds()\n        .stdout_only(\"first\\nsecond\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/wasm/tests/wasm_testsuite.rs::testsuite", "code": "fn handle_module(\n    options: &Options,\n    path: &Path,\n    name: &str,\n    fisa: FlagsOrIsa,\n    module: Option<&mut impl cranelift_module::Module>,\n) -> Result<()> {\n    let buffer = read_to_string(&path)?;\n    let test_file = parse_test(&buffer, ParseOptions::default())\n        .with_context(|| format!(\"failed to parse {}\", name))?;\n\n    // If we have an isa from the command-line, use that. Otherwise if the\n    // file contains a unique isa, use that.\n    let isa = fisa.isa.or(test_file.isa_spec.unique_isa());\n\n    let isa = match isa {\n        None => anyhow::bail!(\"compilation requires a target isa\"),\n        Some(isa) => isa,\n    };\n\n    for (func, _) in test_file.functions {\n        let mut context = Context::new();\n        context.func = func;\n        let mut mem = vec![];\n\n        // Compile and encode the result to machine code.\n        let compiled_code = context\n            .compile_and_emit(isa, &mut mem, &mut Default::default())\n            .map_err(|err| anyhow::anyhow!(\"{}\", pretty_error(&err.func, err.inner)))?;\n        let code_info = compiled_code.code_info();\n\n        if let Some(&mut ref mut module) = module {\n            let name = context.func.name.to_string();\n            let fid = module.declare_function(\n                &name,\n                cranelift_module::Linkage::Export,\n                &context.func.signature,\n            )?;\n            module.define_function_with_control_plane(\n                fid,\n                &mut context,\n                &mut Default::default(),\n            )?;\n        }\n\n        if options.print {\n            println!(\"{}\", context.func.display());\n        }\n\n        if options.disasm {\n            let result = context.compiled_code().unwrap();\n            print_all(\n                isa,\n                &context.func.params,\n                &mem,\n                code_info.total_size,\n                options.print,\n                result.buffer.relocs(),\n                result.buffer.traps(),\n                result.buffer.stack_maps(),\n            )?;\n        }\n    }\n\n    if options.report_times {\n        print!(\"{}\", timing::take_current());\n    }\n\n    Ok(())\n}", "test": "fn testsuite() {\n    let mut paths: Vec<_> = fs::read_dir(\"./wasmtests\")\n        .unwrap()\n        .map(|r| r.unwrap())\n        .filter(|p| {\n            // Ignore files starting with `.`, which could be editor temporary files\n            if let Some(stem) = p.path().file_stem() {\n                if let Some(stemstr) = stem.to_str() {\n                    return !stemstr.starts_with('.');\n                }\n            }\n            false\n        })\n        .collect();\n    paths.sort_by_key(|dir| dir.path());\n    let flags = Flags::new(settings::builder());\n    for path in paths {\n        let path = path.path();\n        println!(\"=== {} ===\", path.display());\n        let data = read_module(&path);\n        handle_module(data, &flags);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_backup", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_existing_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_existing_backup\";\n    let link = \"test_symlink_existing_backup_link\";\n    let link_backup = \"test_symlink_existing_backup_link.~1~\";\n    let resulting_backup = \"test_symlink_existing_backup_link.~2~\";\n\n    // Create symlink and verify\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    // Create backup symlink and verify\n    at.symlink_file(file, link_backup);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link_backup));\n    assert_eq!(at.resolve_link(link_backup), file);\n\n    ucmd.args(&[\"-s\", \"--backup=nil\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link_backup));\n    assert_eq!(at.resolve_link(link_backup), file);\n\n    assert!(at.is_symlink(resulting_backup));\n    assert_eq!(at.resolve_link(resulting_backup), file);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_do_not_overwrite", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_do_not_overwrite() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_do_not_overwrite\";\n    let link = \"test_symlink_do_not_overwrite_link\";\n\n    at.touch(file);\n    at.touch(link);\n\n    ucmd.args(&[\"-s\", file, link]).fails();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(link));\n    assert!(!at.is_symlink(link));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_lease_unsafe_during_leader_transfers", "code": "fn test_lease_unsafe_during_leader_transfers<T: Simulator>(cluster: &mut Cluster<T>) {\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(500), Some(5));\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n    cluster.cfg.raft_store.renew_leader_lease_advance_duration = ReadableDuration::secs(0);\n\n    let store_id = 1u64;\n    let peer = new_peer(store_id, 1);\n    let peer3_store_id = 3u64;\n    let peer3 = new_peer(peer3_store_id, 3);\n\n    cluster.pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_add_peer(r1, new_peer(2, 2));\n    must_get_equal(&cluster.get_engine(2), b\"k0\", b\"v0\");\n    cluster.pd_client.must_add_peer(r1, new_peer(3, 3));\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer1` to became leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n\n    let state = cluster.raft_local_state(region_id, store_id);\n    let last_index = state.get_last_index();\n\n    // Check if the leader does a local read.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    let state = cluster.raft_local_state(region_id, store_id);\n    assert_eq!(state.get_last_index(), last_index);\n    assert_eq!(detector.ctx.rl().len(), 0);\n\n    // Ensure peer 3 is ready to transfer leader.\n    must_get_equal(&cluster.get_engine(3), key, b\"v1\");\n\n    // Drop MsgTimeoutNow to `peer3` so that the leader transfer procedure would\n    // abort later.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(region_id, peer3_store_id)\n            .msg_type(MessageType::MsgTimeoutNow)\n            .direction(Direction::Recv),\n    ));\n\n    // Issue a transfer leader request to transfer leader from `peer` to `peer3`.\n    cluster.transfer_leader(region_id, peer3);\n\n    // Delay a while to ensure transfer leader procedure is triggered inside raft\n    // module.\n    thread::sleep(election_timeout / 2);\n\n    // Issue a read request and it will fall back to read index.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    assert_eq!(detector.ctx.rl().len(), 1);\n\n    // And read index should not update lease.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    assert_eq!(detector.ctx.rl().len(), 2);\n\n    // Make sure the leader transfer procedure timeouts.\n    thread::sleep(election_timeout * 2);\n\n    // Then the leader transfer procedure aborts, now the leader could do lease read\n    // or consistent read/write and renew/reuse the lease as usual.\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    assert_eq!(detector.ctx.rl().len(), 3);\n\n    // Check if the leader also propose an entry to renew its lease.\n    cluster.wait_last_index(region_id, store_id, last_index + 1, Duration::from_secs(5));\n\n    // Wait some time for the proposal to be applied.\n    let now = Instant::now();\n    loop {\n        thread::sleep(Duration::from_millis(100));\n        if now.saturating_elapsed() > election_timeout * 2 {\n            panic!(\"store {} must apply to {}\", store_id, last_index + 1);\n        }\n        let apply_state = cluster.apply_state(region_id, store_id);\n        if apply_state.applied_index > last_index {\n            break;\n        }\n    }\n\n    // Check if the leader does a local read.\n    must_read_on_peer(cluster, peer, region, key, b\"v1\");\n    let state = cluster.raft_local_state(region_id, store_id);\n    assert_eq!(state.get_last_index(), last_index + 1);\n    assert_eq!(detector.ctx.rl().len(), 3);\n}", "test": "fn test_node_lease_unsafe_during_leader_transfers() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_lease_unsafe_during_leader_transfers(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_preserve_negative_zero_start", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_preserve_negative_zero_start() {\n    new_ucmd!()\n        .args(&[\"-0\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0\\n1\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-0\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-0\\n1\\n2\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-0\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-0\\n1\\n2\\n\")\n        .no_stderr();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_partition_leader_in_majority_detect_in_minority", "code": "fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };\n\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        // Once we see a response on the wire we know a prevote round is happening.\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with failure prevote notifier, got {:?}\", received);\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during failure.\",\n        );\n    }\n\n    // Let the cluster recover.\n    match failure_type {\n        FailureType::Partition(..) => {\n            cluster.clear_send_filters();\n        }\n        FailureType::Reboot(peers) => {\n            cluster.clear_send_filters();\n            peers.iter().for_each(|&peer| {\n                cluster.run_node(peer).unwrap();\n            });\n        }\n    };\n\n    // Prepare to listen.\n    let rx = if let Some((id, _)) = detect_during_recovery {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached recovery prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    if let Some(leader_id) = leader_after_failure_id.into() {\n        cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    };\n\n    // Once we see a response on the wire we know a prevote round is happening.\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with recovery prevote notifier, got {:?}\", received);\n\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during recovery.\",\n        );\n    };\n\n    cluster.must_put(b\"k3\", b\"v3\");\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n}", "test": "fn test_prevote_partition_leader_in_majority_detect_in_minority() {\n    let mut cluster = new_node_cluster(0, 5);\n    // The follower is in the minority and is part of a prevote process. On rejoin\n    // it adopts the old leader.\n    test_prevote(\n        &mut cluster,\n        FailureType::Partition(&[1, 2, 3], &[4, 5]),\n        None,\n        (4, true),\n        None,\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::line_width_parse_errors_overflow", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn line_width_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--line-width\"), (\"321\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"line_width_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::defaultcheck_order", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn defaultcheck_order() {\n    new_ucmd!()\n        .args(&[\"a\", \"bad_order_1\"])\n        .fails()\n        .stderr_only(\"error to be defined\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_while_region_merge", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_stale_read_while_region_merge() {\n    let (mut cluster, pd_client, _) =\n        prepare_for_stale_read_before_run(new_peer(1, 1), Some(Box::new(configure_for_merge)));\n\n    cluster.must_split(&cluster.get_region(&[]), b\"key3\");\n    let source = pd_client.get_region(b\"key1\").unwrap();\n    let target = pd_client.get_region(b\"key5\").unwrap();\n\n    cluster.must_transfer_leader(target.get_id(), new_peer(1, 1));\n    let target_leader = PeerClient::new(&cluster, target.get_id(), new_peer(1, 1));\n    // Write `(key5, value1)`\n    target_leader.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key5\"[..], &b\"value1\"[..])],\n        b\"key5\".to_vec(),\n    );\n\n    let source_leader = cluster.leader_of_region(source.get_id()).unwrap();\n    let source_leader = PeerClient::new(&cluster, source.get_id(), source_leader);\n    // Prewrite on `key1` but not commit yet\n    let k1_prewrite_ts = get_tso(&pd_client);\n    source_leader.must_kv_prewrite(\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n        k1_prewrite_ts,\n    );\n\n    // Write `(key5, value2)`\n    let k5_commit_ts = target_leader.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key5\"[..], &b\"value2\"[..])],\n        b\"key5\".to_vec(),\n    );\n\n    // Merge source region into target region, the lock on source region should also\n    // merge into the target region and cause the target region's `safe_ts`\n    // decrease\n    pd_client.must_merge(source.get_id(), target.get_id());\n\n    let mut follower_client2 = PeerClient::new(&cluster, target.get_id(), new_peer(2, 2));\n    follower_client2.ctx.set_stale_read(true);\n    // We can read `(key5, value1)` with `k1_prewrite_ts`\n    follower_client2.must_kv_read_equal(b\"key5\".to_vec(), b\"value1\".to_vec(), k1_prewrite_ts);\n    // Can't read `key5` with `k5_commit_ts` because `k1_prewrite_ts` is smaller\n    // than `k5_commit_ts`\n    let resp = follower_client2.kv_read(b\"key5\".to_vec(), k5_commit_ts);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    let target_leader = PeerClient::new(&cluster, target.get_id(), new_peer(1, 1));\n    // Commit on `key1`\n    target_leader.must_kv_commit(vec![b\"key1\".to_vec()], k1_prewrite_ts, get_tso(&pd_client));\n    // We can read `(key5, value2)` now\n    follower_client2.must_kv_read_equal(b\"key5\".to_vec(), b\"value2\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_var_array", "code": "fn concat() {\n    run_test_actions([\n        TestAction::run_harness(),\n        // Empty ++ Empty\n        TestAction::assert(\"arrayEquals([].concat([]), [])\"),\n        // Empty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([].concat([1]), [1])\"),\n        // NonEmpty ++ Empty\n        TestAction::assert(\"arrayEquals([1].concat([]), [1])\"),\n        // NonEmpty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([1].concat([1]), [1, 1])\"),\n    ]);\n}", "test": "fn for_in_var_array() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let arr = [\"a\", \"b\"];\n                for (var i in arr) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['0', '1'])\"),\n    ]);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/scopes.rs::test_top_level_strict", "code": "pub fn test(&mut self) {\n        self.test_pass();\n        self.test_fail();\n        self.test_fix();\n    }", "test": "fn test_top_level_strict() {\n    // Module with top-level \"use strict\"\n    SemanticTester::js(\n        r#\"\n    \"use strict\";\n    function foo() {\n        return 1\n    }    \n    \"#,\n    )\n    .has_root_symbol(\"foo\")\n    .is_in_scope(ScopeFlags::Top | ScopeFlags::StrictMode)\n    // .expect(expect_strict)\n    .test();\n\n    // Module without top-level \"use strict\"\n    SemanticTester::js(\n        r#\"\n    function foo() {\n        return 1\n    }    \n    \"#,\n    )\n    .has_root_symbol(\"foo\")\n    .is_in_scope(ScopeFlags::Top | ScopeFlags::StrictMode)\n    .test();\n\n    // Script with top-level \"use strict\"\n    SemanticTester::js(\n        r#\"\n    \"use strict\";\n    function foo() {\n        return 1\n    }    \n    \"#,\n    )\n    .with_module(false)\n    .has_root_symbol(\"foo\")\n    .is_in_scope(ScopeFlags::Top | ScopeFlags::StrictMode)\n    .test();\n\n    // Script without top-level \"use strict\"\n    SemanticTester::js(\n        r#\"\n    function foo() {\n        return 1\n    }    \n    \"#,\n    )\n    .with_module(false)\n    .has_root_symbol(\"foo\")\n    .is_in_scope(ScopeFlags::Top)\n    .is_not_in_scope(ScopeFlags::StrictMode)\n    .test();\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_read", "code": "pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    }", "test": "fn client_complete_io_for_read() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        server\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        {\n            let mut pipe = OtherSession::new(&mut server);\n            let (rdlen, wrlen) = client.complete_io(&mut pipe).unwrap();\n            assert!(rdlen > 0 && wrlen == 0);\n            assert_eq!(pipe.reads, 1);\n        }\n        check_read(&mut client.reader(), b\"01234567890123456789\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_titan.rs::test_delete_files_in_range_for_titan", "code": "fn build(&self, region_id: u64, path: &Path) -> Result<()> {\n        if let Some(mut c) = self.get(region_id) && let Some(db) = c.latest() {\n            let mut checkpointer = db.new_checkpointer()?;\n            // Avoid flush.\n            checkpointer.create_at(path, None, u64::MAX)?;\n            Ok(())\n        } else {\n            Err(Error::Other(format!(\"region {} not found\", region_id).into()))\n        }\n    }", "test": "fn test_delete_files_in_range_for_titan() {\n    let path = Builder::new()\n        .prefix(\"test-titan-delete-files-in-range\")\n        .tempdir()\n        .unwrap();\n\n    // Set configs and create engines\n    let mut cfg = TikvConfig::default();\n    let cache = cfg\n        .storage\n        .block_cache\n        .build_shared_cache(cfg.storage.engine);\n    cfg.rocksdb.titan.enabled = true;\n    cfg.rocksdb.titan.disable_gc = true;\n    cfg.rocksdb.titan.purge_obsolete_files_period = ReadableDuration::secs(1);\n    cfg.rocksdb.defaultcf.disable_auto_compactions = true;\n    // Disable dynamic_level_bytes, otherwise SST files would be ingested to L0.\n    cfg.rocksdb.defaultcf.dynamic_level_bytes = false;\n    cfg.rocksdb.defaultcf.titan.min_gc_batch_size = ReadableSize(0);\n    cfg.rocksdb.defaultcf.titan.discardable_ratio = 0.4;\n    cfg.rocksdb.defaultcf.titan.min_blob_size = ReadableSize(0);\n    let resource = cfg.rocksdb.build_resources(Default::default());\n    let kv_db_opts = cfg.rocksdb.build_opt(&resource, cfg.storage.engine);\n    let kv_cfs_opts = cfg.rocksdb.build_cf_opts(\n        &cfg.rocksdb.build_cf_resources(cache),\n        None,\n        cfg.storage.api_version(),\n        None,\n        cfg.storage.engine,\n    );\n\n    let raft_path = path.path().join(Path::new(\"titan\"));\n    let engines = Engines::new(\n        engine_rocks::util::new_engine_opt(path.path().to_str().unwrap(), kv_db_opts, kv_cfs_opts)\n            .unwrap(),\n        engine_rocks::util::new_engine(raft_path.to_str().unwrap(), &[CF_DEFAULT]).unwrap(),\n    );\n\n    // Write some mvcc keys and values into db\n    // default_cf : a_7, b_7\n    // write_cf : a_8, b_8\n    let start_ts = 7.into();\n    let commit_ts = 8.into();\n    let write = Write::new(WriteType::Put, start_ts, None);\n    engines\n        .kv\n        .put_cf(\n            CF_DEFAULT,\n            &data_key(Key::from_raw(b\"a\").append_ts(start_ts).as_encoded()),\n            b\"a_value\",\n        )\n        .unwrap();\n    engines\n        .kv\n        .put_cf(\n            CF_WRITE,\n            &data_key(Key::from_raw(b\"a\").append_ts(commit_ts).as_encoded()),\n            &write.as_ref().to_bytes(),\n        )\n        .unwrap();\n    engines\n        .kv\n        .put_cf(\n            CF_DEFAULT,\n            &data_key(Key::from_raw(b\"b\").append_ts(start_ts).as_encoded()),\n            b\"b_value\",\n        )\n        .unwrap();\n    engines\n        .kv\n        .put_cf(\n            CF_WRITE,\n            &data_key(Key::from_raw(b\"b\").append_ts(commit_ts).as_encoded()),\n            &write.as_ref().to_bytes(),\n        )\n        .unwrap();\n\n    // Flush and compact the kvs into L6.\n    engines.kv.flush_cfs(&[], true).unwrap();\n    engines.kv.compact_files_in_range(None, None, None).unwrap();\n    let db = engines.kv.as_inner();\n    let value = db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap();\n    assert_eq!(value, 0);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level6\").unwrap();\n    assert_eq!(value, 1);\n\n    // Delete one mvcc kvs we have written above.\n    // Here we make the kvs on the L5 by ingesting SST.\n    let sst_file_path = Path::new(db.path()).join(\"for_ingest.sst\");\n    let mut writer = RocksSstWriterBuilder::new()\n        .build(sst_file_path.to_str().unwrap())\n        .unwrap();\n    writer\n        .delete(&data_key(\n            Key::from_raw(b\"a\").append_ts(start_ts).as_encoded(),\n        ))\n        .unwrap();\n    writer.finish().unwrap();\n    let mut opts = IngestExternalFileOptions::new();\n    opts.move_files(true);\n    let cf_default = db.cf_handle(CF_DEFAULT).unwrap();\n    db.ingest_external_file_cf(cf_default, &opts, &[sst_file_path.to_str().unwrap()])\n        .unwrap();\n\n    // Now the LSM structure of default cf is:\n    // L5: [delete(a_7)]\n    // L6: [put(a_7, blob1), put(b_7, blob1)]\n    // the ranges of two SST files are overlapped.\n    //\n    // There is one blob file in Titan\n    // blob1: (a_7, a_value), (b_7, b_value)\n    let value = db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap();\n    assert_eq!(value, 0);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level5\").unwrap();\n    assert_eq!(value, 1);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level6\").unwrap();\n    assert_eq!(value, 1);\n\n    // Used to trigger titan gc\n    let engine = &engines.kv;\n    engine.put(b\"1\", b\"1\").unwrap();\n    engine.flush_cfs(&[], true).unwrap();\n    engine.put(b\"2\", b\"2\").unwrap();\n    engine.flush_cfs(&[], true).unwrap();\n    engine\n        .compact_files_in_range(Some(b\"0\"), Some(b\"3\"), Some(1))\n        .unwrap();\n\n    // Now the LSM structure of default cf is:\n    // memtable: [put(b_7, blob4)] (because of Titan GC)\n    // L0: [put(1, blob2), put(2, blob3)]\n    // L5: [delete(a_7)]\n    // L6: [put(a_7, blob1), put(b_7, blob1)]\n    // the ranges of two SST files are overlapped.\n    //\n    // There is four blob files in Titan\n    // blob1: (a_7, a_value), (b_7, b_value)\n    // blob2: (1, 1)\n    // blob3: (2, 2)\n    // blob4: (b_7, b_value)\n    let db = engine.as_inner();\n    let value = db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap();\n    assert_eq!(value, 0);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level1\").unwrap();\n    assert_eq!(value, 1);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level5\").unwrap();\n    assert_eq!(value, 1);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level6\").unwrap();\n    assert_eq!(value, 1);\n\n    // Wait Titan to purge obsolete files\n    thread::sleep(Duration::from_secs(2));\n    // Now the LSM structure of default cf is:\n    // memtable: [put(b_7, blob4)] (because of Titan GC)\n    // L0: [put(1, blob2), put(2, blob3)]\n    // L5: [delete(a_7)]\n    // L6: [put(a_7, blob1), put(b_7, blob1)]\n    // the ranges of two SST files are overlapped.\n    //\n    // There is three blob files in Titan\n    // blob2: (1, 1)\n    // blob3: (2, 2)\n    // blob4: (b_7, b_value)\n\n    // `delete_files_in_range` may expose some old keys.\n    // For Titan it may encounter `missing blob file` in `delete_ranges_cfs`,\n    // so we set key_only for Titan.\n    engines\n        .kv\n        .delete_ranges_cfs(\n            DeleteStrategy::DeleteFiles,\n            &[Range::new(\n                &data_key(Key::from_raw(b\"a\").as_encoded()),\n                &data_key(Key::from_raw(b\"b\").as_encoded()),\n            )],\n        )\n        .unwrap();\n    engines\n        .kv\n        .delete_ranges_cfs(\n            DeleteStrategy::DeleteByKey,\n            &[Range::new(\n                &data_key(Key::from_raw(b\"a\").as_encoded()),\n                &data_key(Key::from_raw(b\"b\").as_encoded()),\n            )],\n        )\n        .unwrap();\n    engines\n        .kv\n        .delete_ranges_cfs(\n            DeleteStrategy::DeleteBlobs,\n            &[Range::new(\n                &data_key(Key::from_raw(b\"a\").as_encoded()),\n                &data_key(Key::from_raw(b\"b\").as_encoded()),\n            )],\n        )\n        .unwrap();\n\n    // Now the LSM structure of default cf is:\n    // memtable: [put(b_7, blob4)] (because of Titan GC)\n    // L0: [put(1, blob2), put(2, blob3)]\n    // L6: [put(a_7, blob1), put(b_7, blob1)]\n    // the ranges of two SST files are overlapped.\n    //\n    // There is three blob files in Titan\n    // blob2: (1, 1)\n    // blob3: (2, 2)\n    // blob4: (b_7, b_value)\n    let value = db.get_property_int(\"rocksdb.num-files-at-level0\").unwrap();\n    assert_eq!(value, 0);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level1\").unwrap();\n    assert_eq!(value, 1);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level5\").unwrap();\n    assert_eq!(value, 0);\n    let value = db.get_property_int(\"rocksdb.num-files-at-level6\").unwrap();\n    assert_eq!(value, 1);\n\n    // Generate a snapshot\n    let limiter = Limiter::new(f64::INFINITY);\n    let mut cf_file = CfFile::new(\n        CF_DEFAULT,\n        PathBuf::from(path.path().to_str().unwrap()),\n        \"default\".to_string(),\n        \".sst\".to_string(),\n    );\n    build_sst_cf_file_list::<RocksEngine>(\n        &mut cf_file,\n        &engines.kv,\n        &engines.kv.snapshot(),\n        b\"\",\n        b\"{\",\n        u64::MAX,\n        &limiter,\n    )\n    .unwrap();\n    let mut cf_file_write = CfFile::new(\n        CF_WRITE,\n        PathBuf::from(path.path().to_str().unwrap()),\n        \"write\".to_string(),\n        \".sst\".to_string(),\n    );\n    build_sst_cf_file_list::<RocksEngine>(\n        &mut cf_file_write,\n        &engines.kv,\n        &engines.kv.snapshot(),\n        b\"\",\n        b\"{\",\n        u64::MAX,\n        &limiter,\n    )\n    .unwrap();\n\n    // Apply the snapshot to other DB.\n    let dir1 = Builder::new()\n        .prefix(\"test-snap-cf-db-apply\")\n        .tempdir()\n        .unwrap();\n    let engines1 = new_temp_engine(&dir1);\n    let tmp_file_paths = cf_file.tmp_file_paths();\n    let tmp_file_paths = tmp_file_paths\n        .iter()\n        .map(|s| s.as_str())\n        .collect::<Vec<&str>>();\n    apply_sst_cf_file(&tmp_file_paths, &engines1.kv, CF_DEFAULT).unwrap();\n    let tmp_file_paths = cf_file_write.tmp_file_paths();\n    let tmp_file_paths = tmp_file_paths\n        .iter()\n        .map(|s| s.as_str())\n        .collect::<Vec<&str>>();\n    apply_sst_cf_file(&tmp_file_paths, &engines1.kv, CF_WRITE).unwrap();\n\n    // Do scan on other DB.\n    let mut r = Region::default();\n    r.mut_peers().push(Peer::default());\n    r.set_start_key(b\"a\".to_vec());\n    r.set_end_key(b\"z\".to_vec());\n    let snapshot = RegionSnapshot::<RocksSnapshot>::from_raw(engines1.kv, r);\n    let mut scanner = ScannerBuilder::new(snapshot, 10.into())\n        .range(Some(Key::from_raw(b\"a\")), None)\n        .build()\n        .unwrap();\n    assert_eq!(\n        scanner.next().unwrap(),\n        Some((Key::from_raw(b\"b\"), b\"b_value\".to_vec())),\n    );\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_cert_resolve", "code": "pub fn do_handshake_until_error(\n    client: &mut ClientConnection,\n    server: &mut ServerConnection,\n) -> Result<(), ErrorFromPeer> {\n    while server.is_handshaking() || client.is_handshaking() {\n        transfer(client, server);\n        server\n            .process_new_packets()\n            .map_err(ErrorFromPeer::Server)?;\n        transfer(server, client);\n        client\n            .process_new_packets()\n            .map_err(ErrorFromPeer::Client)?;\n    }\n\n    Ok(())\n}", "test": "fn client_cert_resolve() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        let expected_issuers = match *kt {\n            KeyType::Rsa => vec![\n                b\"0,1*0(\\x06\\x03U\\x04\\x03\\x0c!ponytown RSA level 2 intermediate\".to_vec(),\n                b\"0\\x1a1\\x180\\x16\\x06\\x03U\\x04\\x03\\x0c\\x0fponytown RSA CA\".to_vec(),\n            ],\n            KeyType::Ecdsa => vec![\n                b\"0.1,0*\\x06\\x03U\\x04\\x03\\x0c#ponytown ECDSA level 2 intermediate\".to_vec(),\n                b\"0\\x1c1\\x1a0\\x18\\x06\\x03U\\x04\\x03\\x0c\\x11ponytown ECDSA CA\".to_vec(),\n            ],\n            KeyType::Ed25519 => vec![\n                b\"0.1,0*\\x06\\x03U\\x04\\x03\\x0c#ponytown EdDSA level 2 intermediate\".to_vec(),\n                b\"0\\x1c1\\x1a0\\x18\\x06\\x03U\\x04\\x03\\x0c\\x11ponytown EdDSA CA\".to_vec(),\n            ],\n        };\n\n        for version in rustls::ALL_VERSIONS {\n            let expected_sigschemes = match version.version {\n                ProtocolVersion::TLSv1_2 => vec![\n                    SignatureScheme::ECDSA_NISTP384_SHA384,\n                    SignatureScheme::ECDSA_NISTP256_SHA256,\n                    SignatureScheme::ED25519,\n                    SignatureScheme::RSA_PSS_SHA512,\n                    SignatureScheme::RSA_PSS_SHA384,\n                    SignatureScheme::RSA_PSS_SHA256,\n                    SignatureScheme::RSA_PKCS1_SHA512,\n                    SignatureScheme::RSA_PKCS1_SHA384,\n                    SignatureScheme::RSA_PKCS1_SHA256,\n                ],\n                ProtocolVersion::TLSv1_3 => vec![\n                    SignatureScheme::ECDSA_NISTP384_SHA384,\n                    SignatureScheme::ECDSA_NISTP256_SHA256,\n                    SignatureScheme::ED25519,\n                    SignatureScheme::RSA_PSS_SHA512,\n                    SignatureScheme::RSA_PSS_SHA384,\n                    SignatureScheme::RSA_PSS_SHA256,\n                ],\n                _ => unreachable!(),\n            };\n\n            println!(\"{:?} {:?}:\", version.version, *kt);\n\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config.client_auth_cert_resolver = Arc::new(ClientCheckCertResolve::new(\n                1,\n                expected_issuers.clone(),\n                expected_sigschemes,\n            ));\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(\n                do_handshake_until_error(&mut client, &mut server),\n                Err(ErrorFromPeer::Server(Error::NoCertificatesPresented))\n            );\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_number_r", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nul_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator=\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x004\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"2\\x005\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"3\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_decrease_async_ios", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_decrease_async_ios() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 4;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // Save current async-io tids before shrinking\n    let org_writers_tids = get_async_writers_tids();\n    assert_eq!(4, org_writers_tids.len());\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    // Update config, shrink from 4 to 1\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-io-pool-size\".to_owned(), \"1\".to_owned());\n            change\n        };\n\n        cfg_controller.update(change).unwrap();\n        assert_eq!(\n            cfg_controller.get_current().raft_store.store_io_pool_size,\n            1\n        );\n        // Wait for the completion of decreasing async-ios\n        std::thread::sleep(std::time::Duration::from_secs(1));\n    }\n\n    // Save current async-io tids after scaling down, and compared with the\n    // orginial one before shrinking. As the decreasing of async-ios won't\n    // release asynchronous writers, the thread num should not be updated.\n    let cur_writers_tids = get_async_writers_tids();\n    assert_eq!(cur_writers_tids.len(), org_writers_tids.len());\n    // After shrinking, all the left tids must be there before\n    for tid in cur_writers_tids {\n        assert!(org_writers_tids.contains(&tid));\n    }\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_key_prev_miss_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_key_prev_miss_engine() {\n    let db = default_engine();\n    seek_key_prev_miss(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_do_string_concat", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn can_do_string_concat() {\n    let mut context = Context::new();\n    context.insert(\"a_string\", \"hello\");\n    context.insert(\"another_string\", \"xXx\");\n    context.insert(\"an_int\", &1);\n    context.insert(\"a_float\", &3.18);\n\n    let inputs = vec![\n        (r#\"{{ \"hello\" ~ \" world\" }}\"#, \"hello world\"),\n        (r#\"{{ \"hello\" ~ 1 }}\"#, \"hello1\"),\n        (r#\"{{ \"hello\" ~ 3.18 }}\"#, \"hello3.18\"),\n        (r#\"{{ 3.18 ~ \"hello\"}}\"#, \"3.18hello\"),\n        (r#\"{{ \"hello\" ~ get_string() }}\"#, \"helloHello\"),\n        (r#\"{{ get_string() ~ \"hello\" }}\"#, \"Hellohello\"),\n        (r#\"{{ get_string() ~ 3.18 }}\"#, \"Hello3.18\"),\n        (r#\"{{ a_string ~ \" world\" }}\"#, \"hello world\"),\n        (r#\"{{ a_string ~ ' world ' ~ another_string }}\"#, \"hello world xXx\"),\n        (r#\"{{ a_string ~ another_string }}\"#, \"helloxXx\"),\n        (r#\"{{ a_string ~ an_int }}\"#, \"hello1\"),\n        (r#\"{{ a_string ~ a_float }}\"#, \"hello3.18\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_filter_section", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_filter_section() {\n    assert_err_msg(\n        r#\"{% filter uppercase %}sd\"#,\n        &[\"1:25\", r#\"expected tag or the filter section content\"#],\n    );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::large_add_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn large_add_test() {\n    // Overflow, both single values\n    let mut x = VecType::from_u32(4294967295);\n    let y = VecType::from_u32(5);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    // No overflow, single value\n    let mut x = VecType::from_u32(5);\n    let y = VecType::from_u32(7);\n    bigint::large_add(&mut x, &y);\n    let expected = VecType::from_u32(12);\n    assert_eq!(&*x, &*expected);\n\n    // Single carry, internal overflow\n    let mut x = VecType::from_u64(0x80000000FFFFFFFF);\n    let y = VecType::from_u32(7);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[6, 0x80000001]);\n    assert_eq!(&*x, &*expected);\n\n    // 1st overflows, 2nd doesn't.\n    let mut x = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    let y = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFE, 0xFFFFFFFF]);\n    assert_eq!(&*x, &*expected);\n\n    // Both overflow.\n    let mut x = VecType::from_u64(0x8FFFFFFFFFFFFFFF);\n    let y = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFE, 0x0FFFFFFF, 1]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_on_hibernated_leader", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_on_hibernated_leader() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // wait a while to hibernate\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 3,\n    ));\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_storage_keysize", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_txn_storage_keysize() {\n    let store = AssertionStorage::default();\n    let long_key = vec![b'x'; 10240];\n    store.raw_put_ok(\"\".to_string(), b\"short_key\".to_vec(), b\"v\".to_vec());\n    store.raw_put_err(\"\".to_string(), long_key.clone(), b\"v\".to_vec());\n    store.raw_delete_ok(\"\".to_string(), b\"short_key\".to_vec());\n    store.raw_delete_err(\"\".to_string(), long_key.clone());\n    store.prewrite_ok(\n        vec![Mutation::make_put(\n            Key::from_raw(b\"short_key\"),\n            b\"v\".to_vec(),\n        )],\n        b\"short_key\",\n        1,\n    );\n    store.prewrite_err(\n        vec![Mutation::make_put(Key::from_raw(&long_key), b\"v\".to_vec())],\n        b\"short_key\",\n        1,\n    );\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::compaction", "code": "pub fn compact(&mut self) -> Result<bool, CompactionError> {\n        // Commit to free up any pending free pages\n        // Use 2-phase commit to avoid any possible security issues. Plus this compaction is going to be so slow that it doesn't matter\n        let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n        if txn.list_persistent_savepoints()?.next().is_some() {\n            return Err(CompactionError::PersistentSavepointExists);\n        }\n        if self\n            .transaction_tracker\n            .lock()\n            .unwrap()\n            .any_savepoint_exists()\n        {\n            return Err(CompactionError::EphemeralSavepointExists);\n        }\n        txn.set_durability(Durability::Paranoid);\n        txn.commit().map_err(|e| e.into_storage_error())?;\n        // Repeat, just in case executing list_persistent_savepoints() created a new table\n        let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n        txn.set_durability(Durability::Paranoid);\n        txn.commit().map_err(|e| e.into_storage_error())?;\n        // There can't be any outstanding transactions because we have a `&mut self`, so all pending free pages\n        // should have been cleared out by the above commit()\n        assert!(self.mem.get_freed_root().is_none());\n\n        let mut compacted = false;\n        // Iteratively compact until no progress is made\n        loop {\n            let mut progress = false;\n\n            let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n            if txn.compact_pages()? {\n                progress = true;\n                txn.commit().map_err(|e| e.into_storage_error())?;\n            } else {\n                txn.abort()?;\n            }\n\n            // Double commit to free up the relocated pages for reuse\n            let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n            txn.set_durability(Durability::Paranoid);\n            txn.commit().map_err(|e| e.into_storage_error())?;\n            assert!(self.mem.get_freed_root().is_none());\n\n            if !progress {\n                break;\n            } else {\n                compacted = true;\n            }\n        }\n\n        Ok(compacted)\n    }", "test": "fn compaction() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &[u8]> = TableDefinition::new(\"x\");\n\n    let big_value = vec![0u8; 100 * 1024];\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        // Insert 10MiB of data\n        for i in 0..100 {\n            table.insert(&i, big_value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        // Delete 90% of it\n        for i in 0..90 {\n            table.remove(&i).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n    // Second commit to trigger dynamic compaction\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n\n    // The values are > 1 page, so shouldn't get relocated. Therefore there should be a bunch of fragmented space,\n    // since we left the last 100 values in the db.\n    drop(db);\n    let file_size = tmpfile.as_file().metadata().unwrap().len();\n    let mut db = Database::open(tmpfile.path()).unwrap();\n\n    assert!(db.compact().unwrap());\n    drop(db);\n    let file_size2 = tmpfile.as_file().metadata().unwrap().len();\n    assert!(file_size2 < file_size);\n}"}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::deflate_decoder_empty_read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "test": "fn deflate_decoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder =\n        flate2::write::DeflateEncoder::new(Vec::new(), flate2::Compression::default());\n    encoder.write_all(original).unwrap();\n    let encoded: Vec<u8> = encoder.finish().unwrap();\n    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());\n    assert_eq!(decoder.read(&mut []).unwrap(), 0);\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue500", "code": "pub fn from_str(s: &'i str) -> Self {\n        Self::new(Reader::from_str(s))\n    }", "test": "fn issue500() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TagOne {}\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TagTwo {}\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    enum Tag {\n        TagOne(TagOne),\n        TagTwo(TagTwo),\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Root {\n        #[serde(rename = \"$value\", default)]\n        data: Vec<Tag>,\n    }\n\n    let data: Root = from_str(\n        \"\\\n        <root>\\\n            <TagOne></TagOne>\\\n            <TagTwo></TagTwo>\\\n            <TagOne></TagOne>\\\n        </root>\\\n    \",\n    )\n    .unwrap();\n\n    assert_eq!(\n        data,\n        Root {\n            data: vec![\n                Tag::TagOne(TagOne {}),\n                Tag::TagTwo(TagTwo {}),\n                Tag::TagOne(TagOne {}),\n            ],\n        }\n    );\n\n    let data: Vec<Tag> = from_str(\n        \"\\\n        <TagOne></TagOne>\\\n        <TagTwo></TagTwo>\\\n        <TagOne></TagOne>\\\n    \",\n    )\n    .unwrap();\n\n    assert_eq!(\n        data,\n        vec![\n            Tag::TagOne(TagOne {}),\n            Tag::TagTwo(TagTwo {}),\n            Tag::TagOne(TagOne {}),\n        ]\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_start_matches", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_start_matches() {\n  assert_eval_eq(\"trim_start_matches('oof', 'o')\", \"f\");\n  assert_eval_eq(\"trim_start_matches('ababf', 'ab')\", \"f\");\n  assert_eval_eq(\"trim_start_matches('ababbaf', 'ab')\", \"baf\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_down_node_when_disk_full", "code": "pub fn has_disk_full(&self) -> bool {\n        self.disk_full.is_some()\n    }", "test": "fn test_down_node_when_disk_full() {\n    let mut cluster = new_server_cluster(0, 5);\n    // To ensure the thread has full store disk usage infomation.\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    cluster.cfg.raft_store.max_peer_down_duration = ReadableDuration::secs(1);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    let region = cluster.get_region(b\"k1\");\n    for i in 3..6 {\n        fail::cfg(get_fp(DiskUsage::AlmostFull, i), \"return\").unwrap();\n        ensure_disk_usage_is_reported(&mut cluster, i, i, &region);\n    }\n\n    let lead_client = PeerClient::new(&cluster, 1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&cluster.pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k2\", b\"v2\")],\n        b\"k2\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    lead_client.must_kv_commit(\n        vec![b\"k2\".to_vec()],\n        prewrite_ts,\n        get_tso(&cluster.pd_client),\n    );\n\n    cluster.stop_node(2);\n    wait_down_peers_reported(&cluster, 1, 2u64);\n\n    let prewrite_ts = get_tso(&cluster.pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k3\", b\"v3\")],\n        b\"k3\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    lead_client.must_kv_commit(\n        vec![b\"k3\".to_vec()],\n        prewrite_ts,\n        get_tso(&cluster.pd_client),\n    );\n\n    for i in 3..6 {\n        fail::remove(get_fp(DiskUsage::AlmostFull, i));\n    }\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::expr_test", "code": "pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}", "test": "fn expr_test() {\n  assert_eq!(\n    expr(\" 1 + 2 *  3 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"(1 + (2 * 3))\")))\n  );\n  assert_eq!(\n    expr(\" 1 + 2 *  3 / 4 - 5 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"((1 + ((2 * 3) / 4)) - 5)\")))\n  );\n  assert_eq!(\n    expr(\" 72 / 2 / 3 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"((72 / 2) / 3)\")))\n  );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_function_simple", "code": "pub fn test(self) {\n        let res: Result<_, _> = self.into();\n\n        res.unwrap();\n    }", "test": "fn test_function_simple() {\n    SemanticTester::js(\"function foo() { return }\")\n        .has_root_symbol(\"foo\")\n        .contains_flags(SymbolFlags::Function)\n        .test();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_cast_date_format", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_cast_date_format() {\n    let sql =\n        r\"SELECT CAST(date_valid_from AS DATE FORMAT 'YYYY-MM-DD') AS date_valid_from FROM foo\";\n    bigquery_and_generic().verified_only_select(sql);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_stdin_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_stdin_newline() {\n    new_ucmd!()\n        .args(&[\"-s\", \"-\", \"-w\", \"1\"])\n        .pipe_in(\"Line One\\nLine Two\\n\")\n        .run()\n        .stdout_is(\"1-Line One\\n2-Line Two\\n\");\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::assignment", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn assignment() {\n    test(\"a = b ? c : d\", \"a=b?c:d;\");\n    test(\"[a,b] = (1, 2)\", \"[a,b]=(1,2);\");\n    // `{a,b}` is a block, must wrap the whole expression to be an assignment expression\n    test(\"({a,b} = (1, 2))\", \"({a,b}=(1,2));\");\n    test(\"a *= yield b\", \"a*=yield b;\");\n    test(\"a /= () => {}\", \"a/=()=>{};\");\n    test(\"a %= async () => {}\", \"a%=async()=>{};\");\n    test(\"a -= (1, 2)\", \"a-=(1,2);\");\n    test(\"a >>= b >>= c\", \"a>>=b>>=c;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_equal_as_delimiter3", "code": "pub fn stdout_only_bytes<T: AsRef<[u8]>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is_bytes(msg)\n    }", "test": "fn test_equal_as_delimiter3() {\n    new_ucmd!()\n        .args(&[\"-f\", \"1,2\", \"-d\", \"''\", \"--output-delimiter=Z\"])\n        .pipe_in(\"ab\\0cd\\n\")\n        .succeeds()\n        .stdout_only_bytes(\"abZcd\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_key_miss_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_key_miss_engine() {\n    let db = default_engine();\n    seek_key_miss(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_pat.rs::test_pat_path", "code": "fn parse2(self, tokens: TokenStream) -> Result<T> {\n        let buf = TokenBuffer::new2(tokens);\n        let state = tokens_to_parse_buffer(&buf);\n        let node = self(&state)?;\n        state.check_unexpected()?;\n        if let Some(unexpected_span) = span_of_unexpected_ignoring_nones(state.cursor()) {\n            Err(Error::new(unexpected_span, \"unexpected token\"))\n        } else {\n            Ok(node)\n        }\n    }", "test": "fn test_pat_path() {\n    match Pat::parse_single.parse2(quote!(self::CONST)).unwrap() {\n        Pat::Path(_) => (),\n        value => panic!(\"expected PatPath, got {:?}\", value),\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression7", "code": "fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n                            fixed_key_size,\n                            fixed_value_size,\n                        );\n                        let entry = if reverse {\n                            child_accessor.num_pairs() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Leaf {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            entry,\n                            parent,\n                        }))\n                    }\n                    BRANCH => {\n                        let child_accessor = BranchAccessor::new(&child_page, fixed_key_size);\n                        let child = if reverse {\n                            child_accessor.count_children() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Internal {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            child,\n                            parent,\n                        }))\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", "test": "fn regression7() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let big_value = vec![0u8; 4063];\n        t.insert(&35723, big_value.as_slice()).unwrap();\n        t.remove(&145278).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 47];\n        t.insert(&66469, v.as_slice()).unwrap();\n        let v = vec![0u8; 2414];\n        t.insert(&146255, v.as_slice()).unwrap();\n        let v = vec![0u8; 159];\n        t.insert(&153701, v.as_slice()).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 223];\n        t.insert(&118749, v.as_slice()).unwrap();\n\n        t.remove(&145227).unwrap();\n\n        let mut iter = t.range(138763..(138763 + 232359)).unwrap().rev();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 153701);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 146255);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shred.rs::test_shred_remove", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_shred_remove() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_shred_remove_a\";\n    let file_b = \"test_shred_remove_b\";\n\n    // Create file_a and file_b.\n    at.touch(file_a);\n    at.touch(file_b);\n\n    // Shred file_a.\n    scene.ucmd().arg(\"-u\").arg(file_a).succeeds();\n\n    // file_a was deleted, file_b exists.\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_operator", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_operator() {\n    assert_err_msg(\n        \"{{ hey =! }}\",\n        &[\n            \"1:8\",\n            \"expected `or`, `and`, `not`, `<=`, `>=`, `<`, `>`, `==`, `!=`, `+`, `-`, `*`, `/`, `%`, a filter, or a variable end (`}}`)\"\n        ],\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::mock_nameserver_trust_nx", "code": "fn mock_nameserver_on_send_nx<O: OnSend + Unpin>(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    options: ResolverOpts,\n    on_send: O,\n    addr: IpAddr,\n    trust_negative_responses: bool,\n) -> MockedNameServer<O> {\n    let conn_provider = MockConnProvider {\n        on_send: on_send.clone(),\n        _p: Default::default(),\n    };\n    let client = MockClientHandle::mock_on_send(messages, on_send);\n\n    NameServer::from_conn(\n        NameServerConfig {\n            socket_addr: SocketAddr::new(addr, 0),\n            protocol: Protocol::Udp,\n            tls_dns_name: None,\n            trust_negative_responses,\n            #[cfg(any(feature = \"dns-over-rustls\", feature = \"dns-over-https-rustls\"))]\n            tls_config: None,\n            bind_addr: None,\n        },\n        options,\n        client,\n        conn_provider,\n    )\n}", "test": "fn mock_nameserver_trust_nx(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    options: ResolverOpts,\n    trust_negative_responses: bool,\n) -> MockedNameServer<DefaultOnSend> {\n    mock_nameserver_on_send_nx(\n        messages,\n        options,\n        DefaultOnSend,\n        DEFAULT_SERVER_ADDR,\n        trust_negative_responses,\n    )\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_empty_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iter_empty_snapshot() {\n    let db = default_engine();\n    iter_empty(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_during_merge", "code": "pub fn get_peer_reports(&self) -> &[PeerReport] {\n        &self.peer_reports\n    }", "test": "fn test_unsafe_recovery_during_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n\n    let left_on_store1 = find_peer(&left, 1).unwrap();\n    cluster.must_transfer_leader(left.get_id(), left_on_store1.clone());\n    let right_on_store1 = find_peer(&right, 1).unwrap();\n    cluster.must_transfer_leader(right.get_id(), right_on_store1.clone());\n\n    // Blocks the replication of prepare merge message, so that the commit merge\n    // back fills it in CatchUpLogs.\n    let append_filter = Box::new(\n        RegionPacketFilter::new(left.get_id(), 2)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    );\n    // Blocks the target region from receiving MsgAppendResponse, so that the commit\n    // merge message will only be replicated but not committed.\n    let commit_filter = Box::new(\n        RegionPacketFilter::new(right.get_id(), 1)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppendResponse),\n    );\n    cluster.sim.wl().add_recv_filter(1, append_filter);\n    cluster.sim.wl().add_recv_filter(1, commit_filter);\n\n    pd_client.merge_region(left.get_id(), right.get_id());\n    // Wait until the commit merge is proposed.\n    sleep_ms(300);\n\n    cluster.stop_node(1);\n    cluster.stop_node(3);\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    let report = cluster.must_enter_force_leader(right.get_id(), 2, vec![1, 3]);\n    assert_eq!(report.get_peer_reports().len(), 1);\n    let peer_report = &report.get_peer_reports()[0];\n    assert_eq!(peer_report.get_has_commit_merge(), false);\n    let region = peer_report.get_region_state().get_region();\n    assert_eq!(region.get_id(), right.get_id());\n    assert_eq!(region.get_start_key().len(), 0);\n    assert_eq!(region.get_end_key().len(), 0);\n\n    let to_be_removed: Vec<metapb::Peer> = right\n        .get_peers()\n        .iter()\n        .filter(|&peer| peer.get_store_id() != 2)\n        .cloned()\n        .collect();\n    let mut plan = pdpb::RecoveryPlan::default();\n    let mut demote = pdpb::DemoteFailedVoters::default();\n    demote.set_region_id(right.get_id());\n    demote.set_failed_voters(to_be_removed.into());\n    plan.mut_demotes().push(demote);\n    pd_client.must_set_unsafe_recovery_plan(2, plan);\n    cluster.must_send_store_heartbeat(2);\n\n    let mut demoted = true;\n    for _ in 0..10 {\n        let region = block_on(pd_client.get_region_by_id(right.get_id()))\n            .unwrap()\n            .unwrap();\n\n        demoted = true;\n        for peer in region.get_peers() {\n            if peer.get_id() != 2 && peer.get_role() == metapb::PeerRole::Voter {\n                demoted = false;\n            }\n        }\n        if demoted {\n            break;\n        }\n        sleep_ms(200);\n    }\n    assert!(demoted);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_set", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_set() {\n    let set = \"SET HIVEVAR:name = a, b, c_d\";\n    hive().verified_stmt(set);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_multiple_nonexistent_files", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_multiple_nonexistent_files() {\n    new_ucmd!()\n        .args(&[\"bogusfile1\", \"bogusfile2\"])\n        .fails()\n        .stdout_does_not_contain(\"==> bogusfile1 <==\")\n        .stderr_contains(\"cannot open 'bogusfile1' for reading: No such file or directory\")\n        .stdout_does_not_contain(\"==> bogusfile2 <==\")\n        .stderr_contains(\"cannot open 'bogusfile2' for reading: No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::check_order", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn check_order() {\n    new_ucmd!()\n        .args(&[\"--check-order\", \"bad_order_1\", \"bad_order_2\"])\n        .fails()\n        .stdout_is_fixture(\"bad_order12.check_order.expected\")\n        .stderr_is(\"error to be defined\");\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::test_basic", "code": "fn pretty(f: f64) -> String {\n    ryu::Buffer::new().format(f).to_owned()\n}", "test": "fn test_basic() {\n    check!(0.0);\n    check!(-0.0);\n    check!(1.0);\n    check!(-1.0);\n    assert_eq!(pretty(f64::NAN), \"NaN\");\n    assert_eq!(pretty(f64::INFINITY), \"inf\");\n    assert_eq!(pretty(f64::NEG_INFINITY), \"-inf\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_18", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_18() {\n    let original = r##\"# H1 {.a .a .a}\n\"##;\n    let expected = r##\"<h1 class=\"a a a\">H1</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/attributes.rs::multiple_attributes_one_line_error_message", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn multiple_attributes_one_line_error_message() {\n  Test::new()\n    .justfile(\n      \"\n      [macos, windows linux]\n      [no-exit-message]\n      foo:\n        exit 1\n    \",\n    )\n    .stderr(\n      \"\n        error: Expected ']' or ',', but found identifier\n          |\n        1 | [macos, windows linux]\n          |                 ^^^^^\n          \",\n    )\n    .status(1)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_single.rs::test_node_apply_no_op", "code": "pub fn sleep_ms(ms: u64) {\n    std::thread::sleep(Duration::from_millis(ms));\n}", "test": "fn test_node_apply_no_op() {\n    let mut cluster = test_raftstore::new_node_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    let timer = Instant::now();\n    loop {\n        let state = cluster.apply_state(1, 1);\n        if state.get_applied_index() > RAFT_INIT_LOG_INDEX {\n            break;\n        }\n        if timer.saturating_elapsed() > Duration::from_secs(3) {\n            panic!(\"apply no-op log not finish after 3 seconds\");\n        }\n        sleep_ms(10);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_status_command.rs::test_region_detail", "code": "pub fn has_region(&self) -> bool {\n        self.region.is_some()\n    }", "test": "fn test_region_detail() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.run();\n\n    let leader = cluster.leader_of_region(1).unwrap();\n    let region_detail = cluster.region_detail(1, 1);\n    assert!(region_detail.has_region());\n    let region = region_detail.get_region();\n    assert_eq!(region.get_id(), 1);\n    assert!(region.get_start_key().is_empty());\n    assert!(region.get_end_key().is_empty());\n    assert_eq!(region.get_peers().len(), 5);\n    let epoch = region.get_region_epoch();\n    assert_eq!(epoch.get_conf_ver(), 1);\n    assert_eq!(epoch.get_version(), 1);\n\n    assert!(region_detail.has_leader());\n    assert_eq!(region_detail.get_leader(), &leader);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::test_invalid_break_target", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn test_invalid_break_target() {\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            while (false) {\n                break nonexistent;\n            }\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"undefined break target: nonexistent at line 1, col 1\",\n    )]);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn file_too_large() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement();\\n\".repeat(80660).as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_missing", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_realpath_missing() {\n    let p = Path::new(\"\").join(GIBBERISH).join(GIBBERISH);\n    let (at, mut ucmd) = at_and_ucmd!();\n    let expect = path_concat!(at.root_dir_resolved(), p.to_str().unwrap()) + \"\\n\";\n    ucmd.arg(\"-m\")\n        .arg(p.as_os_str())\n        .succeeds()\n        .stdout_only(expect);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_file_all_filesystems", "code": "fn next(&mut self) -> Option<std::io::Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.sep, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => Some(Ok(buf)),\n            Err(e) => Some(Err(e)),\n        }\n    }", "test": "fn test_output_file_all_filesystems() {\n    // When run with no positional arguments, `df` lets \"-\" represent\n    // the \"File\" entry for each row.\n    let output = new_ucmd!()\n        .arg(\"--output=file\")\n        .succeeds()\n        .stdout_move_str();\n    let mut lines = output.lines();\n    assert_eq!(lines.next().unwrap(), \"File\");\n    for line in lines {\n        assert_eq!(line, \"-\");\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_between_data", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_between_data() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client.recv_frame(frames::headers(1).response(200)).await;\n        client.recv_frame(frames::data(1, &b\"\"[..])).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(2).response(200).eos())\n            .await;\n        client.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Push response to stream 1 and send some data\n        let mut s1_tx = {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            let mut tx = stream.send_response(rsp, false).unwrap();\n            tx.send_data(vec![0; 0].into(), false).unwrap();\n            tx\n        };\n\n        // Promise stream 2 and push response headers\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // End response for stream 1\n        s1_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_div_newline", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_div_newline() {\n    assert_eq!(\"<div></div>\", normalize_html(\"<div>\\n</div>\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_group_followed_by_filename", "code": "pub fn write_all(self, settings: &GlobalSettings, output: Output) -> UResult<()> {\n        let mut out = output.into_write();\n        self.write_all_to(settings, &mut out)\n    }", "test": "fn test_group_followed_by_filename() {\n    let filename = \"test.txt\";\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let mut file = at.make_file(filename);\n    file.write_all(b\"a\\na\\n\").unwrap();\n\n    ucmd.args(&[\"--group\", filename])\n        .run()\n        .success()\n        .stdout_is(\"a\\na\\n\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::write_float_positive_exponent_test", "code": "fn write_float_positive_exponent(mant: u64, exp: i32, options: &Options, expected: &str) {\n    let mut buffer = [b'\\x00'; 512];\n    let fp = ExtendedFloat80 {\n        mant,\n        exp,\n    };\n    let digit_count = f64::digit_count(fp.mant);\n    let sci_exp = fp.exp + digit_count as i32 - 1;\n    let count = unsafe {\n        algorithm::write_float_positive_exponent::<f64, DECIMAL>(&mut buffer, fp, sci_exp, &options)\n    };\n    let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n    assert_eq!(actual, expected);\n}", "test": "fn write_float_positive_exponent_test() {\n    let options = Options::new();\n    write_float_positive_exponent(&mut [b'1'], 0, &options, \"1.0\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 0, &options, \"9.99999999999999\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 1, &options, \"99.9999999999999\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 2, &options, \"999.999999999999\");\n    write_float_positive_exponent(mut_b!(b\"17976931348623157\"), 308, &options, \"179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\");\n\n    let options = Options::builder().trim_floats(true).build().unwrap();\n    write_float_positive_exponent(&mut [b'1'], 0, &options, \"1\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 0, &options, \"9.99999999999999\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 1, &options, \"99.9999999999999\");\n    write_float_positive_exponent(mut_b!(b\"999999999999999\"), 2, &options, \"999.999999999999\");\n    write_float_positive_exponent(mut_b!(b\"17976931348623157\"), 308, &options, \"179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_list_all_signals", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_kill_list_all_signals() {\n    // Check for a few signals.  Do not try to be comprehensive.\n    new_ucmd!()\n        .arg(\"-l\")\n        .succeeds()\n        .stdout_contains(\"KILL\")\n        .stdout_contains(\"TERM\")\n        .stdout_contains(\"HUP\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_write", "code": "pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    }", "test": "fn server_complete_io_for_write() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        server\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        server\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        {\n            let mut pipe = OtherSession::new(&mut client);\n            let (rdlen, wrlen) = server.complete_io(&mut pipe).unwrap();\n            assert!(rdlen == 0 && wrlen > 0);\n            assert_eq!(pipe.writevs, vec![vec![42, 42]]);\n        }\n        check_read(\n            &mut client.reader(),\n            b\"0123456789012345678901234567890123456789\",\n        );\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::repeated_request_response", "code": "pub fn accept(&self) -> Accept<'_> {\n        Accept {\n            endpoint: self,\n            notify: self.inner.shared.incoming.notified(),\n        }\n    }", "test": "fn repeated_request_response() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            max_concurrent_bidi_streams: 1u32.into(),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    const REQUEST: &[u8] = b\"hello\";\n    const RESPONSE: &[u8] = b\"world\";\n    for _ in 0..3 {\n        let s = pair.client_streams(client_ch).open(Dir::Bi).unwrap();\n\n        pair.client_send(client_ch, s).write(REQUEST).unwrap();\n        pair.client_send(client_ch, s).finish().unwrap();\n\n        pair.drive();\n\n        assert_eq!(pair.server_streams(server_ch).accept(Dir::Bi), Some(s));\n        let mut recv = pair.server_recv(server_ch, s);\n        let mut chunks = recv.read(false).unwrap();\n        assert_matches!(\n            chunks.next(usize::MAX),\n            Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == REQUEST\n        );\n\n        assert_matches!(chunks.next(usize::MAX), Ok(None));\n        let _ = chunks.finalize();\n        pair.server_send(server_ch, s).write(RESPONSE).unwrap();\n        pair.server_send(server_ch, s).finish().unwrap();\n\n        pair.drive();\n\n        let mut recv = pair.client_recv(client_ch, s);\n        let mut chunks = recv.read(false).unwrap();\n        assert_matches!(\n            chunks.next(usize::MAX),\n            Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == RESPONSE\n        );\n        assert_matches!(chunks.next(usize::MAX), Ok(None));\n        let _ = chunks.finalize();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_owner_colon", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_only_owner_colon() {\n    // test chown username: file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_name}:\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .succeeds()\n        .stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_name}.\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .succeeds()\n        .stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"root:\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_migrate_replication_mode", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_migrate_replication_mode() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.pd_store_heartbeat_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 10;\n    cluster.add_label(1, \"zone\", \"ES\");\n    cluster.add_label(2, \"zone\", \"ES\");\n    cluster.add_label(3, \"zone\", \"WS\");\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n    cluster.must_put(b\"k1\", b\"v0\");\n    // Non exists label key can't tolerate any node unavailable.\n    cluster.pd_client.configure_dr_auto_sync(\"host\");\n    thread::sleep(Duration::from_millis(100));\n    let region = cluster.get_region(b\"k1\");\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k2\", b\"v2\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    must_get_none(&cluster.get_engine(1), b\"k2\");\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 1);\n    assert_eq!(state.state, RegionReplicationState::SimpleMajority);\n\n    // Correct label key should resume committing log\n    cluster.pd_client.configure_dr_auto_sync(\"zone\");\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 2);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_inf", "code": "pub fn run(&mut self) -> CmdResult {\n        self.run_no_wait().wait().unwrap()\n    }", "test": "fn test_inf() {\n    run(&[\"inf\"], b\"1\\n2\\n3\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/router.rs::test_basic", "code": "pub fn shutdown(&mut self) {\n        if self.name_prefix.is_none() {\n            return;\n        }\n        let name_prefix = self.name_prefix.take().unwrap();\n        info!(\"shutdown batch system {}\", name_prefix);\n        self.router.broadcast_shutdown();\n        let mut last_error = None;\n        for h in self.workers.lock().unwrap().drain(..) {\n            debug!(\"waiting for {}\", h.thread().name().unwrap());\n            if let Err(e) = h.join() {\n                error!(\"failed to join worker thread: {:?}\", e);\n                last_error = Some(e);\n            }\n        }\n        if let Some(e) = last_error {\n            safe_panic!(\"failed to join worker thread: {:?}\", e);\n        }\n        info!(\"batch system {} is stopped.\", name_prefix);\n    }", "test": "fn test_basic() {\n    let (control_tx, mut control_fsm) = Runner::new(10);\n    let (control_drop_tx, control_drop_rx) = mpsc::unbounded();\n    control_fsm.sender = Some(control_drop_tx);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n\n    // Missing mailbox should report error.\n    match router.force_send(1, unreachable()) {\n        Err(SendError(_)) => (),\n        Ok(_) => panic!(\"send should fail\"),\n    }\n    match router.send(1, unreachable()) {\n        Err(TrySendError::Disconnected(_)) => (),\n        Ok(_) => panic!(\"send should fail\"),\n        Err(TrySendError::Full(_)) => panic!(\"expect disconnected.\"),\n    }\n\n    let (tx, rx) = mpsc::unbounded();\n    let router_ = router.clone();\n    // Control mailbox should be connected.\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (sender, mut runner) = Runner::new(10);\n                let (tx1, rx1) = mpsc::unbounded();\n                runner.sender = Some(tx1);\n                let mailbox = BasicMailbox::new(sender, runner, Arc::default());\n                router_.register(1, mailbox);\n                tx.send(rx1).unwrap();\n            },\n        )))\n        .unwrap();\n    let runner_drop_rx = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n\n    // Registered mailbox should be connected.\n    router.force_send(1, noop()).unwrap();\n    router.send(1, noop()).unwrap();\n\n    // Send should respect capacity limit, while force_send not.\n    let (tx, rx) = mpsc::unbounded();\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                rx.recv_timeout(Duration::from_secs(100)).unwrap();\n            })),\n        )\n        .unwrap();\n    let counter = Arc::default();\n    let sent_cnt = (0..)\n        .take_while(|_| router.send(1, counter_closure(&counter)).is_ok())\n        .count();\n    match router.send(1, counter_closure(&counter)) {\n        Err(TrySendError::Full(_)) => {}\n        Err(TrySendError::Disconnected(_)) => panic!(\"mailbox should still be connected.\"),\n        Ok(_) => panic!(\"send should fail\"),\n    }\n    router.force_send(1, counter_closure(&counter)).unwrap();\n    tx.send(1).unwrap();\n    // Flush.\n    let (tx, rx) = mpsc::unbounded();\n    router\n        .force_send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(1).unwrap();\n            })),\n        )\n        .unwrap();\n    rx.recv_timeout(Duration::from_secs(100)).unwrap();\n\n    let c = counter.load(Ordering::SeqCst);\n    assert_eq!(c, sent_cnt + 1);\n\n    // close should release resources.\n    assert_eq!(runner_drop_rx.try_recv(), Err(TryRecvError::Empty));\n    router.close(1);\n    assert_eq!(\n        runner_drop_rx.recv_timeout(Duration::from_secs(3)),\n        Err(RecvTimeoutError::Disconnected)\n    );\n    match router.send(1, unreachable()) {\n        Err(TrySendError::Disconnected(_)) => (),\n        Ok(_) => panic!(\"send should fail.\"),\n        Err(TrySendError::Full(_)) => panic!(\"sender should be closed\"),\n    }\n    match router.force_send(1, unreachable()) {\n        Err(SendError(_)) => (),\n        Ok(_) => panic!(\"send should fail.\"),\n    }\n    assert_eq!(control_drop_rx.try_recv(), Err(TryRecvError::Empty));\n    system.shutdown();\n    assert_eq!(\n        control_drop_rx.recv_timeout(Duration::from_secs(3)),\n        Err(RecvTimeoutError::Disconnected)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_zero_step", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_zero_step() {\n    new_ucmd!().args(&[\"10\", \"0\", \"32\"]).fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_accept_proposal_during_conf_change", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_accept_proposal_during_conf_change() {\n    let mut cluster = new_node_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let r = cluster.run_conf_change();\n    cluster.must_put(b\"a\", b\"v\");\n\n    let conf_change_fp = \"apply_on_conf_change_all_1\";\n    fail::cfg(conf_change_fp, \"pause\").unwrap();\n    let mut add_peer_rx = cluster.async_add_peer(r, new_peer(2, 2)).unwrap();\n    add_peer_rx\n        .recv_timeout(Duration::from_millis(100))\n        .unwrap_err();\n\n    // Conf change doesn't affect proposals.\n    let write_req = make_write_req(&mut cluster, b\"k\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    cb_receivers\n        .committed\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    cb_receivers.proposed.try_recv().unwrap();\n\n    fail::remove(conf_change_fp);\n    assert!(\n        !add_peer_rx\n            .recv_timeout(Duration::from_secs(1))\n            .unwrap()\n            .get_header()\n            .has_error()\n    );\n    assert!(\n        !cb_receivers\n            .applied\n            .recv_timeout(Duration::from_secs(1))\n            .unwrap()\n            .get_header()\n            .has_error()\n    );\n    must_get_equal(&cluster.get_engine(2), b\"k\", b\"v\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit126_wasi_snapshot1", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit126_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit126_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[wasm.path().to_str().unwrap(), \"-Ccache=n\"], None)?;\n    assert_eq!(output.status.code().unwrap(), 1);\n    assert!(output.stdout.is_empty());\n    assert!(String::from_utf8_lossy(&output.stderr).contains(\"invalid exit status\"));\n    Ok(())\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_externally_a_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_externally_a_ser() {\n    let v = EnumStructExternally::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    let e = \"VariantA(foo:1,bar:2,different:3)\";\n    test_ser(&v, e);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_random_latency", "code": "fn test_multi_random_latency<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(RandomLatencyFilter::new(50)));\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_server_random_latency() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_random_latency(&mut cluster);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/options_tests.rs::options_tests", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn options_tests() {\n    let builder = OptionsBuilder::new();\n    assert!(builder.is_valid());\n    assert!(unsafe { builder.build_unchecked() }.is_valid());\n    assert!(OptionsBuilder::default().is_valid());\n\n    let options: Options = Options::new();\n    assert!(options.is_valid());\n    assert_eq!(options, Options::default());\n    assert!(OptionsBuilder::new().build().is_ok());\n    assert!(OptionsBuilder::default().build().is_ok());\n    assert!(OptionsBuilder::default().is_valid());\n    assert_eq!(options.rebuild(), Options::builder());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_preserve_final_newline_when_line_less_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_preserve_final_newline_when_line_less_than_fold() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"1234\\n\")\n        .succeeds()\n        .stdout_is(\"1234\\n\");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::init_decl", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn init_decl() {\n    let needle = \"{$foo = 100;}\";\n    let source = \"void bar() {int foo = 100; char *foo =100;}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 2);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_decimal_point_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_decimal_point_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.decimal_point(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.decimal_point(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.decimal_point(b',');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_positive_lines() {\n    new_ucmd!()\n        .args(&[\"-n\", \"+3\"])\n        .pipe_in(\"a\\nb\\nc\\nd\\ne\\n\")\n        .succeeds()\n        .stdout_is(\"c\\nd\\ne\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_sequence2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_sequence2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%0$%\", \"{1}\", \"%^4%\"])\n        .succeeds()\n        .stdout_only(\"33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(40, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_for_prev_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_for_prev_snapshot() {\n    let db = default_engine();\n    seek_for_prev(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_invalid_option", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_invalid_option() {\n    new_ucmd!().arg(\"-w\").arg(\"/\").fails();\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::implicit_open", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn implicit_open() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s1 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    let s2 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    pair.client_send(client_ch, s2).write(b\"hello\").unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), Some(s1));\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), Some(s2));\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), None);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_transaction", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_transaction() {\n    let ser = include_bytes!(\"data/serde/transaction_ser\");\n    let tx: Transaction = deserialize(ser).unwrap();\n    let got = serialize(&tx).unwrap();\n    let want = include_bytes!(\"data/serde/transaction_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_jpg", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_jpg() {\n    truncate_images(\"jpg\")\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sum.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/sst.rs::external_sst_info_key_values_with_delete", "code": "fn smallest_key(&self) -> &[u8] {\n        panic!()\n    }", "test": "fn external_sst_info_key_values_with_delete() -> Result<()> {\n    let tempdir = tempdir();\n    let sst_path = tempdir\n        .path()\n        .join(\"test-data.sst\")\n        .to_string_lossy()\n        .to_string();\n    let sst_builder = <KvTestEngine as SstExt>::SstWriterBuilder::new();\n    let mut sst_writer = sst_builder.build(&sst_path)?;\n\n    sst_writer.delete(b\"k1\")?;\n\n    let info = sst_writer.finish()?;\n\n    assert_eq!(b\"k1\", info.smallest_key());\n    assert_eq!(b\"k1\", info.largest_key());\n    assert_eq!(1, info.num_entries());\n\n    let size = fs::metadata(&sst_path).unwrap().len();\n\n    assert_eq!(size, info.file_size());\n\n    Ok(())\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_empty_extends", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_empty_extends() {\n    test_formatting(\n        r#\"\n        class A extends Object {}\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_nested_paths_copy_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_nested_paths_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let dir1 = \"source_dir\";\n    let dir2 = \"target_dir\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    at.touch(format!(\"{dir1}/{file1}\"));\n\n    ucmd.arg(format!(\"{dir1}/{file1}\"))\n        .arg(dir2)\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(format!(\"{dir2}/{file1}\")));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typed_struct_syntax", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_typed_struct_syntax() {\n    // typed struct syntax https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#typed_struct_syntax\n    // syntax: STRUCT<[field_name] field_type, ...>( expr1 [, ... ])\n\n    let sql = r#\"SELECT STRUCT<INT64>(5), STRUCT<x INT64, y STRING>(1, t.str_col), STRUCT<arr ARRAY<FLOAT64>, str STRUCT<BOOL>>(nested_col)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Int64,\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![\n                Expr::Value(number(\"1\")),\n                Expr::CompoundIdentifier(vec![\n                    Ident {\n                        value: \"t\".into(),\n                        quote_style: None,\n                    },\n                    Ident {\n                        value: \"str_col\".into(),\n                        quote_style: None,\n                    },\n                ]),\n            ],\n            fields: vec![\n                StructField {\n                    field_name: Some(Ident {\n                        value: \"x\".into(),\n                        quote_style: None,\n                    }),\n                    field_type: DataType::Int64\n                },\n                StructField {\n                    field_name: Some(Ident {\n                        value: \"y\".into(),\n                        quote_style: None,\n                    }),\n                    field_type: DataType::String(None)\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Identifier(Ident {\n                value: \"nested_col\".into(),\n                quote_style: None,\n            }),],\n            fields: vec![\n                StructField {\n                    field_name: Some(\"arr\".into()),\n                    field_type: DataType::Array(ArrayElemTypeDef::AngleBracket(Box::new(\n                        DataType::Float64\n                    )))\n                },\n                StructField {\n                    field_name: Some(\"str\".into()),\n                    field_type: DataType::Struct(vec![StructField {\n                        field_name: None,\n                        field_type: DataType::Bool\n                    }])\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n\n    let sql = r#\"SELECT STRUCT<x STRUCT, y ARRAY<STRUCT>>(nested_col)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(1, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Identifier(Ident {\n                value: \"nested_col\".into(),\n                quote_style: None,\n            }),],\n            fields: vec![\n                StructField {\n                    field_name: Some(\"x\".into()),\n                    field_type: DataType::Struct(Default::default())\n                },\n                StructField {\n                    field_name: Some(\"y\".into()),\n                    field_type: DataType::Array(ArrayElemTypeDef::AngleBracket(Box::new(\n                        DataType::Struct(Default::default())\n                    )))\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n\n    let sql = r#\"SELECT STRUCT<BOOL>(true), STRUCT<BYTES(42)>(B'abc')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::Boolean(true)),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Bool\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::SingleQuotedByteStringLiteral(\n                \"abc\".into()\n            )),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Bytes(Some(42))\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<DATE>(\"2011-05-05\"), STRUCT<DATETIME>(DATETIME '1999-01-01 01:23:34.45'), STRUCT<FLOAT64>(5.0), STRUCT<INT64>(1)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(4, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\n                \"2011-05-05\".to_string()\n            )),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Date\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Datetime(None),\n                value: \"1999-01-01 01:23:34.45\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Datetime(None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5.0\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Float64\n            }]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"1\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Int64\n            }]\n        },\n        expr_from_projection(&select.projection[3])\n    );\n\n    let sql = r#\"SELECT STRUCT<INTERVAL>(INTERVAL '1-2 3 4:5:6.789999'), STRUCT<JSON>(JSON '{\"class\" : {\"students\" : [{\"name\" : \"Jane\"}]}}')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Interval(ast::Interval {\n                value: Box::new(Expr::Value(Value::SingleQuotedString(\n                    \"1-2 3 4:5:6.789999\".to_string()\n                ))),\n                leading_field: None,\n                leading_precision: None,\n                last_field: None,\n                fractional_seconds_precision: None\n            }),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Interval\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::JSON,\n                value: r#\"{\"class\" : {\"students\" : [{\"name\" : \"Jane\"}]}}\"#.to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::JSON\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<STRING(42)>(\"foo\"), STRUCT<TIMESTAMP>(TIMESTAMP '2008-12-25 15:30:00 America/Los_Angeles'), STRUCT<TIME>(TIME '15:30:00')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\"foo\".to_string())),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::String(Some(42))\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Timestamp(None, TimezoneInfo::None),\n                value: \"2008-12-25 15:30:00 America/Los_Angeles\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Timestamp(None, TimezoneInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Time(None, TimezoneInfo::None),\n                value: \"15:30:00\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Time(None, TimezoneInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n\n    let sql = r#\"SELECT STRUCT<NUMERIC>(NUMERIC '1'), STRUCT<BIGNUMERIC>(BIGNUMERIC '1')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Numeric(ExactNumberInfo::None),\n                value: \"1\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Numeric(ExactNumberInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::BigNumeric(ExactNumberInfo::None),\n                value: \"1\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::BigNumeric(ExactNumberInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_pubsub.rs::test_multiple_subscribers", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "pub fn test_multiple_subscribers() {\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        report_receiver_interval: ReadableDuration::secs(3),\n        precision: ReadableDuration::secs(1),\n        ..Default::default()\n    });\n\n    // Workload\n    // [req-1, req-2]\n    test_suite.setup_workload(vec![\"req-1\", \"req-2\"]);\n    let jhs: Vec<_> = (0..3)\n        .map(|_| {\n            let (client, stream) = test_suite.subscribe();\n            test_suite.rt.spawn(async move {\n                let _client = client;\n                let tags = stream.take(4).map(|record| {\n                    String::from_utf8_lossy(record.unwrap().get_record().get_resource_group_tag())\n                        .into_owned()\n                });\n                tags.collect::<HashSet<_>>().await\n            })\n        })\n        .collect();\n\n    for jh in jhs {\n        let res = test_suite.rt.block_on(jh).unwrap();\n        assert!(res.contains(\"req-1\"));\n        assert!(res.contains(\"req-2\"));\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_il", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_il() {\n    // Test iterators that skip single, internal or leading-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4_5__.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix_via_env", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_custom_backup_suffix_via_env() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_12", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_12() {\n    let original = r##\"# H1 { #id1\n## H2 {#id2\n\"##;\n    let expected = r##\"<h1>H1 { #id1</h1>\n<h2>H2 {#id2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_retry_async", "code": "fn test_retry<F: Fn(&RpcClient)>(func: F) {\n    let eps_count = 1;\n    // Retry mocker returns `Err(_)` for most request, here two thirds are `Err(_)`.\n    let retry = Arc::new(Retry::new(3));\n    let server = MockServer::with_case(eps_count, retry);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps, None);\n\n    for _ in 0..3 {\n        func(&client);\n    }\n}", "test": "fn test_retry_async() {\n    let r#async = |client: &RpcClient| {\n        block_on(client.get_region_by_id(1)).unwrap();\n    };\n    test_retry(r#async);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u128_pow2_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u128_pow2_test() {\n    let values: &[u128] = &[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        15,\n        16,\n        17,\n        31,\n        32,\n        33,\n        63,\n        64,\n        65,\n        127,\n        128,\n        129,\n        255,\n        256,\n        257,\n        511,\n        512,\n        513,\n        1023,\n        1024,\n        1025,\n        2047,\n        2048,\n        2049,\n        4095,\n        4096,\n        4097,\n        8191,\n        8192,\n        8193,\n        16383,\n        16384,\n        16385,\n        32767,\n        32768,\n        32769,\n        65535,\n        65536,\n        65537,\n        131071,\n        131072,\n        131073,\n        262143,\n        262144,\n        262145,\n        524287,\n        524288,\n        524289,\n        1048575,\n        1048576,\n        1048577,\n        2097151,\n        2097152,\n        2097153,\n        4194303,\n        4194304,\n        4194305,\n        8388607,\n        8388608,\n        8388609,\n        16777215,\n        16777216,\n        16777217,\n        33554431,\n        33554432,\n        33554433,\n        67108863,\n        67108864,\n        67108865,\n        134217727,\n        134217728,\n        134217729,\n        268435455,\n        268435456,\n        268435457,\n        536870911,\n        536870912,\n        536870913,\n        1073741823,\n        1073741824,\n        1073741825,\n        2147483647,\n        2147483648,\n        2147483649,\n        4294967295,\n        4294967296,\n        4294967297,\n        8589934591,\n        8589934592,\n        8589934593,\n        17179869183,\n        17179869184,\n        17179869185,\n        34359738367,\n        34359738368,\n        34359738369,\n        68719476735,\n        68719476736,\n        68719476737,\n        137438953471,\n        137438953472,\n        137438953473,\n        274877906943,\n        274877906944,\n        274877906945,\n        549755813887,\n        549755813888,\n        549755813889,\n        1099511627775,\n        1099511627776,\n        1099511627777,\n        2199023255551,\n        2199023255552,\n        2199023255553,\n        4398046511103,\n        4398046511104,\n        4398046511105,\n        8796093022207,\n        8796093022208,\n        8796093022209,\n        17592186044415,\n        17592186044416,\n        17592186044417,\n        35184372088831,\n        35184372088832,\n        35184372088833,\n        70368744177663,\n        70368744177664,\n        70368744177665,\n        140737488355327,\n        140737488355328,\n        140737488355329,\n        281474976710655,\n        281474976710656,\n        281474976710657,\n        562949953421311,\n        562949953421312,\n        562949953421313,\n        1125899906842623,\n        1125899906842624,\n        1125899906842625,\n        2251799813685247,\n        2251799813685248,\n        2251799813685249,\n        4503599627370495,\n        4503599627370496,\n        4503599627370497,\n        9007199254740991,\n        9007199254740992,\n        9007199254740993,\n        18014398509481983,\n        18014398509481984,\n        18014398509481985,\n        36028797018963967,\n        36028797018963968,\n        36028797018963969,\n        72057594037927935,\n        72057594037927936,\n        72057594037927937,\n        144115188075855871,\n        144115188075855872,\n        144115188075855873,\n        288230376151711743,\n        288230376151711744,\n        288230376151711745,\n        576460752303423487,\n        576460752303423488,\n        576460752303423489,\n        1152921504606846975,\n        1152921504606846976,\n        1152921504606846977,\n        2305843009213693951,\n        2305843009213693952,\n        2305843009213693953,\n        4611686018427387903,\n        4611686018427387904,\n        4611686018427387905,\n        9223372036854775807,\n        9223372036854775808,\n        9223372036854775809,\n        18446744073709551615,\n        18446744073709551616,\n        18446744073709551617,\n        36893488147419103231,\n        36893488147419103232,\n        36893488147419103233,\n        73786976294838206463,\n        73786976294838206464,\n        73786976294838206465,\n        147573952589676412927,\n        147573952589676412928,\n        147573952589676412929,\n        295147905179352825855,\n        295147905179352825856,\n        295147905179352825857,\n        590295810358705651711,\n        590295810358705651712,\n        590295810358705651713,\n        1180591620717411303423,\n        1180591620717411303424,\n        1180591620717411303425,\n        2361183241434822606847,\n        2361183241434822606848,\n        2361183241434822606849,\n        4722366482869645213695,\n        4722366482869645213696,\n        4722366482869645213697,\n        9444732965739290427391,\n        9444732965739290427392,\n        9444732965739290427393,\n        18889465931478580854783,\n        18889465931478580854784,\n        18889465931478580854785,\n        37778931862957161709567,\n        37778931862957161709568,\n        37778931862957161709569,\n        75557863725914323419135,\n        75557863725914323419136,\n        75557863725914323419137,\n        151115727451828646838271,\n        151115727451828646838272,\n        151115727451828646838273,\n        302231454903657293676543,\n        302231454903657293676544,\n        302231454903657293676545,\n        604462909807314587353087,\n        604462909807314587353088,\n        604462909807314587353089,\n        1208925819614629174706175,\n        1208925819614629174706176,\n        1208925819614629174706177,\n        2417851639229258349412351,\n        2417851639229258349412352,\n        2417851639229258349412353,\n        4835703278458516698824703,\n        4835703278458516698824704,\n        4835703278458516698824705,\n        9671406556917033397649407,\n        9671406556917033397649408,\n        9671406556917033397649409,\n        19342813113834066795298815,\n        19342813113834066795298816,\n        19342813113834066795298817,\n        38685626227668133590597631,\n        38685626227668133590597632,\n        38685626227668133590597633,\n        77371252455336267181195263,\n        77371252455336267181195264,\n        77371252455336267181195265,\n        154742504910672534362390527,\n        154742504910672534362390528,\n        154742504910672534362390529,\n        309485009821345068724781055,\n        309485009821345068724781056,\n        309485009821345068724781057,\n        618970019642690137449562111,\n        618970019642690137449562112,\n        618970019642690137449562113,\n        1237940039285380274899124223,\n        1237940039285380274899124224,\n        1237940039285380274899124225,\n        2475880078570760549798248447,\n        2475880078570760549798248448,\n        2475880078570760549798248449,\n        4951760157141521099596496895,\n        4951760157141521099596496896,\n        4951760157141521099596496897,\n        9903520314283042199192993791,\n        9903520314283042199192993792,\n        9903520314283042199192993793,\n        19807040628566084398385987583,\n        19807040628566084398385987584,\n        19807040628566084398385987585,\n        39614081257132168796771975167,\n        39614081257132168796771975168,\n        39614081257132168796771975169,\n        79228162514264337593543950335,\n        79228162514264337593543950336,\n        79228162514264337593543950337,\n        158456325028528675187087900671,\n        158456325028528675187087900672,\n        158456325028528675187087900673,\n        316912650057057350374175801343,\n        316912650057057350374175801344,\n        316912650057057350374175801345,\n        633825300114114700748351602687,\n        633825300114114700748351602688,\n        633825300114114700748351602689,\n        1267650600228229401496703205375,\n        1267650600228229401496703205376,\n        1267650600228229401496703205377,\n        2535301200456458802993406410751,\n        2535301200456458802993406410752,\n        2535301200456458802993406410753,\n        5070602400912917605986812821503,\n        5070602400912917605986812821504,\n        5070602400912917605986812821505,\n        10141204801825835211973625643007,\n        10141204801825835211973625643008,\n        10141204801825835211973625643009,\n        20282409603651670423947251286015,\n        20282409603651670423947251286016,\n        20282409603651670423947251286017,\n        40564819207303340847894502572031,\n        40564819207303340847894502572032,\n        40564819207303340847894502572033,\n        81129638414606681695789005144063,\n        81129638414606681695789005144064,\n        81129638414606681695789005144065,\n        162259276829213363391578010288127,\n        162259276829213363391578010288128,\n        162259276829213363391578010288129,\n        324518553658426726783156020576255,\n        324518553658426726783156020576256,\n        324518553658426726783156020576257,\n        649037107316853453566312041152511,\n        649037107316853453566312041152512,\n        649037107316853453566312041152513,\n        1298074214633706907132624082305023,\n        1298074214633706907132624082305024,\n        1298074214633706907132624082305025,\n        2596148429267413814265248164610047,\n        2596148429267413814265248164610048,\n        2596148429267413814265248164610049,\n        5192296858534827628530496329220095,\n        5192296858534827628530496329220096,\n        5192296858534827628530496329220097,\n        10384593717069655257060992658440191,\n        10384593717069655257060992658440192,\n        10384593717069655257060992658440193,\n        20769187434139310514121985316880383,\n        20769187434139310514121985316880384,\n        20769187434139310514121985316880385,\n        41538374868278621028243970633760767,\n        41538374868278621028243970633760768,\n        41538374868278621028243970633760769,\n        83076749736557242056487941267521535,\n        83076749736557242056487941267521536,\n        83076749736557242056487941267521537,\n        166153499473114484112975882535043071,\n        166153499473114484112975882535043072,\n        166153499473114484112975882535043073,\n        332306998946228968225951765070086143,\n        332306998946228968225951765070086144,\n        332306998946228968225951765070086145,\n        664613997892457936451903530140172287,\n        664613997892457936451903530140172288,\n        664613997892457936451903530140172289,\n        1329227995784915872903807060280344575,\n        1329227995784915872903807060280344576,\n        1329227995784915872903807060280344577,\n        2658455991569831745807614120560689151,\n        2658455991569831745807614120560689152,\n        2658455991569831745807614120560689153,\n        5316911983139663491615228241121378303,\n        5316911983139663491615228241121378304,\n        5316911983139663491615228241121378305,\n        10633823966279326983230456482242756607,\n        10633823966279326983230456482242756608,\n        10633823966279326983230456482242756609,\n        21267647932558653966460912964485513215,\n        21267647932558653966460912964485513216,\n        21267647932558653966460912964485513217,\n        42535295865117307932921825928971026431,\n        42535295865117307932921825928971026432,\n        42535295865117307932921825928971026433,\n        85070591730234615865843651857942052863,\n        85070591730234615865843651857942052864,\n        85070591730234615865843651857942052865,\n        170141183460469231731687303715884105727,\n        170141183460469231731687303715884105728,\n        170141183460469231731687303715884105729,\n        340282366920938463463374607431768211455,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_verbose", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source = \"create_leading_test_file\";\n    let target = \"dir1/no-dir2/no-dir3/test_file\";\n\n    at.touch(source);\n    at.mkdir(\"dir1\");\n\n    let creating_dir1 = regex::Regex::new(\"(?m)^install: creating directory.*dir1'$\").unwrap();\n    let creating_nodir23 =\n        regex::Regex::new(r\"(?m)^install: creating directory.*no-dir[23]'$\").unwrap();\n\n    scene\n        .ucmd()\n        .arg(\"-Dv\")\n        .arg(source)\n        .arg(at.plus(target))\n        .succeeds()\n        .stdout_matches(&creating_nodir23)\n        .stdout_does_not_match(&creating_dir1)\n        .no_stderr();\n\n    assert!(at.file_exists(target));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_boot", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_boot() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-b\", \"--boot\", \"--b\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file1 = \"source_file1\";\n    let file2 = \"source_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.mkdir(dir);\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(&format!(\"--target-directory={dir}\"))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.file_exists(format!(\"{dir}/{file1}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file2}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shred.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version.rs::test_spec_order", "code": "pub(super) fn version(text: &str) -> Version {\n    Version::parse(text).unwrap()\n}", "test": "fn test_spec_order() {\n    let vs = [\n        \"1.0.0-alpha\",\n        \"1.0.0-alpha.1\",\n        \"1.0.0-alpha.beta\",\n        \"1.0.0-beta\",\n        \"1.0.0-beta.2\",\n        \"1.0.0-beta.11\",\n        \"1.0.0-rc.1\",\n        \"1.0.0\",\n    ];\n    let mut i = 1;\n    while i < vs.len() {\n        let a = version(vs[i - 1]);\n        let b = version(vs[i]);\n        assert!(a < b, \"nope {:?} < {:?}\", a, b);\n        i += 1;\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_file_exists", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_file_exists() {\n    new_ucmd!().args(&[\"-e\", \"regular_file\"]).succeeds();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_with_cte", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_with_cte() {\n    let with = \"WITH a AS (SELECT * FROM b) INSERT INTO TABLE db.table_table PARTITION (a) SELECT * FROM b\";\n    hive().verified_stmt(with);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::pow_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn pow_test() {\n    let mut x = VecType::from_u64(1);\n    bigint::pow(&mut x, 2);\n    let expected = VecType::from_u64(25);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(1);\n    bigint::pow(&mut x, 15);\n    let expected: VecType = vec_from_u32(&[452807053, 7]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(1);\n    bigint::pow(&mut x, 16);\n    let expected: VecType = vec_from_u32(&[2264035265, 35]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(1);\n    bigint::pow(&mut x, 17);\n    let expected: VecType = vec_from_u32(&[2730241733, 177]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(1);\n    bigint::pow(&mut x, 302);\n    let expected: VecType = vec_from_u32(&[\n        2443090281, 2149694430, 2297493928, 1584384001, 1279504719, 1930002239, 3312868939,\n        3735173465, 3523274756, 2025818732, 1641675015, 2431239749, 4292780461, 3719612855,\n        4174476133, 3296847770, 2677357556, 638848153, 2198928114, 3285049351, 2159526706,\n        626302612,\n    ]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::result_of_empty_block", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn result_of_empty_block() {\n    run_test_actions([TestAction::assert_eq(\"{}\", JsValue::undefined())]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_string_comparison", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_string_comparison() {\n    let scenario = TestScenario::new(util_name!());\n    let tests = [\n        [\"foo\", \"!=\", \"bar\"],\n        [\"contained\\nnewline\", \"=\", \"contained\\nnewline\"],\n        [\"(\", \"=\", \"(\"],\n        [\"(\", \"!=\", \")\"],\n        [\"(\", \"!=\", \"=\"],\n        [\"!\", \"=\", \"!\"],\n        [\"=\", \"=\", \"=\"],\n    ];\n\n    for test in &tests {\n        scenario.ucmd().args(&test[..]).succeeds();\n    }\n\n    // run the inverse of all these tests\n    for test in &tests {\n        scenario.ucmd().arg(\"!\").args(&test[..]).run().code_is(1);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pwd.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_directory_and_no_such_file", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_directory_and_no_such_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"some\");\n\n    ucmd.arg(\"-b1\")\n        .arg(\"some\")\n        .run()\n        .stderr_is(\"cut: some: Is a directory\\n\");\n\n    new_ucmd!()\n        .arg(\"-b1\")\n        .arg(\"some\")\n        .run()\n        .stderr_is(\"cut: some: No such file or directory\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_check_file_not_found_warning", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_check_file_not_found_warning() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.write(\"testf\", \"foobar\\n\");\n    at.write(\n        \"testf.sha1\",\n        \"988881adc9fc3655077dc2d4d757d480b5ea0e11  testf\\n\",\n    );\n    at.remove(\"testf\");\n    scene\n        .ccmd(\"sha1sum\")\n        .arg(\"-c\")\n        .arg(at.subdir.join(\"testf.sha1\"))\n        .succeeds()\n        .stdout_is(\"sha1sum: testf: No such file or directory\\ntestf: FAILED open or read\\n\")\n        .stderr_is(\"sha1sum: warning: 1 listed file could not be read\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raft_storage.rs::test_atomic_basic", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_atomic_basic() {\n    let (_cluster, storage, ctx) = new_raft_storage();\n    storage\n        .raw_batch_put_atomic(\n            ctx.clone(),\n            \"default\".to_string(),\n            vec![(b\"k1\".to_vec(), b\"v1\".to_vec())],\n            vec![0],\n        )\n        .unwrap();\n    let (prev_val, succeed) = storage\n        .raw_compare_and_swap_atomic(\n            ctx.clone(),\n            \"default\".to_string(),\n            b\"k1\".to_vec(),\n            Some(b\"v2\".to_vec()),\n            b\"v3\".to_vec(),\n            0,\n        )\n        .unwrap();\n    assert!(!succeed);\n    assert_eq!(prev_val, Some(b\"v1\".to_vec()));\n    let (prev_val, succeed) = storage\n        .raw_compare_and_swap_atomic(\n            ctx.clone(),\n            \"default\".to_string(),\n            b\"k1\".to_vec(),\n            Some(b\"v1\".to_vec()),\n            b\"v2\".to_vec(),\n            0,\n        )\n        .unwrap();\n    assert!(succeed);\n    assert_eq!(prev_val, Some(b\"v1\".to_vec()));\n    let value = storage\n        .raw_get(ctx.clone(), \"default\".to_string(), b\"k1\".to_vec())\n        .unwrap();\n    assert_eq!(b\"v2\".to_vec(), value.unwrap());\n    storage\n        .raw_batch_delete_atomic(ctx.clone(), \"default\".to_string(), vec![b\"k1\".to_vec()])\n        .unwrap();\n    let value = storage\n        .raw_get(ctx, \"default\".to_string(), b\"k1\".to_vec())\n        .unwrap();\n    assert!(value.is_none());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_num_prefixed_chunks_by_lines", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_num_prefixed_chunks_by_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-d\", \"-l\", \"1000\", name, \"c\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"c\\d\\d$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/slow_tests.rs::bh_test", "code": "pub fn bh<F: RawFloat>(float: F) -> ExtendedFloat80 {\n    let fp = b(float);\n    ExtendedFloat80 {\n        mant: (fp.mant << 1) + 1,\n        exp: fp.exp - 1,\n    }\n}", "test": "fn bh_test() {\n    assert_eq!(bh(1e-45_f32), (3, -150));\n    assert_eq!(bh(5e-324_f64), (3, -1075));\n    assert_eq!(bh(1_f32), (16777217, -24));\n    assert_eq!(bh(1_f64), (9007199254740993, -53));\n    assert_eq!(bh(1e38_f32), (19721523, 102));\n    assert_eq!(bh(1e308_f64), (10020841800044865, 970));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_short_no_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_short_no_overwrite_file1\";\n    let new = \"test_cp_arg_update_short_no_overwrite_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/stack_overflow.rs::big_stack_works_ok", "code": "pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    }", "test": "fn big_stack_works_ok() -> Result<()> {\n    const N: usize = 10000;\n\n    // Build a module with a function that uses a very large amount of stack space,\n    // modeled here by calling an i64-returning-function many times followed by\n    // adding them all into one i64.\n    //\n    // This should exercise the ability to consume multi-page stacks and\n    // only touch a few internals of it at a time.\n    let mut s = String::new();\n    s.push_str(\"(module\\n\");\n    s.push_str(\"(func (export \\\"\\\") (result i64)\\n\");\n    s.push_str(\"i64.const 0\\n\");\n    for _ in 0..N {\n        s.push_str(\"call $get\\n\");\n    }\n    for _ in 0..N {\n        s.push_str(\"i64.add\\n\");\n    }\n    s.push_str(\")\\n\");\n    s.push_str(\"(func $get (result i64) i64.const 0)\\n\");\n    s.push_str(\")\\n\");\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), &s)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_typed_func::<(), i64>(&mut store, \"\")?;\n    assert_eq!(func.call(&mut store, ())?, 0);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_from_auto", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_from_auto() {\n    new_ucmd!()\n        .args(&[\"--from=auto\"])\n        .pipe_in(\"1K\\n1Ki\")\n        .run()\n        .stdout_is(\"1000\\n1024\\n\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_flush_does_nothing", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn client_flush_does_nothing() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    assert!(matches!(client.writer().flush(), Ok(())));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_basic_write.rs::test_put_delete", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn test_put_delete() {\n    let mut cluster = Cluster::default();\n    let router = &mut cluster.routers[0];\n    let header = Box::new(router.new_request_for(2).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    let snap = router.stale_snapshot(2);\n    assert!(snap.get_value(b\"key\").unwrap().is_none());\n    let (msg, mut sub) = PeerMsg::simple_write(header.clone(), put.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub.wait_proposed()));\n    assert!(block_on(sub.wait_committed()));\n    let resp = block_on(sub.result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    let snap = router.stale_snapshot(2);\n    assert_eq!(snap.get_value(b\"key\").unwrap().unwrap(), b\"value\");\n\n    let mut delete = SimpleWriteEncoder::with_capacity(64);\n    delete.delete(CF_DEFAULT, b\"key\");\n    let (msg, mut sub) = PeerMsg::simple_write(header, delete.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub.wait_proposed()));\n    assert!(block_on(sub.wait_committed()));\n    let resp = block_on(sub.result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    let snap = router.stale_snapshot(2);\n    assert_matches!(snap.get_value(b\"key\"), Ok(None));\n\n    // Check if WAL is skipped for basic writes.\n    let mut cached = cluster.node(0).tablet_registry().get(2).unwrap();\n    check_skip_wal(cached.latest().unwrap().as_inner().path());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix_no_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_numeric_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--numeric-suffixes\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x10\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x11\"), \"99\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_padding", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_padding() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--padding=8\"])\n        .pipe_in(\"1K\\n1.1M\\n0.1G\")\n        .run()\n        .stdout_is(\"    1000\\n 1100000\\n100000000\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::filter_identical_matches", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn filter_identical_matches() {\n    // https://github.com/googleprojectzero/weggli/issues/3\n    let needle = \"{if ($x){_;}}\";\n    let source = r\"\n    void func(){\n    if (foo) {\n        a = 1;\n        b = 2;\n        c = 3;\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_y", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_format_y() {\n    let scene = TestScenario::new(util_name!());\n\n    let mut re = Regex::new(r\"^\\d{4}\\n$\").unwrap();\n    scene.ucmd().arg(\"+%Y\").succeeds().stdout_matches(&re);\n\n    re = Regex::new(r\"^\\d{2}\\n$\").unwrap();\n    scene.ucmd().arg(\"+%y\").succeeds().stdout_matches(&re);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_u64_digits_test", "code": "pub fn integer_iter<'b>(&'b mut self) -> IntegerBytesIterator<'a, 'b, FORMAT> {\n        IntegerBytesIterator {\n            byte: self,\n        }\n    }", "test": "fn parse_u64_digits_test() {\n    const FORMAT: u128 = STANDARD;\n    let mut mantissa: u64 = 0;\n    let mut step = u64_step(10);\n    let digits = b\"1234567890123456789012345\";\n    let mut byte = digits.bytes::<{ FORMAT }>();\n    parse::parse_u64_digits::<_, FORMAT>(byte.integer_iter(), &mut mantissa, &mut step);\n    assert_eq!(mantissa, 1234567890123456789);\n    assert_eq!(step, 0);\n\n    let mut mantissa: u64 = 0;\n    let mut step = u64_step(10);\n    let digits = b\"1234567890123456789\";\n    let mut byte = digits.bytes::<{ FORMAT }>();\n    parse::parse_u64_digits::<_, FORMAT>(byte.integer_iter(), &mut mantissa, &mut step);\n    assert_eq!(mantissa, 1234567890123456789);\n    assert_eq!(step, 0);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/server_cert_verifier.rs::client_can_override_certificate_verification", "code": "pub fn do_handshake(\n    client: &mut (impl DerefMut + Deref<Target = ConnectionCommon<impl SideData>>),\n    server: &mut (impl DerefMut + Deref<Target = ConnectionCommon<impl SideData>>),\n) -> (usize, usize) {\n    let (mut to_client, mut to_server) = (0, 0);\n    while server.is_handshaking() || client.is_handshaking() {\n        to_server += transfer(client, server);\n        server.process_new_packets().unwrap();\n        to_client += transfer(server, client);\n        client.process_new_packets().unwrap();\n    }\n    (to_server, to_client)\n}", "test": "fn client_can_override_certificate_verification() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let verifier = Arc::new(MockServerVerifier::accepts_anything());\n\n        let server_config = Arc::new(make_server_config(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config\n                .dangerous()\n                .set_certificate_verifier(verifier.clone());\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            do_handshake(&mut client, &mut server);\n        }\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::mutability", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "test": "fn mutability() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Var),\n        0.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(0));\n    g.set(&mut store, 1.into())?;\n    assert_eq!(g.get(&mut store).i32(), Some(1));\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/config.rs::wasmer_config_multiget", "code": "pub fn stdout(mut self, new_file: Box<dyn VirtualFile + Send + Sync + 'static>) -> Self {\n        self.stdout = Some(new_file);\n\n        self\n    }", "test": "fn wasmer_config_multiget() {\n    let temp = setup_wasmer_dir();\n    let wasmer_dir = temp.path();\n\n    let bin_path = wasmer_dir.join(\"bin\");\n    let include_path = wasmer_dir.join(\"include\");\n    let bin = bin_path.display().to_string();\n    let include = format!(\"-I{}\", include_path.display());\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--bindir\")\n        .arg(\"--cflags\")\n        .env(\"WASMER_DIR\", wasmer_dir)\n        .assert()\n        .success()\n        .stdout(contains(bin))\n        .stdout(contains(include));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple_protect_source", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_simple_protect_source() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let source = format!(\"{TEST_HELLO_WORLD_SOURCE}~\");\n    at.touch(&source);\n    ucmd.arg(\"--backup=simple\")\n        .arg(&source)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .fails()\n        .stderr_only(format!(\n            \"cp: backing up '{TEST_HELLO_WORLD_SOURCE}' might destroy source;  '{source}' not copied\\n\",\n        ));\n\n    assert_eq!(at.read(TEST_HELLO_WORLD_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(at.read(&source), \"\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::with_invalid_semicolons_option", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn with_invalid_semicolons_option() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--semicolons\"), (\"asneed\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"with_invalid_semicolons_option\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::options_test", "code": "pub const fn lossy(mut self, lossy: bool) -> Self {\n        self.lossy = lossy;\n        self\n    }", "test": "fn options_test() {\n    let mut opts = Options::new();\n\n    unsafe {\n        opts.set_lossy(true);\n        opts.set_exponent(b'^');\n        opts.set_decimal_point(b',');\n        opts.set_nan_string(Some(b\"nan\"));\n        opts.set_inf_string(Some(b\"Infinity\"));\n        opts.set_infinity_string(Some(b\"Infiniiiiiity\"));\n    }\n\n    assert_eq!(opts.lossy(), true);\n    assert_eq!(opts.exponent(), b'^');\n    assert_eq!(opts.decimal_point(), b',');\n    assert_eq!(opts.nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(opts.inf_string(), Some(\"Infinity\".as_bytes()));\n    assert_eq!(opts.infinity_string(), Some(\"Infiniiiiiity\".as_bytes()));\n    assert!(opts.is_valid());\n\n    assert_eq!(Options::builder(), OptionsBuilder::new());\n    assert_eq!(opts.rebuild().build(), Ok(opts));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::functions_in_instances", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn functions_in_instances() -> Result<()> {\n    let component = r#\"\n        (component\n            (type $import-type (instance\n                (export \"a\" (func (param \"a\" string)))\n            ))\n            (import (interface \"test:test/foo\") (instance $import (type $import-type)))\n            (alias export $import \"a\" (func $log))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func $call\n                (canon lift (core func $i \"call\"))\n            )\n            (component $c\n                (import \"import-call\" (func $f))\n                (export \"call\" (func $f))\n            )\n            (instance $export (instantiate $c\n                (with \"import-call\" (func $call))\n            ))\n            (export (interface \"test:test/foo\") (instance $export))\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            *store.data_mut() = Some(s);\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .typed_func::<(), ()>(\"call\")?;\n    func.call(&mut store, ())?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = None;\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_new(\n        &component,\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {\n            if let Val::String(s) = &args[0] {\n                assert!(store.data().is_none());\n                *store.data_mut() = Some(s.to_string());\n                Ok(())\n            } else {\n                panic!()\n            }\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .func(\"call\")\n        .unwrap();\n    func.call(&mut store, &[], &mut [])?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_transfer_leader_slow_apply", "code": "pub fn leader_of_region(&mut self, region_id: u64) -> Option<metapb::Peer> {\n        let timer = Instant::now_coarse();\n        let timeout = Duration::from_secs(5);\n        let mut store_ids = None;\n        while timer.saturating_elapsed() < timeout {\n            match self.voter_store_ids_of_region(region_id) {\n                None => thread::sleep(Duration::from_millis(10)),\n                Some(ids) => {\n                    store_ids = Some(ids);\n                    break;\n                }\n            }\n        }\n        let store_ids = store_ids?;\n        if let Some(l) = self.leaders.get(&region_id) {\n            // leader may be stopped in some tests.\n            if self.valid_leader_id(region_id, l.get_store_id()) {\n                return Some(l.clone());\n            }\n        }\n        self.reset_leader_of_region(region_id);\n        let mut leader = None;\n        let mut leaders = HashMap::default();\n\n        let node_ids = self.sim.rl().get_node_ids();\n        // For some tests, we stop the node but pd still has this information,\n        // and we must skip this.\n        let alive_store_ids: Vec<_> = store_ids\n            .iter()\n            .filter(|id| node_ids.contains(id))\n            .cloned()\n            .collect();\n        while timer.saturating_elapsed() < timeout {\n            for store_id in &alive_store_ids {\n                let l = match self.query_leader(*store_id, region_id, Duration::from_secs(1)) {\n                    None => continue,\n                    Some(l) => l,\n                };\n                leaders\n                    .entry(l.get_id())\n                    .or_insert((l, vec![]))\n                    .1\n                    .push(*store_id);\n            }\n            if let Some((_, (l, c))) = leaders.iter().max_by_key(|(_, (_, c))| c.len()) {\n                if c.contains(&l.get_store_id()) {\n                    leader = Some(l.clone());\n                    // Technically, correct calculation should use two quorum when in joint\n                    // state. Here just for simplicity.\n                    if c.len() > store_ids.len() / 2 {\n                        break;\n                    }\n                }\n            }\n            debug!(\"failed to detect leaders\"; \"leaders\" => ?leaders, \"store_ids\" => ?store_ids);\n            sleep_ms(10);\n            leaders.clear();\n        }\n\n        if let Some(l) = leader {\n            self.leaders.insert(region_id, l);\n        }\n\n        self.leaders.get(&region_id).cloned()\n    }", "test": "fn test_transfer_leader_slow_apply() {\n    // 3 nodes cluster.\n    let mut cluster = new_node_cluster(0, 3);\n\n    let pd_client = cluster.pd_client.clone();\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 1002));\n    pd_client.must_add_peer(r1, new_peer(3, 1003));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    let fp = \"on_handle_apply_1003\";\n    fail::cfg(fp, \"pause\").unwrap();\n    for i in 0..=cluster.cfg.raft_store.leader_transfer_max_log_lag {\n        let bytes = format!(\"k{:03}\", i).into_bytes();\n        cluster.must_put(&bytes, &bytes);\n    }\n    cluster.transfer_leader(r1, new_peer(3, 1003));\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    assert_ne!(cluster.leader_of_region(r1).unwrap(), new_peer(3, 1003));\n    fail::remove(fp);\n    cluster.must_transfer_leader(r1, new_peer(3, 1003));\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(3), b\"k3\", b\"v3\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_chained_cname_lookup_preserve", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }", "test": "fn test_chained_cname_lookup_preserve() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n\n    // The first response should be a cname, the second will be the actual record\n    let message1 = message(\n        resp_query.clone(),\n        vec![cname_record.clone()],\n        vec![],\n        vec![],\n    );\n    let message2 = message(resp_query, vec![v4_record], vec![], vec![]);\n\n    // the mock pops messages...\n    let client: MockClientHandle<_, ResolveError> = MockClientHandle::mock(vec![\n        Ok(DnsResponse::from_message(message2).unwrap()),\n        Ok(DnsResponse::from_message(message1).unwrap()),\n    ]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, true),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    let mut iter = lookup.iter();\n    assert_eq!(iter.next().unwrap(), cname_record.data().unwrap());\n    assert_eq!(*iter.next().unwrap(), RData::A(A::new(93, 184, 216, 34)));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_one_fifo", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_create_one_fifo() {\n    new_ucmd!().arg(\"abc\").succeeds();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::option_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn option_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<Option<u8>, Option<u32>> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(None, None).unwrap();\n        table.insert(None, Some(0)).unwrap();\n        table.insert(Some(1), Some(1)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(table.get(None).unwrap().unwrap().value(), Some(0));\n    assert_eq!(table.get(Some(1)).unwrap().unwrap().value(), Some(1));\n    let mut iter = table.iter().unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().0.value(), None);\n    assert_eq!(iter.next().unwrap().unwrap().0.value(), Some(1));\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::refuse_to_inscribe_already_inscribed_utxo", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn refuse_to_inscribe_already_inscribed_utxo() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let (inscription, reveal) = inscribe(&rpc_server);\n\n  let output = OutPoint {\n    txid: reveal,\n    vout: 0,\n  };\n\n  CommandBuilder::new(format!(\n    \"wallet inscribe --satpoint {output}:55555 --file hello.txt --fee-rate 1\"\n  ))\n  .write(\"hello.txt\", \"HELLOWORLD\")\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(format!(\n    \"error: utxo {output} already inscribed with inscription {inscription} on sat {output}:0\\n\",\n  ))\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::_do_not_overwrite() {\n    ", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "eek_do_not_overwrite() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let mut outfile = at.make_file(\"outfile\");\n    outfile.write_all(b\"abc\").unwrap();\n    // Skip the first byte of the input, seek past the first byte of\n    // the output, and write only one byte to the output.\n    ucmd.args(&[\n        \"bs=1\",\n        \"skip=1\",\n        \"seek=1\",\n        \"count=1\",\n        \"status=noxfer\",\n        \"of=outfile\",\n    ])\n    .pipe_in(\"123\")\n    .succeeds()\n    .stderr_is(\"1+0 records in\\n1+0 records out\\n\")\n    .no_stdout();\n    assert_eq!(at.read(\"outfile\"), \"a2\");\n}\n\n#[test]"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_path.rs::print_incomplete_qpath", "code": "pub(crate) fn is_some(&self) -> bool {\n            match self {\n                Visibility::Inherited => false,\n                _ => true,\n            }\n        }", "test": "fn print_incomplete_qpath() {\n    // qpath with `as` token\n    let mut ty: TypePath = parse_quote!(<Self as A>::Q);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self as A > :: Q`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self as A > ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self >`)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n\n    // qpath without `as` token\n    let mut ty: TypePath = parse_quote!(<Self>::A::B);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > :: A :: B`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > :: A ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n\n    // normal path\n    let mut ty: TypePath = parse_quote!(Self::A::B);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self :: A :: B`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self :: A ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(``)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::decorators", "code": "fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n}", "test": "fn decorators() {\n    let source = r#\"\n@decorator\ndef a():\n    pass\n\n@test\nclass A:\n    pass\n\"#;\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uptime.rs::test_uptime", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_uptime() {\n    TestScenario::new(util_name!())\n        .ucmd()\n        .succeeds()\n        .stdout_contains(\"load average:\")\n        .stdout_contains(\" up \");\n\n    // Don't check for users as it doesn't show in some CI\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_bool", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_bool() {\n    let tests = &[(true, \"true\"), (false, \"false\")];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_formatter_linter_organize_imports", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_formatter_linter_organize_imports() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = r#\"{\n    \"linter\": {\n        \"enabled\": true,\n        \"rules\": {\n            \"recommended\": true\n        }\n    },\n    \"organizeImports\": {\n        \"enabled\": true\n    }\n}\"#;\n\n    let input = r#\"\nimport { B, C } from \"b.js\"\nimport A from \"a.js\"\n\n\nsomething( )\n    \"#;\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), rome_json.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), input.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"ci target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_formatter_linter_organize_imports\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_false.rs::test_conflict", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_conflict() {\n    new_ucmd!()\n        .args(&[\"--help\", \"--version\"])\n        .fails()\n        .stdout_is(\"\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::spread_in_arrow_function", "code": "pub const fn flags(&self) -> FormalParameterListFlags {\n        self.flags\n    }", "test": "fn spread_in_arrow_function() {\n    let s = r#\"\n    (...b) => {\n        b\n    }\n    \"#;\n\n    let interner = &mut Interner::default();\n    let b = interner.get_or_intern_static(\"b\", utf16!(\"b\"));\n    let params = FormalParameterList::from(FormalParameter::new(\n        Variable::from_identifier(b.into(), None),\n        true,\n    ));\n    assert_eq!(params.flags(), FormalParameterListFlags::HAS_REST_PARAMETER);\n    assert_eq!(params.length(), 0);\n    check_script_parser(\n        s,\n        vec![Statement::Expression(Expression::from(ArrowFunction::new(\n            None,\n            params,\n            FunctionBody::new(\n                vec![Statement::Expression(Expression::from(Identifier::from(b))).into()].into(),\n            ),\n        )))\n        .into()],\n        interner,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_without_plus", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_date_format_without_plus() {\n    // [+FORMAT]\n    new_ucmd!()\n        .arg(\"%s\")\n        .fails()\n        .stderr_contains(\"date: invalid date '%s'\")\n        .code_is(1);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_test_caching_works_for_urls", "code": "pub fn stderr(&self) -> Result<Option<Box<dyn VirtualFile + Send + Sync + 'static>>, FsError> {\n        self.state.stderr()\n    }", "test": "fn run_test_caching_works_for_urls() {\n    let wasmer_dir = TempDir::new().unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(\"https://wasmer.io/python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"/app/test.py\")\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .assert()\n        .success();\n\n    assert\n        .success()\n        .stderr(contains(\"builtin_loader: Downloading a webc file\"))\n        .stderr(contains(\"module_cache::filesystem: Saved to disk\"));\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(\"https://wasmer.io/python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"/app/test.py\")\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .assert()\n        .success();\n\n    assert\n        // Got a cache hit downloading the *.webc file's metadata\n        .stderr(contains(\"web_source: Cache hit\"))\n        // Cache hit downloading the *.webc file\n        .stderr(contains(\n            r#\"builtin_loader: Cache hit! pkg.name=\"python\" pkg.version=0.1.0\"#,\n        ))\n        // Cache hit compiling the module\n        .stderr(contains(\"module_cache::filesystem: Cache hit!\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_twice_2", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_twice_2() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    for i in 64..128_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    for i in 1..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_never_reflink_always", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_cp_sparse_never_reflink_always() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.make_file(\"src_file1\");\n\n    ucmd.args(&[\n        \"--sparse=never\",\n        \"--reflink=always\",\n        \"src_file1\",\n        \"dst_file\",\n    ])\n    .fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_on_wrong_leader", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_force_leader_on_wrong_leader() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    // peer on node2 doesn't have latest committed log\n    cluster.stop_node(2);\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n    cluster.run_node(2).unwrap();\n\n    // restart to clean lease\n    cluster.stop_node(1);\n    cluster.run_node(1).unwrap();\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    // try to force leader on peer of node2 which is stale\n    cluster.must_enter_force_leader(region.get_id(), 2, vec![3, 4, 5]);\n    // can't propose confchange as it's not in force leader state\n    let cmd = new_change_peer_request(\n        ConfChangeType::RemoveNode,\n        find_peer(&region, 3).unwrap().clone(),\n    );\n    let req = new_admin_request(region.get_id(), region.get_region_epoch(), cmd);\n    cluster\n        .call_command_on_leader(req, Duration::from_millis(10))\n        .unwrap_err();\n    cluster.exit_force_leader(region.get_id(), 2);\n\n    // peer on node2 still doesn't have the latest committed log.\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_unknown_file_extension", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_unknown_file_extension() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"wallet inscribe --file pepe.xyz --fee-rate 1\")\n    .write(\"pepe.xyz\", [1; 520])\n    .rpc_server(&rpc_server)\n    .expected_exit_code(1)\n    .stderr_regex(r\"error: unsupported file extension `\\.xyz`, supported extensions: apng .*\\n\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::write_float_positive_exponent_test", "code": "fn write_float_positive_exponent(mant: u64, exp: i32, options: &Options, expected: &str) {\n    let mut buffer = [b'\\x00'; 512];\n    let fp = ExtendedFloat80 {\n        mant,\n        exp,\n    };\n    let digit_count = f64::digit_count(fp.mant);\n    let sci_exp = fp.exp + digit_count as i32 - 1;\n    let count = unsafe {\n        algorithm::write_float_positive_exponent::<f64, DECIMAL>(&mut buffer, fp, sci_exp, &options)\n    };\n    let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n    assert_eq!(actual, expected);\n}", "test": "fn write_float_positive_exponent_test() {\n    let options = Options::new();\n    write_float_positive_exponent(1, 0, &options, \"1.0\");\n    write_float_positive_exponent(1, 3, &options, \"1000.0\");\n    write_float_positive_exponent(1, 12, &options, \"1000000000000.0\");\n    write_float_positive_exponent(999999999999999, -14, &options, \"9.99999999999999\");\n    write_float_positive_exponent(999999999999999, -13, &options, \"99.9999999999999\");\n    write_float_positive_exponent(999999999999999, -12, &options, \"999.999999999999\");\n    write_float_positive_exponent(17976931348623157, 292, &options, \"179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\");\n\n    let options =\n        Options::builder().min_significant_digits(num::NonZeroUsize::new(50)).build().unwrap();\n    write_float_positive_exponent(\n        1,\n        0,\n        &options,\n        \"1.0000000000000000000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(\n        1,\n        3,\n        &options,\n        \"1000.0000000000000000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(\n        1,\n        12,\n        &options,\n        \"1000000000000.0000000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(\n        999999999999999,\n        -14,\n        &options,\n        \"9.9999999999999900000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(\n        999999999999999,\n        -13,\n        &options,\n        \"99.999999999999900000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(\n        999999999999999,\n        -12,\n        &options,\n        \"999.99999999999900000000000000000000000000000000000\",\n    );\n    write_float_positive_exponent(17976931348623157, 292, &options, \"179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\");\n\n    let options =\n        Options::builder().max_significant_digits(num::NonZeroUsize::new(5)).build().unwrap();\n    write_float_positive_exponent(1, 0, &options, \"1.0\");\n    write_float_positive_exponent(1, 3, &options, \"1000.0\");\n    write_float_positive_exponent(1, 12, &options, \"1000000000000.0\");\n    write_float_positive_exponent(999999999999999, -14, &options, \"10.0\");\n    write_float_positive_exponent(999999999999999, -13, &options, \"100.0\");\n    write_float_positive_exponent(999999999999999, -12, &options, \"1000.0\");\n    write_float_positive_exponent(17976931348623157, 292, &options, \"179770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\");\n\n    let options = Options::builder().trim_floats(true).build().unwrap();\n    write_float_positive_exponent(1, 0, &options, \"1\");\n    write_float_positive_exponent(1, 3, &options, \"1000\");\n    write_float_positive_exponent(1, 12, &options, \"1000000000000\");\n    write_float_positive_exponent(999999999999999, -14, &options, \"9.99999999999999\");\n    write_float_positive_exponent(999999999999999, -13, &options, \"99.9999999999999\");\n    write_float_positive_exponent(999999999999999, -12, &options, \"999.999999999999\");\n    write_float_positive_exponent(17976931348623157, 292, &options, \"179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_7", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_7() {\n    let original = r##\"| abc | def |\n| --- | --- |\n| bar |\n| bar | baz | boo |\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bar</td>\n<td></td>\n</tr>\n<tr>\n<td>bar</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_help", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_help() {\n    new_ucmd!().arg(\"--help\").succeeds();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::len", "code": "pub fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: TableDefinition<K, V>,\n    ) -> Result<Table<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Normal)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(Table::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn len() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello2\", \"world2\").unwrap();\n        table.insert(\"hi\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 3);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::cap_zero", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn cap_zero() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch_with_cap(0);\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(0);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&123_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&255_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::fill_externref_tables_via_api", "code": "pub fn get(&self, index: u32) -> Option<TableElement> {\n        self.elements()\n            .get(index as usize)\n            .map(|p| unsafe { TableElement::clone_from_table_value(self.element_type(), *p) })\n    }", "test": "fn fill_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::ExternRef(None))?;\n\n    for i in 0..10 {\n        assert!(table\n            .get(&mut store, i)\n            .unwrap()\n            .unwrap_externref()\n            .is_none());\n    }\n\n    table.fill(\n        &mut store,\n        2,\n        Val::ExternRef(Some(ExternRef::new(42_usize))),\n        4,\n    )?;\n\n    for i in (0..2).chain(7..10) {\n        assert!(table\n            .get(&mut store, i)\n            .unwrap()\n            .unwrap_externref()\n            .is_none());\n    }\n    for i in 2..6 {\n        assert_eq!(\n            *table\n                .get(&mut store, i)\n                .unwrap()\n                .unwrap_externref()\n                .unwrap()\n                .data()\n                .downcast_ref::<usize>()\n                .unwrap(),\n            42\n        );\n    }\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"aa\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete(b\"a\").unwrap();\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_none());\n\n    let db = multi_batch_write_engine();\n\n    for i in 0..127_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n    db.engine.put(b\"a\", b\"aa\").unwrap();\n    for i in 127..255_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    for i in 0..255_usize {\n        let k = i.to_be_bytes();\n        wb.delete(&k).unwrap();\n    }\n    wb.delete(b\"a\").unwrap();\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_none());\n    for i in 0..255_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_twice", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_too_small_line_num_twice() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"10\", \"15\", \"/40/\"])\n        .succeeds()\n        .stdout_only(\"48\\n0\\n0\\n60\\n33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 5);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), \"\");\n    assert_eq!(at.read(\"xx03\"), generate(20, 40));\n    assert_eq!(at.read(\"xx04\"), generate(40, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_stdin", "code": "pub fn stdout_is_templated_fixture_any<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[Vec<(String, String)>],\n    ) {\n        let contents = String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        let possible_values = template_vars.iter().map(|vars| {\n            let mut contents = contents.clone();\n            for kv in vars {\n                contents = contents.replace(&kv.0, &kv.1);\n            }\n            contents\n        });\n        self.stdout_is_any(&possible_values.collect::<Vec<_>>());\n    }", "test": "fn test_with_stdin() {\n    let expected_file_path = \"stdin.log.expected\";\n    let mut scenario = new_ucmd!();\n    let start = OffsetDateTime::now_utc();\n    scenario\n        .pipe_in_fixture(\"stdin.log\")\n        .args(&[\"--pages=1:2\", \"-n\", \"-\"])\n        .run()\n        .stdout_is_templated_fixture_any(\n            expected_file_path,\n            &valid_last_modified_template_vars(start),\n        );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_local_read_cache", "code": "fn get_store_id(&self) -> Result<u64> {\n        let res = self\n            .engines\n            .kv\n            .get_msg::<StoreIdent>(keys::STORE_IDENT_KEY)\n            .unwrap();\n        if res.is_none() {\n            return Ok(0);\n        }\n\n        let ident = res.unwrap();\n        let store_id = ident.get_store_id();\n        if store_id == 0 {\n            error!(\"invalid store to report\");\n        }\n        Ok(store_id)\n    }", "test": "fn test_local_read_cache() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_lease_read(&mut cluster.cfg, Some(50), None);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    let r1 = cluster.get_region(b\"k1\");\n    let leader = cluster.leader_of_region(r1.get_id()).unwrap();\n    let new_leader = new_peer((leader.get_id() + 1) % 3 + 1, (leader.get_id() + 1) % 3 + 1);\n    cluster.must_transfer_leader(r1.get_id(), new_leader);\n\n    // Add the peer back and make sure it catches up latest logs.\n    pd_client.must_remove_peer(r1.get_id(), leader.clone());\n    let replace_peer = new_peer(leader.get_store_id(), 10000);\n    pd_client.must_add_peer(r1.get_id(), replace_peer.clone());\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(leader.get_store_id()), b\"k2\", b\"v2\");\n\n    cluster.must_transfer_leader(r1.get_id(), replace_peer);\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(leader.get_store_id()), b\"k3\", b\"v3\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_line_num_range_with_up_to_match1", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_line_num_range_with_up_to_match1() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"/12/-5\"])\n        .fails()\n        .stderr_is(\"csplit: '/12/-5': line number out of range\\n\")\n        .stdout_is(\"18\\n0\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"/12/-5\", \"-k\"])\n        .fails()\n        .stderr_is(\"csplit: '/12/-5': line number out of range\\n\")\n        .stdout_is(\"18\\n0\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), generate(10, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_line_num_out_of_range2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_line_num_out_of_range2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"100\"])\n        .fails()\n        .stdout_is(\"18\\n123\\n\")\n        .stderr_is(\"csplit: '100': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"100\", \"-k\"])\n        .fails()\n        .stdout_is(\"18\\n123\\n\")\n        .stderr_is(\"csplit: '100': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 51));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/iterators.rs::mixed_iterators_close_in_continue", "code": "fn run_jobs(&self, context: &mut boa_engine::Context<'_>) {\n        // Early return in case there were no jobs scheduled.\n        if self.jobs.borrow().is_empty() && self.futures.borrow().is_empty() {\n            return;\n        }\n\n        let context = RefCell::new(context);\n\n        future::block_on(self.executor.run(async move {\n            // Used to sync the finalization of both tasks\n            let finished = Cell::new(0b00u8);\n\n            let fqueue = async {\n                loop {\n                    if self.futures.borrow().is_empty() {\n                        finished.set(finished.get() | 0b01);\n                        if finished.get() >= 0b11 {\n                            // All possible futures and jobs were completed. Exit.\n                            return;\n                        }\n                        // All possible jobs were completed, but `jqueue` could have\n                        // pending jobs. Yield to the executor to try to progress on\n                        // `jqueue` until we have more pending futures.\n                        future::yield_now().await;\n                        continue;\n                    }\n                    finished.set(finished.get() & 0b10);\n\n                    // Blocks on all the enqueued futures, driving them all to completion.\n                    let futures = &mut std::mem::take(&mut *self.futures.borrow_mut());\n                    while let Some(job) = futures.next().await {\n                        // Important to schedule the returned `job` into the job queue, since that's\n                        // what allows updating the `Promise` seen by ECMAScript for when the future\n                        // completes.\n                        self.enqueue_promise_job(job, &mut context.borrow_mut());\n                    }\n                }\n            };\n\n            let jqueue = async {\n                loop {\n                    if self.jobs.borrow().is_empty() {\n                        finished.set(finished.get() | 0b10);\n                        if finished.get() >= 0b11 {\n                            // All possible futures and jobs were completed. Exit.\n                            return;\n                        }\n                        // All possible jobs were completed, but `fqueue` could have\n                        // pending futures. Yield to the executor to try to progress on\n                        // `fqueue` until we have more pending jobs.\n                        future::yield_now().await;\n                        continue;\n                    };\n                    finished.set(finished.get() & 0b01);\n\n                    let jobs = std::mem::take(&mut *self.jobs.borrow_mut());\n                    for job in jobs {\n                        if let Err(e) = job.call(&mut context.borrow_mut()) {\n                            eprintln!(\"Uncaught {e}\");\n                        }\n                        future::yield_now().await;\n                    }\n                }\n            };\n\n            // Wait for both queues to complete\n            future::zip(fqueue, jqueue).await;\n        }))\n    }", "test": "fn mixed_iterators_close_in_continue() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n            var actual = [];\n\n            var iter = {\n                [Symbol.iterator]() {\n                    return this;\n                },\n                next() {\n                    actual.push(\"call next\");\n                    return {\n                        done: false,\n                    };\n                },\n                get return() {\n                    actual.push(\"get return\");\n                    return function () {\n                        actual.push(\"return call\");\n                        return {\n                            done: true\n                        }\n                    }\n                }\n            };\n\n            var asyncIter = {\n                [Symbol.asyncIterator]() {\n                    return this;\n                },\n                next() {\n                    actual.push(\"async call next\");\n                    return {\n                        done: false,\n                    };\n                },\n                get return() {\n                    actual.push(\"get async return\");\n                    return function () {\n                        actual.push(\"async return call\");\n                        return {\n                            done: true\n                        };\n                    }\n                }\n            };\n\n            Promise.resolve(0)\n                .then(() => actual.push(\"tick 1\"))\n                .then(() => actual.push(\"tick 2\"))\n                .then(() => actual.push(\"tick 3\"));\n\n            void async function f() {\n                actual.push(\"async fn start\");\n                let count = 0;\n                loop: while (count === 0) {\n                    count++;\n                    for (_ of iter) {\n                        for await (__ of asyncIter) {\n                            continue loop;\n                        }\n                    }\n                }\n                actual.push(\"async fn end\");\n            }();\n        \"#}),\n        #[allow(clippy::redundant_closure_for_method_calls)]\n        TestAction::inspect_context(|ctx| ctx.run_jobs()),\n        TestAction::assert(indoc! {r#\"\n            arrayEquals(\n                actual,\n                [\n                    \"async fn start\",\n                    \"call next\",\n                    \"async call next\",\n                    \"tick 1\",\n                    \"get async return\",\n                    \"async return call\",\n                    \"tick 2\",\n                    \"get return\",\n                    \"return call\",\n                    \"async fn end\",\n                    \"tick 3\",\n                ]\n            )\n        \"#}),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_verbose", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_mkdir_verbose() {\n    let _guard = TEST_MUTEX.lock();\n    let expected = \"mkdir: created directory 'test_dir'\\n\";\n    new_ucmd!()\n        .arg(\"test_dir\")\n        .arg(\"-v\")\n        .run()\n        .stdout_is(expected);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i64_max", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_i64_max() {\n    assert_eq!(\n        std::i64::MAX,\n        from_str(&to_string(&std::i64::MAX).unwrap()).unwrap()\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_timeout_query_nonet", "code": "fn test_timeout_query(mut client: AsyncClient, io_loop: Runtime) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n\n    let err = io_loop\n        .block_on(client.query(name.clone(), DNSClass::IN, RecordType::A))\n        .unwrap_err();\n\n    println!(\"got error: {err:?}\");\n    if let ClientErrorKind::Timeout = err.kind() {\n    } else {\n        panic!(\"expected timeout error\");\n    }\n\n    io_loop\n        .block_on(client.query(name, DNSClass::IN, RecordType::AAAA))\n        .unwrap_err();\n\n    // test that we don't have any thing funky with registering new timeouts, etc...\n    //   it would be cool if we could maintain a different error here, but shutdown is probably ok.\n    //\n    // match err.kind() {\n    //     &ClientErrorKind::Timeout => (),\n    //     e @ _ => assert!(false, format!(\"something else: {}\", e)),\n    // }\n}", "test": "fn test_timeout_query_nonet() {\n    // env_logger::try_init().ok();\n    // TODO: need to add timeout length to SyncClient\n    let client = SyncClient::new(NeverReturnsClientConnection::new().unwrap());\n    test_timeout_query(client);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_node_stale_peer_without_data_right_derive_when_split", "code": "fn test_stale_peer_without_data<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let region = cluster.get_region(b\"\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.must_split(&region, b\"k2\");\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine3 = cluster.get_engine(3);\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    let new_region = if right_derive {\n        cluster.get_region(b\"k1\")\n    } else {\n        cluster.get_region(b\"k3\")\n    };\n    let new_region_id = new_region.get_id();\n    // Block peer (3, 4) at receiving snapshot, but not the heartbeat\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(new_region_id, 3).msg_type(MessageType::MsgSnapshot),\n    ));\n\n    pd_client.must_add_peer(new_region_id, new_peer(3, 4));\n\n    // Wait for the heartbeat broadcasted from peer (1, 1000) to peer (3, 4).\n    cluster.must_region_exist(new_region_id, 3);\n\n    // And then isolate peer (3, 4) from peer (1, 1000).\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_remove_peer(new_region_id, new_peer(3, 4));\n\n    cluster.must_remove_region(3, new_region_id);\n\n    // There must be no data on store 3 belongs to new region\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n    } else {\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    // Check whether peer(3, 4) is destroyed.\n    // Before peer 4 is destroyed, a tombstone mark will be written into the engine.\n    // So we could check the tombstone mark to make sure peer 4 is destroyed.\n    let state_key = keys::region_state_key(new_region_id);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // other region should not be affected.\n    if right_derive {\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n    }\n}", "test": "fn test_node_stale_peer_without_data_right_derive_when_split() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_stale_peer_without_data(&mut cluster, true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stdbuf.rs::test_stdbuf_no_buffer_option_fails", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_stdbuf_no_buffer_option_fails() {\n    let ts = TestScenario::new(util_name!());\n\n    ts.ucmd()\n        .args(&[\"head\"])\n        .fails()\n        .stderr_contains(\"the following required arguments were not provided:\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_multiple_files_target_is_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_cp_multiple_files_target_is_file() {\n    new_ucmd!()\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_EXISTING_FILE)\n        .fails()\n        .stderr_contains(\"not a directory\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_binding", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch_binding() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw 20;\n            } catch(err) {\n                a = err;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::hashbang_comment", "code": "pub(super) fn check_script_parser<L>(js: &str, expr: L, interner: &mut Interner)\nwhere\n    L: Into<Box<[StatementListItem]>>,\n{\n    assert_eq!(\n        Parser::new(Source::from_bytes(js))\n            .parse_script(interner)\n            .expect(\"failed to parse\"),\n        Script::new(StatementList::from(expr.into()))\n    );\n}", "test": "fn hashbang_comment() {\n    check_script_parser(r\"#!Comment Here\", vec![], &mut Interner::default());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_indexes.rs::same_import_names_still_distinct", "code": "pub fn is_empty(&self) -> bool {\n        self.dense.is_empty()\n    }", "test": "fn same_import_names_still_distinct() -> anyhow::Result<()> {\n    const WAT: &str = r#\"\n(module\n  (import \"\" \"\" (func $a (result i32)))\n  (import \"\" \"\" (func $b (result f32)))\n  (func (export \"foo\") (result i32)\n    call $a\n    call $b\n    i32.trunc_f32_u\n    i32.add)\n)\n    \"#;\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), WAT)?;\n\n    let imports = [\n        Func::new(\n            &mut store,\n            FuncType::new(None, Some(ValType::I32)),\n            |_, params, results| {\n                assert!(params.is_empty());\n                assert_eq!(results.len(), 1);\n                results[0] = 1i32.into();\n                Ok(())\n            },\n        )\n        .into(),\n        Func::new(\n            &mut store,\n            FuncType::new(None, Some(ValType::F32)),\n            |_, params, results| {\n                assert!(params.is_empty());\n                assert_eq!(results.len(), 1);\n                results[0] = 2.0f32.into();\n                Ok(())\n            },\n        )\n        .into(),\n    ];\n    let instance = Instance::new(&mut store, &module, &imports)?;\n\n    let func = instance.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    let result = func.call(&mut store, ())?;\n    assert_eq!(result, 3);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_ignore_initial_slashes", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_ignore_initial_slashes() {\n    new_ucmd!()\n        .args(&[\"--tabs=//3\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"   a  b  c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_shortcut", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_shortcut() {\n    new_ucmd!()\n        .arg(\"-3\")\n        .pipe_in(\"   a   b\")\n        .run()\n        .stdout_is(\"\\ta   b\");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::_loop", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn _loop() {\n    let needle = \"{$x $array[_]; for (int $i=0; _; _) {$array[$i]=_;}}\";\n    let source = \"void bar() {char a[512]; for (int x=0;x<10;x++) {a[x]=0;}}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_number_format_rz", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_number_format_rz() {\n    for arg in [\"-nrz\", \"--number-format=rz\"] {\n        new_ucmd!()\n            .arg(arg)\n            .pipe_in(\"test\")\n            .succeeds()\n            .stdout_is(\"000001\\ttest\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_version_empty_lines", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_version_empty_lines() {\n    test_helper(\"version-empty-lines\", &[\"-V\", \"--version-sort\"]);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::does_error_with_only_warnings", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn does_error_with_only_warnings() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        r#\"\n{\n    \"formatter\": { \"enabled\": false},\n  \"linter\": {\n    \"rules\": {\n        \"recommended\": true,\n        \"suspicious\": {\n            \"noClassAssign\": \"warn\"\n        }\n    }\n  }\n}\n        \"#\n        .as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(\n        file_path.into(),\n        r#\"class A {};\nA = 0;\n\"#\n        .as_bytes(),\n    );\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                \"ci\",\n                \"--error-on-warnings\",\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_error_with_only_warnings\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_1024", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_1024() {\n    fn get_header(block_size: u64) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-B\", &format!(\"{block_size}\"), \"--output=size\"])\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(1024), \"1K-blocks\");\n    assert_eq!(get_header(2048), \"2K-blocks\");\n    assert_eq!(get_header(4096), \"4K-blocks\");\n    assert_eq!(get_header(1024 * 1024), \"1M-blocks\");\n    assert_eq!(get_header(2 * 1024 * 1024), \"2M-blocks\");\n    assert_eq!(get_header(1024 * 1024 * 1024), \"1G-blocks\");\n    assert_eq!(get_header(34 * 1024 * 1024 * 1024), \"34G-blocks\");\n\n    // multiples of both 1024 and 1000\n    assert_eq!(get_header(128_000), \"128kB-blocks\");\n    assert_eq!(get_header(1000 * 1024), \"1.1MB-blocks\");\n    assert_eq!(get_header(1_000_000_000_000), \"1TB-blocks\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_trust_nx_responses_fails", "code": "pub fn kind(&self) -> &ResolveErrorKind {\n        &self.kind\n    }", "test": "fn test_trust_nx_responses_fails() {\n    let query = Query::query(Name::from_str(\"www.example.\").unwrap(), RecordType::A);\n\n    // NXDOMAIN responses are only trusted if there's a SOA record, so make sure we return one.\n    let soa_record = soa_record(\n        query.name().clone(),\n        Name::from_str(\"example.com.\").unwrap(),\n    );\n    let mut nx_message = message(query.clone(), vec![], vec![soa_record], vec![]);\n    nx_message.set_response_code(ResponseCode::NXDomain);\n\n    let success_msg = message(\n        query.clone(),\n        vec![v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2))],\n        vec![],\n        vec![],\n    );\n\n    // Fail the first UDP request.\n    let fail_nameserver = mock_nameserver_trust_nx(\n        vec![Ok(DnsResponse::from_message(nx_message).unwrap())],\n        ResolverOpts::default(),\n        true,\n    );\n    let succeed_nameserver = mock_nameserver_trust_nx(\n        vec![Ok(DnsResponse::from_message(success_msg).unwrap())],\n        ResolverOpts::default(),\n        true,\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![fail_nameserver, succeed_nameserver],\n        vec![],\n        None,\n        ResolverOpts::default(),\n    );\n\n    // Lookup on UDP should fail, since we trust nx responses.\n    // (If we retried the query with the second name server, we'd see a successful response.)\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n    let response = block_on(future).expect_err(\"lookup request should fail with NXDOMAIN\");\n    match response.kind() {\n        ResolveErrorKind::NoRecordsFound { response_code, .. }\n            if *response_code == ResponseCode::NXDomain => {}\n        kind => panic!(\n            \"got unexpected kind of resolve error; expected `NoRecordsFound` error with NXDOMAIN,\n            got {:#?}\",\n            kind,\n        ),\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_inscribe_with_multiple_inscriptions", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn batch_inscribe_with_multiple_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let output = CommandBuilder::new(\"wallet inscribe --batch batch.yaml --fee-rate 55\")\n    .write(\"inscription.txt\", \"Hello World\")\n    .write(\"tulip.png\", [0; 555])\n    .write(\"meow.wav\", [0; 2048])\n    .write(\n      \"batch.yaml\",\n      \"mode: shared-output\\ninscriptions:\\n- file: inscription.txt\\n- file: tulip.png\\n- file: meow.wav\\n\"\n    )\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let request = TestServer::spawn_with_args(&rpc_server, &[])\n    .request(format!(\"/content/{}\", output.inscriptions[0].id));\n  assert_eq!(request.status(), 200);\n  assert_eq!(\n    request.headers().get(\"content-type\").unwrap(),\n    \"text/plain;charset=utf-8\"\n  );\n  assert_eq!(request.text().unwrap(), \"Hello World\");\n\n  let request = TestServer::spawn_with_args(&rpc_server, &[])\n    .request(format!(\"/content/{}\", output.inscriptions[1].id));\n  assert_eq!(request.status(), 200);\n  assert_eq!(request.headers().get(\"content-type\").unwrap(), \"image/png\");\n\n  let request = TestServer::spawn_with_args(&rpc_server, &[])\n    .request(format!(\"/content/{}\", output.inscriptions[2].id));\n  assert_eq!(request.status(), 200);\n  assert_eq!(request.headers().get(\"content-type\").unwrap(), \"audio/wav\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_after_rollback_merge", "code": "fn to_vec(&self) -> Vec<Option<Enum>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            if let Some(value) = self.values.get_option_ref(i) {\n                let name = self.names.get(i).unwrap().to_vec();\n                x.push(Some(Enum::new(name, *value as u64)));\n            } else {\n                x.push(None);\n            }\n        }\n        x\n    }", "test": "fn test_stale_read_after_rollback_merge() {\n    let (mut cluster, pd_client, leader_client) =\n        prepare_for_stale_read_before_run(new_peer(1, 1), Some(Box::new(configure_for_merge)));\n\n    // Write on source region\n    leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    cluster.must_split(&cluster.get_region(&[]), b\"key3\");\n    let source = pd_client.get_region(b\"key1\").unwrap();\n    let target = pd_client.get_region(b\"key5\").unwrap();\n\n    // Trigger merge rollback\n    let on_schedule_merge = \"on_schedule_merge\";\n    fail::cfg(on_schedule_merge, \"return()\").unwrap();\n    cluster.must_try_merge(source.get_id(), target.get_id());\n    // Change the epoch of target region and the merge will fail\n    pd_client.must_remove_peer(target.get_id(), new_peer(3, 3));\n    fail::remove(on_schedule_merge);\n\n    // Make sure the rollback is done, it is okey to use raw kv here\n    cluster.must_put(b\"key2\", b\"value2\");\n\n    let mut source_client3 = PeerClient::new(\n        &cluster,\n        source.get_id(),\n        find_peer(&source, 3).unwrap().clone(),\n    );\n    source_client3.ctx.set_stale_read(true);\n    // the `safe_ts` should resume updating after merge rollback so we can read\n    // `key1` with the newest ts\n    source_client3.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::mock_nameserver_with_addr", "code": "fn mock_nameserver_on_send_nx<O: OnSend + Unpin>(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    options: ResolverOpts,\n    on_send: O,\n    addr: IpAddr,\n    trust_negative_responses: bool,\n) -> MockedNameServer<O> {\n    let conn_provider = MockConnProvider {\n        on_send: on_send.clone(),\n        _p: Default::default(),\n    };\n    let client = MockClientHandle::mock_on_send(messages, on_send);\n\n    NameServer::from_conn(\n        NameServerConfig {\n            socket_addr: SocketAddr::new(addr, 0),\n            protocol: Protocol::Udp,\n            tls_dns_name: None,\n            trust_negative_responses,\n            #[cfg(any(feature = \"dns-over-rustls\", feature = \"dns-over-https-rustls\"))]\n            tls_config: None,\n            bind_addr: None,\n        },\n        options,\n        client,\n        conn_provider,\n    )\n}", "test": "fn mock_nameserver_with_addr(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    addr: IpAddr,\n    options: ResolverOpts,\n) -> MockedNameServer<DefaultOnSend> {\n    mock_nameserver_on_send_nx(messages, options, DefaultOnSend, addr, false)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_big_p", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_big_p() {\n    if geteuid() != 0 {\n        new_ucmd!()\n            .arg(\"-RP\")\n            .arg(\"bin\")\n            .arg(\"/proc/self/cwd\")\n            .fails()\n            .stderr_contains(\n                // linux fails with \"Operation not permitted (os error 1)\"\n                // because of insufficient permissions,\n                // android fails with \"Permission denied (os error 13)\"\n                // because it can't resolve /proc (even though it can resolve /proc/self/)\n                \"chown: changing ownership of '/proc/self/cwd': \",\n            );\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/table.rs::table_test_6", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn table_test_6() {\n    let original = r##\"| Col 1 | Col 2 |\n|-------|-------|\n|       |       |\n|       |       |\n\"##;\n    let expected = r##\"<table><thead><tr><th> Col 1 </th><th> Col 2 </th></tr></thead>\n<tr><td>       </td><td>       </td></tr>\n<tr><td>       </td><td>       </td></tr>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::r#for", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn r#for() {\n    // Make sure \"in\" expressions are forbidden in the right places\n    test(\"for ((a in b);;);\", \"for((a in b);;);\");\n    test(\"for (a ? b : (c in d);;);\", \"for(a?b:(c in d);;);\");\n    test(\"for ((a ? b : c in d).foo;;);\", \"for((a?b:c in d).foo;;);\");\n    test(\"for (var x = (a in b);;);\", \"for(var x=(a in b);;);\");\n    test(\"for (x = (a in b);;);\", \"for(x=(a in b);;);\");\n    test(\"for (x == (a in b);;);\", \"for(x==(a in b);;);\");\n    test(\"for (1 * (x == a in b);;);\", \"for(1*(x==a in b);;);\");\n    test(\"for (a ? b : x = (c in d);;);\", \"for(a?b:x=(c in d);;);\");\n    test(\"for (var x = y = (a in b);;);\", \"for(var x=y=(a in b);;);\");\n    test(\"for ([a in b];;);\", \"for([a in b];;);\");\n    test(\"for (x(a in b);;);\", \"for(x(a in b);;);\");\n    test(\"for (x[a in b];;);\", \"for(x[a in b];;);\");\n    test(\"for (x?.[a in b];;);\", \"for(x?.[a in b];;);\");\n    test(\"for ((x => a in b);;);\", \"for(x=>(a in b);;);\");\n\n    // Make sure for-of loops with commas are wrapped in parentheses\n    test(\"for (let a in b, c);\", \"for(let a in b,c);\");\n    test(\"for (let a of (b, c));\", \"for(let a of (b,c));\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_uname_help() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .succeeds()\n        .stdout_contains(\"system information\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_try_parse_8digits", "code": "pub fn parse<N: FromLexical, Bytes: AsRef<[u8]>>(bytes: Bytes) -> Result<N> {\n    N::from_lexical(bytes.as_ref())\n}", "test": "fn test_try_parse_8digits() {\n    let parse = |bytes: &[u8]| {\n        let mut digits = bytes.bytes::<{ STANDARD }>();\n        algorithm::try_parse_8digits::<u64, _, STANDARD>(&mut digits.integer_iter())\n    };\n\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n    assert_eq!(parse(b\"1234567\"), None);\n    assert_eq!(parse(b\"1234567\\x00\"), None);\n    assert_eq!(parse(b\"1234567.\"), None);\n    assert_eq!(parse(b\"1234567_\"), None);\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_select_star_except", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_select_star_except() {\n    clickhouse().verified_stmt(\"SELECT * EXCEPT (prev_status) FROM anomalies\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_squeeze_blank_before_numbering", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_squeeze_blank_before_numbering() {\n    for same_param in [\"-s\", \"--squeeze-blank\"] {\n        new_ucmd!()\n            .args(&[same_param, \"-n\", \"-\"])\n            .pipe_in(\"a\\n\\n\\nb\")\n            .succeeds()\n            .stdout_only(\"     1\\ta\\n     2\\t\\n     3\\tb\");\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_13", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_13() {\n    let original = r##\"# H1 #id1 }\n## H2 #id2}\n\"##;\n    let expected = r##\"<h1>H1 #id1 }</h1>\n<h2>H2 #id2}</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_io.rs::test_async_io_cannot_handle_ready_when_persist_snapshot", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_async_io_cannot_handle_ready_when_persist_snapshot() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    configure_for_snapshot(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    for i in 2..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    must_get_equal(&cluster.get_engine(2), b\"k9\", b\"v1\");\n\n    let raft_before_save_kv_on_store_3_fp = \"raft_before_save_kv_on_store_3\";\n    fail::cfg(raft_before_save_kv_on_store_3_fp, \"pause\").unwrap();\n\n    let (notify_tx, notify_rx) = mpsc::channel();\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(MessageTypeNotifier::new(\n            MessageType::MsgSnapshot,\n            notify_tx,\n            Arc::new(AtomicBool::new(true)),\n        )),\n    );\n\n    cluster.clear_send_filters();\n\n    // Wait for leader sending snapshot to peer 3\n    notify_rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    // Wait for peer 3 handling snapshot\n    sleep_ms(100);\n\n    let panic_if_handle_ready_3_fp = \"panic_if_handle_ready_3\";\n    fail::cfg(panic_if_handle_ready_3_fp, \"return\").unwrap();\n\n    for i in 10..20 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    cluster.must_transfer_leader(r1, new_peer(2, 2));\n\n    for i in 20..30 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    fail::remove(panic_if_handle_ready_3_fp);\n    fail::remove(raft_before_save_kv_on_store_3_fp);\n\n    must_get_equal(&cluster.get_engine(3), b\"k29\", b\"v1\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error_scaled64_test", "code": "fn compute_error_scaled64(q: i64, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f64>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error_scaled64_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 10),\n        (1065 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 10),\n        (1065 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 10),\n        (1065 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 10),\n        (1065 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 10),\n        (1065 + INVALID_FP, 9223372036854779904)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 9),\n        (1066 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 9),\n        (1066 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 9),\n        (1066 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 9),\n        (1066 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 9),\n        (1066 + INVALID_FP, 9223372036854779904)\n    );\n\n    // Test a much closer set of examples.\n    assert_eq!(\n        compute_error_scaled64(0, 9223372036854774784, 11),\n        (1064 + INVALID_FP, 18446744073709549568)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388415, 0),\n        (1075 + INVALID_FP, 9223372036854776830)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765748947, 10),\n        (925 + INVALID_FP, 13021432563531497894)\n    );\n    assert_eq!(\n        compute_error_scaled64(-43, 6510716281765749303, 7),\n        (925 + INVALID_FP, 13021432563531498606)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765749660, 10),\n        (925 + INVALID_FP, 13021432563531499320)\n    );\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854775808, 1),\n        (1065 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854776832, 1),\n        (1065 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854777856, 1),\n        (1065 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854778880, 1),\n        (1065 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854779904, 1),\n        (1065 + INVALID_FP, 9223372036854779904)\n    );\n\n    // Test from errors in atof.\n    assert_eq!(\n        compute_error_scaled64(-18, 9223373686122217470, 4),\n        (1012 + INVALID_FP, 9223373686122217470)\n    );\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error_scaled64(-342, 9223372036854775804, 2),\n        (-64 + INVALID_FP, 18446744073709551608)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_disable_escapes", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_disable_escapes() {\n    let input_str = \"\\\\a \\\\\\\\ \\\\b \\\\r \\\\e \\\\f \\\\x41 \\\\n a\\\\cb \\\\u0100 \\\\t \\\\v\";\n    new_ucmd!()\n        .arg(\"-E\")\n        .arg(input_str)\n        .succeeds()\n        .stdout_only(format!(\"{input_str}\\n\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_recover_snapshot", "code": "pub fn must_put(&mut self, key: &[u8], value: &[u8]) {\n        self.must_put_cf(CF_DEFAULT, key, value);\n    }", "test": "fn test_node_merge_recover_snapshot() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 12;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(12);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    // Start the cluster and evict the region leader from peer 3.\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k3\").unwrap();\n    let target_region = pd_client.get_region(b\"k1\").unwrap();\n\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    cluster.must_try_merge(region.get_id(), target_region.get_id());\n\n    // Remove a peer to trigger rollback.\n    pd_client.must_remove_peer(left.get_id(), left.get_peers()[0].to_owned());\n    must_get_none(&cluster.get_engine(3), b\"k4\");\n\n    let step_store_3_region_1 = \"step_message_3_1\";\n    fail::cfg(step_store_3_region_1, \"return()\").unwrap();\n    fail::remove(schedule_merge_fp);\n\n    for i in 0..100 {\n        cluster.must_put(format!(\"k4{}\", i).as_bytes(), b\"v4\");\n    }\n    fail::remove(step_store_3_region_1);\n    must_get_equal(&cluster.get_engine(3), b\"k40\", b\"v4\");\n    cluster.must_transfer_leader(1, new_peer(3, 3));\n    cluster.must_put(b\"k40\", b\"v5\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_for_if_nodes", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn handle_ws_for_if_nodes() {\n    let end_ws = WS { left: false, right: true };\n    let ast = vec![\n        Node::Text(\"C \".to_string()),\n        Node::If(\n            If {\n                conditions: vec![\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: false },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                ],\n                otherwise: None,\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"C\".to_string()),\n            Node::If(\n                If {\n                    conditions: vec![\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: false },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\" a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a \".to_string())],\n                        ),\n                    ],\n                    otherwise: None,\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_hex_identifier_in_wrong_place", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_hex_identifier_in_wrong_place() {\n    new_ucmd!()\n        .args(&[\"1234ABCD0x\"])\n        .fails()\n        .no_stdout()\n        .usage_error(\"invalid floating point argument: '1234ABCD0x'\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::reserved_capacity_assigned_in_multi_window_updates", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn reserved_capacity_assigned_in_multi_window_updates() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let (response, mut stream) = client.send_request(request, false).unwrap();\n\n        // Consume the capacity\n        let payload = vec![0; frame::DEFAULT_INITIAL_WINDOW_SIZE as usize];\n        stream.send_data(payload.into(), false).unwrap();\n\n        // Reserve more data than we want\n        stream.reserve_capacity(10);\n\n        let mut stream = h2.drive(util::wait_for_capacity(stream, 5)).await;\n        stream.send_data(\"hello\".into(), false).unwrap();\n        stream.send_data(\"world\".into(), true).unwrap();\n\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::NO_CONTENT);\n\n        // Wait for the connection to close\n        h2.await.unwrap();\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_383])).await;\n        idle_ms(100).await;\n        // Increase the connection window\n        srv.send_frame(frames::window_update(0, 10)).await;\n        // Incrementally increase the stream window\n        srv.send_frame(frames::window_update(1, 4)).await;\n        idle_ms(50).await;\n        srv.send_frame(frames::window_update(1, 1)).await;\n        // Receive first chunk\n        srv.recv_frame(frames::data(1, \"hello\")).await;\n        srv.send_frame(frames::window_update(1, 5)).await;\n        // Receive second chunk\n        srv.recv_frame(frames::data(1, \"world\").eos()).await;\n        srv.send_frame(frames::headers(1).response(204).eos()).await;\n        /*\n        .recv_frame(frames::data(1, \"hello\").eos())\n        .send_frame(frames::window_update(1, 5))\n        */\n    };\n    join(srv, h2).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_fail_null_with_program", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_fail_null_with_program() {\n    new_ucmd!()\n        .arg(\"--null\")\n        .arg(\"cd\")\n        .fails()\n        .stderr_contains(\"cannot specify --null (-0) with command\");\n}"}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/fnmut.rs::accumulate", "code": "fn parse_peek(&mut self, mut input: I) -> IResult<I, O, E> {\n        match self.parse_next(&mut input) {\n            Ok(o) => Ok((input, o)),\n            Err(err) => Err(err),\n        }\n    }", "test": "fn accumulate() {\n    let mut v = Vec::new();\n\n    let (_, count) = {\n        let mut parser = repeat::<_, _, usize, (), _>(\n            0..,\n            unpeek(|i| {\n                let (i, o) = \"abc\".parse_peek(i)?;\n                v.push(o);\n                Ok((i, ()))\n            }),\n        );\n        parser.parse_peek(\"abcabcabcabc\").unwrap()\n    };\n\n    println!(\"v: {:?}\", v);\n    assert_eq!(count, 4);\n    assert_eq!(v.len(), 4);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::help", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn help() {\n    new_ucmd!().fails();\n    new_ucmd!().arg(\"--help\").succeeds();\n    new_ucmd!().arg(\"-h\").fails(); // -h is NOT --help, it is actually --no-dereference.\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_spaceship", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_spaceship() {\n    let spaceship = \"SELECT * FROM db.table WHERE a <=> b\";\n    hive().verified_stmt(spaceship);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::pass_moved_resource", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn pass_moved_resource() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (core module $m\n                    (func (export \"f\") (param i32 i32))\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (own $t)) (param \"y\" (borrow $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>, &Resource<MyType>), ()>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource, &resource)).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"host resource already consumed\"),\n        \"bad error: {err:?}\"\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_no_operands", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_no_operands() {\n    new_ucmd!()\n        .arg(\"777\")\n        .fails()\n        .code_is(1)\n        .usage_error(\"missing operand\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_unknown_inscription", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn send_unknown_inscription() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let txid = rpc_server.mine_blocks(1)[0].txdata[0].txid();\n\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qcqgs2pps4u4yedfyl5pysdjjncs8et5utseepv {txid}i0\"\n  ))\n  .rpc_server(&rpc_server)\n  .expected_stderr(format!(\"error: Inscription {txid}i0 not found\\n\"))\n  .expected_exit_code(1)\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_no_permission_dir", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_sync_no_permission_dir() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n    let dir = \"foo\";\n    at.mkdir_all(dir);\n\n    ts.ccmd(\"chmod\").arg(\"0\").arg(dir).succeeds();\n    let result = ts.ucmd().arg(\"--data\").arg(dir).fails();\n    result.stderr_contains(\"sync: error opening 'foo': Permission denied\");\n    let result = ts.ucmd().arg(dir).fails();\n    result.stderr_contains(\"sync: error opening 'foo': Permission denied\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/tests/workspace.rs::debug_control_flow", "code": "pub fn get_control_flow_graph(&self, cursor: TextSize) -> Result<String, WorkspaceError> {\n        self.workspace\n            .get_control_flow_graph(GetControlFlowGraphParams {\n                path: self.path.clone(),\n                cursor,\n            })\n    }", "test": "fn debug_control_flow() {\n    const SOURCE: &str = \"function test () { return; }\";\n    const GRAPH: &str = \"flowchart TB\n    block_0[\\\"<b>block_0</b><br/>Return(JS_RETURN_STATEMENT 19..26)<br/>Return\\\"]\n\n\";\n\n    let workspace = server();\n\n    let file = FileGuard::open(\n        workspace.as_ref(),\n        OpenFileParams {\n            path: RomePath::new(\"file.js\"),\n            content: SOURCE.into(),\n            version: 0,\n            language_hint: Language::JavaScript,\n        },\n    )\n    .unwrap();\n\n    let cfg = file.get_control_flow_graph(TextSize::from(20)).unwrap();\n\n    assert_eq!(cfg, GRAPH);\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::issue_195", "code": "pub fn get_size(&self) -> (usize, usize) {\n        (self.height(), self.width())\n    }", "test": "fn issue_195() {\n    setup();\n\n    let path = format!(\n        \"{}/JLCPCB SMT Parts Library(20210204).xls\",\n        env!(\"CARGO_MANIFEST_DIR\")\n    );\n    let mut excel: Xls<_> = open_workbook(&path).expect(\"can't open wb\");\n    let range = excel\n        .worksheet_range(\"JLCPCB SMT Parts Library\")\n        .expect(\"error in wks range\")\n        .expect(\"sheet not found\");\n    assert_eq!(range.get_size(), (52046, 12));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_five_nodes", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_five_nodes() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    // quorum is lost, can't propose command successfully.\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    // forbid writes in force leader state\n    let put = new_put_cmd(b\"k3\", b\"v3\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, put);\n    // forbid reads in force leader state\n    let get = new_get_cmd(b\"k1\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, get);\n    // forbid read index in force leader state\n    let read_index = new_read_index_cmd();\n    must_get_error_recovery_in_progress(&mut cluster, &region, read_index);\n\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::wrong_start_block", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn wrong_start_block() {\n    assert_err_msg(\n        \"{{ if true %}\",\n        &[\n            \"1:7\",\n            \"expected `or`, `and`, `not`, `<=`, `>=`, `<`, `>`, `==`, `!=`, `+`, `-`, `*`, `/`, `%`, a filter, or a variable end (`}}`)\"\n        ],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_error_filename_only", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_error_filename_only() {\n    // truncate: you must specify either '--size' or '--reference'\n    new_ucmd!()\n        .args(&[\"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"error: the following required arguments were not provided:\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage_with_stage_params", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_create_stage_with_stage_params() {\n    let sql = concat!(\n        \"CREATE OR REPLACE STAGE my_ext_stage \",\n        \"URL='s3://load/files/' \",\n        \"STORAGE_INTEGRATION=myint \",\n        \"ENDPOINT='<s3_api_compatible_endpoint>' \",\n        \"CREDENTIALS=(AWS_KEY_ID='1a2b3c' AWS_SECRET_KEY='4x5y6z') \",\n        \"ENCRYPTION=(MASTER_KEY='key' TYPE='AWS_SSE_KMS')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage { stage_params, .. } => {\n            assert_eq!(\"s3://load/files/\", stage_params.url.unwrap());\n            assert_eq!(\"myint\", stage_params.storage_integration.unwrap());\n            assert_eq!(\n                \"<s3_api_compatible_endpoint>\",\n                stage_params.endpoint.unwrap()\n            );\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_KEY_ID\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"1a2b3c\".to_string()\n                }));\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_SECRET_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"4x5y6z\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"MASTER_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"key\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"TYPE\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"AWS_SSE_KMS\".to_string()\n                }));\n        }\n        _ => unreachable!(),\n    };\n\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shred.rs::test_shred_force", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_shred_force() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_shred_force\";\n\n    // Create file_a.\n    at.touch(file);\n    assert!(at.file_exists(file));\n\n    // Make file_a readonly.\n    at.set_readonly(file);\n\n    // Try shred -u.\n    scene.ucmd().arg(\"-u\").arg(file).run();\n\n    // file_a was not deleted because it is readonly.\n    assert!(at.file_exists(file));\n\n    // Try shred -u -f.\n    scene.ucmd().arg(\"-u\").arg(\"-f\").arg(file).run();\n\n    // file_a was deleted.\n    assert!(!at.file_exists(file));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_no_clobber_conflicting_options", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_cp_backup_no_clobber_conflicting_options() {\n    new_ucmd!()\n        .arg(\"--backup\")\n        .arg(\"--no-clobber\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .fails()\n        .usage_error(\"options --backup and --no-clobber are mutually exclusive\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_echo_and_input_range_not_allowed", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_shuf_echo_and_input_range_not_allowed() {\n    new_ucmd!()\n        .args(&[\"-e\", \"0\", \"-i\", \"0-2\"])\n        .fails()\n        .stderr_contains(\"cannot be used with\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_tasklist.rs::gfm_tasklist_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_tasklist_test_1() {\n    let original = r##\"- [ ] foo\n- [x] bar\n\"##;\n    let expected = r##\"<ul>\n<li><input disabled=\"\" type=\"checkbox\"> foo</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> bar</li>\n</ul>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_directory_with_parents", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_ignore_nonempty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(NESTED_DIR_FILE);\n\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(\"-p\")\n        .arg(NESTED_DIR)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(NESTED_DIR));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer128", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_integer128() {\n    let signed = &[i128::min_value(), -1, 0, 1, i128::max_value()];\n    let unsigned = &[0, 1, u128::max_value()];\n\n    for integer128 in signed {\n        let expected = integer128.to_string();\n        assert_eq!(to_string(integer128).unwrap(), expected);\n        assert_eq!(from_str::<i128>(&expected).unwrap(), *integer128);\n    }\n\n    for integer128 in unsigned {\n        let expected = integer128.to_string();\n        assert_eq!(to_string(integer128).unwrap(), expected);\n        assert_eq!(from_str::<u128>(&expected).unwrap(), *integer128);\n    }\n\n    test_parse_err::<i128>(&[\n        (\n            \"-170141183460469231731687303715884105729\",\n            \"number out of range at line 1 column 40\",\n        ),\n        (\n            \"170141183460469231731687303715884105728\",\n            \"number out of range at line 1 column 39\",\n        ),\n    ]);\n\n    test_parse_err::<u128>(&[\n        (\"-1\", \"number out of range at line 1 column 1\"),\n        (\n            \"340282366920938463463374607431768211456\",\n            \"number out of range at line 1 column 39\",\n        ),\n    ]);\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/lib.rs::read_exif_data", "code": "pub fn exif_data(&self) -> Option<&[u8]> {\n        self.exif_data.as_deref()\n    }", "test": "fn read_exif_data() {\n    let path = Path::new(\"tests\")\n        .join(\"reftest\")\n        .join(\"images\")\n        .join(\"ycck.jpg\");\n\n    let mut decoder = jpeg::Decoder::new(File::open(&path).unwrap());\n    decoder.decode().unwrap();\n\n    let exif_data = decoder.exif_data().unwrap();\n    // exif data start as a TIFF header\n    assert_eq!(&exif_data[0..8], b\"\\x49\\x49\\x2A\\x00\\x08\\x00\\x00\\x00\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_fixed_width_value_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn vec_fixed_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<u64>> = TableDefinition::new(\"x\");\n\n    let value = vec![0, 1, 2, 3];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_checksum.rs::test_checksum", "code": "pub fn get_data(&self) -> &[u8] {\n        &self.data\n    }", "test": "fn test_checksum() {\n    let data = vec![\n        (1, Some(\"name:1\"), 1),\n        (2, Some(\"name:2\"), 2),\n        (3, Some(\"name:3\"), 3),\n        (4, Some(\"name:4\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (store, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    for column in &[&product[\"id\"], &product[\"name\"], &product[\"count\"]] {\n        assert!(column.index >= 0);\n        let (range, scan_on) = if column.index == 0 {\n            let range = product.get_record_range_all();\n            (range, ChecksumScanOn::Table)\n        } else {\n            let range = product.get_index_range_all(column.index);\n            (range, ChecksumScanOn::Index)\n        };\n        let request = new_checksum_request(range.clone(), scan_on);\n        let expected = reversed_checksum_crc64_xor(&store, range);\n\n        let response = handle_request(&endpoint, request);\n        let mut resp = ChecksumResponse::default();\n        resp.merge_from_bytes(response.get_data()).unwrap();\n        assert_eq!(resp.get_checksum(), expected);\n        assert_eq!(resp.get_total_kvs(), data.len() as u64);\n    }\n}"}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/parse_self.rs::test_parse_self_debug_info_with_endian_rc_slice", "code": "fn impl_parse_self_debug_info<R: gimli::Reader>(\n    debug_info: &DebugInfo<R>,\n    debug_abbrev: &DebugAbbrev<R>,\n) {\n    let mut iter = debug_info.units();\n    while let Some(unit) = iter.next().expect(\"Should parse compilation unit\") {\n        let abbrevs = unit\n            .abbreviations(&debug_abbrev)\n            .expect(\"Should parse abbreviations\");\n\n        let mut cursor = unit.entries(&abbrevs);\n\n        while cursor.next_dfs().expect(\"Should parse next dfs\").is_some() {\n            let entry = cursor.current().expect(\"Should have a current entry\");\n\n            let mut attrs = entry.attrs();\n            while let Some(attr) = attrs.next().expect(\"Should parse entry's attribute\") {\n                if let AttributeValue::Exprloc(expression) = attr.value() {\n                    parse_expression(expression, unit.encoding());\n                }\n            }\n        }\n    }\n}", "test": "fn test_parse_self_debug_info_with_endian_rc_slice() {\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = Rc::from(&debug_info[..]);\n    let debug_info = gimli::EndianRcSlice::new(debug_info, LittleEndian);\n    let debug_info = DebugInfo::from(debug_info);\n\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = Rc::from(&debug_abbrev[..]);\n    let debug_abbrev = gimli::EndianRcSlice::new(debug_abbrev, LittleEndian);\n    let debug_abbrev = DebugAbbrev::from(debug_abbrev);\n\n    impl_parse_self_debug_info(&debug_info, &debug_abbrev);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tty.rs::test_close_stdin_silent_alias", "code": "pub fn wait(self) -> io::Result<CmdResult> {\n        let (bin_path, util_name, tmpd) = (\n            self.bin_path.clone(),\n            self.util_name.clone(),\n            self.tmpd.clone(),\n        );\n\n        #[allow(deprecated)]\n        let output = self.wait_with_output()?;\n\n        Ok(CmdResult {\n            bin_path,\n            util_name,\n            tmpd,\n            exit_status: Some(output.status),\n            stdout: output.stdout,\n            stderr: output.stderr,\n        })\n    }", "test": "fn test_close_stdin_silent_alias() {\n    let mut child = new_ucmd!().arg(\"--quiet\").run_no_wait();\n    child.close_stdin();\n    child.wait().unwrap().code_is(1).no_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_words", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_words() {\n    new_ucmd!()\n        .arg(\"-w\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"87\\n\");\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_bad_input", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "test": "fn test_bad_input() {\n    assert_eq!(Error::MalformedInput, s2d(b\"x\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"..\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1ee1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1e.1\").unwrap_err());\n    assert_eq!(Error::InputTooShort, s2d(b\"\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"123456789012345678\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"1e12345\").unwrap_err());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_same_file_not_dot_dir", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_mv_same_file_not_dot_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_errors_dir\";\n\n    at.mkdir(dir);\n    ucmd.arg(dir).arg(dir).fails().stderr_is(format!(\n        \"mv: cannot move '{dir}' to a subdirectory of itself, '{dir}/{dir}'\\n\",\n    ));\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_negative_lit", "code": "fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n}", "test": "fn test_negative_lit() {\n    let meta = test(\"#[form(min = -1, max = 200)]\");\n\n    snapshot!(meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"form\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`min = - 1 , max = 200`),\n    }\n    \"###);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_arg1_arg2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_arg1_arg2() {\n    let args = [\"am\", \"i\"];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::deny_unicode_escape_in_true_expression", "code": "pub(super) fn check_invalid_script(js: &str) {\n    assert!(Parser::new(Source::from_bytes(js))\n        .parse_script(&mut Interner::default())\n        .is_err());\n}", "test": "fn deny_unicode_escape_in_true_expression() {\n    check_invalid_script(r\"let x = tru\\u{65};\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_multiple_occurrences", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "test": "fn test_output_multiple_occurrences() {\n    let output = new_ucmd!()\n        .args(&[\"--output=source\", \"--output=target\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\"]\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_loop_break_label", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_loop_break_label() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var str = \"\";\n\n            outer: for (let i = 0; i < 5; i++) {\n                inner: for (let b = 0; b < 5; b++) {\n                    if (b === 2) {\n                    break outer;\n                    }\n                    str = str + b;\n                }\n                str = str + i;\n            }\n            str\n        \"#},\n        \"01\",\n    )]);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_filter_works", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn filter_filter_works() {\n    #[derive(Debug, Serialize)]\n    struct Author {\n        id: u8,\n    }\n\n    let mut context = Context::new();\n    context.insert(\"authors\", &vec![Author { id: 1 }, Author { id: 2 }, Author { id: 3 }]);\n\n    let inputs =\n        vec![(r#\"{{ authors | filter(attribute=\"id\", value=1) | first | get(key=\"id\") }}\"#, \"1\")];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_drop_packet", "code": "fn test_multi_drop_packet<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(DropPacketFilter::new(30)));\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_server_drop_packet() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_drop_packet(&mut cluster);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_types_simple", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_types_simple() {\n    let test = SemanticTester::ts(\n        \"\n    interface A {\n      x: number;\n      y: string;\n    }\n    type T = { x: number; y: string; }\n\n    const t: T = { x: 1, y: 'foo' };\n    \",\n    );\n    test.has_root_symbol(\"A\")\n        .contains_flags(SymbolFlags::Interface)\n        .has_number_of_references(0)\n        .test();\n\n    test.has_root_symbol(\"T\")\n        .contains_flags(SymbolFlags::TypeAlias)\n        .has_number_of_references(1)\n        .test();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_single_tab_should_not_add_extra_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_single_tab_should_not_add_extra_newline() {\n    new_ucmd!()\n        .args(&[\"-w1\", \"-b\"])\n        .pipe_in(\"\\t\")\n        .succeeds()\n        .stdout_is(\"\\t\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_cname_lookup", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_cname_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(resp_query, vec![cname_record, v4_record], vec![], vec![]);\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_users.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_carriage_return_should_not_reset_column_count", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_carriage_return_should_not_reset_column_count() {\n    new_ucmd!()\n        .args(&[\"-w6\", \"-b\"])\n        .pipe_in(\"12345\\r123456789abcdef\")\n        .succeeds()\n        .stdout_is(\"12345\\r\\n123456\\n789abc\\ndef\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_into_self_data", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_into_self_data() {\n    let scene = TestScenario::new(util_name!());\n\n    let at = &scene.fixtures;\n    let sub_dir = \"sub_folder\";\n    let file1 = \"t1.test\";\n    let file2 = \"sub_folder/t2.test\";\n\n    let file1_result_location = \"sub_folder/t1.test\";\n\n    at.mkdir(sub_dir);\n    at.touch(file1);\n    at.touch(file2);\n\n    let result = scene.ucmd().arg(file1).arg(sub_dir).arg(sub_dir).run();\n\n    // sub_dir exists, file1 has been moved, file2 still exists.\n    result.code_is(1);\n\n    assert!(at.dir_exists(sub_dir));\n    assert!(at.file_exists(file1_result_location));\n    assert!(at.file_exists(file2));\n    assert!(!at.file_exists(file1));\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::alpn_mismatch", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn alpn_mismatch() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"quux\".into(), \"corge\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(err) }) if err.error_code == TransportErrorCode::crypto(0x78)\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/mdns_tests.rs::test_query_mdns_ipv4", "code": "fn store(&self, conn_state: NameServerStateInner) {\n        self.conn_state\n            .store(conn_state.into(), atomic::Ordering::Release);\n    }", "test": "fn test_query_mdns_ipv4() {\n    let addr = SocketAddr::new(*TEST_MDNS_IPV4, MDNS_PORT + 1);\n    let client_done = Arc::new(AtomicBool::new(false));\n    let _server_thread = mdns_responsder(\"test_query_mdns_ipv4\", client_done.clone(), addr);\n\n    // Check that the server is ready before sending...\n    let io_loop = Runtime::new().unwrap();\n    //let addr: SocketAddr = (\"8.8.8.8\", 53).to_socket_addrs().unwrap().next().unwrap();\n\n    // not using MdnsClientConnection here, b/c we need to change the IP for testing.\n    let (stream, sender) = MdnsClientStream::new(addr, MdnsQueryType::OneShot, None, None, None);\n    let client = AsyncClient::new(stream, sender, None);\n    let (mut client, bg) = io_loop.block_on(client).expect(\"failed to connect mDNS\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // A PTR request is the DNS-SD method for doing a directory listing...\n    let name = Name::from_ascii(\"_dns._udp.local.\").unwrap();\n    let message = io_loop.block_on(client.query(name, DNSClass::IN, RecordType::PTR));\n\n    client_done.store(true, Ordering::Relaxed);\n\n    println!(\"client message: {:#?}\", message);\n}"}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/parse_self.rs::test_parse_self_debug_line", "code": "fn is_empty(&self) -> bool {\n        self.slice.is_empty()\n    }", "test": "fn test_parse_self_debug_line() {\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = DebugInfo::new(&debug_info, LittleEndian);\n\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);\n\n    let debug_line = read_section(\"debug_line\");\n    let debug_line = DebugLine::new(&debug_line, LittleEndian);\n\n    let debug_str = read_section(\"debug_str\");\n    let debug_str = DebugStr::new(&debug_str, LittleEndian);\n\n    let mut iter = debug_info.units();\n    while let Some(unit) = iter.next().expect(\"Should parse compilation unit\") {\n        let abbrevs = unit\n            .abbreviations(&debug_abbrev)\n            .expect(\"Should parse abbreviations\");\n\n        let mut cursor = unit.entries(&abbrevs);\n        cursor.next_dfs().expect(\"Should parse next dfs\");\n\n        let unit_entry = cursor.current().expect(\"Should have a root entry\");\n\n        let comp_dir = unit_entry\n            .attr_value(gimli::DW_AT_comp_dir)\n            .expect(\"Should parse comp_dir attribute\")\n            .and_then(|val| val.string_value(&debug_str));\n        let comp_name = unit_entry\n            .attr_value(gimli::DW_AT_name)\n            .expect(\"Should parse name attribute\")\n            .and_then(|val| val.string_value(&debug_str));\n\n        if let Some(AttributeValue::DebugLineRef(offset)) = unit_entry\n            .attr_value(gimli::DW_AT_stmt_list)\n            .expect(\"Should parse stmt_list\")\n        {\n            let program = debug_line\n                .program(offset, unit.address_size(), comp_dir, comp_name)\n                .expect(\"should parse line number program header\");\n\n            let mut results = Vec::new();\n            let mut rows = program.rows();\n            while let Some((_, row)) = rows\n                .next_row()\n                .expect(\"Should parse and execute all rows in the line number program\")\n            {\n                results.push(*row);\n            }\n            results.reverse();\n\n            let program = debug_line\n                .program(offset, unit.address_size(), comp_dir, comp_name)\n                .expect(\"should parse line number program header\");\n            let (program, sequences) = program\n                .sequences()\n                .expect(\"should parse and execute the entire line number program\");\n            assert!(!sequences.is_empty()); // Should be at least one sequence.\n            for sequence in sequences {\n                let mut rows = program.resume_from(&sequence);\n                while let Some((_, row)) = rows\n                    .next_row()\n                    .expect(\"Should parse and execute all rows after resuming\")\n                {\n                    let other_row = results.pop().unwrap();\n                    assert!(row.address() >= sequence.start);\n                    assert!(row.address() <= sequence.end);\n                    assert_eq!(row.address(), other_row.address());\n                    assert_eq!(row.line(), other_row.line());\n                }\n            }\n            assert!(results.is_empty());\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_base64_encode_file", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_base64_encode_file() {\n    new_ucmd!()\n        .arg(\"input-simple.txt\")\n        .succeeds()\n        .stdout_only(\"SGVsbG8sIFdvcmxkIQo=\\n\"); // spell-checker:disable-line\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_underflow_relative_size", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_underflow_relative_size() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-s-1\", FILE1])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert!(at.file_exists(FILE1));\n    assert!(at.read_bytes(FILE1).is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_between_dirs", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_file_between_dirs() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir1 = \"test_mv_move_file_between_dirs_dir1\";\n    let dir2 = \"test_mv_move_file_between_dirs_dir2\";\n    let file = \"test_mv_move_file_between_dirs_file\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    at.touch(format!(\"{dir1}/{file}\"));\n\n    assert!(at.file_exists(format!(\"{dir1}/{file}\")));\n\n    ucmd.arg(&format!(\"{dir1}/{file}\"))\n        .arg(dir2)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(format!(\"{dir1}/{file}\")));\n    assert!(at.file_exists(format!(\"{dir2}/{file}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_same_rollback_all", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_same_rollback_all() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    assert_engine_error(wb.pop_save_point());\n    assert_engine_error(wb.rollback_to_save_point());\n\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n\n    assert!(a.is_some());\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    assert_engine_error(wb.pop_save_point());\n    assert_engine_error(wb.rollback_to_save_point());\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    for i in max_keys..2 * max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_dereferenced_symlink", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_dereferenced_symlink() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"check_rome_test_broken_symlink\");\n    let subdir_path = root_path.join(\"prefix\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(subdir_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(root_path.join(\"null\"), root_path.join(\"broken_symlink\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_file(\n            root_path.join(\"null\"),\n            root_path.join(\"broken_symlink\")\n        ));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"check\"), root_path.display().to_string().as_str()].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_dereferenced_symlink\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/read_consistency.rs::iterator_with_writes_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iterator_with_writes_engine() {\n    let db = default_engine();\n    iterator_with_writes(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_width_too_big", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_fmt_width_too_big() {\n    for param in [\"-w\", \"--width\"] {\n        new_ucmd!()\n            .args(&[\"one-word-per-line.txt\", param, \"2501\"])\n            .fails()\n            .code_is(1)\n            .stderr_is(\"fmt: invalid width: '2501': Numerical result out of range\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_multiple_decimals_numeric", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_multiple_decimals_numeric() {\n    test_helper(\n        \"multiple_decimals_numeric\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::trap_smoke", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn trap_smoke() -> Result<()> {\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n    linker.func_wrap(\"\", \"\", || -> Result<()> { bail!(\"test\") })?;\n\n    let mut store = Store::new(&engine, ());\n\n    let f = linker.get(&mut store, \"\", \"\").unwrap().into_func().unwrap();\n\n    let err = f.call(&mut store, &[], &mut []).unwrap_err();\n\n    assert!(err.to_string().contains(\"test\"));\n\n    Ok(())\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/windows_shell.rs::windows_powershell_setting_uses_powershell_set_shell", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn windows_powershell_setting_uses_powershell_set_shell() {\n  Test::new()\n    .justfile(\n      r#\"\n      set windows-powershell\n      set shell := [\"asdfasdfasdfasdf\"]\n\n      foo:\n        Write-Output bar\n    \"#,\n    )\n    .shell(false)\n    .stdout(\"bar\\r\\n\")\n    .stderr(\"Write-Output bar\\n\")\n    .run();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_create_table", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_create_table() {\n    clickhouse().verified_stmt(r#\"CREATE TABLE \"x\" (\"a\" \"int\") ENGINE=MergeTree ORDER BY (\"x\")\"#);\n    clickhouse().one_statement_parses_to(\n        r#\"CREATE TABLE \"x\" (\"a\" \"int\") ENGINE=MergeTree ORDER BY \"x\"\"#,\n        r#\"CREATE TABLE \"x\" (\"a\" \"int\") ENGINE=MergeTree ORDER BY (\"x\")\"#,\n    );\n    clickhouse().verified_stmt(\n        r#\"CREATE TABLE \"x\" (\"a\" \"int\") ENGINE=MergeTree ORDER BY (\"x\") AS SELECT * FROM \"t\" WHERE true\"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(125);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::does_not_format_ignored_files", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn does_not_format_ignored_files() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_FORMATTER_IGNORED_FILES.as_bytes());\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"test.js\"), (\"--write\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_not_format_ignored_files\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_not_add_newline_when_line_longer_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_not_add_newline_when_line_longer_than_fold() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"1234\")\n        .succeeds()\n        .stdout_is(\"12\\n34\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_who.rs::test_login", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_login() {\n    let ts = TestScenario::new(util_name!());\n    for opt in [\"-l\", \"--login\", \"--log\"] {\n        let expected_stdout = unwrap_or_return!(expected_result(&ts, &[opt])).stdout_move_str();\n        ts.ucmd().arg(opt).succeeds().stdout_is(expected_stdout);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_word_boundary_only_whitespace", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_word_boundary_only_whitespace() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-s\"])\n        .pipe_in(\"    \")\n        .succeeds()\n        .stdout_is(\"  \\n  \");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_pooling_allocator_initial_limits_exceeded", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_pooling_allocator_initial_limits_exceeded() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.total_memories(2)\n        .max_memories_per_module(2)\n        .memory_pages(5);\n    let mut config = Config::new();\n    config.wasm_multi_memory(true);\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m1\") 2) (memory (export \"m2\") 5))\"#,\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(3 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 5 pages exceeds memory limits\"\n        ),\n    }\n\n    // An instance should still be able to be created after the failure above\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 2))\"#)?;\n\n    Instance::new(&mut store, &module, &[])?;\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_f16", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_f16() {\n    let input: [u8; 14] = [\n        0x00, 0x3c, // 0x3C00 1.0\n        0x00, 0x00, // 0x0000 0.0\n        0x00, 0x80, // 0x8000 -0.0\n        0x00, 0x7c, // 0x7C00 Inf\n        0x00, 0xfc, // 0xFC00 -Inf\n        0x00, 0xfe, // 0xFE00 NaN\n        0x00, 0x84,\n    ]; // 0x8400 -6.104e-5\n    let expected_output = unindent(\n        \"\n            0000000     1.000         0        -0       inf\n            0000010      -inf       NaN -6.104e-5\n            0000016\n            \",\n    );\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-tf2\")\n        .arg(\"-w8\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_works_with_dir", "code": "pub fn exists(&self, module: &str, name: &str) -> bool {\n        self.map\n            .contains_key(&(module.to_string(), name.to_string()))\n    }", "test": "fn test_wasmer_run_works_with_dir() {\n    let temp_dir = tempfile::TempDir::new().unwrap();\n    let qjs_path = temp_dir.path().join(\"qjs.wasm\");\n\n    std::fs::copy(fixtures::qjs(), &qjs_path).unwrap();\n    std::fs::copy(\n        fixtures::qjs_wasmer_toml(),\n        temp_dir.path().join(\"wasmer.toml\"),\n    )\n    .unwrap();\n\n    assert!(temp_dir.path().exists());\n    assert!(temp_dir.path().join(\"wasmer.toml\").exists());\n    assert!(temp_dir.path().join(\"qjs.wasm\").exists());\n\n    // test with \"wasmer qjs.wasm\"\n    Command::new(get_wasmer_path())\n        .arg(temp_dir.path())\n        .arg(\"--\")\n        .arg(\"--quit\")\n        .assert()\n        .success();\n\n    // test again with \"wasmer run qjs.wasm\"\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(temp_dir.path())\n        .arg(\"--\")\n        .arg(\"--quit\")\n        .assert()\n        .success();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_to_key_then_reverse_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_to_key_then_reverse_snapshot() {\n    let db = default_engine();\n    seek_to_key_then_reverse(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/find.rs::find_range_command_fails_for_unmined_sat_ranges", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn find_range_command_fails_for_unmined_sat_ranges() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new(format!(\n    \"--index-sats find {} {}\",\n    50 * COIN_VALUE,\n    100 * COIN_VALUE\n  ))\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(\"error: range has not been mined as of index height\\n\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_more.rs::test_invalid_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_invalid_arg() {\n    if std::io::stdout().is_terminal() {\n        new_ucmd!().arg(\"--invalid\").fails();\n\n        new_ucmd!().arg(\"--lines\").arg(\"-10\").fails();\n        new_ucmd!().arg(\"--number\").arg(\"-10\").fails();\n\n        new_ucmd!().arg(\"--from-line\").arg(\"-10\").fails();\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_inside_macro", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_location_inside_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'tpl\\': error while rendering macro `macros::hello`\"\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_28", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_28() {\n    let original = r##\"# H1 {\\}\n## this is also ok \\{\\}\n\nnewline can be used for setext heading {\n}\n--\n\"##;\n    let expected = r##\"<h1>H1 {}</h1>\n<h2>this is also ok {}</h2>\n<h2>newline can be used for setext heading {\n}</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::splitting_merged_inscriptions_is_possible", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "test": "fn splitting_merged_inscriptions_is_possible() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(3);\n\n  let inscription = envelope(&[b\"ord\", &[1], b\"text/plain;charset=utf-8\", &[], b\"bar\"]);\n\n  // merging 3 inscriptions into one utxo\n  let reveal_txid = rpc_server.broadcast_tx(TransactionTemplate {\n    inputs: &[\n      (1, 0, 0, inscription.clone()),\n      (2, 0, 0, inscription.clone()),\n      (3, 0, 0, inscription.clone()),\n    ],\n    outputs: 1,\n    ..Default::default()\n  });\n\n  rpc_server.mine_blocks(1);\n\n  let server =\n    TestServer::spawn_with_server_args(&rpc_server, &[\"--index-sats\"], &[\"--enable-json-api\"]);\n\n  let response = server.json_request(format!(\"/output/{}:0\", reveal_txid));\n  assert_eq!(response.status(), StatusCode::OK);\n\n  let output_json: OutputJson = serde_json::from_str(&response.text().unwrap()).unwrap();\n\n  pretty_assert_eq!(\n    output_json,\n    OutputJson {\n      value: 3 * 50 * COIN_VALUE,\n      script_pubkey: \"\".to_string(),\n      address: None,\n      transaction: reveal_txid.to_string(),\n      sat_ranges: Some(vec![\n        (5000000000, 10000000000,),\n        (10000000000, 15000000000,),\n        (15000000000, 20000000000,),\n      ],),\n      inscriptions: vec![\n        InscriptionId {\n          txid: reveal_txid,\n          index: 0\n        },\n        InscriptionId {\n          txid: reveal_txid,\n          index: 1\n        },\n        InscriptionId {\n          txid: reveal_txid,\n          index: 2\n        },\n      ],\n      runes: BTreeMap::new(),\n    }\n  );\n\n  // try and fail to send first\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i0\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(format!(\n    \"error: cannot send {reveal_txid}:0:0 without also sending inscription {reveal_txid}i2 at {reveal_txid}:0:{}\\n\", 100 * COIN_VALUE\n  ))\n  .run_and_extract_stdout();\n\n  // splitting out last\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i2\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n\n  rpc_server.mine_blocks(1);\n\n  // splitting second to last\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i1\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n\n  rpc_server.mine_blocks(1);\n\n  // splitting send first\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i0\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::format_stdin_with_errors", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn format_stdin_with_errors() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--stdin-file-path\"), (\"mock.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"format_stdin_with_errors\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_flattening_sub_item_good", "code": "pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n                .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n                .unwrap_or_else(|| context!());\n            slf.inner\n                .lock()\n                .unwrap()\n                .env\n                .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n                .map_err(to_py_error)\n        })\n    }", "test": "fn test_flattening_sub_item_good() {\n    let bad = Bad {\n        a: 42,\n        more: Value::from(BTreeMap::from([(\"b\", 23)])),\n    };\n\n    let ctx = context!(bad, good => \"good\");\n    let env = Environment::new();\n\n    // we are not touching a bad value, so we are good\n    let rv = env.render_str(\"{{ good }}\", ctx).unwrap();\n    assert_eq!(rv, \"good\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_empty_string_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_empty_string_is_false() {\n    new_ucmd!().arg(\"\").run().code_is(1);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_logic_expr", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_variable_block_logic_expr() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"a\", &2);\n    context.insert(\"b\", &3);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert(\"tuple_list\", &vec![(1, 2, 3), (1, 2, 3)]);\n    let mut hashmap = HashMap::new();\n    hashmap.insert(\"a\", 1);\n    hashmap.insert(\"b\", 10);\n    hashmap.insert(\"john\", 100);\n    context.insert(\"object\", &hashmap);\n    context.insert(\"urls\", &vec![\"https://test\"]);\n\n    let inputs = vec![\n        (\"{{ (1.9 + a) | round > 10 }}\", \"false\"),\n        (\"{{ (1.9 + a) | round > 10 or b > a }}\", \"true\"),\n        (\"{{ 1.9 + a | round == 4 and numbers | length == 3}}\", \"true\"),\n        (\"{{ numbers | length > 1 }}\", \"true\"),\n        (\"{{ numbers | length == 1 }}\", \"false\"),\n        (\"{{ numbers | length - 2 == 1 }}\", \"true\"),\n        (\"{{ not name }}\", \"false\"),\n        (\"{{ not true }}\", \"false\"),\n        (\"{{ not undefined }}\", \"true\"),\n        (\"{{ name == 'john' }}\", \"true\"),\n        (\"{{ name != 'john' }}\", \"false\"),\n        (\"{{ name == 'john' | capitalize }}\", \"false\"),\n        (\"{{ name != 'john' | capitalize }}\", \"true\"),\n        (\"{{ 1 in numbers }}\", \"true\"),\n        (\"{{ 1 not in numbers }}\", \"false\"),\n        (\"{{ 40 not in numbers }}\", \"true\"),\n        (\"{{ 'e' in 'hello' }}\", \"true\"),\n        (\"{{ 'e' not in 'hello' }}\", \"false\"),\n        (\"{{ 'x' not in 'hello' }}\", \"true\"),\n        (\"{{ name in 'hello john' }}\", \"true\"),\n        (\"{{ name not in 'hello john' }}\", \"false\"),\n        (\"{{ name not in 'hello' }}\", \"true\"),\n        (\"{{ name in ['bob', 2, 'john'] }}\", \"true\"),\n        (\"{{ a in ['bob', 2, 'john'] }}\", \"true\"),\n        (\"{{ \\\"https://test\\\" in [\\\"https://test\\\"] }}\", \"true\"),\n        (\"{{ \\\"https://test\\\" in urls }}\", \"true\"),\n        (\"{{ 'n' in name }}\", \"true\"),\n        (\"{{ '<' in malicious }}\", \"true\"),\n        (\"{{ 'a' in object }}\", \"true\"),\n        (\"{{ name in object }}\", \"true\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_single_voter_restart", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_single_voter_restart() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.pd_client.disable_default_operator();\n    cluster.run_conf_change();\n    cluster.pd_client.must_add_peer(1, new_learner_peer(2, 2));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    cluster.stop_node(2);\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.stop_node(1);\n    // Restart learner first to avoid network influence.\n    cluster.run_node(2).unwrap();\n    cluster.run_node(1).unwrap();\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc", "code": "pub fn test_txn_store_gc(&self, key: &str, region: metapb::Region) {\n        let key_bytes = key.as_bytes();\n        self.put_ok(key_bytes, b\"v1\", 5, 10);\n        self.put_ok(key_bytes, b\"v2\", 15, 20);\n        self.gc_ok(region, 30);\n        self.get_none(key_bytes, 15);\n        self.get_ok(key_bytes, 25, b\"v2\");\n    }", "test": "fn test_txn_store_gc() {\n    let key = \"k\";\n    let store = AssertionStorage::default();\n    let (cluster, raft_store) = AssertionStorageApiV1::new_raft_storage_with_store_count(3, key);\n\n    let region = cluster.get_region(key.as_bytes());\n    store.test_txn_store_gc(key, region.clone());\n    raft_store.test_txn_store_gc(key, region);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/object/tests/basic.rs::error_on_incompatible_sig_in_declare_function", "code": "pub fn err(&self) -> Option<Type> {\n        Some(Type::from(\n            self.0.types[self.0.index].err.as_ref()?,\n            &self.0.instance(),\n        ))\n    }", "test": "fn error_on_incompatible_sig_in_declare_function() {\n    let flag_builder = settings::builder();\n    let isa_builder = cranelift_codegen::isa::lookup_by_name(\"x86_64-unknown-linux-gnu\").unwrap();\n    let isa = isa_builder\n        .finish(settings::Flags::new(flag_builder))\n        .unwrap();\n    let mut module =\n        ObjectModule::new(ObjectBuilder::new(isa, \"foo\", default_libcall_names()).unwrap());\n    let mut sig = Signature {\n        params: vec![AbiParam::new(types::I64)],\n        returns: vec![],\n        call_conv: CallConv::SystemV,\n    };\n    module\n        .declare_function(\"abc\", Linkage::Local, &sig)\n        .unwrap();\n    sig.params[0] = AbiParam::new(types::I32);\n    module\n        .declare_function(\"abc\", Linkage::Local, &sig)\n        .err()\n        .unwrap(); // Make sure this is an error\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_raw_tag", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_raw_tag() {\n    assert_err_msg(r#\"{% raw %}sd\"#, &[\"1:12\", \"expected tag\"]);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::template", "code": "fn concat() {\n    run_test_actions([\n        TestAction::run_harness(),\n        // Empty ++ Empty\n        TestAction::assert(\"arrayEquals([].concat([]), [])\"),\n        // Empty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([].concat([1]), [1])\"),\n        // NonEmpty ++ Empty\n        TestAction::assert(\"arrayEquals([1].concat([]), [1])\"),\n        // NonEmpty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([1].concat([1]), [1, 1])\"),\n    ]);\n}", "test": "fn template() {\n    test_formatting(\n        r#\"\n        function tag(t, ...args) {\n            let a = [];\n            a = a.concat([t[0], t[1], t[2]]);\n            a = a.concat([t.raw[0], t.raw[1], t.raw[2]]);\n            a = a.concat([args[0], args[1]]);\n            return a;\n        }\n        let a = 10;\n        tag`result: ${a} \\x26 ${a + 10}`;\n        \"#,\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_does_not_run_linter_via_cli", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_does_not_run_linter_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UNFORMATTED_AND_INCORRECT.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--linter-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED_AND_INCORRECT);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_does_not_run_linter_via_cli\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_by_rdata", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_delete_by_rdata() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record1 = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record1.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_by_rdata(record1.clone(), origin.clone()))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record1.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let mut record2 = record1.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = io_loop\n        .block_on(client.append(record2.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_by_rdata(record2, origin))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record1.name().clone(),\n            record1.dns_class(),\n            record1.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == record1));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/recursion_limit.rs::bugfix", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn bugfix() {\n  let mut justfile = String::from(\"foo: (x \");\n  for _ in 0..500 {\n    justfile.push('(');\n  }\n  Test::new()\n    .justfile(&justfile)\n    .stderr(RECURSION_LIMIT_REACHED)\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_to_key_then_reverse_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_to_key_then_reverse_engine() {\n    let db = default_engine();\n    seek_to_key_then_reverse(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_restart_leader_secure", "code": "fn restart_leader(mgr: SecurityManager) {\n    let mgr = Arc::new(mgr);\n    // Service has only one GetMembersResponse, so the leader never changes.\n    let mut server =\n        MockServer::<Service>::with_configuration(&mgr, vec![(\"127.0.0.1\".to_owned(), 0); 3], None);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), Some(Arc::clone(&mgr)));\n    // Put a region.\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer);\n    client.bootstrap_cluster(store, region.clone()).unwrap();\n\n    let region = block_on(client.get_region_by_id(region.get_id()))\n        .unwrap()\n        .unwrap();\n\n    // Stop servers and restart them again.\n    server.stop();\n    server.start(&mgr, eps);\n\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let region = block_on(client.get_region_by_id(region.get_id())).unwrap();\n    assert_eq!(region.unwrap().get_id(), region_id);\n}", "test": "fn test_restart_leader_secure() {\n    let security_cfg = test_util::new_security_cfg(None);\n    let mgr = SecurityManager::new(&security_cfg).unwrap();\n    restart_leader(mgr)\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_basic", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "test": "fn test_basic() {\n    assert_eq!(0.0, s2d(b\"0\").unwrap());\n    assert_eq!(-0.0, s2d(b\"-0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1\").unwrap());\n    assert_eq!(2.0, s2d(b\"2\").unwrap());\n    assert_eq!(123456789.0, s2d(b\"123456789\").unwrap());\n    assert_eq!(123.456, s2d(b\"123.456\").unwrap());\n    assert_eq!(123.456, s2d(b\"123456e-3\").unwrap());\n    assert_eq!(123.456, s2d(b\"1234.56e-1\").unwrap());\n    assert_eq!(1.453, s2d(b\"1.453\").unwrap());\n    assert_eq!(1453.0, s2d(b\"1.453e+3\").unwrap());\n    assert_eq!(0.0, s2d(b\".0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1e0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1E0\").unwrap());\n    assert_eq!(1.0, s2d(b\"000001.000000\").unwrap());\n    assert_eq!(0.2316419, s2d(b\"0.2316419\").unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_one_fifo_already_exists", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_create_one_fifo_already_exists() {\n    new_ucmd!()\n        .arg(\"abcdef\")\n        .arg(\"abcdef\")\n        .fails()\n        .stderr_is(\"mkfifo: cannot create fifo 'abcdef': File exists\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_atomic_getting_max_ts_and_storing_memory_lock", "code": "pub fn get_min_commit_ts(&self) -> u64 {\n        self.min_commit_ts\n    }", "test": "fn test_atomic_getting_max_ts_and_storing_memory_lock() {\n    let engine = TestEngineBuilder::new().build().unwrap();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    let (prewrite_tx, prewrite_rx) = channel();\n    let (fp_tx, fp_rx) = sync_channel(1);\n    // sleep a while between getting max ts and store the lock in memory\n    fail::cfg_callback(\"before-set-lock-in-memory\", move || {\n        fp_tx.send(()).unwrap();\n        thread::sleep(Duration::from_millis(200));\n    })\n    .unwrap();\n    storage\n        .sched_txn_command(\n            commands::Prewrite::new(\n                vec![Mutation::make_put(Key::from_raw(b\"k\"), b\"v\".to_vec())],\n                b\"k\".to_vec(),\n                40.into(),\n                20000,\n                false,\n                1,\n                TimeStamp::default(),\n                TimeStamp::default(),\n                Some(vec![]),\n                false,\n                AssertionLevel::Off,\n                Context::default(),\n            ),\n            Box::new(move |res| {\n                prewrite_tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    fp_rx.recv().unwrap();\n    match block_on(storage.get(Context::default(), Key::from_raw(b\"k\"), 100.into())) {\n        // In this case, min_commit_ts is smaller than the start ts, but the lock is visible\n        // to the get.\n        Err(storage::Error(box storage::ErrorInner::Txn(txn::Error(\n            box txn::ErrorInner::Mvcc(mvcc::Error(box mvcc::ErrorInner::KeyIsLocked(lock))),\n        )))) => {\n            assert_eq!(lock.get_min_commit_ts(), 41);\n        }\n        res => panic!(\"unexpected result: {:?}\", res),\n    }\n    let res = prewrite_rx.recv().unwrap().unwrap();\n    assert_eq!(res.min_commit_ts, 41.into());\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_6", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_6() {\n    let original = r##\"| abc | def |\n| --- |\n| bar |\n\"##;\n    let expected = r##\"<p>| abc | def |\n| --- |\n| bar |</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/allocation.rs::gc_basic_pointer_alloc", "code": "fn run_test(test: impl FnOnce() + Send + 'static) {\n    let handle = std::thread::spawn(test);\n    handle.join().unwrap();\n}", "test": "fn gc_basic_pointer_alloc() {\n    run_test(|| {\n        let gc = Gc::new(16_u8);\n\n        force_collect();\n        Harness::assert_collections(1);\n        Harness::assert_bytes_allocated();\n        assert_eq!(*gc, 16);\n\n        drop(gc);\n        force_collect();\n        Harness::assert_collections(2);\n        Harness::assert_empty_gc();\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_stale_peer_destroy_when_apply_snapshot", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_stale_peer_destroy_when_apply_snapshot() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_snapshot(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    for i in 2..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    let region_apply_snap_fp = \"region_apply_snap\";\n    fail::cfg(region_apply_snap_fp, \"pause\").unwrap();\n\n    let (notify_tx, notify_rx) = mpsc::channel();\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(MessageTypeNotifier::new(\n            MessageType::MsgSnapshot,\n            notify_tx,\n            Arc::new(AtomicBool::new(true)),\n        )),\n    );\n\n    cluster.clear_send_filters();\n\n    // Wait for leader sending snapshot to peer 3\n    notify_rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    // Wait for peer 3 handling snapshot\n    let timer = Instant::now();\n    loop {\n        let local_state = cluster.region_local_state(region.get_id(), 3);\n        if local_state.get_state() == PeerState::Applying {\n            break;\n        }\n        if timer.saturating_elapsed() > Duration::from_secs(3) {\n            panic!(\"not become applying state after 3 seconds.\");\n        }\n        sleep_ms(10);\n    }\n\n    pd_client.must_remove_peer(region.get_id(), new_peer(3, 3));\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let mut tombstone_msg = RaftMessage::default();\n    tombstone_msg.set_region_id(region.get_id());\n    tombstone_msg.set_from_peer(new_peer(3, 3));\n    tombstone_msg.set_to_peer(new_peer(3, 3));\n    tombstone_msg.set_region_epoch(region.get_region_epoch().clone());\n    tombstone_msg.set_is_tombstone(true);\n    cluster\n        .sim\n        .wl()\n        .send_raft_msg(tombstone_msg.clone())\n        .unwrap();\n    // Wait for cancelling snapshot\n    sleep_ms(100);\n    fail::remove(region_apply_snap_fp);\n    // Wait for peer 3 changing `SnapState`\n    sleep_ms(100);\n    cluster.sim.wl().send_raft_msg(tombstone_msg).unwrap();\n\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat", "code": "pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    }", "test": "fn test_datetimeformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATETIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|datetimeformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"2023-06-24 18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"Jun 24 2023 18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"June 24 2023 18:37:22\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"Saturday, June 24 2023 18:37:22.5\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"unix\")).unwrap().to_string(),\n        \"1687624642\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"iso\")).unwrap().to_string(),\n        \"2023-06-24T18:37:22+02:00\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|datetimeformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"19:37\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_node_drop_packet", "code": "fn test_multi_drop_packet<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(DropPacketFilter::new(30)));\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_node_drop_packet() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_multi_drop_packet(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_one_fifo_with_mode", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_create_one_fifo_with_mode() {\n    new_ucmd!().arg(\"abcde\").arg(\"-m600\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_trailing_slash_regfile", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_canonicalize_trailing_slash_regfile() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"regfile\");\n    at.relative_symlink_file(\"regfile\", \"link1\");\n    for name in [\"regfile\", \"link1\"] {\n        scene\n            .ucmd()\n            .args(&[\"-f\", name])\n            .succeeds()\n            .stdout_contains(\"regfile\");\n        scene\n            .ucmd()\n            .args(&[\"-fv\", &format!(\"./{name}/\")])\n            .fails()\n            .code_is(1)\n            .stderr_contains(NOT_A_DIRECTORY)\n            .no_stdout();\n        scene\n            .ucmd()\n            .args(&[\"-fv\", &format!(\"{name}/more\")])\n            .fails()\n            .code_is(1)\n            .stderr_contains(NOT_A_DIRECTORY)\n            .no_stdout();\n        scene\n            .ucmd()\n            .args(&[\"-fv\", &format!(\"./{name}/more/\")])\n            .fails()\n            .code_is(1)\n            .stderr_contains(NOT_A_DIRECTORY)\n            .no_stdout();\n    }\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::function_type_parameters", "code": "fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n}", "test": "fn function_type_parameters() {\n    let source = r#\"def X[T: str, U, *Ts, **P](): ...\"#;\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_initial_memory_limits_exceeded", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_initial_memory_limits_exceeded() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 11))\"#)?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(10 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 11 pages exceeds memory limits\"\n        ),\n    }\n\n    match Memory::new(&mut store, MemoryType::new(25, None)) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 25 pages exceeds memory limits\"\n        ),\n    }\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_several_directories", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_several_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir1 = \"dir1\";\n    let dir2 = \"dir2\";\n    let dir3 = \"dir3\";\n    let directories_arg = \"-d\";\n\n    ucmd.args(&[directories_arg, dir1, dir2, dir3])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.dir_exists(dir3));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_relative_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"test_symlink_existing_dir\";\n    let link = \"test_symlink_existing_dir_link\";\n\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-r\", dir, link]).succeeds().no_stderr();\n    assert!(at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_0_others", "code": "fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n}", "test": "fn remove_entry_multi_0_others() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 0);\n    assert_eq!(headers.len(), 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_standalone_overflow", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_obs_lines_standalone_overflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-standalone\";\n    RandomFile::new(&at, name).add_lines(4);\n    ucmd.args(&[\"-99999999999999999991\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 1);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_line_option_suppress_matched", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_line_option_suppress_matched() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"--suppress-matched\", \"10\"])\n        .succeeds()\n        .stdout_only(\"18\\n120\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(11, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_dynamic_config.rs::test_precision", "code": "pub fn next(&mut self, statistics: &mut CfStatistics) -> bool {\n        self.mark_unread();\n        let _guard = StatsCollector::new(StatsKind::Next, statistics);\n        self.iter.next().expect(\"Invalid Iterator\")\n    }", "test": "pub fn test_precision() {\n    let port = alloc_port();\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        receiver_address: format!(\"127.0.0.1:{}\", port),\n        report_receiver_interval: ReadableDuration::secs(3),\n        max_resource_groups: 5000,\n        precision: ReadableDuration::secs(1),\n    });\n    test_suite.start_receiver_at(port);\n\n    // Workload\n    // [req-1]\n    test_suite.setup_workload(vec![\"req-1\"]);\n\n    // | Precision |\n    // |    1s     |\n    let res = test_suite.block_receive_one();\n    let (secs, _) = res.get(\"req-1\").unwrap();\n    for (l, r) in secs.iter().zip({\n        let mut next_secs = secs.iter();\n        next_secs.next();\n        next_secs\n    }) {\n        let diff = r - l;\n        assert!(diff <= 2);\n    }\n\n    // | Precision |\n    // |    3s     |\n    test_suite.cfg_precision(\"3s\");\n    test_suite.cfg_report_receiver_interval(\"9s\");\n    test_suite.flush_receiver();\n    let res = test_suite.block_receive_one();\n    let (secs, _) = res.get(\"req-1\").unwrap();\n    for (l, r) in secs.iter().zip({\n        let mut next_secs = secs.iter();\n        next_secs.next();\n        next_secs\n    }) {\n        let diff = r - l;\n        assert!((2..=4).contains(&diff));\n    }\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/cli/tests/run.rs::test_simple_print", "code": "fn contains_slice<T>(slice: &[T], other: &[T]) -> bool\nwhere\n    T: Eq,\n{\n    if other.is_empty() {\n        return true;\n    }\n    slice.windows(other.len()).any(|window| window == other)\n}", "test": "fn test_simple_print() {\n    let mut cmd = get_cmd();\n    let assert = cmd.arg(get_bin_path(\"simple_print\")).assert();\n    let output = assert.get_output();\n    let stdout = &output.stdout;\n    assert!(contains_slice(stdout, b\"Hello World\"));\n    if !(contains_slice(stdout, b\"Hello World\\n\")) {\n        eprint!(\"UNEQUAL: {}\", std::str::from_utf8(stdout).unwrap());\n    }\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_3_others_a", "code": "fn remove_values<K>(headers: &mut HeaderMap, key: K) -> Option<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => Some(e.remove_entry().1),\n        Entry::Vacant(_) => None,\n    }\n}", "test": "fn remove_entry_3_others_a() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n    headers.insert(VARY, \"*\".parse().unwrap());\n\n    assert_eq!(headers.len(), 6);\n\n    let cookie = remove_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookie, Some(\"cookie_1=value 1\".parse().unwrap()));\n    assert_eq!(headers.len(), 3);\n\n    let via = remove_values(&mut headers, VIA);\n    assert_eq!(via, Some(\"1.1 example.com\".parse().unwrap()));\n    assert_eq!(headers.len(), 1);\n\n    let vary = remove_values(&mut headers, VARY);\n    assert_eq!(vary, Some(\"*\".parse().unwrap()));\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_non_existing_file_silent", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_chmod_non_existing_file_silent() {\n    new_ucmd!()\n        .arg(\"-R\")\n        .arg(\"--quiet\")\n        .arg(\"-r,a+w\")\n        .arg(\"does-not-exist\")\n        .fails()\n        .no_stderr()\n        .code_is(1);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::shl_bits_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn shl_bits_test() {\n    let mut x = VecType::from_u32(0xD2210408);\n    bigint::shl_bits(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x44208100, 0x1A]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_import_macros_missing_filename", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_import_macros_missing_filename() {\n    assert_err_msg(\"{% import as macros %}\", &[\"1:11\", \"expected a string\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_encode", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_encode() {\n    let input = \"Hello, World!\";\n    new_ucmd!()\n        .pipe_in(input)\n        .succeeds()\n        .stdout_only(\"JBSWY3DPFQQFO33SNRSCC===\\n\"); // spell-checker:disable-line\n\n    // Using '-' as our file\n    new_ucmd!()\n        .arg(\"-\")\n        .pipe_in(input)\n        .succeeds()\n        .stdout_only(\"JBSWY3DPFQQFO33SNRSCC===\\n\"); // spell-checker:disable-line\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscription_metadata", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "test": "fn inscription_metadata() {\n  let metadata = r#\"{\"foo\":\"bar\",\"baz\":1}\"#;\n  let mut encoded_metadata = Vec::new();\n  let cbor_map = ciborium::value::Value::Map(vec![\n    (\n      ciborium::value::Value::Text(\"foo\".into()),\n      ciborium::value::Value::Text(\"bar\".into()),\n    ),\n    (\n      ciborium::value::Value::Text(\"baz\".into()),\n      ciborium::value::Value::Integer(Integer::from(1)),\n    ),\n  ]);\n  ciborium::ser::into_writer(&cbor_map, &mut encoded_metadata).unwrap();\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let inscription_id = CommandBuilder::new(\n    \"wallet inscribe --fee-rate 1 --json-metadata metadata.json --file foo.txt\",\n  )\n  .write(\"foo.txt\", \"FOO\")\n  .write(\"metadata.json\", metadata)\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Inscribe>()\n  .inscriptions\n  .get(0)\n  .unwrap()\n  .id;\n\n  rpc_server.mine_blocks(1);\n\n  let response =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/r/metadata/{inscription_id}\"));\n\n  assert_eq!(response.status(), StatusCode::OK);\n  assert_eq!(\n    response.headers().get(\"content-type\").unwrap(),\n    \"application/json\"\n  );\n  assert_eq!(\n    response.text().unwrap(),\n    format!(\"\\\"{}\\\"\", hex::encode(encoded_metadata))\n  );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_basic_alloc_dump_test", "code": "pub(crate) fn value(&self) -> Option<&V> {\n        // SAFETY: the garbage collector ensures `ptr` is valid as long as `data` is `Some`.\n        unsafe { self.data.get().map(|ptr| &ptr.as_ref().value) }\n    }", "test": "fn eph_basic_alloc_dump_test() {\n    run_test(|| {\n        let gc_value = Gc::new(String::from(\"gc here\"));\n        let _gc_two = Gc::new(\"hmmm\");\n\n        let eph = Ephemeron::new(&gc_value, 4);\n        let _fourth = Gc::new(\"tail\");\n\n        assert_eq!(eph.value(), Some(4));\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_suspend_import", "code": "pub fn get_metas(&self) -> &[SstMeta] {\n        &self.metas\n    }", "test": "fn test_suspend_import() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n    let sst_range = (0, 10);\n    let write = |sst_range: (u8, u8)| {\n        let mut meta = new_sst_meta(0, 0);\n        meta.set_region_id(ctx.get_region_id());\n        meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n        let mut keys = vec![];\n        let mut values = vec![];\n        for i in sst_range.0..sst_range.1 {\n            keys.push(vec![i]);\n            values.push(vec![i]);\n        }\n        send_write_sst(&import, &meta, keys, values, 1)\n    };\n    let ingest = |sst_meta: &SstMeta| {\n        let mut ingest = IngestRequest::default();\n        ingest.set_context(ctx.clone());\n        ingest.set_sst(sst_meta.clone());\n        import.ingest(&ingest)\n    };\n    let multi_ingest = |sst_metas: &[SstMeta]| {\n        let mut multi_ingest = MultiIngestRequest::default();\n        multi_ingest.set_context(ctx.clone());\n        multi_ingest.set_ssts(sst_metas.to_vec().into());\n        import.multi_ingest(&multi_ingest)\n    };\n    let suspendctl = |for_time| {\n        let mut req = SuspendImportRpcRequest::default();\n        req.set_caller(\"test_suspend_import\".to_owned());\n        if for_time == 0 {\n            req.set_should_suspend_imports(false);\n        } else {\n            req.set_should_suspend_imports(true);\n            req.set_duration_in_secs(for_time);\n        }\n        req\n    };\n\n    let write_res = write(sst_range).unwrap();\n    assert_eq!(write_res.metas.len(), 1);\n    let sst = write_res.metas[0].clone();\n\n    assert!(\n        !import\n            .suspend_import_rpc(&suspendctl(6000))\n            .unwrap()\n            .already_suspended\n    );\n    let write_res = write(sst_range);\n    write_res.unwrap();\n    let ingest_res = ingest(&sst);\n    assert_to_string_contains!(ingest_res.unwrap_err(), \"Suspended\");\n    let multi_ingest_res = multi_ingest(&[sst.clone()]);\n    assert_to_string_contains!(multi_ingest_res.unwrap_err(), \"Suspended\");\n\n    assert!(\n        import\n            .suspend_import_rpc(&suspendctl(0))\n            .unwrap()\n            .already_suspended\n    );\n\n    let ingest_res = ingest(&sst);\n    assert!(ingest_res.is_ok(), \"{:?} => {:?}\", sst, ingest_res);\n\n    check_ingested_txn_kvs(&tikv, &ctx, sst_range, 2);\n\n    // test timeout.\n    assert!(\n        !import\n            .suspend_import_rpc(&suspendctl(1))\n            .unwrap()\n            .already_suspended\n    );\n    let sst_range = (10, 20);\n    let write_res = write(sst_range);\n    let sst = write_res.unwrap().metas;\n    let res = multi_ingest(&sst);\n    assert_to_string_contains!(res.unwrap_err(), \"Suspended\");\n    std::thread::sleep(Duration::from_secs(1));\n    multi_ingest(&sst).unwrap();\n\n    // check an insane value should be rejected.\n    import\n        .suspend_import_rpc(&suspendctl(u64::MAX - 42))\n        .unwrap_err();\n    let sst_range = (20, 30);\n    let ssts = write(sst_range).unwrap();\n    multi_ingest(ssts.get_metas()).unwrap();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_more_than_conns", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_concurrent_requests_more_than_conns() {\n    let mut options = ResolverOpts::default();\n\n    // there are only two conns, but this requests 3 concurrent requests, only 2 called\n    options.num_concurrent_reqs = 3;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(2);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send.clone(),\n    );\n    let udp2_nameserver = mock_nameserver_on_send(vec![], options.clone(), on_send);\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::early_return", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn early_return() {\n    run_test_actions([\n        TestAction::assert(indoc! {r#\"\n                function early_return() {\n                    if (true) {\n                        return true;\n                    }\n                    return false;\n                }\n                early_return()\n            \"#}),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                function nested_fnct() {\n                    return \"nested\";\n                }\n                function outer_fnct() {\n                    nested_fnct();\n                    return \"outer\";\n                }\n                outer_fnct()\n            \"#},\n            \"outer\",\n        ),\n    ]);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_break", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_break() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (var i of [1, 2, 3]) {\n                    if (i > 1)\n                        break;\n                    result = i\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 1),\n        TestAction::assert_eq(\"i\", 2),\n    ]);\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_reserve_exact", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "test": "fn TinyVec_try_reserve_exact() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve_exact(2).is_ok());\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve_exact(4).is_ok());\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  assert!(tv.try_reserve_exact(4).is_ok());\n  assert!(tv.capacity() >= 10);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_ingest_sst_v2", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_sst_v2() {\n    let mut cluster = test_raftstore_v2::new_server_cluster(1, 1);\n    let (ctx, _tikv, import) = open_cluster_and_tikv_import_client_v2(None, &mut cluster);\n    let temp_dir = Builder::new().prefix(\"test_ingest_sst\").tempdir().unwrap();\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n\n    // No region id and epoch.\n    send_upload_sst(&import, &meta, &data).unwrap();\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta.clone());\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    send_upload_sst(&import, &meta, &data).unwrap();\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n    fail::cfg(\"on_cleanup_import_sst\", \"return\").unwrap();\n    let (tx, rx) = channel::<()>();\n    let tx = Arc::new(Mutex::new(tx));\n    fail::cfg_callback(\"on_cleanup_import_sst_schedule\", move || {\n        tx.lock().unwrap().send(()).unwrap();\n    })\n    .unwrap();\n\n    rx.recv_timeout(std::time::Duration::from_secs(20)).unwrap();\n    let mut count = 0;\n    for path in &cluster.paths {\n        let sst_dir = path.path().join(\"import-sst\");\n        for entry in std::fs::read_dir(sst_dir).unwrap() {\n            let entry = entry.unwrap();\n            if entry.file_type().unwrap().is_file() {\n                count += 1;\n            }\n        }\n    }\n    fail::remove(\"on_cleanup_import_sst\");\n    fail::remove(\"on_cleanup_import_sst_schedule\");\n    assert_ne!(0, count);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::calling_function_with_unspecified_arguments", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn calling_function_with_unspecified_arguments() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            function test(a, b) {\n                return b;\n            }\n\n            test(10)\n        \"#},\n        JsValue::undefined(),\n    )]);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_drop_stage", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn test_drop_stage() {\n    match snowflake_and_generic().verified_stmt(\"DROP STAGE s1\") {\n        Statement::Drop {\n            names, if_exists, ..\n        } => {\n            assert!(!if_exists);\n            assert_eq!(\"s1\", names[0].to_string());\n        }\n        _ => unreachable!(),\n    };\n    match snowflake_and_generic().verified_stmt(\"DROP STAGE IF EXISTS s1\") {\n        Statement::Drop {\n            names, if_exists, ..\n        } => {\n            assert!(if_exists);\n            assert_eq!(\"s1\", names[0].to_string());\n        }\n        _ => unreachable!(),\n    };\n\n    snowflake_and_generic().one_statement_parses_to(\"DROP STAGE s1\", \"DROP STAGE s1\");\n\n    snowflake_and_generic()\n        .one_statement_parses_to(\"DROP STAGE IF EXISTS s1\", \"DROP STAGE IF EXISTS s1\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error32_test", "code": "fn compute_error32(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f32>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_error32(0, 16777216), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(0, 16777218), (111 + INVALID_FP, 9223373136366403584));\n    assert_eq!(compute_error32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(0, 16777220), (111 + INVALID_FP, 9223374235878031360));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error32(-10, 167772160000000000), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(-10, 167772180000000000), (111 + INVALID_FP, 9223373136366403584));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_error32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(-10, 167772200000000000), (111 + INVALID_FP, 9223374235878031360));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_number_non_blank", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_number_non_blank() {\n    // spell-checker:disable-next-line\n    for same_param in [\"-b\", \"--number-nonblank\", \"--number-non\"] {\n        new_ucmd!()\n            .arg(same_param)\n            .arg(\"-\")\n            .pipe_in(\"\\na\\nb\\n\\n\\nc\")\n            .succeeds()\n            .stdout_only(\"\\n     1\\ta\\n     2\\tb\\n\\n\\n     3\\tc\");\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_dateformat", "code": "pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    }", "test": "fn test_dateformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATE_FORMAT\", \"[year]-[month]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|dateformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"2023-06-24\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"Jun 24 2023\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"June 24 2023\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"Saturday, June 24 2023\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|dateformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"2023-06\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::shl_test", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "test": "fn shl_test() {\n    // Pattern generated via `''.join([\"1\" +\"0\"*i for i in range(20)])`\n    let mut big = Bigint {\n        data: from_u32(&[0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x44208100, 0x1A]));\n    big.ishl(32);\n    assert_eq!(big.data, from_u32(&[0, 0x44208100, 0x1A]));\n    big.ishl(27);\n    assert_eq!(big.data, from_u32(&[0, 0, 0xD2210408]));\n\n    // 96-bits of previous pattern\n    let mut big = Bigint {\n        data: from_u32(&[0x20020010, 0x8040100, 0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x400200, 0x802004, 0x44208101, 0x1A]));\n    big.ishl(32);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0x400200, 0x802004, 0x44208101, 0x1A])\n    );\n    big.ishl(27);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0, 0x20020010, 0x8040100, 0xD2210408])\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_show_ends_crlf", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_show_ends_crlf() {\n    new_ucmd!()\n        .arg(\"-E\")\n        .pipe_in(\"a\\nb\\r\\n\\rc\\n\\r\\n\\r\")\n        .succeeds()\n        .stdout_only(\"a$\\nb^M$\\n\\rc$\\n^M$\\n\\r\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_keep_trailing_newlines", "code": "pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n                .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n                .unwrap_or_else(|| context!());\n            slf.inner\n                .lock()\n                .unwrap()\n                .env\n                .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n                .map_err(to_py_error)\n        })\n    }", "test": "fn test_keep_trailing_newlines() {\n    let mut env = Environment::new();\n    env.add_template(\"foo.txt\", \"blub\\r\\n\").unwrap();\n    assert_eq!(env.render_str(\"blub\\r\\n\", ()).unwrap(), \"blub\");\n\n    env.set_keep_trailing_newline(true);\n    env.add_template(\"foo_keep.txt\", \"blub\\r\\n\").unwrap();\n    assert_eq!(\n        env.get_template(\"foo.txt\").unwrap().render(()).unwrap(),\n        \"blub\"\n    );\n    assert_eq!(\n        env.get_template(\"foo_keep.txt\")\n            .unwrap()\n            .render(())\n            .unwrap(),\n        \"blub\\r\\n\"\n    );\n    assert_eq!(env.render_str(\"blub\\r\\n\", ()).unwrap(), \"blub\\r\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_short_format_q", "code": "fn collect(&self) -> Vec<String> {\n        read_dir(Path::new(&self.directory.subdir))\n            .unwrap()\n            .filter_map(|entry| {\n                let path = entry.unwrap().path();\n                let name = self\n                    .directory\n                    .minus_as_string(path.as_path().to_str().unwrap_or(\"\"));\n                if self.regex.is_match(&name) {\n                    Some(name)\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }", "test": "fn test_short_format_q() {\n    // allow whitespace variation\n    // * minor whitespace differences occur between platform built-in outputs; specifically, the number of trailing TABs may be variant\n    let args = [\"-q\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    let v_actual: Vec<&str> = actual.split_whitespace().collect();\n    let v_expect: Vec<&str> = expect.split_whitespace().collect();\n    assert_eq!(v_actual, v_expect);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_table_function", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "test": "fn parse_table_function() {\n    let select = verified_only_select(\"SELECT * FROM TABLE(FUN('1')) AS a\");\n\n    match only(select.from).relation {\n        TableFactor::TableFunction { expr, alias } => {\n            let expected_expr = Expr::Function(Function {\n                name: ObjectName(vec![Ident::new(\"FUN\")]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(\n                    Value::SingleQuotedString(\"1\".to_owned()),\n                )))],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            });\n            assert_eq!(expr, expected_expr);\n            assert_eq!(alias, table_alias(\"a\"))\n        }\n        _ => panic!(\"Expecting TableFactor::TableFunction\"),\n    }\n\n    let res = parse_sql_statements(\"SELECT * FROM TABLE '1' AS a\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected (, found: \\'1\\'\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = parse_sql_statements(\"SELECT * FROM TABLE (FUN(a) AS a\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: AS\".to_string()),\n        res.unwrap_err()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_target_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n\n    at.touch(file1);\n    at.touch(file2);\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_should_report_invalid_suffix_on_stdin", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_should_report_invalid_suffix_on_stdin() {\n    for c in b'a'..=b'z' {\n        new_ucmd!()\n            .args(&[\"--from=auto\"])\n            .pipe_in(format!(\"1{}\", c as char))\n            .run()\n            .stderr_is(format!(\n                \"numfmt: invalid suffix in input: '1{}'\\n\",\n                c as char\n            ));\n    }\n\n    // GNU numfmt reports this one as \u201cinvalid number\u201d\n    new_ucmd!()\n        .args(&[\"--from=auto\"])\n        .pipe_in(\"NaN\")\n        .run()\n        .stderr_is(\"numfmt: invalid suffix in input: 'NaN'\\n\");\n}\n\n#["}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_comma_separated_tabs_shortcut", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_comma_separated_tabs_shortcut() {\n    new_ucmd!()\n        .args(&[\"-2,5\", \"-7\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"  a  b c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_arguments_override_themselves", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_arguments_override_themselves() {\n    new_ucmd!().args(&[\"--help\", \"--help\"]).succeeds();\n    new_ucmd!().arg(\"-aa\").succeeds();\n    new_ucmd!()\n        .args(&[\"--block-size=3000\", \"--block-size=1000\"])\n        .succeeds();\n    new_ucmd!().args(&[\"--total\", \"--total\"]).succeeds();\n    new_ucmd!().arg(\"-hh\").succeeds();\n    new_ucmd!().arg(\"-HH\").succeeds();\n    new_ucmd!().arg(\"-ii\").succeeds();\n    new_ucmd!().arg(\"-kk\").succeeds();\n    new_ucmd!().arg(\"-ll\").succeeds();\n    new_ucmd!().args(&[\"--no-sync\", \"--no-sync\"]).succeeds();\n    new_ucmd!().arg(\"-PP\").succeeds();\n    new_ucmd!().args(&[\"--sync\", \"--sync\"]).succeeds();\n    new_ucmd!().arg(\"-TT\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_ignore_garbage", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_ignore_garbage() {\n    for ignore_garbage_param in [\"-i\", \"--ignore-garbage\", \"--ig\"] {\n        let input = \"aGVsbG8sIHdvcmxkIQ==\\0\"; // spell-checker:disable-line\n        new_ucmd!()\n            .arg(\"-d\")\n            .arg(ignore_garbage_param)\n            .pipe_in(input)\n            .succeeds()\n            .stdout_only(\"hello, world!\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_cp", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_cp() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    // Invoke our binary to make the copy.\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_HELLO_WORLD_DEST), \"Hello, World!\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_end", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_end() {\n  assert_eval_eq(\"trim_end('  f  ')\", \"  f\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/windows_shell.rs::windows_powershell_setting_uses_powershell", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn windows_powershell_setting_uses_powershell() {\n  Test::new()\n    .justfile(\n      r#\"\n      set windows-powershell\n\n      foo:\n        Write-Output bar\n    \"#,\n    )\n    .shell(false)\n    .stdout(\"bar\\r\\n\")\n    .stderr(\"Write-Output bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_multiple_input_files_missing", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_multiple_input_files_missing() {\n    new_ucmd!()\n        .arg(FOOBAR_TXT)\n        .arg(\"missing1\")\n        .arg(FOOBAR_2_TXT)\n        .arg(\"missing2\")\n        .run()\n        .stdout_is_fixture(\"foobar_follow_multiple.expected\")\n        .stderr_is(\n            \"tail: cannot open 'missing1' for reading: No such file or directory\\n\\\n                tail: cannot open 'missing2' for reading: No such file or directory\\n\",\n        )\n        .code_is(1);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_read_returns_wouldblock_when_no_data", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn server_read_returns_wouldblock_when_no_data() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    assert!(matches!(server.reader().read(&mut [0u8; 1]),\n                     Err(err) if err.kind() == io::ErrorKind::WouldBlock));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_never", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=never\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_mode_directories", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_ancestors_mode_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_dir = \"ancestor1/ancestor2/target_dir\";\n    let directories_arg = \"-d\";\n    let mode_arg = \"--mode=200\";\n    let probe = \"probe\";\n\n    at.mkdir(probe);\n    let default_perms = at.metadata(probe).permissions().mode();\n\n    ucmd.args(&[mode_arg, directories_arg, target_dir])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.dir_exists(target_dir));\n\n    assert_eq!(default_perms, at.metadata(ancestor1).permissions().mode());\n    assert_eq!(default_perms, at.metadata(ancestor2).permissions().mode());\n\n    // Expected mode only on the target_dir.\n    assert_eq!(0o40_200_u32, at.metadata(target_dir).permissions().mode());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_solo_and_or_or_is_a_literal", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_solo_and_or_or_is_a_literal() {\n    // /bin/test '' -a '' => 1; so test(1) must interpret `-a` by itself as\n    // a literal string\n    new_ucmd!().arg(\"-a\").succeeds();\n    new_ucmd!().arg(\"-o\").succeeds();\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::small_mul_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn small_mul_test() {\n    // No overflow check, 1-int.\n    let mut x = VecType::from_u64(5);\n    bigint::small_mul(&mut x, 7);\n    let expected = VecType::from_u64(35);\n    assert_eq!(&*x, &*expected);\n\n    // No overflow check, 2-ints.\n    let mut x = VecType::from_u64(0x4000000040000);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x00140000, 0x140000]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 1 carry.\n    let mut x = VecType::from_u64(0x33333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 1 carry, internal.\n    let mut x = VecType::from_u64(0x133333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 6]);\n    assert_eq!(&*x, &*expected);\n\n    // Overflow, 2 carries.\n    let mut x = VecType::from_u64(0x3333333333333334);\n    bigint::small_mul(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 0, 1]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_with_numbered", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_numbered_with_numbered() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=numbered\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::v128", "code": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}", "test": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon_tests.rs::compute_float_f64_test", "code": "pub fn compute_float64(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f64>(&num);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1065 + f64::INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1065 + f64::INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(\n        compute_float64(0, 18014398509481986),\n        (1066 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(\n        compute_float64(0, 18014398509481990),\n        (1066 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(\n        compute_float64(-3, 9007199254740993000),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(\n        compute_float64(-3, 9007199254740995000),\n        (1065 + f64::INVALID_FP, 9223372036854778879)\n    );\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}"}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/connection_reset.rs::test_client_close", "code": "pub fn into_data(self) -> Vec<u8> {\n        match self {\n            Message::Text(string) => string.into_bytes(),\n            Message::Binary(data) | Message::Ping(data) | Message::Pong(data) => data,\n            Message::Close(None) => Vec::new(),\n            Message::Close(Some(frame)) => frame.reason.into_owned().into_bytes(),\n            Message::Frame(frame) => frame.into_data(),\n        }\n    }", "test": "fn test_client_close() {\n    do_test(\n        3014,\n        |mut cli_sock| {\n            cli_sock.send(Message::Text(\"Hello WebSocket\".into())).unwrap();\n\n            let message = cli_sock.read().unwrap(); // receive answer from server\n            assert_eq!(message.into_data(), b\"From Server\");\n\n            cli_sock.close(None).unwrap(); // send close to server\n\n            let message = cli_sock.read().unwrap(); // receive acknowledgement from server\n            assert!(message.is_close());\n\n            let err = cli_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n        |mut srv_sock| {\n            let message = srv_sock.read().unwrap();\n            assert_eq!(message.into_data(), b\"Hello WebSocket\");\n\n            srv_sock.send(Message::Text(\"From Server\".into())).unwrap();\n\n            let message = srv_sock.read().unwrap(); // receive close from client\n            assert!(message.is_close());\n\n            let err = srv_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n    );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_project_references.rs::disabled", "code": "pub fn full_path(&self) -> PathBuf {\n        let mut path = self.path.clone().into_os_string();\n        if let Some(query) = &self.query {\n            path.push(query);\n        }\n        if let Some(fragment) = &self.fragment {\n            path.push(fragment);\n        }\n        PathBuf::from(path)\n    }", "test": "fn disabled() {\n    let f = super::fixture_root().join(\"tsconfig_project_references\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        tsconfig: Some(TsconfigOptions {\n            config_file: f.join(\"app\"),\n            references: TsconfigReferences::Disabled,\n        }),\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        // Test normal paths alias\n        (f.join(\"app\"), \"@/index.ts\", Ok(f.join(\"app/aliased/index.ts\"))),\n        (f.join(\"app\"), \"@/../index.ts\", Ok(f.join(\"app/index.ts\"))),\n        // Test project reference\n        (f.join(\"project_a\"), \"@/index.ts\", Err(ResolveError::NotFound(f.join(\"project_a\")))),\n        (f.join(\"project_b/src\"), \"@/index.ts\", Err(ResolveError::NotFound(f.join(\"project_b/src\")))),\n        // Does not have paths alias\n        (f.join(\"project_a\"), \"./index.ts\", Ok(f.join(\"project_a/index.ts\"))),\n        (f.join(\"project_c\"), \"./index.ts\", Ok(f.join(\"project_c/index.ts\"))),\n    ];\n\n    for (path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolved_path, expected, \"{request} {path:?}\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_sequence", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_sequence() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\", \"/5$/\"])\n        .succeeds()\n        .stdout_only(\"16\\n17\\n108\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 9));\n    assert_eq!(at.read(\"xx01\"), generate(9, 15));\n    assert_eq!(at.read(\"xx02\"), generate(15, 51));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::continuations_with_echo_comments_true", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn continuations_with_echo_comments_true() {\n  Test::new()\n    .justfile(\n      \"\n      set ignore-comments := false\n\n      some_recipe:\n        # comment lines can be continued \\\\\n        echo something-useful\n    \",\n    )\n    .stdout(\"\")\n    .stderr(\"# comment lines can be continued echo something-useful\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_never", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_interactive_never() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_2 = \"test_rm_interactive\";\n\n    at.touch(file_2);\n    #[cfg(feature = \"chmod\")]\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_2).succeeds();\n\n    scene\n        .ucmd()\n        .arg(\"--interactive=never\")\n        .arg(file_2)\n        .succeeds()\n        .stdout_is(\"\");\n\n    assert!(!at.file_exists(file_2));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::range_lifetime", "code": "fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n                            fixed_key_size,\n                            fixed_value_size,\n                        );\n                        let entry = if reverse {\n                            child_accessor.num_pairs() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Leaf {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            entry,\n                            parent,\n                        }))\n                    }\n                    BRANCH => {\n                        let child_accessor = BranchAccessor::new(&child_page, fixed_key_size);\n                        let child = if reverse {\n                            child_accessor.count_children() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Internal {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            child,\n                            parent,\n                        }))\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", "test": "fn range_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.range::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_owner_group_id", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_owner_group_id() {\n    // test chown 1111:1111 file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let result = scene.cmd(\"id\").arg(\"-g\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_id = String::from(result.stdout_str().trim());\n    assert!(!group_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    let result = scene\n        .ucmd()\n        .arg(format!(\"{user_id}:{group_id}\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001:116'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    let result = scene\n        .ucmd()\n        .arg(format!(\"{user_id}.{group_id}\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001.116'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"0:0\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_negative_offset_before_a_line_num", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_negative_offset_before_a_line_num() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/-10\", \"15\"])\n        .succeeds()\n        .stdout_only(\"18\\n15\\n108\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 15));\n    assert_eq!(at.read(\"xx02\"), generate(15, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_key_is_locked_for_primary", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_key_is_locked_for_primary() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, false);\n\n    let req = DagSelect::from(&product).build();\n    let resp = handle_request(&endpoint, req);\n    assert!(resp.get_data().is_empty(), \"{:?}\", resp);\n    assert!(resp.has_locked(), \"{:?}\", resp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_lines_leading_zeros", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_lines_leading_zeros() {\n    new_ucmd!()\n        .arg(\"--lines=010\")\n        .pipe_in(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\")\n        .succeeds()\n        .stdout_is(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::default", "code": "pub(crate) fn assert_stdout(output: &std::process::Output, stdout: &str) {\n  assert_success(output);\n  assert_eq!(String::from_utf8_lossy(&output.stdout), stdout);\n}", "test": "fn default() {\n  let tmp = temptree! {\n    justfile: \"foo:\\n echo foo\\n\",\n  };\n\n  let cat = which(\"cat\").unwrap();\n  let fzf = tmp.path().join(format!(\"fzf{EXE_SUFFIX}\"));\n\n  #[cfg(unix)]\n  std::os::unix::fs::symlink(cat, fzf).unwrap();\n\n  #[cfg(windows)]\n  std::os::windows::fs::symlink_file(cat, fzf).unwrap();\n\n  let path = env::join_paths(\n    iter::once(tmp.path().to_owned()).chain(env::split_paths(&env::var_os(\"PATH\").unwrap())),\n  )\n  .unwrap();\n\n  let output = Command::new(executable_path(\"just\"))\n    .arg(\"--choose\")\n    .arg(\"--chooser=fzf\")\n    .current_dir(tmp.path())\n    .env(\"PATH\", path)\n    .output()\n    .unwrap();\n\n  assert_stdout(&output, \"foo\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::break_labelled_try_statement", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn break_labelled_try_statement() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let result = \"\"\n            one: try {\n                result = \"foo\";\n                break one;\n                result = \"did not break\"\n            } catch (err) {\n                console.log(err)\n            }\n            result\n        \"#},\n        \"foo\",\n    )]);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::field_expr", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn field_expr() {\n    let source = r#\"\n        void foo() {\n            if (a->x > 10) {\n                a->x = 10;\n            }\n        }\"#;\n\n    let needle = \"{if($x>10) {$x=10;}}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n\n    let source = r#\"\n        void foo() {\n            if (a.x > 10) {\n                a.x = 10;\n            }\n        }\"#;\n\n    let needle = \"{if($x>10) {$x=10;}}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nohup.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(125);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_values", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_values() {\n    verified_stmt(\"SELECT * FROM (VALUES (1), (2), (3))\");\n    verified_stmt(\"SELECT * FROM (VALUES (1), (2), (3)), (VALUES (1, 2, 3))\");\n    verified_stmt(\"SELECT * FROM (VALUES (1)) UNION VALUES (1)\");\n    verified_stmt(\"SELECT * FROM (VALUES ROW(1, true, 'a'), ROW(2, false, 'b')) AS t (a, b, c)\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_simple_backup", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_simple_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a\";\n    let file_b = \"test_mv_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_for_loop", "code": "pub fn add(ctx: &mut ValueMap, key: &'static str, value: Value) {\n        ctx.insert(KeyRef::Str(key), value);\n    }", "test": "fn test_for_loop() {\n    let mut c = CodeGenerator::new(\"<unknown>\", \"\");\n    c.add(Instruction::Lookup(\"items\"));\n    c.start_for_loop(true, false);\n    c.add(Instruction::Emit);\n    c.end_for_loop(false);\n    c.add(Instruction::EmitRaw(\"!\"));\n\n    insta::assert_debug_snapshot!(&c.finish());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::continue_inner_loop", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn continue_inner_loop() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var a = 0, b = 0;\n                for (let i = 0; i < 2; i++) {\n                    a++;\n                    for (let j = 0; j < 10; j++) {\n                        if (j < 3)\n                            continue;\n                        b++;\n                    }\n                    a++;\n                }\n            \"#}),\n        TestAction::assert_eq(\"a\", 4),\n        TestAction::assert_eq(\"b\", 14),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_multiple_obs_lines_standalone", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_multiple_obs_lines_standalone() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"multiple-obs-lines\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-3000\", \"-200\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::errors_with_inheritance_in_included_template", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn errors_with_inheritance_in_included_template() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"base\", \"Base - {% include \\\"child\\\" %}\"),\n        (\"parent\", \"{% block title %}Parent{% endblock %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block title %}{{ super() }} - Child{% endblock %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"base\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Inheritance in included templates is currently not supported: extended `parent`\"\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_1() {\n    let original = r##\"with the ID {#myh1}\n===================\nwith a class {.myclass}\n------------\nmultiple! {.myclass1 #myh3 .myclass2}\n--\n\"##;\n    let expected = r##\"<h1 id=\"myh1\">with the ID</h1>\n<h2 class=\"myclass\">with a class</h2>\n<h2 id=\"myh3\" class=\"myclass1 myclass2\">multiple!</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_stale_read_during_merging", "code": "fn must_not_stale_read(\n    cluster: &mut Cluster<NodeCluster>,\n    stale_key: &[u8],\n    old_region: &Region,\n    old_leader: &Peer,\n    new_region: &Region,\n    new_leader: &Peer,\n    fp: &str,\n) {\n    // A new value for stale_key.\n    let v3 = b\"v3\";\n    let mut request = new_request(\n        new_region.get_id(),\n        new_region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", stale_key, v3)],\n        false,\n    );\n    request.mut_header().set_peer(new_leader.clone());\n    cluster\n        .call_command_on_node(new_leader.get_store_id(), request, Duration::from_secs(5))\n        .unwrap();\n\n    // LocalRead.\n    let read_quorum = false;\n    must_not_eq_on_key(\n        cluster,\n        stale_key,\n        v3,\n        read_quorum,\n        old_region,\n        old_leader,\n        new_region,\n        new_leader,\n    );\n\n    // ReadIndex.\n    let read_quorum = true;\n    must_not_eq_on_key(\n        cluster,\n        stale_key,\n        v3,\n        read_quorum,\n        old_region,\n        old_leader,\n        new_region,\n        new_leader,\n    );\n\n    // Leaders can always propose read index despite split/merge.\n    let propose_readindex = \"before_propose_readindex\";\n    fail::cfg(propose_readindex, \"return(true)\").unwrap();\n\n    // Can not execute reads that are queued.\n    let value1 = read_on_peer(\n        cluster,\n        old_leader.clone(),\n        old_region.clone(),\n        stale_key,\n        read_quorum,\n        Duration::from_secs(1),\n    );\n    debug!(\"stale_key: {:?}, {:?}\", stale_key, value1);\n    value1.unwrap_err(); // Error::Timeout\n\n    // Remove the fp.\n    fail::remove(fp);\n\n    // It should read an error instead of timeout.\n    let value1 = read_on_peer(\n        cluster,\n        old_leader.clone(),\n        old_region.clone(),\n        stale_key,\n        read_quorum,\n        Duration::from_secs(5),\n    );\n    debug!(\"stale_key: {:?}, {:?}\", stale_key, value1);\n    assert!(value1.unwrap().get_header().has_error());\n\n    // Clean up.\n    fail::remove(propose_readindex);\n}", "test": "fn test_stale_read_during_merging() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    configure_for_merge(&mut cluster.cfg);\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, None, None);\n    cluster.cfg.raft_store.right_derive_when_split = false;\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval =\n        cluster.cfg.raft_store.raft_base_tick_interval;\n    debug!(\"max leader lease: {:?}\", election_timeout);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run_conf_change();\n\n    // Write the initial values.\n    let key1 = b\"k1\";\n    let v1 = b\"v1\";\n    cluster.must_put(key1, v1);\n    let key2 = b\"k2\";\n    let v2 = b\"v2\";\n    cluster.must_put(key2, v2);\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    pd_client.must_add_peer(region.get_id(), new_peer(2, 4));\n    pd_client.must_add_peer(region.get_id(), new_peer(3, 5));\n\n    cluster.must_split(&region, b\"k2\");\n\n    let mut region1 = cluster.get_region(key1);\n    let mut region1000 = cluster.get_region(key2);\n    assert_ne!(region1, region1000);\n    assert_eq!(region1.get_id(), 1); // requires disable right_derive.\n    let leader1 = region1\n        .get_peers()\n        .iter()\n        .find(|p| p.get_id() == 4)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(region1.get_id(), leader1.clone());\n\n    let leader1000 = region1000\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() != leader1.get_store_id())\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(region1000.get_id(), leader1000.clone());\n    assert_ne!(leader1.get_store_id(), leader1000.get_store_id());\n\n    // Sleeps an election timeout. The new leader needs enough time to gather\n    // all followers progress, in cause the merge request is reject by the\n    // log gap too large (min_progress == 0).\n    thread::sleep(election_timeout);\n\n    //             merge into\n    // region1000 ------------> region1\n    cluster.must_try_merge(region1000.get_id(), region1.get_id());\n\n    // Pause the apply workers except for the peer 4.\n    let apply_commit_merge = \"apply_before_commit_merge_except_1_4\";\n    fail::cfg(apply_commit_merge, \"pause\").unwrap();\n\n    // Wait for commit merge.\n    // The TiKVs that have followers of the old region will elected a leader\n    // of the new region.\n    //             TiKV A  TiKV B  TiKV C\n    // Region    1   L       F       F\n    // Region 1000   F       L       F\n    //           after wait\n    // Region    1   L       F       F\n    // Region 1000   X       L       F\n    // Note: L: leader, F: follower, X: peer is not exist.\n    // TODO: what if cluster runs slow and lease is expired.\n    // Epoch changed by prepare merge.\n    // We can not use `get_region_with` to get the latest info of reigon 1000,\n    // because leader1 is not paused, it executes commit merge very fast\n    // and reports pd, its range covers region1000.\n    //\n    // region1000 does prepare merge, it increases ver and conf_ver by 1.\n    debug!(\"before merge: {:?} | {:?}\", region1000, region1);\n    let region1000_version = region1000.get_region_epoch().get_version() + 1;\n    region1000\n        .mut_region_epoch()\n        .set_version(region1000_version);\n    let region1000_conf_version = region1000.get_region_epoch().get_conf_ver() + 1;\n    region1000\n        .mut_region_epoch()\n        .set_conf_ver(region1000_conf_version);\n\n    // Epoch changed by commit merge.\n    region1 = cluster.get_region_with(key1, |region| region != &region1);\n    debug!(\"after merge: {:?} | {:?}\", region1000, region1);\n\n    // A key that is covered by region 1000 and region 1.\n    let stale_key = key2;\n\n    must_not_stale_read(\n        &mut cluster,\n        stale_key,\n        &region1000,\n        &leader1000,\n        &region1,\n        &leader1,\n        apply_commit_merge,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_zeros_to_stdout", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_zeros_to_stdout() {\n    let output = vec![0; 256 * 1024];\n    let output = String::from_utf8(output).unwrap();\n    new_ucmd!()\n        .args(&[\"status=none\", \"if=zero-256k.txt\"])\n        .run()\n        .no_stderr()\n        .stdout_is(output)\n        .success();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::assignment_multiline_terminator", "code": "pub fn get_or_intern_static(&mut self, utf8: &'static str, utf16: &'static [u16]) -> Sym {\n        // Uses the utf8 because it's quicker to check inside `COMMON_STRINGS_UTF8`\n        // (which is a perfect hash set) than to check inside `COMMON_STRINGS_UTF16`\n        // (which is a lazy static hash set).\n        self.get(utf8).unwrap_or_else(|| {\n            let index = self.utf8_interner.intern(utf8.as_bytes());\n            let utf16_index = self.utf16_interner.intern(utf16);\n\n            // Just to check everything is okay\n            debug_assert_eq!(index, utf16_index);\n\n            index\n                .checked_add(1 + COMMON_STRINGS_UTF8.len())\n                .and_then(Sym::new)\n                .expect(\"Cannot intern new string: integer overflow\")\n        })\n    }", "test": "fn assignment_multiline_terminator() {\n    let s = r#\"\n    let a = 3;\n\n\n    a =\n\n\n    5;\n    \"#;\n\n    let interner = &mut Interner::default();\n    let a = interner.get_or_intern_static(\"a\", utf16!(\"a\"));\n    check_script_parser(\n        s,\n        vec![\n            Declaration::Lexical(LexicalDeclaration::Let(\n                vec![Variable::from_identifier(\n                    a.into(),\n                    Some(Literal::Int(3).into()),\n                )]\n                .try_into()\n                .unwrap(),\n            ))\n            .into(),\n            Statement::Expression(Expression::from(Assign::new(\n                AssignOp::Assign,\n                Identifier::new(a).into(),\n                Literal::from(5).into(),\n            )))\n            .into(),\n        ],\n        interner,\n    );\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_log10_pow5", "code": "pub fn log10_pow5(e: i32) -> u32 /* or u32 -> u32 */ {\n    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}", "test": "fn test_log10_pow5() {\n    assert_eq!(0, log10_pow5(0));\n    assert_eq!(0, log10_pow5(1));\n    assert_eq!(1, log10_pow5(2));\n    assert_eq!(2, log10_pow5(3));\n    assert_eq!(2, log10_pow5(4));\n    assert_eq!(1831, log10_pow5(2620));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_attach_database", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_attach_database() {\n    let sql = \"ATTACH DATABASE 'test.db' AS test\";\n    let verified_stmt = sqlite().verified_stmt(sql);\n    assert_eq!(sql, format!(\"{}\", verified_stmt));\n    match verified_stmt {\n        Statement::AttachDatabase {\n            schema_name,\n            database_file_name: Expr::Value(Value::SingleQuotedString(literal_name)),\n            database: true,\n        } => {\n            assert_eq!(schema_name.value, \"test\");\n            assert_eq!(literal_name, \"test.db\");\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_interactive_skipped", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_mv_arg_interactive_skipped() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"a\");\n    at.touch(\"b\");\n    ucmd.args(&[\"-vi\", \"a\", \"b\"])\n        .pipe_in(\"N\\n\")\n        .ignore_stdin_write_error()\n        .fails()\n        .stderr_is(\"mv: overwrite 'b'? \")\n        .no_stdout();\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error32_test", "code": "fn compute_error32(q: i32, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f32>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_error32(0, 16777216), (111 + f32::INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(0, 16777217), (111 + f32::INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(0, 16777218), (111 + f32::INVALID_FP, 9223373136366403584));\n    assert_eq!(compute_error32(0, 16777219), (111 + f32::INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(0, 16777220), (111 + f32::INVALID_FP, 9223374235878031360));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error32(-10, 167772160000000000),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772170000000000),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772180000000000),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(\n        compute_error32(-10, 167772190000000000),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772200000000000),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_simple_backup_with_file_extension", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_simple_backup_with_file_extension() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a.txt\";\n    let file_b = \"test_mv_simple_backup_file_b.txt\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nproc.rs::test_nproc_ignore", "code": "fn parse(s: &str) -> Result<usize, &'static str> {\n            match s.parse::<usize>() {\n                Ok(0) => Err(\"fields and positions are numbered from 1\"),\n                // GNU fails when we are at the limit. Match their behavior\n                Ok(n) if n == usize::MAX => Err(\"byte/character offset is too large\"),\n                Ok(n) => Ok(n),\n                Err(_) => Err(\"failed to parse range\"),\n            }\n        }", "test": "fn test_nproc_ignore() {\n    let result = new_ucmd!().succeeds();\n    let nproc_total: u8 = result.stdout_str().trim().parse().unwrap();\n    if nproc_total > 1 {\n        // Ignore all CPU but one\n        let result = TestScenario::new(util_name!())\n            .ucmd()\n            .arg(\"--ignore\")\n            .arg((nproc_total - 1).to_string())\n            .succeeds();\n        let nproc: u8 = result.stdout_str().trim().parse().unwrap();\n        assert_eq!(nproc, 1);\n        // Ignore all CPU but one with a string\n        let result = TestScenario::new(util_name!())\n            .ucmd()\n            .arg(\"--ignore= 1\")\n            .succeeds();\n        let nproc: u8 = result.stdout_str().trim().parse().unwrap();\n        assert_eq!(nproc_total - 1, nproc);\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_basic", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn can_remove_whitespace_basic() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (\"  {%- for n in numbers %}{{n}}{% endfor -%} \", \"123\"),\n        (\"{%- for n in numbers %} {{n}}{%- endfor -%} \", \" 1 2 3\"),\n        (\"{%- for n in numbers -%}\\n {{n}}\\n {%- endfor -%} \", \"123\"),\n        (\"{%- if true -%}\\n {{numbers}}\\n {%- endif -%} \", \"[1, 2, 3]\"),\n        (\"{%- if false -%}\\n {{numbers}}\\n {% else %} Nope{%- endif -%} \", \" Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% else -%} Nope {%- endif -%} \", \"Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% elif true -%} Nope {%- endif -%} \", \"Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% elif false -%} Nope {% else %} else {%- endif -%} \", \" else\"),\n        (\"  {%- set var = 2 -%} {{var}}\", \"2\"),\n        (\"  {% set var = 2 -%} {{var}}\", \"  2\"),\n        (\" {% raw -%} {{2}} {% endraw -%} \", \" {{2}} \"),\n        (\"  {% filter upper -%} hey {%- endfilter -%} \", \"  HEY\"),\n        (\"  {{ \\\"hello\\\" -}} \", \"  hello\"),\n        (\"  {{- \\\"hello\\\" }} \", \"hello \"),\n        (\"  {{- \\\"hello\\\" -}} \", \"hello\"),\n        // Comments are not rendered so it should be just whitespace if anything\n        (\"  {#- \\\"hello\\\" -#} \", \"\"),\n        (\"  {# \\\"hello\\\" -#} \", \"  \"),\n        (\"  {#- \\\"hello\\\" #} \", \" \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_template(\"tpl\", input).unwrap();\n        println!(\"{} -> {:?}\", input, expected);\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_multiple_rollback_merge", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_multiple_rollback_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.right_derive_when_split = true;\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(20);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v\");\n    }\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let left_peer_1 = find_peer(&left, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1.clone());\n    assert_eq!(left_peer_1.get_id(), 1001);\n\n    let on_schedule_merge_fp = \"on_schedule_merge\";\n    let on_check_merge_not_1001_fp = \"on_check_merge_not_1001\";\n\n    let mut right_peer_1_id = find_peer(&right, 1).unwrap().get_id();\n\n    for i in 0..3 {\n        fail::cfg(on_schedule_merge_fp, \"return()\").unwrap();\n        cluster.must_try_merge(left.get_id(), right.get_id());\n        // Change the epoch of target region and the merge will fail\n        pd_client.must_remove_peer(right.get_id(), new_peer(1, right_peer_1_id));\n        right_peer_1_id += 100;\n        pd_client.must_add_peer(right.get_id(), new_peer(1, right_peer_1_id));\n        // Only the source leader is running `on_check_merge`\n        fail::cfg(on_check_merge_not_1001_fp, \"return()\").unwrap();\n        fail::remove(on_schedule_merge_fp);\n        // In previous implementation, rollback merge proposal can be proposed by leader\n        // itself So wait for the leader propose rollback merge if possible\n        sleep_ms(100);\n        // Check if the source region is still in merging mode.\n        let mut l_r = pd_client.get_region(b\"k1\").unwrap();\n        let req = new_request(\n            l_r.get_id(),\n            l_r.take_region_epoch(),\n            vec![new_put_cf_cmd(\n                \"default\",\n                format!(\"k1{}\", i).as_bytes(),\n                b\"vv\",\n            )],\n            false,\n        );\n        let resp = cluster\n            .call_command_on_leader(req, Duration::from_millis(100))\n            .unwrap();\n        if !resp\n            .get_header()\n            .get_error()\n            .get_message()\n            .contains(\"merging mode\")\n        {\n            panic!(\"resp {:?} does not contain merging mode error\", resp);\n        }\n\n        fail::remove(on_check_merge_not_1001_fp);\n        // Write data for waiting the merge to rollback easily\n        cluster.must_put(format!(\"k1{}\", i).as_bytes(), b\"vv\");\n        // Make sure source region is not merged to target region\n        assert_eq!(pd_client.get_region(b\"k1\").unwrap().get_id(), left.get_id());\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::error_message_when_parsing_json_metadata_is_reasonable", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn error_message_when_parsing_json_metadata_is_reasonable() {\n  CommandBuilder::new(\n    \"wallet inscribe --fee-rate 1 --json-metadata metadata.json --file content.png\",\n  )\n  .write(\"content.png\", [1; 520])\n  .write(\"metadata.json\", \"{\")\n  .stderr_regex(\".*failed to parse JSON metadata.*\")\n  .expected_exit_code(1)\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_with_trailing_invalid_chars", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_with_trailing_invalid_chars() {\n    test_helper(\n        \"numeric_trailing_chars\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_input_from_free_arguments", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_input_from_free_arguments() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"1K\", \"1.1M\", \"0.1G\"])\n        .run()\n        .stdout_is(\"1000\\n1100000\\n100000000\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_number_format_ln", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_number_format_ln() {\n    for arg in [\"-nln\", \"--number-format=ln\"] {\n        new_ucmd!()\n            .arg(arg)\n            .pipe_in(\"test\")\n            .succeeds()\n            .stdout_is(\"1     \\ttest\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_fold_at_word_boundary_only_whitespace", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_fold_at_word_boundary_only_whitespace() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-s\", \"-b\"])\n        .pipe_in(\"    \")\n        .succeeds()\n        .stdout_is(\"  \\n  \");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_hard_logical_dir_fail", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_hard_logical_dir_fail() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"d\";\n    at.mkdir(dir);\n    let target = \"link-to-dir\";\n\n    scene.ucmd().args(&[\"-s\", dir, target]);\n\n    scene\n        .ucmd()\n        .args(&[\"-L\", target, \"hard-to-dir-link\"])\n        .fails()\n        .stderr_contains(\"failed to create hard link 'link-to-dir'\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_grouping.rs::test_grouping", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "test": "fn test_grouping() {\n    let tokens: TokenStream = TokenStream::from_iter(vec![\n        TokenTree::Literal(Literal::i32_suffixed(1)),\n        TokenTree::Punct(Punct::new('+', Spacing::Alone)),\n        TokenTree::Group(Group::new(\n            Delimiter::None,\n            TokenStream::from_iter(vec![\n                TokenTree::Literal(Literal::i32_suffixed(2)),\n                TokenTree::Punct(Punct::new('+', Spacing::Alone)),\n                TokenTree::Literal(Literal::i32_suffixed(3)),\n            ]),\n        )),\n        TokenTree::Punct(Punct::new('*', Spacing::Alone)),\n        TokenTree::Literal(Literal::i32_suffixed(4)),\n    ]);\n\n    assert_eq!(tokens.to_string(), \"1i32 + 2i32 + 3i32 * 4i32\");\n\n    snapshot!(tokens as Expr, @r###\"\n    Expr::Binary {\n        left: Expr::Lit {\n            lit: 1i32,\n        },\n        op: BinOp::Add,\n        right: Expr::Binary {\n            left: Expr::Group {\n                expr: Expr::Binary {\n                    left: Expr::Lit {\n                        lit: 2i32,\n                    },\n                    op: BinOp::Add,\n                    right: Expr::Lit {\n                        lit: 3i32,\n                    },\n                },\n            },\n            op: BinOp::Mul,\n            right: Expr::Lit {\n                lit: 4i32,\n            },\n        },\n    }\n    \"###);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::div_plus_load_reported_right", "code": "pub fn call(mut self) -> Self {\n        self.is_call = true;\n        self\n    }", "test": "fn div_plus_load_reported_right() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"memory\") 1)\n                (func (export \"i32.div_s\") (param i32 i32) (result i32)\n                    (i32.div_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.div_u\") (param i32 i32) (result i32)\n                    (i32.div_u (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_s\") (param i32 i32) (result i32)\n                    (i32.rem_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_u\") (param i32 i32) (result i32)\n                    (i32.rem_u (local.get 0) (i32.load (local.get 1))))\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"memory\").unwrap();\n    let i32_div_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.div_s\")?;\n    let i32_div_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.div_u\")?;\n    let i32_rem_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.rem_s\")?;\n    let i32_rem_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.rem_u\")?;\n\n    memory.write(&mut store, 0, &1i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 4, &0i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 8, &(-1i32).to_le_bytes()).unwrap();\n\n    assert_eq!(i32_div_s.call(&mut store, (100, 0))?, 100);\n    assert_eq!(i32_div_u.call(&mut store, (101, 0))?, 101);\n    assert_eq!(i32_rem_s.call(&mut store, (102, 0))?, 0);\n    assert_eq!(i32_rem_u.call(&mut store, (103, 0))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n\n    assert_trap(\n        i32_div_s.call(&mut store, (i32::MIN, 8)),\n        Trap::IntegerOverflow,\n    );\n    assert_eq!(i32_rem_s.call(&mut store, (i32::MIN, 8))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n\n    return Ok(());\n\n    #[track_caller]\n    fn assert_trap<T>(result: Result<T>, expected: Trap) {\n        match result {\n            Ok(_) => panic!(\"expected failure\"),\n            Err(e) => {\n                if let Some(code) = e.downcast_ref::<Trap>() {\n                    if *code == expected {\n                        return;\n                    }\n                }\n                panic!(\"unexpected error {e:?}\");\n            }\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_numeric_prefixed_chunks_by_bytes", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_numeric_prefixed_chunks_by_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_bytes\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    ucmd.args(&[\n        \"-d\", // --numeric-suffixes\n        \"-b\", // --bytes\n        \"1000\", name, \"a\",\n    ])\n    .succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"a\\d\\d$\");\n    assert_eq!(glob.count(), 10);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 1000);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/float_tests.rs::int_pow_fast_path_test", "code": "fn int_pow_fast_path(radix: u32) {\n    for exponent in 0..f64::mantissa_limit(radix) {\n        let exponent = exponent as usize;\n        let actual = unsafe { f64::int_pow_fast_path(exponent, radix) };\n        assert_eq!(actual, slow_int_power(exponent, radix));\n    }\n}", "test": "fn int_pow_fast_path_test() {\n    int_pow_fast_path(10);\n    if cfg!(feature = \"power-of-two\") {\n        int_pow_fast_path(2);\n        int_pow_fast_path(4);\n        int_pow_fast_path(8);\n        int_pow_fast_path(16);\n        int_pow_fast_path(32);\n    }\n    if cfg!(feature = \"radix\") {\n        int_pow_fast_path(3);\n        int_pow_fast_path(5);\n        int_pow_fast_path(6);\n        int_pow_fast_path(7);\n        int_pow_fast_path(9);\n        int_pow_fast_path(11);\n        int_pow_fast_path(12);\n        int_pow_fast_path(13);\n        int_pow_fast_path(14);\n        int_pow_fast_path(15);\n        int_pow_fast_path(17);\n        int_pow_fast_path(18);\n        int_pow_fast_path(19);\n        int_pow_fast_path(20);\n        int_pow_fast_path(21);\n        int_pow_fast_path(22);\n        int_pow_fast_path(23);\n        int_pow_fast_path(24);\n        int_pow_fast_path(25);\n        int_pow_fast_path(26);\n        int_pow_fast_path(27);\n        int_pow_fast_path(28);\n        int_pow_fast_path(29);\n        int_pow_fast_path(30);\n        int_pow_fast_path(31);\n        int_pow_fast_path(33);\n        int_pow_fast_path(34);\n        int_pow_fast_path(35);\n        int_pow_fast_path(36);\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_with_optional_satpoint_arg", "code": "pub(crate) fn assert_response_regex(&self, path: impl AsRef<str>, regex: impl AsRef<str>) {\n    self.sync_server();\n\n    let response = reqwest::blocking::get(self.url().join(path.as_ref()).unwrap()).unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n    assert_regex_match!(response.text().unwrap(), regex.as_ref());\n  }", "test": "fn inscribe_with_optional_satpoint_arg() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  let txid = rpc_server.mine_blocks(1)[0].txdata[0].txid();\n\n  let Inscribe { inscriptions, .. } = CommandBuilder::new(format!(\n    \"wallet inscribe --file foo.txt --satpoint {txid}:0:10000 --fee-rate 1\"\n  ))\n  .write(\"foo.txt\", \"FOO\")\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output();\n  let inscription = inscriptions[0].id;\n\n  rpc_server.mine_blocks(1);\n\n  TestServer::spawn_with_args(&rpc_server, &[\"--index-sats\"]).assert_response_regex(\n    \"/sat/5000010000\",\n    format!(\".*<a href=/inscription/{inscription}>.*\"),\n  );\n\n  TestServer::spawn_with_args(&rpc_server, &[])\n    .assert_response_regex(format!(\"/content/{inscription}\",), \"FOO\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_number", "code": "fn to_owned(&self) -> Self::Owned {\n        RawValue::from_owned(self.json.to_owned().into_boxed_str())\n    }", "test": "fn test_parse_number() {\n    test_parse_ok(vec![\n        (\"0.0\", Number::from_f64(0.0f64).unwrap()),\n        (\"3.0\", Number::from_f64(3.0f64).unwrap()),\n        (\"3.1\", Number::from_f64(3.1).unwrap()),\n        (\"-1.2\", Number::from_f64(-1.2).unwrap()),\n        (\"0.4\", Number::from_f64(0.4).unwrap()),\n    ]);\n\n    test_fromstr_parse_err::<Number>(&[\n        (\" 1.0\", \"invalid number at line 1 column 1\"),\n        (\"1.0 \", \"invalid number at line 1 column 4\"),\n        (\"\\t1.0\", \"invalid number at line 1 column 1\"),\n        (\"1.0\\t\", \"invalid number at line 1 column 4\"),\n    ]);\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    test_parse_ok(vec![\n        (\"1e999\", Number::from_string_unchecked(\"1e999\".to_owned())),\n        (\"1e+999\", Number::from_string_unchecked(\"1e+999\".to_owned())),\n        (\"-1e999\", Number::from_string_unchecked(\"-1e999\".to_owned())),\n        (\"1e-999\", Number::from_string_unchecked(\"1e-999\".to_owned())),\n        (\"1E999\", Number::from_string_unchecked(\"1E999\".to_owned())),\n        (\"1E+999\", Number::from_string_unchecked(\"1E+999\".to_owned())),\n        (\"-1E999\", Number::from_string_unchecked(\"-1E999\".to_owned())),\n        (\"1E-999\", Number::from_string_unchecked(\"1E-999\".to_owned())),\n        (\"1E+000\", Number::from_string_unchecked(\"1E+000\".to_owned())),\n        (\n            \"2.3e999\",\n            Number::from_string_unchecked(\"2.3e999\".to_owned()),\n        ),\n        (\n            \"-2.3e999\",\n            Number::from_string_unchecked(\"-2.3e999\".to_owned()),\n        ),\n    ]);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_option", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_option() {\n    test_parse_ok(vec![\n        (\"null\", None::<String>),\n        (\"\\\"jodhpurs\\\"\", Some(\"jodhpurs\".to_string())),\n    ]);\n\n    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n    struct Foo {\n        x: Option<isize>,\n    }\n\n    let value: Foo = from_str(\"{}\").unwrap();\n    assert_eq!(value, Foo { x: None });\n\n    test_parse_ok(vec![\n        (\"{\\\"x\\\": null}\", Foo { x: None }),\n        (\"{\\\"x\\\": 5}\", Foo { x: Some(5) }),\n    ]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_raftkv_precheck_write_with_ctx", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_raftkv_precheck_write_with_ctx() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(b\"k1\"), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let follower = region\n        .get_peers()\n        .iter()\n        .find(|p| p.get_id() != leader.get_id())\n        .unwrap();\n\n    let leader_storage = cluster.sim.rl().storages[&leader.get_id()].clone();\n    let follower_storage = cluster.sim.rl().storages[&follower.get_id()].clone();\n\n    // Assume this is a write request.\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(region.get_peers()[0].clone());\n\n    // The (write) request can be sent to the leader.\n    leader_storage.precheck_write_with_ctx(&ctx).unwrap();\n    // The (write) request should not be send to a follower.\n    follower_storage.precheck_write_with_ctx(&ctx).unwrap_err();\n\n    // Leader has network partition and it must be not leader any more.\n    let filter = Box::new(RegionPacketFilter::new(\n        region.get_id(),\n        leader.get_store_id(),\n    ));\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(leader.get_store_id(), filter.clone());\n    cluster\n        .sim\n        .wl()\n        .add_send_filter(leader.get_store_id(), filter);\n    sleep_until_election_triggered(&cluster.cfg);\n    leader_storage.precheck_write_with_ctx(&ctx).unwrap_err();\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/gen_c_header.rs::gen_c_header_works_pirita", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "test": "fn gen_c_header_works_pirita() -> anyhow::Result<()> {\n    let temp_dir = tempfile::tempdir()?;\n    let operating_dir: PathBuf = temp_dir.path().to_owned();\n\n    let wasm_path = operating_dir.join(fixtures::wabt());\n    let out_path = temp_dir.path().join(\"header.h\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .arg(\"--atom\")\n        .arg(\"wasm-validate\")\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(file.contains(\"wasmer_function_0f41d38dcfb5abc1fadb5e9acbc5c645e53fe4d0dd86270b72a09bfeee04d055_0\"), \"no wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0 in file\");\n\n    let cmd = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .output()\n        .unwrap();\n\n    assert!(!cmd.status.success());\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%23%\"])\n        .succeeds()\n        .stdout_only(\"84\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(23, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_negative_zero", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_negative_zero() {\n    new_ucmd!()\n        .args(&[\"-w\", \"-0\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n02\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n02\\n\")\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_deref_conflicting_options", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_cp_deref_conflicting_options() {\n    new_ucmd!()\n        .arg(\"-LP\")\n        .arg(TEST_COPY_TO_FOLDER)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::should_write_to_engine", "code": "fn should_write_to_engine(&self) -> bool {\n        panic!()\n    }", "test": "fn should_write_to_engine() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() == max_keys + 1 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() == max_keys + 1 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/options.rs::default_options", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn default_options() {\n    let ron = Options::default();\n\n    let de: Struct = ron.from_str(\"(Some(42),(4.2))\").unwrap();\n    let ser = ron.to_string(&de).unwrap();\n\n    assert_eq!(ser, \"(Some(42),(4.2))\")\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::strict_mode_octal", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn strict_mode_octal() {\n    // Checks as per https://tc39.es/ecma262/#sec-literals-numeric-literals that 0 prefix\n    // octal number literal syntax is a syntax error in strict mode.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            var n = 023;\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"implicit octal literals are not allowed in strict mode at line 2, col 9\",\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_restart", "code": "pub fn get_state(&self) -> Arc<AtomicCell<DownstreamState>> {\n        self.state.clone()\n    }", "test": "fn test_node_merge_restart() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.run();\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n    let leader = cluster.leader_of_region(left.get_id()).unwrap();\n\n    cluster.shutdown();\n    let engine = cluster.get_engine(leader.get_store_id());\n    let state_key = keys::region_state_key(left.get_id());\n    let state: RegionLocalState = engine.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Merging, \"{:?}\", state);\n    let state_key = keys::region_state_key(right.get_id());\n    let state: RegionLocalState = engine.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Normal, \"{:?}\", state);\n    fail::remove(schedule_merge_fp);\n    cluster.start().unwrap();\n\n    // Wait till merge is finished.\n    pd_client.check_merged_timeout(left.get_id(), Duration::from_secs(5));\n\n    cluster.must_put(b\"k4\", b\"v4\");\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), b\"k4\", b\"v4\");\n        let state_key = keys::region_state_key(left.get_id());\n        let state: RegionLocalState = cluster\n            .get_engine(i)\n            .get_msg_cf(CF_RAFT, &state_key)\n            .unwrap()\n            .unwrap();\n        assert_eq!(state.get_state(), PeerState::Tombstone, \"{:?}\", state);\n        let state_key = keys::region_state_key(right.get_id());\n        let state: RegionLocalState = cluster\n            .get_engine(i)\n            .get_msg_cf(CF_RAFT, &state_key)\n            .unwrap()\n            .unwrap();\n        assert_eq!(state.get_state(), PeerState::Normal, \"{:?}\", state);\n        assert!(state.get_region().get_start_key().is_empty());\n        assert!(state.get_region().get_end_key().is_empty());\n    }\n\n    // Now test if cluster works fine when it crash after merge is applied\n    // but before notifying raftstore thread.\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_on_store1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n    let peer_on_store1 = find_peer(&left, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(left.get_id(), peer_on_store1);\n    cluster.must_put(b\"k11\", b\"v11\");\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v11\");\n    let skip_destroy_fp = \"raft_store_skip_destroy_peer\";\n    fail::cfg(skip_destroy_fp, \"return()\").unwrap();\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    pd_client.must_merge(left.get_id(), right.get_id());\n    let peer = find_peer(&right, 3).unwrap().to_owned();\n    pd_client.must_remove_peer(right.get_id(), peer);\n    cluster.shutdown();\n    fail::remove(skip_destroy_fp);\n    cluster.clear_send_filters();\n    cluster.start().unwrap();\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    must_get_none(&cluster.get_engine(3), b\"k3\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_split_region.rs::test_split_lost_request_vote", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_split_lost_request_vote() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run();\n    let region = cluster.get_region(b\"\");\n\n    // Only need peer 1 and 3. Stop node 2 to avoid extra vote messages.\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    cluster.stop_node(2);\n\n    // Use a channel to retrieve start_key and end_key in pre-vote messages.\n    let (range_tx, range_rx) = mpsc::channel();\n    let (after_sent_tx, after_sent_rx) = mpsc::channel();\n    let prevote_filter = PrevoteRangeFilter {\n        // Only send 1 pre-vote message to peer 3 so if peer 3 drops it,\n        // it needs to start a new election.\n        filter: RegionPacketFilter::new(1000, 1) // new region id is 1000\n            .msg_type(MessageType::MsgRequestPreVote)\n            .direction(Direction::Send)\n            .allow(1),\n        before: Some(Mutex::new(range_tx)),\n        after: Some(Mutex::new(after_sent_tx)),\n    };\n    cluster\n        .sim\n        .wl()\n        .add_send_filter(1, Box::new(prevote_filter));\n\n    // Ensure pre-vote response is really sent.\n    let (tx, rx) = mpsc::channel();\n    let prevote_resp_notifier = Box::new(MessageTypeNotifier::new(\n        MessageType::MsgRequestPreVoteResponse,\n        tx,\n        Arc::from(AtomicBool::new(true)),\n    ));\n    cluster.sim.wl().add_send_filter(3, prevote_resp_notifier);\n\n    // After split, pre-vote message should be sent to peer 3.\n    fail::cfg(\"apply_after_split_1_3\", \"pause\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let range = range_rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    assert_eq!(range.0, b\"\");\n    assert_eq!(range.1, b\"k2\");\n\n    // Make sure the message has sent to peer 3.\n    after_sent_rx\n        .recv_timeout(Duration::from_millis(100))\n        .unwrap();\n\n    // Make sure pre-vote is handled.\n    let new_region = cluster.pd_client.get_region(b\"\").unwrap();\n    let pending_create_peer = new_region\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() == 3)\n        .unwrap()\n        .to_owned();\n    let _ = read_on_peer(\n        &mut cluster,\n        pending_create_peer,\n        region,\n        b\"k1\",\n        false,\n        Duration::from_millis(100),\n    );\n\n    // Make sure pre-vote is cached in pending votes.\n    {\n        let store_meta = cluster.store_metas.get(&3).unwrap();\n        let meta = store_meta.lock().unwrap();\n        assert!(meta.pending_msgs.iter().any(|m| {\n            m.region_id == new_region.id\n                && raftstore::store::util::is_first_message(m.get_message())\n        }));\n    }\n\n    // After the follower split success, it will response to the pending vote.\n    fail::cfg(\"apply_after_split_1_3\", \"off\").unwrap();\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_node_leader_crash", "code": "fn test_multi_leader_crash<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key1, value1) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key1, value1);\n\n    let last_leader = cluster.leader_of_region(1).unwrap();\n    cluster.stop_node(last_leader.get_store_id());\n\n    sleep_ms(800);\n    cluster.reset_leader_of_region(1);\n    let new_leader = cluster\n        .leader_of_region(1)\n        .expect(\"leader should be elected.\");\n    assert_ne!(new_leader, last_leader);\n\n    assert_eq!(cluster.get(key1), Some(value1.to_vec()));\n\n    let (key2, value2) = (b\"k2\", b\"v2\");\n\n    cluster.must_put(key2, value2);\n    cluster.must_delete(key1);\n    must_get_none(&cluster.engines[&last_leader.get_store_id()].kv, key2);\n    must_get_equal(\n        &cluster.engines[&last_leader.get_store_id()].kv,\n        key1,\n        value1,\n    );\n\n    // week up\n    cluster.run_node(last_leader.get_store_id()).unwrap();\n\n    must_get_equal(\n        &cluster.engines[&last_leader.get_store_id()].kv,\n        key2,\n        value2,\n    );\n    must_get_none(&cluster.engines[&last_leader.get_store_id()].kv, key1);\n}", "test": "fn test_multi_node_leader_crash() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_multi_leader_crash(&mut cluster)\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::try_break_finally_edge_cases", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn try_break_finally_edge_cases() {\n    let scenario = r#\"\n        var a;\n        var b;\n        {\n            while (true) {\n                try {\n                    try {\n                        break;\n                    } catch(a) {\n                    } finally {\n                    }\n                } finally {\n                }\n            }\n        }\n\n        {\n            while (true) {\n                try {\n                    try {\n                        throw \"b\";\n                    } catch (b) {\n                        break;\n                    } finally {\n                        a = \"foo\"\n                    }\n                } finally {\n                }\n            }\n        }\n\n        {\n            while (true) {\n                try {\n                    try {\n                    } catch (c) {\n                    } finally {\n                        b = \"bar\"\n                        break;\n                    }\n                } finally {\n                }\n            }\n        }\n        a + b\n    \"#;\n\n    run_test_actions([TestAction::assert_eq(scenario, \"foobar\")]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_upload_and_ingest_with_tde", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_upload_and_ingest_with_tde() {\n    let (_tmp_dir, _cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client_tde();\n\n    let temp_dir = Builder::new().prefix(\"test_ingest_sst\").tempdir().unwrap();\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n\n    check_ingested_kvs(&tikv, &ctx, sst_range);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_cdc_filter_key_range", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_cdc_filter_key_range() {\n    let mut suite = TestSuite::new(1, ApiVersion::V1);\n\n    let req = suite.new_changedata_request(1);\n\n    // Observe range [key1, key3).\n    let mut req_1_3 = req.clone();\n    req_1_3.request_id = 13;\n    req_1_3.start_key = Key::from_raw(b\"key1\").into_encoded();\n    req_1_3.end_key = Key::from_raw(b\"key3\").into_encoded();\n    let (mut req_tx13, _event_feed_wrap13, receive_event13) =\n        new_event_feed(suite.get_region_cdc_client(1));\n    block_on(req_tx13.send((req_1_3, WriteFlags::default()))).unwrap();\n    let event = receive_event13(false);\n    event\n        .events\n        .into_iter()\n        .for_each(|e| match e.event.unwrap() {\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        });\n\n    let (mut req_tx24, _event_feed_wrap24, receive_event24) =\n        new_event_feed(suite.get_region_cdc_client(1));\n    let mut req_2_4 = req;\n    req_2_4.request_id = 24;\n    req_2_4.start_key = Key::from_raw(b\"key2\").into_encoded();\n    req_2_4.end_key = Key::from_raw(b\"key4\").into_encoded();\n    block_on(req_tx24.send((req_2_4, WriteFlags::default()))).unwrap();\n    let event = receive_event24(false);\n    event\n        .events\n        .into_iter()\n        .for_each(|e| match e.event.unwrap() {\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        });\n\n    // Sleep a while to make sure the stream is registered.\n    sleep_ms(1000);\n\n    let receive_and_check_events = |is13: bool, is24: bool| -> Vec<Event> {\n        if is13 && is24 {\n            let mut events = receive_event13(false).events.to_vec();\n            let mut events24 = receive_event24(false).events.to_vec();\n            events.append(&mut events24);\n            events\n        } else if is13 {\n            let events = receive_event13(false).events.to_vec();\n            let event = receive_event24(true);\n            assert!(event.resolved_ts.is_some(), \"{:?}\", event);\n            events\n        } else if is24 {\n            let events = receive_event24(false).events.to_vec();\n            let event = receive_event13(true);\n            assert!(event.resolved_ts.is_some(), \"{:?}\", event);\n            events\n        } else {\n            let event = receive_event13(true);\n            assert!(event.resolved_ts.is_some(), \"{:?}\", event);\n            let event = receive_event24(true);\n            assert!(event.resolved_ts.is_some(), \"{:?}\", event);\n            vec![]\n        }\n    };\n    for case in &[\n        (\"key1\", true, false, true /* commit */),\n        (\"key1\", true, false, false /* rollback */),\n        (\"key2\", true, true, true),\n        (\"key3\", false, true, true),\n        (\"key4\", false, false, true),\n    ] {\n        let (k, v) = (case.0.to_owned(), \"value\".to_owned());\n        // Prewrite\n        let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.key = k.clone().into_bytes();\n        mutation.value = v.into_bytes();\n        suite.must_kv_prewrite(1, vec![mutation], k.clone().into_bytes(), start_ts);\n        let mut events = receive_and_check_events(case.1, case.2);\n        while let Some(event) = events.pop() {\n            match event.event.unwrap() {\n                Event_oneof_event::Entries(entries) => {\n                    assert_eq!(entries.entries.len(), 1);\n                    assert_eq!(entries.entries[0].get_type(), EventLogType::Prewrite);\n                }\n                other => panic!(\"unknown event {:?}\", other),\n            }\n        }\n\n        if case.3 {\n            // Commit\n            let commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n            suite.must_kv_commit(1, vec![k.into_bytes()], start_ts, commit_ts);\n            let mut events = receive_and_check_events(case.1, case.2);\n            while let Some(event) = events.pop() {\n                match event.event.unwrap() {\n                    Event_oneof_event::Entries(entries) => {\n                        assert_eq!(entries.entries.len(), 1);\n                        assert_eq!(entries.entries[0].get_type(), EventLogType::Commit);\n                    }\n                    other => panic!(\"unknown event {:?}\", other),\n                }\n            }\n        } else {\n            // Rollback\n            suite.must_kv_rollback(1, vec![k.into_bytes()], start_ts);\n            let mut events = receive_and_check_events(case.1, case.2);\n            while let Some(event) = events.pop() {\n                match event.event.unwrap() {\n                    Event_oneof_event::Entries(entries) => {\n                        assert_eq!(entries.entries.len(), 1);\n                        assert_eq!(entries.entries[0].get_type(), EventLogType::Rollback);\n                    }\n                    other => panic!(\"unknown event {:?}\", other),\n                }\n            }\n        }\n    }\n\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_context_overflow", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_context_overflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/45/+10\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/45/+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.args(&[\"numbers50.txt\", \"/45/+10\", \"-k\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/45/+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_prompt_write_protected_yes", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_prompt_write_protected_yes() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_1 = \"test_rm_prompt_write_protected_1\";\n\n    at.touch(file_1);\n\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_1).succeeds();\n\n    scene.ucmd().arg(file_1).pipe_in(\"y\").succeeds();\n    assert!(!at.file_exists(file_1));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::object", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn object() {\n    test(\"let x = {'(':')'}\", \"let x={'(':')'};\");\n    test(\"({})\", \"({});\");\n    test(\"({}.x)\", \"({}).x;\");\n    test(\"({} = {})\", \"({}={});\");\n    test(\"(x, {} = {})\", \"x,{}={};\");\n    test(\"let x = () => ({})\", \"let x=()=>({});\");\n    test(\"let x = () => ({}.x)\", \"let x=()=>({}).x;\");\n    test(\"let x = () => ({} = {})\", \"let x=()=>({}={});\");\n    test(\"let x = () => (x, {} = {})\", \"let x=()=>(x,{}={});\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_some_literals", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_some_literals() {\n    let scenario = TestScenario::new(util_name!());\n    let tests = [\n        \"a string\",\n        \"(\",\n        \")\",\n        \"-\",\n        \"--\",\n        \"-0\",\n        \"-f\",\n        \"--help\",\n        \"--version\",\n        \"-eq\",\n        \"-lt\",\n        \"-ef\",\n        \"[\",\n    ];\n\n    for test in &tests {\n        scenario.ucmd().arg(test).succeeds();\n    }\n\n    // run the inverse of all these tests\n    for test in &tests {\n        scenario.ucmd().arg(\"!\").arg(test).run().code_is(1);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_output_counts", "code": "pub fn get_output_counts(&self) -> &[i64] {\n        &self.output_counts\n    }", "test": "fn test_output_counts() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n\n    let req = DagSelect::from(&product).build();\n    let resp = handle_select(&endpoint, req);\n    assert_eq!(resp.get_output_counts(), &[data.len() as i64]);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::does_render_owned_for_loop_with_objects", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn does_render_owned_for_loop_with_objects() {\n    let mut context = Context::new();\n    let data = json!([\n        {\"id\": 1, \"year\": 2015},\n        {\"id\": 2, \"year\": 2015},\n        {\"id\": 3, \"year\": 2016},\n        {\"id\": 4, \"year\": 2017},\n        {\"id\": 5, \"year\": 2017},\n        {\"id\": 6, \"year\": 2017},\n        {\"id\": 7, \"year\": 2018},\n        {\"id\": 8},\n        {\"id\": 9, \"year\": null},\n    ]);\n    context.insert(\"something\", &data);\n\n    let tpl =\n        r#\"{% for year, things in something | group_by(attribute=\"year\") %}{{year}},{% endfor %}\"#;\n    let expected = \"2015,2016,2017,2018,\";\n    assert_eq!(render_template(tpl, &context).unwrap(), expected);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::arrow", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn arrow() {\n    test(\"() => {}\", \"()=>{};\");\n    test(\"x => (x, 0)\", \"x=>(x,0);\");\n    test(\"x => {y}\", \"x=>{y};\");\n    test(\"(a = (b, c), ...d) => {}\", \"(a=(b,c),...d)=>{};\");\n    test(\"({[1 + 2]: a = 3} = {[1 + 2]: 3}) => {}\", \"({[3]:a=3}={[3]:3})=>{};\");\n    test(\n        \"([a = (1, 2), ...[b, ...c]] = [1, [2, 3]]) => {}\",\n        \"([a=(1,2),...[b,...c]]=[1,[2,3]])=>{};\",\n    );\n    test(\"([] = []) => {}\", \"([]=[])=>{};\");\n    test(\"([,] = [,]) => {}\", \"([,]=[,])=>{};\");\n    test(\"([,,] = [,,]) => {}\", \"([,,]=[,,])=>{};\");\n    test(\"a = () => {}\", \"a=()=>{};\");\n    test(\"a || (() => {})\", \"a||(()=>{});\");\n    // test(\"({a = b, c = d}) => {}\", \"({a=b,c=d})=>{};\");\n    // test(\"([{a = b, c = d} = {}] = []) => {}\", \"([{a=b,c=d}={}]=[])=>{};\");\n    test(\"({a: [b = c] = []} = {}) => {}\", \"({a:[b=c]=[]}={})=>{};\");\n\n    // These are not arrow functions but initially look like one\n    test(\"(a = b, c)\", \"a=b,c;\");\n    test(\"([...a = b])\", \"[...a=b];\");\n    test(\"([...a, ...b])\", \"[...a,...b];\");\n    test(\"({a: b, c() {}})\", \"({a:b,c(){}});\");\n    test(\"({a: b, get c() {}})\", \"({a:b,get c(){}});\");\n    test(\"({a: b, set c(x) {}})\", \"({a:b,set c(x){}});\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_zero_multiplier_warning", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_zero_multiplier_warning() {\n    for arg in [\"count\", \"seek\", \"skip\"] {\n        new_ucmd!()\n            .args(&[format!(\"{arg}=0\").as_str(), \"status=none\"])\n            .pipe_in(\"\")\n            .succeeds()\n            .no_stdout()\n            .no_stderr();\n\n        new_ucmd!()\n            .args(&[format!(\"{arg}=00x1\").as_str(), \"status=none\"])\n            .pipe_in(\"\")\n            .succeeds()\n            .no_stdout()\n            .no_stderr();\n\n        new_ucmd!()\n            .args(&[format!(\"{arg}=0x1\").as_str(), \"status=none\"])\n            .pipe_in(\"\")\n            .succeeds()\n            .no_stdout()\n            .stderr_contains(\"warning: '0x' is a zero multiplier; use '00x' if that is intended\");\n\n        new_ucmd!()\n            .args(&[format!(\"{arg}=0x0x1\").as_str(), \"status=none\"])\n            .pipe_in(\"\")\n            .succeeds()\n            .no_stdout()\n            .stderr_is(\"dd: warning: '0x' is a zero multiplier; use '00x' if that is intended\\ndd: warning: '0x' is a zero multiplier; use '00x' if that is intended\\n\");\n\n        new_ucmd!()\n            .args(&[format!(\"{arg}=1x0x1\").as_str(), \"status=none\"])\n            .pipe_in(\"\")\n            .succeeds()\n            .no_stdout()\n            .stderr_contains(\"warning: '0x' is a zero multiplier; use '00x' if that is intended\");\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_boxed_raw_value", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "test": "fn test_boxed_raw_value() {\n    #[derive(Serialize, Deserialize)]\n    struct Wrapper {\n        a: i8,\n        b: Box<RawValue>,\n        c: i8,\n    }\n\n    let wrapper_from_str: Wrapper =\n        serde_json::from_str(r#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_str.b.get());\n\n    let wrapper_from_reader: Wrapper =\n        serde_json::from_reader(br#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#.as_ref()).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_reader.b.get());\n\n    let wrapper_from_value: Wrapper =\n        serde_json::from_value(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3})).unwrap();\n    assert_eq!(r#\"{\"foo\":2}\"#, wrapper_from_value.b.get());\n\n    let wrapper_to_string = serde_json::to_string(&wrapper_from_str).unwrap();\n    assert_eq!(r#\"{\"a\":1,\"b\":{\"foo\": 2},\"c\":3}\"#, wrapper_to_string);\n\n    let wrapper_to_value = serde_json::to_value(&wrapper_from_str).unwrap();\n    assert_eq!(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}), wrapper_to_value);\n\n    let array_from_str: Vec<Box<RawValue>> =\n        serde_json::from_str(r#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_str[0].get());\n    assert_eq!(r#\"42\"#, array_from_str[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_str[2].get());\n    assert_eq!(r#\"null\"#, array_from_str[3].get());\n\n    let array_from_reader: Vec<Box<RawValue>> =\n        serde_json::from_reader(br#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#.as_ref()).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_reader[0].get());\n    assert_eq!(r#\"42\"#, array_from_reader[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_reader[2].get());\n    assert_eq!(r#\"null\"#, array_from_reader[3].get());\n\n    let array_to_string = serde_json::to_string(&array_from_str).unwrap();\n    assert_eq!(r#\"[\"a\",42,{\"foo\": \"bar\"},null]\"#, array_to_string);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/snapshot_basic.rs::snapshot_get_value_after_put", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn snapshot_get_value_after_put() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"aa\").unwrap();\n\n    let snap = db.engine.snapshot();\n\n    db.engine.put(b\"a\", b\"aaa\").unwrap();\n\n    let value = snap.get_value(b\"a\").unwrap();\n    let value = value.unwrap();\n    assert_eq!(value, b\"aa\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::conditional_op", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn conditional_op() {\n    run_test_actions([TestAction::assert_eq(\"1 === 2 ? 'a' : 'b'\", \"b\")]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::ile_dev_null() {\n    ", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "utfile_dev_null() {\n    new_ucmd!().arg(\"of=/dev/null\").succeeds().no_stdout();\n}\n\n#[test]"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::default_not_taken_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn default_not_taken_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 5;\n\n            switch (a) {\n                case 5:\n                    a = 150;\n                    break;\n                default:\n                    a = 70;\n            }\n\n            a;\n        \"#},\n        150,\n    )]);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::fill_wrong", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn fill_wrong() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    assert_eq!(\n        table\n            .fill(&mut store, 0, Val::ExternRef(None), 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"value does not match table element type\"\n    );\n\n    let ty = TableType::new(ValType::ExternRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::ExternRef(None)).unwrap();\n    assert_eq!(\n        table\n            .fill(&mut store, 0, Val::FuncRef(None), 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"value does not match table element type\"\n    );\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/save_jpeg.rs::jqeg_qualitys", "code": "pub fn write_to<W: Write + Seek, F: Into<ImageOutputFormat>>(\n        &self,\n        w: &mut W,\n        format: F,\n    ) -> ImageResult<()> {\n        #[allow(unused_variables)]\n        // When no features are supported\n        let w = w;\n        #[allow(unused_variables, unused_mut)]\n        let mut bytes = self.inner_bytes();\n        #[allow(unused_variables)]\n        let (width, height) = self.dimensions();\n        #[allow(unused_variables, unused_mut)]\n        let mut color = self.color();\n        let format = format.into();\n\n        // TODO do not repeat this match statement across the crate\n\n        #[allow(deprecated)]\n        match format {\n            #[cfg(feature = \"png\")]\n            image::ImageOutputFormat::Png => {\n                let p = png::PngEncoder::new(w);\n                p.write_image(bytes, width, height, color)?;\n                Ok(())\n            }\n\n            #[cfg(feature = \"pnm\")]\n            image::ImageOutputFormat::Pnm(subtype) => {\n                let p = pnm::PnmEncoder::new(w).with_subtype(subtype);\n                p.write_image(bytes, width, height, color)?;\n                Ok(())\n            }\n\n            #[cfg(feature = \"gif\")]\n            image::ImageOutputFormat::Gif => {\n                let mut g = gif::GifEncoder::new(w);\n                g.encode_frame(crate::animation::Frame::new(self.to_rgba8()))?;\n                Ok(())\n            }\n\n            format => write_buffer_with_format(w, bytes, width, height, color, format),\n        }\n    }", "test": "fn jqeg_qualitys() {\n    let img = image::open(\"tests/images/tiff/testsuite/mandrill.tiff\").unwrap();\n\n    let mut default = vec![];\n    img.write_to(&mut Cursor::new(&mut default), ImageFormat::Jpeg)\n        .unwrap();\n    assert_eq!(&[255, 216], &default[..2]);\n\n    let mut small = vec![];\n    img.write_to(&mut Cursor::new(&mut small), ImageOutputFormat::Jpeg(10))\n        .unwrap();\n    assert_eq!(&[255, 216], &small[..2]);\n\n    assert!(small.len() < default.len());\n\n    let mut large = vec![];\n    img.write_to(&mut Cursor::new(&mut large), ImageOutputFormat::Jpeg(99))\n        .unwrap();\n    assert_eq!(&[255, 216], &large[..2]);\n\n    assert!(large.len() > default.len());\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::not_decl", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn not_decl() {\n    let source = r#\"\n    void foo() {\n        int x;\n        bar(x);\n      }\n    \"#;\n\n    let needle = \"{\n        not: {int x;}\n        bar(x);\n    }\";\n\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 0);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::type_variable", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn type_variable() {\n    let needle = \"{$t $a = 3; $t foo = $a;}\";\n    let source =\n        \"void foo(){int bar = 3; int foo = bar; unsigned short foo = bar; char *ptr =foo;}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_assert", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_assert() {\n    let sql = \"ASSERT (SELECT COUNT(*) FROM my_table) > 0\";\n    let ast = one_statement_parses_to(sql, \"ASSERT (SELECT COUNT(*) FROM my_table) > 0\");\n    match ast {\n        Statement::Assert {\n            condition: _condition,\n            message,\n        } => {\n            assert_eq!(message, None);\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_backup_numbering", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_backup_numbering() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_backup_numbering\";\n    let link = \"test_symlink_backup_numbering_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-s\", \"--backup=t\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}.~1~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_strict_calls", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn test_strict_calls() {\n    let needle = \"{strict: free(a);}\";\n    let source = r\"\n    void func(){\n        free(a); // match\n        foo::free(a); // no match\n        x->free(a); // no match\n        if (free(a)==0) { // only match for second needle\n            nop;\n        }\n\n        if (x::free(a)==0) { // no match\n            nop;\n        }\n    }\";\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n\n    let needle = \"{strict: _(free(a));}\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::version", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn version() {\n    new_ucmd!().args(&[\"--version\"]).succeeds();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_timeout_query_tcp", "code": "fn test_timeout_query(mut client: AsyncClient, io_loop: Runtime) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n\n    let err = io_loop\n        .block_on(client.query(name.clone(), DNSClass::IN, RecordType::A))\n        .unwrap_err();\n\n    println!(\"got error: {err:?}\");\n    if let ClientErrorKind::Timeout = err.kind() {\n    } else {\n        panic!(\"expected timeout error\");\n    }\n\n    io_loop\n        .block_on(client.query(name, DNSClass::IN, RecordType::AAAA))\n        .unwrap_err();\n\n    // test that we don't have any thing funky with registering new timeouts, etc...\n    //   it would be cool if we could maintain a different error here, but shutdown is probably ok.\n    //\n    // match err.kind() {\n    //     &ClientErrorKind::Timeout => (),\n    //     e @ _ => assert!(false, format!(\"something else: {}\", e)),\n    // }\n}", "test": "fn test_timeout_query_tcp() {\n    use std::time::Duration;\n\n    let addr: SocketAddr = (\"203.0.113.0\", 53)\n        .to_socket_addrs()\n        .unwrap()\n        .next()\n        .unwrap();\n\n    // TODO: need to add timeout length to SyncClient\n    let client =\n        SyncClient::new(TcpClientConnection::with_timeout(addr, Duration::from_millis(1)).unwrap());\n    test_timeout_query(client);\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_reserve", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "test": "fn TinyVec_try_reserve() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve(2).is_ok());\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve(4).is_ok());\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  assert!(tv.try_reserve(4).is_ok());\n  assert!(tv.capacity() >= 10);\n}"}
{"test_id": "image-rs-image-gif/image-rs-image-gif-80fd8c0/tests/stall.rs::try_decode_crash_regression", "code": "fn decode_on_timer(data: Vec<u8>) {\n    let (send, recv) = mpsc::channel();\n\n    thread::spawn(move || {\n        let result = decode(&data);\n        send.send(result).expect(\"still waiting\");\n    });\n\n    let _ = recv.recv_timeout(Duration::from_secs(1))\n        .expect(\"any result\");\n}", "test": "fn try_decode_crash_regression() {\n    let files = fs::read_dir(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/tests/stall\")).unwrap();\n\n    for entry in files {\n        let entry = entry.unwrap();\n        if let Some(ext) = entry.path().extension() {\n            if ext.to_str() != Some(\"gif\") {\n                panic!(\"Unexpected file {} in crashtests, should end with .gif\", entry.path().display());\n            }\n        } else {\n            panic!(\"Unexpected file {} in crashtests, should end with .gif\", entry.path().display());\n        }\n\n        let file_data = fs::read(entry.path()).unwrap();\n        let _ = decode_on_timer(file_data);\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_css_parser/tests/spec_test.rs::quick_test", "code": "pub fn has_bogus_nodes_or_empty_slots(node: &JsSyntaxNode) -> bool {\n    node.descendants().any(|descendant| {\n        let kind = descendant.kind();\n        if kind.is_bogus() {\n            return true;\n        }\n\n        if kind.is_list() {\n            return descendant\n                .slots()\n                .any(|slot| matches!(slot, SyntaxSlot::Empty));\n        }\n\n        false\n    })\n}", "test": "pub fn quick_test() {\n    let code = r#\"::part(sample) {}\"#;\n    let root = parse_css(code, CssParserOptions::default());\n    let syntax = root.syntax();\n    dbg!(&syntax, root.diagnostics(), root.has_errors());\n\n    if has_bogus_nodes_or_empty_slots(&syntax) {\n        panic!(\n            \"modified tree has bogus nodes or empty slots:\\n{syntax:#?} \\n\\n {}\",\n            syntax\n        )\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_tab", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_tab() {\n    new_ucmd!()\n        .arg(\"-w8\")\n        .pipe_in(\"a\\tbbb\\n\")\n        .succeeds()\n        .stdout_is(\"a\\t\\nbbb\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nl_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\n\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n\")\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_split_region.rs::test_meta_inconsistency", "code": "pub fn must_put(&mut self, key: &[u8], value: &[u8]) {\n        self.must_put_cf(CF_DEFAULT, key, value);\n    }", "test": "fn test_meta_inconsistency() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    cluster.cfg.raft_store.store_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    cluster.cfg.raft_store.apply_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.hibernate_regions = false;\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Add new peer on node 3, its snapshot apply is paused.\n    fail::cfg(\"before_set_region_on_peer_3\", \"pause\").unwrap();\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n\n    // Let only heartbeat msg to pass so a replicate peer could be created on node 3\n    // for peer 1003.\n    let region_packet_filter_region_1000_peer_1003 =\n        RegionPacketFilter::new(1000, 3).skip(MessageType::MsgHeartbeat);\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(3, Box::new(region_packet_filter_region_1000_peer_1003));\n\n    // Trigger a region split to create region 1000 with peer 1001, 1002 and 1003.\n    let region = cluster.get_region(b\"\");\n    cluster.must_split(&region, b\"k5\");\n\n    // Scheduler a larger peed id heartbeat msg to trigger peer destroy for peer\n    // 1003, pause it before the meta.lock operation so new region insertions by\n    // region split could go first.\n    // Thus a inconsistency could happen because the destroy is handled\n    // by a uninitialized peer but the new initialized region info is inserted into\n    // the meta by region split.\n    fail::cfg(\"before_destroy_peer_on_peer_1003\", \"pause\").unwrap();\n    let new_region = cluster.get_region(b\"k4\");\n    let mut larger_id_msg = Box::<RaftMessage>::default();\n    larger_id_msg.set_region_id(1000);\n    larger_id_msg.set_to_peer(new_peer(3, 1113));\n    larger_id_msg.set_region_epoch(new_region.get_region_epoch().clone());\n    larger_id_msg\n        .mut_region_epoch()\n        .set_conf_ver(new_region.get_region_epoch().get_conf_ver() + 1);\n    larger_id_msg.set_from_peer(new_peer(1, 1001));\n    let raft_message = larger_id_msg.mut_message();\n    raft_message.set_msg_type(MessageType::MsgHeartbeat);\n    raft_message.set_from(1001);\n    raft_message.set_to(1113);\n    raft_message.set_term(6);\n    cluster.sim.wl().send_raft_msg(*larger_id_msg).unwrap();\n    thread::sleep(Duration::from_millis(500));\n\n    // Let snapshot apply continue on peer 3 from region 0, then region split would\n    // be applied too.\n    fail::remove(\"before_set_region_on_peer_3\");\n    thread::sleep(Duration::from_millis(2000));\n\n    // Let self destroy continue after the region split is finished.\n    fail::remove(\"before_destroy_peer_on_peer_1003\");\n    sleep_ms(1000);\n\n    // Clear the network partition nemesis, trigger a new region split, panic would\n    // be encountered The thread 'raftstore-3-1::test_message_order_3' panicked\n    // at 'meta corrupted: no region for 1000 7A6B35 when creating 1004\n    // region_id: 1004 from_peer { id: 1005 store_id: 1 } to_peer { id: 1007\n    // store_id: 3 } message { msg_type: MsgRequestPreVote to: 1007 from: 1005\n    // term: 6 log_term: 5 index: 5 commit: 5 commit_term: 5 } region_epoch {\n    // conf_ver: 3 version: 3 } end_key: 6B32'.\n    cluster.sim.wl().clear_recv_filters(3);\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    cluster.must_put(b\"k1\", b\"v1\");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::class_cpp", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn class_cpp() {\n    let source = r#\"\n    class Foo {\n    void foo() {\n        x = 10;\n    }};\"#;\n\n    let needle = \"_ $func() {$x=_;}\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_cp_arg_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"--symbolic-link\")\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    assert!(at.is_symlink(TEST_HELLO_WORLD_DEST));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_shortened_long_argument", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_shortened_long_argument() {\n    new_ucmd!().arg(\"--a\").succeeds();\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::set_comprehension", "code": "fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n}", "test": "fn set_comprehension() {\n    let source = \"{x for x in numbers}\";\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_output_simple", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_output_simple() {\n    new_ucmd!()\n        .args(&[\"alpha.txt\"])\n        .succeeds()\n        .stdout_only(\"abcde\\nfghij\\nklmno\\npqrst\\nuvwxyz\\n\"); // spell-checker:disable-line\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_prompts_order", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_force_prompts_order() {\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let empty_file = \"empty\";\n\n    at.touch(empty_file);\n\n    // This should cause rm to prompt to remove regular empty file\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-fi\")\n        .arg(empty_file)\n        .run_no_wait();\n    child.try_write_in(yes.as_bytes()).unwrap();\n\n    let result = child.wait().unwrap();\n    result.stderr_only(\"rm: remove regular empty file 'empty'? \");\n\n    assert!(!at.file_exists(empty_file));\n\n    at.touch(empty_file);\n\n    // This should not cause rm to prompt to remove regular empty file\n    scene\n        .ucmd()\n        .arg(\"-if\")\n        .arg(empty_file)\n        .succeeds()\n        .no_stderr();\n    assert!(!at.file_exists(empty_file));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/pessimistic_txn.rs::test_lock_manager_cfg_update", "code": "pub fn as_millis(&self) -> u64 {\n        crate::time::duration_to_ms(self.0)\n    }", "test": "fn test_lock_manager_cfg_update() {\n    const DEFAULT_TIMEOUT: u64 = 3000;\n    const DEFAULT_DELAY: u64 = 100;\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.pessimistic_txn.wait_for_lock_timeout = ReadableDuration::millis(DEFAULT_TIMEOUT);\n    cfg.pessimistic_txn.wake_up_delay_duration = ReadableDuration::millis(DEFAULT_DELAY);\n    cfg.pessimistic_txn.pipelined = false;\n    cfg.pessimistic_txn.in_memory = false;\n    cfg.validate().unwrap();\n    let (cfg_controller, waiter, deadlock, mut lock_mgr) = setup(cfg);\n\n    // update of other module's config should not effect lock manager config\n    cfg_controller\n        .update_config(\"raftstore.raft-log-gc-threshold\", \"2000\")\n        .unwrap();\n    validate_waiter(&waiter, move |timeout: ReadableDuration| {\n        assert_eq!(timeout.as_millis(), DEFAULT_TIMEOUT);\n    });\n    validate_dead_lock(&deadlock, move |ttl: u64| {\n        assert_eq!(ttl, DEFAULT_TIMEOUT);\n    });\n\n    // only update wait_for_lock_timeout\n    cfg_controller\n        .update_config(\"pessimistic-txn.wait-for-lock-timeout\", \"4000ms\")\n        .unwrap();\n    validate_waiter(&waiter, move |timeout: ReadableDuration| {\n        assert_eq!(timeout.as_millis(), 4000);\n    });\n    validate_dead_lock(&deadlock, move |ttl: u64| {\n        assert_eq!(ttl, 4000);\n    });\n\n    // update pipelined\n    assert!(\n        !lock_mgr\n            .get_storage_dynamic_configs()\n            .pipelined_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.pipelined\", \"true\")\n        .unwrap();\n    assert!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .pipelined_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n\n    // update in-memory\n    assert!(\n        !lock_mgr\n            .get_storage_dynamic_configs()\n            .in_memory_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.in-memory\", \"true\")\n        .unwrap();\n    assert!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .in_memory_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n\n    // update wake-up-delay-duration\n    assert_eq!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .wake_up_delay_duration_ms\n            .load(Ordering::SeqCst),\n        DEFAULT_DELAY\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.wake-up-delay-duration\", \"500ms\")\n        .unwrap();\n    assert_eq!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .wake_up_delay_duration_ms\n            .load(Ordering::SeqCst),\n        500\n    );\n\n    lock_mgr.stop();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::skip_private_recipes", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn skip_private_recipes() {\n  Test::new()\n    .arg(\"--choose\")\n    .env(\"JUST_CHOOSER\", \"head -n1\")\n    .justfile(\n      \"\n        foo:\n          echo foo\n\n        _bar:\n          echo bar\n      \",\n    )\n    .stderr(\"echo foo\\n\")\n    .stdout(\"foo\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_with_t", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_numbered_with_t() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=t\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_parenthesized_literal", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_parenthesized_literal() {\n    let scenario = TestScenario::new(util_name!());\n    let tests = [\n        \"a string\",\n        \"(\",\n        \")\",\n        \"-\",\n        \"--\",\n        \"-0\",\n        \"-f\",\n        \"--help\",\n        \"--version\",\n        \"-e\",\n        \"-t\",\n        \"!\",\n        \"-n\",\n        \"-z\",\n        \"[\",\n        \"-a\",\n        \"-o\",\n    ];\n\n    for test in &tests {\n        scenario.ucmd().arg(\"(\").arg(test).arg(\")\").succeeds();\n    }\n\n    // run the inverse of all these tests\n    for test in &tests {\n        scenario\n            .ucmd()\n            .arg(\"!\")\n            .arg(\"(\")\n            .arg(test)\n            .arg(\")\")\n            .run()\n            .code_is(1);\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::while_loop_early_break", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn while_loop_early_break() {\n    // Ordering with statements after the break.\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 1;\n            while (a < 5) {\n                if (a == 3) {\n                    break;\n                }\n                a++;\n            }\n            a;\n        \"#},\n        3,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_semicolon_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \";\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_cluster_version", "code": "pub fn can_enable(&self, feature: Feature) -> bool {\n        self.version.load(Ordering::Relaxed) >= feature.ver\n    }", "test": "fn test_cluster_version() {\n    let server = MockServer::<Service>::new(3);\n    let eps = server.bind_addrs();\n\n    let feature_a = Feature::require(0, 0, 1);\n    let feature_b = Feature::require(5, 0, 0);\n    let feature_c = Feature::require(5, 0, 1);\n\n    let client = new_client(eps, None);\n    let feature_gate = client.feature_gate();\n    assert!(!feature_gate.can_enable(feature_a));\n\n    let emit_heartbeat = || {\n        let req = pdpb::StoreStats::default();\n        block_on(client.store_heartbeat(req, /* store_report= */ None, None)).unwrap();\n    };\n\n    let set_cluster_version = |version: &str| {\n        let h = server.default_handler();\n        h.set_cluster_version(version.to_owned());\n    };\n\n    // Empty version string will be treated as invalid.\n    emit_heartbeat();\n    assert!(!feature_gate.can_enable(feature_a));\n\n    // Explicitly invalid version string.\n    set_cluster_version(\"invalid-version\");\n    emit_heartbeat();\n    assert!(!feature_gate.can_enable(feature_a));\n\n    // Correct version string.\n    set_cluster_version(\"5.0.0\");\n    emit_heartbeat();\n    assert!(feature_gate.can_enable(feature_a));\n    assert!(feature_gate.can_enable(feature_b));\n    assert!(!feature_gate.can_enable(feature_c));\n\n    // Version can't go backwards.\n    set_cluster_version(\"4.99\");\n    emit_heartbeat();\n    assert!(feature_gate.can_enable(feature_b));\n    assert!(!feature_gate.can_enable(feature_c));\n\n    // After reconnect the version should be still accessable.\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n    client.reconnect().unwrap();\n    assert!(feature_gate.can_enable(feature_b));\n    assert!(!feature_gate.can_enable(feature_c));\n\n    // Version can go forwards.\n    set_cluster_version(\"5.0.1\");\n    emit_heartbeat();\n    assert!(feature_gate.can_enable(feature_c));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_finally", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch_finally() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                a = 20;\n            } catch {\n                a = 40;\n            } finally {\n                a = 30;\n            }\n\n            a;\n        \"#},\n        30,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_restart_leader_insecure", "code": "fn restart_leader(mgr: SecurityManager) {\n    let mgr = Arc::new(mgr);\n    // Service has only one GetMembersResponse, so the leader never changes.\n    let mut server =\n        MockServer::<Service>::with_configuration(&mgr, vec![(\"127.0.0.1\".to_owned(), 0); 3], None);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), Some(Arc::clone(&mgr)));\n    // Put a region.\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer);\n    client.bootstrap_cluster(store, region.clone()).unwrap();\n\n    let region = block_on(client.get_region_by_id(region.get_id()))\n        .unwrap()\n        .unwrap();\n\n    // Stop servers and restart them again.\n    server.stop();\n    server.start(&mgr, eps);\n\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let region = block_on(client.get_region_by_id(region.get_id())).unwrap();\n    assert_eq!(region.unwrap().get_id(), region_id);\n}", "test": "fn test_restart_leader_insecure() {\n    let mgr = SecurityManager::new(&SecurityConfig::default()).unwrap();\n    restart_leader(mgr)\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/lib.rs::read_icc_profile_random_order", "code": "pub fn icc_profile(&self) -> Option<Vec<u8>> {\n        let mut marker_present: [Option<&IccChunk>; 256] = [None; 256];\n        let num_markers = self.icc_markers.len();\n        if num_markers == 0 || num_markers >= 255 {\n            return None;\n        }\n        // check the validity of the markers\n        for chunk in &self.icc_markers {\n            if usize::from(chunk.num_markers) != num_markers {\n                // all the lengths must match\n                return None;\n            }\n            if chunk.seq_no == 0 {\n                return None;\n            }\n            if marker_present[usize::from(chunk.seq_no)].is_some() {\n                // duplicate seq_no\n                return None;\n            } else {\n                marker_present[usize::from(chunk.seq_no)] = Some(chunk);\n            }\n        }\n\n        // assemble them together by seq_no failing if any are missing\n        let mut data = Vec::new();\n        // seq_no's start at 1\n        for &chunk in marker_present.get(1..=num_markers)? {\n            data.extend_from_slice(&chunk?.data);\n        }\n        Some(data)\n    }", "test": "fn read_icc_profile_random_order() {\n    let path = Path::new(\"tests\")\n        .join(\"icc\")\n        .join(\"icc_chunk_order.jpeg\");\n\n    let mut decoder = jpeg::Decoder::new(File::open(&path).unwrap());\n    decoder.decode().unwrap();\n\n    let profile = decoder.icc_profile().unwrap();\n\n    assert_eq!(profile.len(), 254);\n\n    for i in 1..=254 {\n        assert_eq!(profile[i - 1], i as u8);\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_vm.rs::test_basic", "code": "pub fn simple_eval<S: serde::Serialize>(\n    instructions: &Instructions<'_>,\n    ctx: S,\n) -> Result<String, Error> {\n    let env = Environment::new();\n    let empty_blocks = BTreeMap::new();\n    let vm = Vm::new(&env);\n    let root = Value::from_serializable(&ctx);\n    let mut rv = String::new();\n    let mut output = make_string_output(&mut rv);\n    vm.eval(\n        instructions,\n        root,\n        &empty_blocks,\n        &mut output,\n        AutoEscape::None,\n    )?;\n    Ok(rv)\n}", "test": "fn test_basic() {\n    let mut user = std::collections::BTreeMap::new();\n    user.insert(\"name\", \"Peter\");\n    let mut ctx = std::collections::BTreeMap::new();\n    ctx.insert(\"user\", Value::from(user));\n    ctx.insert(\"a\", Value::from(42));\n    ctx.insert(\"b\", Value::from(23));\n\n    let mut i = Instructions::new(\"\", \"\");\n    i.add(Instruction::EmitRaw(\"Hello \"));\n    i.add(Instruction::Lookup(\"user\"));\n    i.add(Instruction::GetAttr(\"name\"));\n    i.add(Instruction::Emit);\n    i.add(Instruction::Lookup(\"a\"));\n    i.add(Instruction::Lookup(\"b\"));\n    i.add(Instruction::Add);\n    i.add(Instruction::Neg);\n    i.add(Instruction::Emit);\n\n    let output = simple_eval(&i, ctx).unwrap();\n    assert_eq!(output, \"Hello Peter-65\");\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_relative_lock_time_height", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_relative_lock_time_height() {\n    let t = relative::LockTime::from(relative::Height::from(0xCAFE_u16));\n    let got = serialize(&t).unwrap();\n\n    let want = include_bytes!(\"data/serde/relative_lock_time_blocks_bincode\") as &[_];\n    assert_eq!(got, want);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_backspace_should_decrease_column_count", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_backspace_should_decrease_column_count() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"1\\x08345\")\n        .succeeds()\n        .stdout_is(\"1\\x0834\\n5\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_count", "code": "fn count(&self) -> usize {\n        panic!()\n    }", "test": "fn write_batch_count() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert_eq!(wb.count(), 0);\n    wb.put(b\"a\", b\"\").unwrap();\n    assert_eq!(wb.count(), 1);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 1);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    assert_eq!(wb.count(), 0);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    assert_eq!(wb.count(), 256);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 256);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_commit_illegal_tso", "code": "pub fn commit_with_illegal_tso(\n        &self,\n        keys: Vec<&[u8]>,\n        start_ts: impl Into<TimeStamp>,\n        commit_ts: impl Into<TimeStamp>,\n    ) {\n        let start_ts = start_ts.into();\n        let commit_ts = commit_ts.into();\n        let keys: Vec<Key> = keys.iter().map(|x| Key::from_raw(x)).collect();\n        let resp = self\n            .store\n            .commit(self.ctx.clone(), keys, start_ts, commit_ts);\n        self.expect_invalid_tso_err(resp, start_ts, commit_ts);\n    }", "test": "fn test_txn_store_commit_illegal_tso() {\n    let store = AssertionStorage::default();\n    let commit_ts = 4;\n    let start_ts = 5;\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"p-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n        ],\n        b\"primary\",\n        start_ts,\n    );\n\n    store.commit_with_illegal_tso(vec![b\"primary\"], start_ts, commit_ts);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_style_parse_errors", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn indent_style_parse_errors() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-style\"), (\"invalid\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_style_parse_errors\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::shl_bits_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn shl_bits_test() {\n    let mut x = VecType::from_u64(0xD2210408);\n    bigint::shl_bits(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x44208100, 0x1A]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_negative_zero_bytes", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_negative_zero_bytes() {\n    new_ucmd!()\n        .args(&[\"--bytes=-0\"])\n        .pipe_in(\"qwerty\")\n        .succeeds()\n        .stdout_is(\"qwerty\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_option", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_output_option() {\n    new_ucmd!().arg(\"--output\").succeeds();\n    new_ucmd!().arg(\"--output=source,target\").succeeds();\n    new_ucmd!().arg(\"--output=invalid_option\").fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replica_read.rs::test_read_hibernated_region", "code": "pub fn has_not_leader(&self) -> bool {\n        self.not_leader.is_some()\n    }", "test": "fn test_read_hibernated_region() {\n    let mut cluster = new_node_cluster(0, 3);\n    // Initialize the cluster.\n    configure_for_lease_read(&mut cluster.cfg, Some(100), Some(8));\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(Duration::from_millis(1));\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n    cluster.pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    let p2 = new_peer(2, 2);\n    cluster.pd_client.must_add_peer(r1, p2.clone());\n    let p3 = new_peer(3, 3);\n    cluster.pd_client.must_add_peer(r1, p3.clone());\n    cluster.must_put(b\"k0\", b\"v0\");\n    let region = cluster.get_region(b\"k0\");\n    cluster.must_transfer_leader(region.get_id(), p3);\n    // Make sure leader writes the data.\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n    // Wait for region is hibernated.\n    thread::sleep(Duration::from_secs(1));\n    cluster.stop_node(2);\n    cluster.run_node(2).unwrap();\n\n    let store2_sent_msgs = Arc::new(Mutex::new(Vec::new()));\n    let filter = Box::new(\n        RegionPacketFilter::new(1, 2)\n            .direction(Direction::Send)\n            .reserve_dropped(Arc::clone(&store2_sent_msgs)),\n    );\n    cluster.sim.wl().add_send_filter(2, filter);\n    cluster.pd_client.trigger_leader_info_loss();\n    // This request will fail because no valid leader.\n    let resp1_ch = async_read_on_peer(&mut cluster, p2.clone(), region.clone(), b\"k1\", true, true);\n    let resp1 = block_on_timeout(resp1_ch, Duration::from_secs(5)).unwrap();\n    assert!(\n        resp1.get_header().get_error().has_not_leader(),\n        \"{:?}\",\n        resp1.get_header()\n    );\n    thread::sleep(Duration::from_millis(300));\n    cluster.sim.wl().clear_send_filters(2);\n    let mut has_extra_message = false;\n    for msg in std::mem::take(&mut *store2_sent_msgs.lock().unwrap()) {\n        let to_store = msg.get_to_peer().get_store_id();\n        assert_ne!(to_store, 0, \"{:?}\", msg);\n        if to_store == 3 && msg.has_extra_msg() {\n            has_extra_message = true;\n        }\n        let router = cluster.sim.wl().get_router(to_store).unwrap();\n        router.send_raft_message(msg).unwrap();\n    }\n    // Had a wakeup message from 2 to 3.\n    assert!(has_extra_message);\n    // Wait for the leader is woken up.\n    thread::sleep(Duration::from_millis(500));\n    let resp2_ch = async_read_on_peer(&mut cluster, p2, region, b\"k1\", true, true);\n    let resp2 = block_on_timeout(resp2_ch, Duration::from_secs(5)).unwrap();\n    assert!(!resp2.get_header().has_error(), \"{:?}\", resp2);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/errors.rs::test_fuzzer_input_2", "code": "fn parse(md: &str) {\n    let parser = Parser::new(md);\n\n    for _ in parser {}\n}", "test": "fn test_fuzzer_input_2() {\n    parse(\" \\u{b}\\\\\\r- \");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::print", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn print() {\n    new_ucmd!().succeeds();\n\n    for flag in [\"-c\", \"--compute\"] {\n        new_ucmd!().arg(flag).succeeds();\n    }\n\n    for flag in [\n        \"-t\", \"--type\", \"-u\", \"--user\", \"-r\", \"--role\", \"-l\", \"--range\",\n    ] {\n        new_ucmd!().args(&[flag, \"example\"]).succeeds();\n        new_ucmd!().args(&[flag, \"example1,example2\"]).succeeds();\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::assignmentoperator_rhs_throws_error", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn assignmentoperator_rhs_throws_error() {\n    run_test_actions([TestAction::assert_native_error(\n        \"let a; a += b\",\n        JsNativeErrorKind::Reference,\n        \"b is not defined\",\n    )]);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_3() {\n    let original = r##\"Songs that simply loop are a popular way to annoy people. [^examples]\n\n[^examples]:\n * [The song that never ends](https://www.youtube.com/watch?v=0U2zJOryHKQ)\n * [I know a song that gets on everybody's nerves](https://www.youtube.com/watch?v=TehWI09qxls)\n * [Ninety-nine bottles of beer on the wall](https://www.youtube.com/watch?v=qVjCag8XoHQ)\n\"##;\n    let expected = r##\"<p>Songs that simply loop are a popular way to annoy people. <sup class=\"footnote-reference\"><a href=\"#examples\">1</a></sup></p>\n<div class=\"footnote-definition\" id=\"examples\"><sup class=\"footnote-definition-label\">1</sup>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=0U2zJOryHKQ\">The song that never ends</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=TehWI09qxls\">I know a song that gets on everybody's nerves</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=qVjCag8XoHQ\">Ninety-nine bottles of beer on the wall</a></li>\n</ul>\n</div>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_many_types_works", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "test": "fn static_many_types_works() {\n    let mut store = test_setup();\n    // Function taking no arguments and returning 16 results as tuple (maximum).\n    let func = Func::wrap(\n        &mut store,\n        |v0: i32, v1: u32, v2: i64, v3: u64, v4: F32, v5: F64| (v0, v1, v2, v3, v4, v5),\n    );\n    let typed_func = func\n        .typed::<(i32, u32, i64, u64, F32, F64), (i32, u32, i64, u64, F32, F64)>(&mut store)\n        .unwrap();\n    let inputs = (0, 1, 2, 3, 4.0.into(), 5.0.into());\n    let result = typed_func.call(&mut store, inputs).unwrap();\n    assert_eq!(result, inputs);\n}"}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/issues.rs::issue_655", "code": "fn twolines(i: Partial<&str>) -> IResult<Partial<&str>, (&str, &str)> {\n        let (i, l1) = not_line_ending.parse_peek(i)?;\n        let (i, _) = line_ending.parse_peek(i)?;\n        let (i, l2) = not_line_ending.parse_peek(i)?;\n        let (i, _) = line_ending.parse_peek(i)?;\n\n        Ok((i, (l1, l2)))\n    }", "test": "fn issue_655() {\n    use winnow::ascii::{line_ending, not_line_ending};\n    fn twolines(i: Partial<&str>) -> IResult<Partial<&str>, (&str, &str)> {\n        let (i, l1) = not_line_ending.parse_peek(i)?;\n        let (i, _) = line_ending.parse_peek(i)?;\n        let (i, l2) = not_line_ending.parse_peek(i)?;\n        let (i, _) = line_ending.parse_peek(i)?;\n\n        Ok((i, (l1, l2)))\n    }\n\n    assert_eq!(\n        twolines(Partial::new(\"foo\\nbar\\n\")),\n        Ok((Partial::new(\"\"), (\"foo\", \"bar\")))\n    );\n    assert_eq!(\n        twolines(Partial::new(\"f\u00e9o\\nbar\\n\")),\n        Ok((Partial::new(\"\"), (\"f\u00e9o\", \"bar\")))\n    );\n    assert_eq!(\n        twolines(Partial::new(\"fo\u00e9\\nbar\\n\")),\n        Ok((Partial::new(\"\"), (\"fo\u00e9\", \"bar\")))\n    );\n    assert_eq!(\n        twolines(Partial::new(\"fo\u00e9\\r\\nbar\\n\")),\n        Ok((Partial::new(\"\"), (\"fo\u00e9\", \"bar\")))\n    );\n}\n\n#[cf"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_b_roundtrip", "code": "fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n}", "test": "fn test_adjacently_b_roundtrip() {\n    let v = EnumStructAdjacently::VariantB { foo: 1, bar: 2 };\n    test_roundtrip(v);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_nonprinting_and_tabs", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_nonprinting_and_tabs() {\n    new_ucmd!()\n        .args(&[\"-t\"])\n        .pipe_in(\"\\t\\0\\n\")\n        .succeeds()\n        .stdout_only(\"^I^@\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::while_loop_continue", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn while_loop_continue() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var i = 0, a = 0, b = 0;\n                while (i < 3) {\n                    i++;\n                    if (i < 2) {\n                        a++;\n                        continue;\n                    }\n                    b++;\n                }\n            \"#}),\n        TestAction::assert_eq(\"a\", 1),\n        TestAction::assert_eq(\"b\", 2),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_preserve_empty_line_and_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_preserve_empty_line_and_final_newline() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-b\"])\n        .pipe_in(\"12\\n\\n34\\n\")\n        .succeeds()\n        .stdout_is(\"12\\n\\n34\\n\");\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_new", "code": "pub(crate) fn is_empty(&self) -> bool {\n        // `cmp rdi, -1` -- basically: `repr as i64 == -1`\n        let empty = Self::empty();\n        let is_empty = self.head == empty.head && self.tail == empty.tail;\n        // The empty representation does nothing on Drop. We can't let this one\n        // drop normally because `impl Drop for Identifier` calls is_empty; that\n        // would be an infinite recursion.\n        mem::forget(empty);\n        is_empty\n    }", "test": "fn test_new() {\n    fn test(identifier: Prerelease, expected: &str) {\n        assert_eq!(identifier.is_empty(), expected.is_empty());\n        assert_eq!(identifier.len(), expected.len());\n        assert_eq!(identifier.as_str(), expected);\n        assert_eq!(identifier, identifier);\n        assert_eq!(identifier, identifier.clone());\n    }\n\n    let ref mut string = String::new();\n    let limit = if cfg!(miri) { 40 } else { 280 }; // miri is slow\n    for _ in 0..limit {\n        test(prerelease(string), string);\n        string.push('1');\n    }\n\n    if !cfg!(miri) {\n        let ref string = string.repeat(20000);\n        test(prerelease(string), string);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_issue_3780", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_date_issue_3780() {\n    new_ucmd!().arg(\"+%Y-%m-%d %H-%M-%S%:::z\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_directory", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_existing_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_existing_dir\";\n    let link = \"test_symlink_existing_dir_link\";\n\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", dir, link]).succeeds().no_stderr();\n    assert!(at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/regression.rs::regression_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn regression_test_1() {\n    let original = r##\"<details><summary>Testing 1..2..3..</summary>\n\nThis is a test of the details element.\n\n</details>\n\"##;\n    let expected = r##\"<details><summary>Testing 1..2..3..</summary>\n<p>This is a test of the details element.</p>\n</details>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::array", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn array() {\n    test_formatting(\n        r#\"\n            let a = [1, 2, 3, \"words\", \"more words\"];\n            let b = [];\n            \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_time", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_du_time() {\n    let ts = TestScenario::new(util_name!());\n\n    // du --time formats the timestamp according to the local timezone. We set the TZ\n    // environment variable to UTC in the commands below to ensure consistent outputs\n    // and test results regardless of the timezone of the machine this test runs in.\n\n    ts.ccmd(\"touch\")\n        .env(\"TZ\", \"UTC\")\n        .arg(\"-a\")\n        .arg(\"-t\")\n        .arg(\"201505150000\")\n        .arg(\"date_test\")\n        .succeeds();\n\n    ts.ccmd(\"touch\")\n        .env(\"TZ\", \"UTC\")\n        .arg(\"-m\")\n        .arg(\"-t\")\n        .arg(\"201606160000\")\n        .arg(\"date_test\")\n        .succeeds();\n\n    let result = ts\n        .ucmd()\n        .env(\"TZ\", \"UTC\")\n        .arg(\"--time\")\n        .arg(\"date_test\")\n        .succeeds();\n    result.stdout_only(\"0\\t2016-06-16 00:00\\tdate_test\\n\");\n\n    let result = ts\n        .ucmd()\n        .env(\"TZ\", \"UTC\")\n        .arg(\"--time=atime\")\n        .arg(\"date_test\")\n        .succeeds();\n    result.stdout_only(\"0\\t2015-05-15 00:00\\tdate_test\\n\");\n\n    let result = ts\n        .ucmd()\n        .env(\"TZ\", \"UTC\")\n        .arg(\"--time=ctime\")\n        .arg(\"date_test\")\n        .succeeds();\n    result.stdout_only(\"0\\t2016-06-16 00:00\\tdate_test\\n\");\n\n    if birth_supported() {\n        use regex::Regex;\n\n        let re_birth =\n            Regex::new(r\"0\\t[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}\\tdate_test\").unwrap();\n        let result = ts.ucmd().arg(\"--time=birth\").arg(\"date_test\").succeeds();\n        result.stdout_matches(&re_birth);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_stale_learner", "code": "pub fn get_state(&self) -> Arc<AtomicCell<DownstreamState>> {\n        self.state.clone()\n    }", "test": "fn test_stale_learner() {\n    let mut cluster = new_server_cluster(0, 4);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 5;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(40);\n    cluster.cfg.raft_store.max_leader_missing_duration = ReadableDuration::millis(150);\n    cluster.cfg.raft_store.abnormal_leader_missing_duration = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration::millis(100);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_learner_peer(3, 3));\n    cluster.must_put(b\"k1\", b\"v1\");\n    let engine3 = cluster.get_engine(3);\n    must_get_equal(&engine3, b\"k1\", b\"v1\");\n\n    // And then isolate peer on store 3 from leader.\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    // Add a new peer to increase the conf version.\n    pd_client.must_add_peer(r1, new_peer(4, 4));\n\n    // It should not be deleted.\n    thread::sleep(Duration::from_millis(200));\n    must_get_equal(&engine3, b\"k1\", b\"v1\");\n\n    // Promote the learner\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    // It should not be deleted.\n    thread::sleep(Duration::from_millis(200));\n    must_get_equal(&engine3, b\"k1\", b\"v1\");\n\n    // Delete the learner\n    pd_client.must_remove_peer(r1, new_peer(3, 3));\n\n    // Check not leader should fail, all data should be removed.\n    must_get_none(&engine3, b\"k1\");\n    let state_key = keys::region_state_key(r1);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_strikethrough.rs::gfm_strikethrough_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_strikethrough_test_2() {\n    let original = r##\"This ~~has a\n\nnew paragraph~~.\n\"##;\n    let expected = r##\"<p>This ~~has a</p>\n<p>new paragraph~~.</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::test_sequence_ex2", "code": "fn read_original(source: &str) -> String {\n    source.to_string().replace(\"\\r\\n\", \"\\n\")\n}", "test": "fn test_sequence_ex2() {\n    let file = include_str!(\"preserve_sequence_ex2.ron\");\n    assert_eq!(read_original(file), make_roundtrip(file));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_region_heartbeat_term", "code": "fn get_region_last_report_term(&self, region_id: u64) -> Option<u64> {\n        self.region_last_report_term.get(&region_id).cloned()\n    }", "test": "fn test_region_heartbeat_term() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n\n    // transfer leader to (2, 2) first to make address resolve happen early.\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n    let reported_term = cluster.pd_client.get_region_last_report_term(1).unwrap();\n    assert_ne!(reported_term, 0);\n\n    // transfer leader to increase the term\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    for _ in 0..100 {\n        sleep_ms(100);\n        let reported_term_now = cluster.pd_client.get_region_last_report_term(1).unwrap();\n        if reported_term_now > reported_term {\n            return;\n        }\n    }\n    panic!(\"reported term should be updated\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_raftkv_early_error_report", "code": "pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    }", "test": "fn test_raftkv_early_error_report() {\n    let raftkv_fp = \"raftkv_early_error_report\";\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    cluster.must_split(&cluster.get_region(b\"k0\"), b\"k1\");\n\n    let env = Arc::new(Environment::new(1));\n    let mut clients: HashMap<&[u8], (Context, TikvClient)> = HashMap::default();\n    for &k in &[b\"k0\", b\"k1\"] {\n        let region = cluster.get_region(k);\n        let leader = region.get_peers()[0].clone();\n        let mut ctx = Context::default();\n        let channel = ChannelBuilder::new(env.clone())\n            .connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n        let client = TikvClient::new(channel);\n        ctx.set_region_id(region.get_id());\n        ctx.set_region_epoch(region.get_region_epoch().clone());\n        ctx.set_peer(leader);\n        clients.insert(k, (ctx, client));\n    }\n\n    // Inject error to all regions.\n    fail::cfg(raftkv_fp, \"return\").unwrap();\n    for (k, (ctx, client)) in &clients {\n        let mut put_req = RawPutRequest::default();\n        put_req.set_context(ctx.clone());\n        put_req.key = k.to_vec();\n        put_req.value = b\"v\".to_vec();\n        let put_resp = client.raw_put(&put_req).unwrap();\n        assert!(put_resp.has_region_error(), \"{:?}\", put_resp);\n        assert!(\n            put_resp.get_region_error().has_region_not_found(),\n            \"{:?}\",\n            put_resp\n        );\n        must_get_none(&cluster.get_engine(1), k);\n    }\n    fail::remove(raftkv_fp);\n\n    // Inject only one region\n    let injected_region_id = clients[b\"k0\".as_ref()].0.get_region_id();\n    fail::cfg(raftkv_fp, &format!(\"return({})\", injected_region_id)).unwrap();\n    for (k, (ctx, client)) in &clients {\n        let mut put_req = RawPutRequest::default();\n        put_req.set_context(ctx.clone());\n        put_req.key = k.to_vec();\n        put_req.value = b\"v\".to_vec();\n        let put_resp = client.raw_put(&put_req).unwrap();\n        if ctx.get_region_id() == injected_region_id {\n            assert!(put_resp.has_region_error(), \"{:?}\", put_resp);\n            assert!(\n                put_resp.get_region_error().has_region_not_found(),\n                \"{:?}\",\n                put_resp\n            );\n            must_get_none(&cluster.get_engine(1), k);\n        } else {\n            assert!(!put_resp.has_region_error(), \"{:?}\", put_resp);\n            must_get_equal(&cluster.get_engine(1), k, b\"v\");\n        }\n    }\n    fail::remove(raftkv_fp);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_newtype_struct", "code": "fn test_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_newtype_struct() {\n    #[derive(Serialize, PartialEq, Debug)]\n    struct Newtype(BTreeMap<String, i32>);\n\n    let inner = Newtype(treemap!(String::from(\"inner\") => 123));\n    let outer = treemap!(String::from(\"outer\") => to_value(&inner).unwrap());\n\n    test_encode_ok(&[(inner, r#\"{\"inner\":123}\"#)]);\n\n    test_encode_ok(&[(outer, r#\"{\"outer\":{\"inner\":123}}\"#)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_ignore_initial_slash", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_ignore_initial_slash() {\n    new_ucmd!()\n        .args(&[\"--tabs=/3\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"   a  b  c\");\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue510", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "test": "fn issue510() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(rename = \"ENTRY\")]\n    struct Entry {\n        #[serde(rename = \"CUE_V2\")]\n        cues: Option<Vec<Cue>>,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    // #[serde_with::serde_as]\n    struct Cue {\n        #[serde(rename = \"@NAME\")]\n        name: String,\n    }\n\n    let data: Entry = from_str(\n        \"\\\n        <ENTRY>\\\n            <CUE_V2 NAME='foo'></CUE_V2>\\\n            <CUE_V2 NAME='bar'></CUE_V2>\\\n        </ENTRY>\\\n    \",\n    )\n    .unwrap();\n\n    assert_eq!(\n        data,\n        Entry {\n            cues: Some(vec![\n                Cue {\n                    name: \"foo\".to_string(),\n                },\n                Cue {\n                    name: \"bar\".to_string(),\n                },\n            ]),\n        }\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_source_replace_dynamic", "code": "pub fn get_template(&self, name: &str) -> Result<Template<'_, '_>, Error> {\n        let compiled = ok!(self.templates.get(name));\n        Ok(Template::new(\n            self,\n            CompiledTemplateRef::Borrowed(compiled),\n            self.initial_auto_escape(name),\n        ))\n    }", "test": "fn test_source_replace_dynamic() {\n    let mut env = Environment::new();\n    env.add_template(\"a\", \"1\").unwrap();\n    env.add_template(\"a\", \"2\").unwrap();\n    env.set_loader(|_| Ok(None));\n    let rv = env.get_template(\"a\").unwrap().render(()).unwrap();\n    assert_eq!(rv, \"2\");\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/compilers/deterministic.rs::deterministic_table", "code": "fn compile_and_compare(wasm: &[u8]) -> Result<()> {\n    let store = Store::default();\n\n    // compile for first time\n    let module = Module::new(&store, wasm)?;\n    let first = module.serialize()?;\n\n    // compile for second time\n    let module = Module::new(&store, wasm)?;\n    let second = module.serialize()?;\n\n    assert!(first == second);\n\n    Ok(())\n}", "test": "fn deterministic_table() -> Result<()> {\n    let wasm_bytes = wat2wasm(\n        br#\"\n(module\n  (table 2 funcref)\n  (func $f1)\n  (func $f2)\n  (elem (i32.const 0) $f1 $f2))\n\"#,\n    )?;\n\n    compile_and_compare(&wasm_bytes)\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_include", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_include() {\n    assert_err_msg(\"{% include %}\", &[\"1:12\", \"expected a string\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_disk_full_for_region_follower", "code": "fn test_disk_full_follower_behaviors(usage: DiskUsage) {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // To ensure all replicas are not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fail::cfg(get_fp(usage, 2), \"return\").unwrap();\n\n    // Test followers will reject pre-transfer-leader command.\n    let epoch = cluster.get_region_epoch(1);\n    let transfer = new_admin_request(1, &epoch, new_transfer_leader_cmd(new_peer(2, 2)));\n    cluster\n        .call_command_on_leader(transfer, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(cluster.leader_of_region(1).unwrap(), new_peer(1, 1));\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    // Test leader shouldn't append entries to disk full followers.\n    let old_last_index = cluster.raft_local_state(1, 2).last_index;\n    cluster.must_put(b\"k3\", b\"v3\");\n    let new_last_index = cluster.raft_local_state(1, 2).last_index;\n    assert_eq!(old_last_index, new_last_index);\n    must_get_none(&cluster.get_engine(2), b\"k3\");\n\n    // Test followers will response votes when disk is full.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .direction(Direction::Send)\n            .msg_type(MessageType::MsgRequestVoteResponse),\n    ));\n    cluster.must_transfer_leader(1, new_peer(3, 3));\n\n    fail::remove(get_fp(usage, 2));\n}", "test": "fn test_disk_full_for_region_follower() {\n    test_disk_full_follower_behaviors(DiskUsage::AlmostFull);\n    test_disk_full_follower_behaviors(DiskUsage::AlreadyFull);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::generic_signature_lifetimes", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn generic_signature_lifetimes() {\n    fn write_key_generic<K: RedbKey>(\n        table: TableDefinition<K, &[u8]>,\n        key: K::SelfType<'_>,\n        db: &Database,\n    ) {\n        let buf = [1, 2, 3];\n        let write_txn = db.begin_write().unwrap();\n        {\n            let mut table = write_txn.open_table(table).unwrap();\n            table.insert(key, buf.as_slice()).unwrap();\n        }\n        write_txn.commit().unwrap();\n    }\n\n    fn read_key_generic<K: RedbKey>(\n        table: TableDefinition<K, &[u8]>,\n        key: K::SelfType<'_>,\n        db: &Database,\n    ) {\n        let buf = [1, 2, 3];\n        let read_txn = db.begin_read().unwrap();\n        let table = read_txn.open_table(table).unwrap();\n        assert_eq!(table.get(key).unwrap().unwrap().value(), buf);\n    }\n\n    let tmpfile = create_tempfile();\n    let db = &Database::create(tmpfile.path()).unwrap();\n    {\n        let (table, key) = (TableDefinition::<&str, _>::new(\"&str\"), \"key\");\n        write_key_generic(table, key, db);\n        read_key_generic(table, key, db);\n    }\n    {\n        let (table, key) = (TableDefinition::<(), _>::new(\"()\"), ());\n        write_key_generic(table, key, db);\n        read_key_generic(table, key, db);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_with_suffix", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_with_suffix() {\n    fn get_header(block_size: &str) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-B\", block_size, \"--output=size\"])\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(\"K\"), \"1K-blocks\");\n    assert_eq!(get_header(\"M\"), \"1M-blocks\");\n    assert_eq!(get_header(\"G\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1K\"), \"1K-blocks\");\n    assert_eq!(get_header(\"1M\"), \"1M-blocks\");\n    assert_eq!(get_header(\"1G\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1KiB\"), \"1K-blocks\");\n    assert_eq!(get_header(\"1MiB\"), \"1M-blocks\");\n    assert_eq!(get_header(\"1GiB\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1KB\"), \"1kB-blocks\");\n    assert_eq!(get_header(\"1MB\"), \"1MB-blocks\");\n    assert_eq!(get_header(\"1GB\"), \"1GB-blocks\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stateless_retry", "code": "pub fn connect(\n        &mut self,\n        config: ClientConfig,\n        remote: SocketAddr,\n        server_name: &str,\n    ) -> Result<(ConnectionHandle, Connection), ConnectError> {\n        if self.is_full() {\n            return Err(ConnectError::TooManyConnections);\n        }\n        if remote.port() == 0 || remote.ip().is_unspecified() {\n            return Err(ConnectError::InvalidRemoteAddress(remote));\n        }\n        if !self.config.supported_versions.contains(&config.version) {\n            return Err(ConnectError::UnsupportedVersion);\n        }\n\n        let remote_id = RandomConnectionIdGenerator::new(MAX_CID_SIZE).generate_cid();\n        trace!(initial_dcid = %remote_id);\n\n        let loc_cid = self.new_cid();\n        let params = TransportParameters::new(\n            &config.transport,\n            &self.config,\n            self.local_cid_generator.as_ref(),\n            loc_cid,\n            None,\n        );\n        let tls = config\n            .crypto\n            .start_session(config.version, server_name, &params)?;\n\n        let (ch, conn) = self.add_connection(\n            config.version,\n            remote_id,\n            loc_cid,\n            remote_id,\n            FourTuple {\n                remote,\n                local_ip: None,\n            },\n            Instant::now(),\n            tls,\n            None,\n            config.transport,\n        );\n        Ok((ch, conn))\n    }", "test": "fn stateless_retry() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig {\n            use_retry: true,\n            ..server_config()\n        },\n    );\n    pair.connect();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_stdin_stdout_count_bytes", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_stdout_count_bytes() {\n    let input = build_ascii_block(521);\n    let mut output = String::from_utf8(input.clone()).unwrap();\n    output.truncate(256);\n    new_ucmd!()\n        .args(&[\"status=none\", \"count=256\", \"iflag=count_bytes\"])\n        .pipe_in(input)\n        .run()\n        .no_stderr()\n        .stdout_only(output);\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::error_file", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn error_file() {\n    setup();\n\n    let path = format!(\"{}/tests/errors.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"Feuil1\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Error(Div0)],\n            [Error(Name)],\n            [Error(Value)],\n            [Error(Null)],\n            [Error(Ref)],\n            [Error(Num)],\n            [Error(NA)]\n        ]\n    );\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/compilers/artifact.rs::artifact_deserialization_roundtrip", "code": "pub fn to_vec(self) -> Vec<u8> {\n        self.0.to_vec()\n    }", "test": "fn artifact_deserialization_roundtrip() {\n    // This test is included to make sure we don't break the serialized format\n    // by mistake. Otherwise, everything in this test is already tested in\n    // `artifact_serialization_roundtrip`.\n    let file_names = [\"bash.wasmu\", \"cowsay.wasmu\", \"python-3.11.3.wasmu\"];\n\n    cfg_if!(\n        if #[cfg(target_os = \"windows\")] {\n            let base_path = \"tests/compilers/wasmu/windows\";\n        } else {\n            let base_path = \"tests/compilers/wasmu/linux\";\n        }\n    );\n\n    for file_name in file_names {\n        let path = PathBuf::from(base_path).join(file_name);\n        let wasm_module_bytes = fs::read(path).unwrap();\n        let engine = Engine::default();\n        let module = unsafe { Module::deserialize(&engine, wasm_module_bytes.clone()) }.unwrap();\n        let reserialized_bytes = module.serialize().unwrap();\n        assert_eq!(wasm_module_bytes.to_vec(), reserialized_bytes);\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_handshake", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn client_complete_io_for_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    assert!(client.is_handshaking());\n    let (rdlen, wrlen) = client\n        .complete_io(&mut OtherSession::new(&mut server))\n        .unwrap();\n    assert!(rdlen > 0 && wrlen > 0);\n    assert!(!client.is_handshaking());\n    assert!(!client.wants_write());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_equal", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_too_small_line_num_equal() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"20\"])\n        .succeeds()\n        .stdout_only(\"48\\n0\\n93\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), generate(20, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_shortcut_with_too_large_size", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_tabs_shortcut_with_too_large_size() {\n    let arg = format!(\"-{}\", u128::MAX);\n    let expected_error = \"tab stop value is too large\";\n\n    new_ucmd!().arg(arg).fails().stderr_contains(expected_error);\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::xls", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn xls() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xls\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xls<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"issue2\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.), String(\"a\".to_string())],\n            [Float(2.), String(\"b\".to_string())],\n            [Float(3.), String(\"c\".to_string())]\n        ]\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_deadline_2", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_deadline_2() {\n    // It should not even take any snapshots when request is outdated from the\n    // beginning.\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"rockskv_async_snapshot\", \"panic\").unwrap();\n    fail::cfg(\"deadline_check_fail\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"exceeding the deadline\"));\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_bin", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn test_bin() {\n    assert_eq!(from_str(\"0b101\"), Ok(0b101));\n    assert_eq!(from_str(\"0b001\"), Ok(0b001));\n    assert_eq!(from_str(\"0b100100\"), Ok(0b100100));\n\n    assert_eq!(\n        from_str::<u8>(\"0b\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0b_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0b111111111\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 12 },\n        })\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_fail_and_its_timeout_is_short", "code": "pub fn must_transfer_leader(&mut self, region_id: u64, leader: metapb::Peer) {\n        let timer = Instant::now();\n        loop {\n            self.reset_leader_of_region(region_id);\n            let cur_leader = self.leader_of_region(region_id);\n            if let Some(ref cur_leader) = cur_leader {\n                if cur_leader.get_id() == leader.get_id()\n                    && cur_leader.get_store_id() == leader.get_store_id()\n                {\n                    return;\n                }\n            }\n            if timer.saturating_elapsed() > Duration::from_secs(5) {\n                panic!(\n                    \"failed to transfer leader to [{}] {:?}, current leader: {:?}\",\n                    region_id, leader, cur_leader\n                );\n            }\n            self.transfer_leader(region_id, leader.clone());\n        }\n    }", "test": "fn test_when_warmup_fail_and_its_timeout_is_short() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.max_entry_cache_warmup_duration = ReadableDuration::millis(10);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_total", "code": "fn next(&mut self) -> Option<(Option<usize>, usize)> {\n        match self.max {\n            // iterate until m is reached\n            Some(m) => {\n                if self.cur == m {\n                    None\n                } else {\n                    self.cur += 1;\n                    Some((self.max, self.cur))\n                }\n            }\n            // no limit, just increment a counter\n            None => {\n                self.cur += 1;\n                Some((None, self.cur))\n            }\n        }\n    }", "test": "fn test_total() {\n    // Example output:\n    //\n    //     Filesystem            1K-blocks     Used Available Use% Mounted on\n    //     udev                    3858016        0   3858016   0% /dev\n    //     ...\n    //     /dev/loop14               63488    63488         0 100% /snap/core20/1361\n    //     total                 258775268 98099712 148220200  40% -\n    let output = new_ucmd!().arg(\"--total\").succeeds().stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    // Parse the values from the last row.\n    let last_line = lines.last().unwrap();\n    let mut iter = last_line.split_whitespace();\n    assert_eq!(iter.next().unwrap(), \"total\");\n    let reported_total_size = iter.next().unwrap().parse().unwrap();\n    let reported_total_used = iter.next().unwrap().parse().unwrap();\n    let reported_total_avail = iter.next().unwrap().parse().unwrap();\n\n    // Loop over each row except the last, computing the sum of each column.\n    let mut computed_total_size = 0;\n    let mut computed_total_used = 0;\n    let mut computed_total_avail = 0;\n    let n = lines.len();\n    for line in &lines[..n - 1] {\n        let mut iter = line.split_whitespace();\n        iter.next().unwrap();\n        computed_total_size += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_used += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_avail += iter.next().unwrap().parse::<u64>().unwrap();\n    }\n\n    // Check that the sum of each column matches the reported value in\n    // the last row.\n    assert_eq!(computed_total_size, reported_total_size);\n    assert_eq!(computed_total_used, reported_total_used);\n    assert_eq!(computed_total_avail, reported_total_avail);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_errors", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_symlink_errors() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_errors_dir\";\n    let file_a = \"test_symlink_errors_file_a\";\n    let file_b = \"test_symlink_errors_file_b\";\n\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    // $ ln -T -t a b\n    // ln: cannot combine --target-directory (-t) and --no-target-directory (-T)\n    ucmd.args(&[\"-T\", \"-t\", dir, file_a, file_b]).fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_form_feed", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_form_feed() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\f\"])\n        .succeeds()\n        .stdout_only(\"\\x0C\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_failed_incorrect_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_failed_incorrect_arg() {\n    let (_at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-s\", \"+5A\", FILE1]).fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_invalid_input", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_invalid_input() {\n    // Test if stdout/stderr for '--lines' option is correct\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: invalid number of lines: 0\");\n    scene\n        .ucmd()\n        .args(&[\"-C\", \"0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: invalid number of bytes: 0\");\n    scene\n        .ucmd()\n        .args(&[\"-b\", \"0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: invalid number of bytes: 0\");\n    scene\n        .ucmd()\n        .args(&[\"-n\", \"0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: invalid number of chunks: 0\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::stored_size", "code": "pub(crate) fn stats(&self) -> Result<BtreeStats> {\n        btree_stats(\n            self.get_root().map(|(p, _)| p),\n            self.mem,\n            K::fixed_width(),\n            V::fixed_width(),\n        )\n    }", "test": "fn stored_size() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    assert_eq!(write_txn.stats().unwrap().stored_bytes(), 10);\n    assert!(write_txn.stats().unwrap().fragmented_bytes() > 0);\n    assert!(write_txn.stats().unwrap().metadata_bytes() > 0);\n    write_txn.abort().unwrap();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_ipv4_like", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_lookup_ipv4_like() {\n    let authority = create_ip_like_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"1.2.3.4.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(Hosts::default())),\n        Some(RData::A(A::new(1, 2, 3, 4))),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        lookup.iter().next().unwrap(),\n        Ipv4Addr::new(198, 51, 100, 35)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_sync_recover_after_apply_snapshot", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_sync_recover_after_apply_snapshot() {\n    let mut cluster = prepare_cluster();\n    configure_for_snapshot(&mut cluster);\n    run_cluster(&mut cluster);\n    let region = cluster.get_region(b\"k1\");\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k2\", b\"v2\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    must_get_none(&cluster.get_engine(1), b\"k2\");\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 1);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n\n    // swith to async\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::Async, vec![]);\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 2);\n    assert_eq!(state.state, RegionReplicationState::SimpleMajority);\n\n    // Write some data to trigger snapshot.\n    for i in 10..110 {\n        let key = format!(\"k{}\", i);\n        let value = format!(\"v{}\", i);\n        cluster.must_put_cf(\"default\", key.as_bytes(), value.as_bytes());\n    }\n\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::SyncRecover, vec![]);\n    thread::sleep(Duration::from_millis(100));\n    // Add node 3 back, snapshot will apply\n    cluster.clear_send_filters();\n    cluster.must_transfer_leader(region.get_id(), new_peer(3, 3));\n    must_get_equal(&cluster.get_engine(3), b\"k100\", b\"v100\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 3);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_comma_with_plus_4", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_comma_with_plus_4() {\n    new_ucmd!()\n        .args(&[\"--tabs=1,3,+5\"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"a  b    c\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_conf_change.rs::test_unknown_peer", "code": "pub fn get_to_peer(&self) -> &super::metapb::Peer {\n        self.to_peer.as_ref().unwrap_or_else(|| super::metapb::Peer::default_instance())\n    }", "test": "fn test_unknown_peer() {\n    let cluster = Cluster::with_node_count(1, None);\n\n    let router = &cluster.routers[0];\n    let header = router.new_request_for(2).take_header();\n\n    // Create a fake message to see whether it's responded.\n    let from_peer = new_peer(10, 10);\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(2);\n    msg.set_to_peer(header.get_peer().clone());\n    msg.set_region_epoch(header.get_region_epoch().clone());\n    msg.set_from_peer(from_peer.clone());\n    let raft_message = msg.mut_message();\n    raft_message.set_msg_type(raft::prelude::MessageType::MsgHeartbeat);\n    raft_message.set_from(10);\n    raft_message.set_term(10);\n\n    router.send_raft_message(msg).unwrap();\n    router.wait_flush(2, Duration::from_secs(3));\n    // If peer cache is updated correctly, it should be able to respond.\n    let msg = cluster.receiver(0).try_recv().unwrap();\n    assert_eq!(*msg.get_to_peer(), from_peer);\n    assert_eq!(msg.get_from_peer(), header.get_peer());\n    assert_eq!(\n        msg.get_message().get_msg_type(),\n        MessageType::MsgHeartbeatResponse\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_const", "code": "pub fn add(ctx: &mut ValueMap, key: &'static str, value: Value) {\n        ctx.insert(KeyRef::Str(key), value);\n    }", "test": "fn test_const() {\n    let mut c = CodeGenerator::new(\"<unknown>\", \"\");\n\n    c.add(Instruction::LoadConst(Value::from(\"a\")));\n    c.add(Instruction::LoadConst(Value::from(42)));\n    c.add(Instruction::StringConcat);\n\n    insta::assert_debug_snapshot!(&c.finish());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_once_recursive_prompt", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_interactive_once_recursive_prompt() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_once_recursive_prompt_file1\";\n\n    at.touch(file1);\n\n    ucmd.arg(\"--interactive=once\")\n        .arg(\"-r\")\n        .arg(file1)\n        .pipe_in(\"y\")\n        .succeeds()\n        .stderr_contains(\"remove 1 argument recursively?\");\n\n    assert!(!at.file_exists(file1));\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::parse_mantissa_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn parse_mantissa_test() {\n    let max_digits = f64::MAX_DIGITS;\n\n    // Large number of digits.\n    let integer = b\"2\";\n    let fraction = b\"4703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328124999\";\n    let (bigmant, count) = slow::parse_mantissa(integer.iter(), fraction.iter(), max_digits);\n    let expected = vec_from_u32(&[\n        1727738439, 330069557, 3509095598, 686205316, 156923684, 750687444, 2688855918, 28211928,\n        1887482096, 3222998811, 913348873, 1652282845, 1600735541, 1664240266, 84454144,\n        1487769792, 1855966778, 2832488299, 507030148, 1410055467, 2513359584, 3453963205,\n        779237894, 3456088326, 3671009895, 3094451696, 1250165638, 2682979794, 357925323,\n        1713890438, 3271046672, 3485897285, 3934710962, 1813530592, 199705026, 976390839,\n        2805488572, 2194288220, 2094065006, 2592523639, 3798974617, 586957244, 1409218821,\n        3442050171, 3789534764, 1380190380, 2055222457, 3535299831, 429482276, 389342206,\n        133558576, 721875297, 3013586570, 540178306, 2389746866, 2313334501, 422440635, 1288499129,\n        864978311, 842263325, 3016323856, 2282442263, 1440906063, 3931458696, 3511314276,\n        1884879882, 946366824, 4260548261, 1073379659, 1732329252, 3828972211, 1915607049,\n        3665440937, 1844358779, 3735281178, 2646335050, 1457460927, 2940016422, 1051,\n    ]);\n    assert_eq!(&*bigmant.data, &*expected);\n    assert_eq!(count, 755);\n\n    // Truncation.\n    let integer = b\"7\";\n    let fraction = b\"4109846876186981626485318930233205854758970392148714663837852375101326090531312779794975454245398856969484704316857659638998506553390969459816219401617281718945106978546710679176872575177347315553307795408549809608457500958111373034747658096871009590975442271004757307809711118935784838675653998783503015228055934046593739791790738723868299395818481660169122019456499931289798411362062484498678713572180352209017023903285791732520220528974020802906854021606612375549983402671300035812486479041385743401875520901590172592547146296175134159774938718574737870961645638908718119841271673056017045493004705269590165763776884908267986972573366521765567941072508764337560846003984904972149117463085539556354188641513168478436313080237596295773983001708984375332669816033062329967789262837\";\n    let (bigmant, count) = slow::parse_mantissa(integer.iter(), fraction.iter(), max_digits);\n    let expected = vec_from_u32(&[\n        983641521, 2202462645, 4170685875, 1591772364, 529830014, 803977727, 126733331, 1695971390,\n        4089590927, 1532849076, 2705586665, 4046282448, 4076195232, 3230469892, 3059053929,\n        79035789, 744229654, 2026438108, 3570486781, 2818088662, 3485839733, 3653138023,\n        2857937689, 602717004, 3689362390, 283607819, 1783392475, 2053068939, 1888214698,\n        550023429, 296880187, 1046779059, 1285361259, 84614934, 1627922685, 2023868765, 1987523901,\n        743493573, 3897769089, 2210613570, 2261081349, 3015057659, 3949711644, 3346092916,\n        2433639051, 36411806, 1050442, 269209477, 2649742673, 1494221829, 2763524503, 2514491481,\n        2325312415, 1741242814, 2479923579, 1098250122, 2416211509, 3612906464, 403420662,\n        3663250314, 1993722098, 365907183, 4270226312, 3962131185, 432952495, 2963635838,\n        2996289227, 3200289391, 2753231690, 2780286109, 884373163, 1418533204, 3382415762,\n        499541562, 3369625401, 3421327641, 3526770155, 3109983188, 1157439767, 734593155,\n    ]);\n    assert_eq!(&*bigmant.data, &*expected);\n    assert_eq!(count, max_digits + 1);\n\n    // No fraction digits.\n    let integer = b\"74109846876186981626485318930233205854758970392148714663837852375101326090531312779794975454245398856969484704316857659638998506553390969459816219401617281718945106978546710679176872575177347315553307795408549809608457500958111373034747658096871009590975442271004757307809711118935784838675653998783503015228055934046593739791790738723868299395818481660169122019456499931289798411362062484498678713572180352209017023903285791732520220528974020802906854021606612375549983402671300035812486479041385743401875520901590172592547146296175134159774938718574737870961645638908718119841271673056017045493004705269590165763776884908267986972573366521765567941072508764337560846003984904972149117463085539556354188641513168478436313080237596295773983001708984375332669816033062329967789262837\";\n    let fraction = b\"\";\n    let (bigmant, count) = slow::parse_mantissa(integer.iter(), fraction.iter(), max_digits);\n    assert_eq!(&*bigmant.data, &*expected);\n    assert_eq!(count, max_digits + 1);\n\n    // Multiple of step (check we add our temporary correctly).\n    let integer = b\"7410984687618698162648531893023320585475897039214871466383785237510132609053131277979497545424539885696948470431685765963899850655339096945981621940161728171894510697854671067917687257517734731555330779540854980960845750095811137303474765809687100959097544227100475730780971111893578483867565399878350301522805593404659373979179073872386829939581848166016912201945649993128979841136206248449867871357218035220901702390328579173252022052897402080290685402160661237554998340267130003581248647904138574340187552090159017259254714629617513415977493871857473787096164563890871811984127167305601704549300470526959016576377688490826798697257336652176556794107250876433756084600398490497214911746308553955635418864151316847843631308023759629577398300170898437533266981\";\n    let fraction = b\"\";\n    let (bigmant, count) = slow::parse_mantissa(integer.iter(), fraction.iter(), max_digits);\n    let expected = vec_from_u32(&[\n        617018405, 396211401, 2130402383, 3812547827, 4263683770, 3918012496, 1787721490,\n        2493014694, 435464626, 3720854431, 2928509507, 2677932436, 369049650, 3606588290,\n        231237141, 2231172875, 3358152367, 95217925, 2777810007, 1016185079, 596681915, 2331711780,\n        593487272, 4212730845, 339602972, 4097829793, 262427536, 4182115035, 3414687403,\n        3711518952, 4168896929, 483727327, 1657080031, 2785588628, 1009114769, 482126749,\n        485376744, 1123705337, 3225501941, 2939050108, 1338451005, 2104263947, 3425461126,\n        1834224928, 4061025704, 792093815, 2707019125, 3610271203, 4254101529, 1026215278,\n        4117890107, 1748110416, 2535111606, 80965120, 3823822115, 2354910057, 590658512,\n        2682089507, 159300272, 1776569442, 3382166479, 3222978591, 540586210, 934713382,\n        2014123057, 1455555790, 4119131465, 3685912982, 3019947291, 3437891678, 2660105801,\n        2605860762, 394373515, 4177081532, 1616198650, 1580399082, 2017617452, 3327697130,\n        315505357,\n    ]);\n    assert_eq!(&*bigmant.data, &*expected);\n    assert_eq!(count, 760);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_sort_different_types", "code": "pub fn sort(state: &State, value: Value, kwargs: Kwargs) -> Result<Value, Error> {\n        let mut items = ok!(state.undefined_behavior().try_iter(value).map_err(|err| {\n            Error::new(ErrorKind::InvalidOperation, \"cannot convert value to list\").with_source(err)\n        }))\n        .collect::<Vec<_>>();\n        let case_sensitive = ok!(kwargs.get::<Option<bool>>(\"case_sensitive\")).unwrap_or(false);\n        if let Some(attr) = ok!(kwargs.get::<Option<&str>>(\"attribute\")) {\n            items.sort_by(|a, b| match (a.get_path(attr), b.get_path(attr)) {\n                (Ok(a), Ok(b)) => sort_helper(&a, &b, case_sensitive),\n                _ => Ordering::Equal,\n            });\n        } else {\n            items.sort_by(|a, b| sort_helper(a, b, case_sensitive))\n        }\n        if let Some(true) = ok!(kwargs.get(\"reverse\")) {\n            items.reverse();\n        }\n        ok!(kwargs.assert_all_used());\n        Ok(Value::from(items))\n    }", "test": "fn test_sort_different_types() {\n    let mut v = vec![\n        Value::from(100u64),\n        Value::from(\"bar\"),\n        Value::from(1),\n        Value::from_iter([1, 2]),\n        Value::from(80u32),\n        Value::from(30i16),\n        Value::from_iter([(\"a\", 3)]),\n        Value::from_iter([(\"a\", 2)]),\n        Value::from_iter([(\"b\", 0)]),\n        Value::from_iter([(\"b\", 3)]),\n        Value::from_iter([0, 2]),\n        Value::from(true),\n        Value::UNDEFINED,\n        Value::from(\"zzz\"),\n        Value::from(false),\n        Value::from(-100),\n        Value::from(-50.0f64),\n        Value::from(-75.0f32),\n        Value::from(99i128),\n        Value::from(1000f32),\n        Value::from_iter([0, 1]),\n        Value::from_iter([1, 1]),\n        Value::from(\"foo\"),\n        Value::from(()),\n        Value::from(0),\n        Value::from(-f64::INFINITY),\n        Value::from(f64::NAN),\n        Value::from(f64::INFINITY),\n    ];\n    v.sort();\n    insta::assert_debug_snapshot!(&v, @r###\"\n    [\n        undefined,\n        none,\n        -inf,\n        -100,\n        -75.0,\n        -50.0,\n        false,\n        0,\n        true,\n        1,\n        30,\n        80,\n        99,\n        100,\n        1000.0,\n        inf,\n        NaN,\n        \"bar\",\n        \"foo\",\n        \"zzz\",\n        [\n            0,\n            1,\n        ],\n        [\n            0,\n            2,\n        ],\n        [\n            1,\n            1,\n        ],\n        [\n            1,\n            2,\n        ],\n        {\n            \"a\": 2,\n        },\n        {\n            \"a\": 3,\n        },\n        {\n            \"b\": 0,\n        },\n        {\n            \"b\": 3,\n        },\n    ]\n    \"###);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_assign_commit_groups_with_migrate_region", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_assign_commit_groups_with_migrate_region() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run_conf_change();\n\n    // Split 1 region into 2 regions.\n    let region = cluster.get_region(b\"\");\n    cluster.must_split(&region, b\"k\");\n    // Put a key value pair.\n    cluster.must_put(b\"a1\", b\"v0\");\n    cluster.must_put(b\"k1\", b\"v0\");\n    let r1 = cluster.get_region(b\"k1\");\n    let r2 = cluster.get_region(b\"\");\n\n    // Add a peer of region 1 to store 2.\n    let fp1 = \"after_assign_commit_groups_on_apply_snapshot\";\n    fail::cfg(fp1, \"pause\").unwrap();\n    pd_client.add_peer(r1.get_id(), new_peer(2, 2));\n    sleep_ms(100);\n\n    // Add a peer of region 1000 to store 2.\n    let fp2 = \"after_acquire_store_meta_on_maybe_create_peer_internal\";\n    fail::cfg(fp2, \"pause\").unwrap();\n    pd_client.add_peer(r2.get_id(), new_peer(2, 1002));\n    sleep_ms(100);\n\n    // Remove failpoints.\n    fail::remove(fp1);\n    fail::remove(fp2);\n\n    // Deadlock should not happen.\n    sleep_ms(100);\n    cluster.must_region_exist(r2.get_id(), 2);\n    cluster.must_region_exist(r1.get_id(), 2);\n    // Must get the key value pair in node 2.\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v0\");\n    must_get_equal(&cluster.get_engine(2), b\"a1\", b\"v0\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_inline_block_internal_text", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_inline_block_internal_text() {\n    assert_eq!(\n        \"<u>a </u>b <u>c</u>\",\n        normalize_html(\" <u> a </u> b <u> c </u> \")\n    )\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_parse_request_failed_2", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_parse_request_failed_2() {\n    // It should not even take any snapshots when parse failed.\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"rockskv_async_snapshot\", \"panic\").unwrap();\n    fail::cfg(\"coprocessor_parse_request\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"unsupported tp\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_bootstrap.rs::test_node_switch_api_version", "code": "fn start(\n        &mut self,\n        cfg: Arc<VersionTrack<Config>>,\n        cop_cfg: Arc<VersionTrack<CopConfig>>,\n        trans: TestTransport,\n    ) -> TestRouter {\n        let (router, state) = RunningState::new(\n            &self.pd_client,\n            self.path.path(),\n            cfg,\n            cop_cfg,\n            trans,\n            ConcurrencyManager::new(1.into()),\n            None,\n            &self.logger,\n        );\n        self.running_state = Some(state);\n        router\n    }", "test": "fn test_node_switch_api_version() {\n    // V1 and V1ttl are impossible to switch between because of config check.\n    let cases = [\n        (ApiVersion::V1, ApiVersion::V1),\n        (ApiVersion::V1, ApiVersion::V2),\n        (ApiVersion::V1ttl, ApiVersion::V1ttl),\n        (ApiVersion::V1ttl, ApiVersion::V2),\n        (ApiVersion::V2, ApiVersion::V1),\n        (ApiVersion::V2, ApiVersion::V1ttl),\n        (ApiVersion::V2, ApiVersion::V2),\n    ];\n    for (from_api, to_api) in cases {\n        // With TiDB data\n        {\n            // Bootstrap with `from_api`\n            let mut cluster = new_node_cluster(0, 1);\n            cluster.cfg.storage.set_api_version(from_api);\n            cluster.start().unwrap();\n\n            // Write TiDB data\n            cluster.put(b\"m_tidb_data\", b\"\").unwrap();\n            cluster.shutdown();\n\n            // Should switch to `to_api`\n            cluster.cfg.storage.set_api_version(to_api);\n            cluster.start().unwrap();\n            cluster.shutdown();\n        }\n\n        // With non-TiDB data.\n        {\n            // Bootstrap with `from_api`\n            let mut cluster = new_node_cluster(0, 1);\n            cluster.cfg.storage.set_api_version(from_api);\n            cluster.start().unwrap();\n\n            // Write non-TiDB data\n            cluster.put(b\"k1\", b\"\").unwrap();\n            cluster.shutdown();\n\n            cluster.cfg.storage.set_api_version(to_api);\n            if from_api == to_api {\n                cluster.start().unwrap();\n                cluster.shutdown();\n            } else {\n                // Should not be able to switch to `to_api`.\n                cluster.start().unwrap_err();\n            }\n        }\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_context() {\n    let var1 = 23;\n    let ctx = context!(var1, var2 => 42);\n    assert_eq!(ctx.get_attr(\"var1\").unwrap(), Value::from(23));\n    assert_eq!(ctx.get_attr(\"var2\").unwrap(), Value::from(42));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_10", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_10() {\n    let original = r##\"# H1 { #id1 }\n## H2 {.myclass      #id2 }\n### H3 {     .myclass}\n\"##;\n    let expected = r##\"<h1 id=\"id1\">H1</h1>\n<h2 id=\"id2\" class=\"myclass\">H2</h2>\n<h3 class=\"myclass\">H3</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/regexes.rs::match_succeeds_evaluates_to_first_branch", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn match_succeeds_evaluates_to_first_branch() {\n  Test::new()\n    .justfile(\n      \"\n      foo := if 'abbbc' =~ 'ab+c' {\n        'yes'\n      } else {\n        'no'\n      }\n\n      default:\n        echo {{ foo }}\n    \",\n    )\n    .stderr(\"echo yes\\n\")\n    .stdout(\"yes\\n\")\n    .run();\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::issue_3", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn issue_3() {\n    setup();\n\n    // test if sheet is resolved with only one row\n    let path = format!(\"{}/tests/issue3.xlsm\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"Sheet1\").unwrap().unwrap();\n    range_eq!(range, [[Float(1.), String(\"a\".to_string())]]);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_a_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_internally_a_ser() {\n    let v = EnumStructInternally::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    let e = \"(type:\\\"VariantA\\\",foo:1,bar:2,different:3)\";\n    test_ser(&v, e);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_no_permissions", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_ignore_nonempty_no_permissions() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    // We make the *parent* dir read-only to prevent deleting the dir in it.\n    at.mkdir_all(\"dir/ect/ory\");\n    at.touch(\"dir/ect/ory/file\");\n    at.set_mode(\"dir/ect\", 0o555);\n\n    // rmdir should now get a permissions error that it interprets as\n    // a non-empty error.\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(\"dir/ect/ory\")\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(\"dir/ect/ory\"));\n\n    // Politely restore permissions for cleanup\n    at.set_mode(\"dir/ect\", 0o755);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_symlink_to_directory", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_trailing_slash_symlink_to_directory() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"directory\");\n    at.relative_symlink_dir(\"directory\", \"link\");\n    for query in [\"./link\", \"./link/\"] {\n        scene\n            .ucmd()\n            .args(&[\"-e\", query])\n            .succeeds()\n            .stdout_contains(\"directory\");\n    }\n    scene\n        .ucmd()\n        .args(&[\"-ev\", \"./link/more\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"No such file or directory\")\n        .no_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_effective_suffix_numeric_last", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_effective_suffix_numeric_last() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"-n\",\n        \"4\",\n        \"--numeric-suffixes=7\",\n        \"--hex-suffixes=4\",\n        \"-d\",\n        \"-x\",\n        \"--numeric-suffixes=9\",\n        \"threebytes.txt\",\n    ])\n    .succeeds()\n    .no_stdout()\n    .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x10\"), \"b\");\n    assert_eq!(at.read(\"x11\"), \"c\");\n    assert_eq!(at.read(\"x12\"), \"\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_majority_disk_full", "code": "fn disk_full_stores(resp: &RaftCmdResponse) -> Vec<u64> {\n    let region_error = resp.get_header().get_error();\n    assert!(region_error.has_disk_full());\n    let mut stores = region_error.get_disk_full().get_store_id().to_vec();\n    stores.sort_unstable();\n    stores\n}", "test": "fn test_majority_disk_full() {\n    let mut cluster = new_node_cluster(0, 3);\n    // To ensure the thread has full store disk usage infomation.\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // To ensure all replicas are not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let region = cluster.get_region(b\"k1\");\n    let epoch = region.get_region_epoch().clone();\n\n    // To ensure followers have reported disk usages to the leader.\n    for i in 1..3 {\n        fail::cfg(get_fp(DiskUsage::AlmostFull, i + 1), \"return\").unwrap();\n        ensure_disk_usage_is_reported(&mut cluster, i + 1, i + 1, &region);\n    }\n\n    // Normal proposals will be rejected because of majority peers' disk full.\n    let mut ch = cluster.async_put(b\"k2\", b\"v2\").unwrap();\n    let resp = ch.recv_timeout(Duration::from_secs(1)).unwrap();\n    assert_eq!(disk_full_stores(&resp), vec![2, 3]);\n\n    // Proposals with special `DiskFullOpt`s can be accepted even if all peers are\n    // disk full.\n    fail::cfg(get_fp(DiskUsage::AlmostFull, 1), \"return\").unwrap();\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let put = new_request(1, epoch.clone(), reqs, false);\n    let mut opts = RaftCmdExtraOpts::default();\n    opts.disk_full_opt = DiskFullOpt::AllowedOnAlmostFull;\n    let mut ch = cluster.async_request_with_opts(put, opts).unwrap();\n    let resp = ch.recv_timeout(Duration::from_secs(1)).unwrap();\n    assert!(!resp.get_header().has_error());\n\n    // Reset disk full status for peer 2 and 3. 2 follower reads must success\n    // because the leader will continue to append entries to followers after the\n    // new disk usages are reported.\n    for i in 1..3 {\n        fail::remove(get_fp(DiskUsage::AlmostFull, i + 1));\n        ensure_disk_usage_is_reported(&mut cluster, i + 1, i + 1, &region);\n        must_get_equal(&cluster.get_engine(i + 1), b\"k3\", b\"v3\");\n    }\n\n    // To ensure followers have reported disk usages to the leader.\n    for i in 1..3 {\n        fail::cfg(get_fp(DiskUsage::AlreadyFull, i + 1), \"return\").unwrap();\n        ensure_disk_usage_is_reported(&mut cluster, i + 1, i + 1, &region);\n    }\n\n    // Proposals with special `DiskFullOpt`s will still be rejected if majority\n    // peers are already disk full.\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let put = new_request(1, epoch.clone(), reqs, false);\n    let mut opts = RaftCmdExtraOpts::default();\n    opts.disk_full_opt = DiskFullOpt::AllowedOnAlmostFull;\n    let mut ch = cluster.async_request_with_opts(put, opts).unwrap();\n    let resp = ch.recv_timeout(Duration::from_secs(10)).unwrap();\n    assert_eq!(disk_full_stores(&resp), vec![2, 3]);\n\n    // Peer 2 disk usage changes from already full to almost full.\n    fail::remove(get_fp(DiskUsage::AlreadyFull, 2));\n    fail::cfg(get_fp(DiskUsage::AlmostFull, 2), \"return\").unwrap();\n    ensure_disk_usage_is_reported(&mut cluster, 2, 2, &region);\n\n    // Configuration change should be alloed.\n    cluster.pd_client.must_remove_peer(1, new_peer(2, 2));\n\n    // After the last configuration change is applied, the raft group will be like\n    // `[(1, DiskUsage::AlmostFull), (3, DiskUsage::AlreadyFull)]`. So no more\n    // proposals should be allowed.\n    let reqs = vec![new_put_cmd(b\"k4\", b\"v4\")];\n    let put = new_request(1, epoch, reqs, false);\n    let mut opts = RaftCmdExtraOpts::default();\n    opts.disk_full_opt = DiskFullOpt::AllowedOnAlmostFull;\n    let mut ch = cluster.async_request_with_opts(put, opts).unwrap();\n    let resp = ch.recv_timeout(Duration::from_secs(1)).unwrap();\n    assert_eq!(disk_full_stores(&resp), vec![3]);\n\n    for i in 0..3 {\n        fail::remove(get_fp(DiskUsage::AlreadyFull, i + 1));\n        fail::remove(get_fp(DiskUsage::AlmostFull, i + 1));\n    }\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/status_code.rs::is_client_error", "code": "fn is_client_error() {\n    assert!(status_code(400).is_client_error());\n    assert!(status_code(499).is_client_error());\n\n    assert!(!status_code(399).is_client_error());\n    assert!(!status_code(500).is_client_error());\n}", "test": "fn is_client_error() {\n    assert!(status_code(400).is_client_error());\n    assert!(status_code(499).is_client_error());\n\n    assert!(!status_code(399).is_client_error());\n    assert!(!status_code(500).is_client_error());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_life.rs::test_gc_removed_peer", "code": "pub fn get_region_id(&self) -> u64 {\n        self.region().get_id()\n    }", "test": "fn test_gc_removed_peer() {\n    let mut cluster = test_raftstore::new_node_cluster(1, 2);\n    cluster.cfg.raft_store.enable_v2_compatible_learner = true;\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let (tx, rx) = channel();\n    let tx = Mutex::new(tx);\n    let factory = ForwardFactory {\n        node_id: 1,\n        chain_send: Arc::new(move |m| {\n            if m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerResponse {\n                let _ = tx.lock().unwrap().send(m);\n            }\n        }),\n        keep_msg: true,\n    };\n    cluster.add_send_filter(factory);\n\n    let check_gc_peer = |to_peer: kvproto::metapb::Peer, timeout| -> bool {\n        let epoch = cluster.get_region_epoch(region_id);\n        let mut msg = RaftMessage::default();\n        msg.set_is_tombstone(true);\n        msg.set_region_id(region_id);\n        msg.set_from_peer(new_peer(1, 1));\n        msg.set_to_peer(to_peer.clone());\n        msg.set_region_epoch(epoch.clone());\n        let extra_msg = msg.mut_extra_msg();\n        extra_msg.set_type(ExtraMessageType::MsgGcPeerRequest);\n        let check_peer = extra_msg.mut_check_gc_peer();\n        check_peer.set_from_region_id(region_id);\n        check_peer.set_check_region_id(region_id);\n        check_peer.set_check_peer(to_peer.clone());\n        check_peer.set_check_region_epoch(epoch);\n\n        cluster.sim.wl().send_raft_msg(msg.clone()).unwrap();\n        let Ok(gc_resp) = rx.recv_timeout(timeout) else {\n            return false;\n        };\n        assert_eq!(gc_resp.get_region_id(), region_id);\n        assert_eq!(*gc_resp.get_from_peer(), to_peer);\n        true\n    };\n\n    // Mock gc a peer that has been removed before creation.\n    assert!(check_gc_peer(\n        new_learner_peer(2, 5),\n        Duration::from_secs(5)\n    ));\n\n    cluster\n        .pd_client\n        .must_add_peer(region_id, new_learner_peer(2, 4));\n    // Make sure learner is created.\n    cluster.wait_peer_state(region_id, 2, PeerState::Normal);\n\n    cluster\n        .pd_client\n        .must_remove_peer(region_id, new_learner_peer(2, 4));\n    // Make sure learner is removed.\n    cluster.wait_peer_state(region_id, 2, PeerState::Tombstone);\n\n    // Mock gc peer request. GC learner(2, 4).\n    let start = Instant::now();\n    loop {\n        if check_gc_peer(new_learner_peer(2, 4), Duration::from_millis(200)) {\n            return;\n        }\n        if start.saturating_elapsed() > Duration::from_secs(5) {\n            break;\n        }\n    }\n    assert!(check_gc_peer(\n        new_learner_peer(2, 4),\n        Duration::from_millis(200)\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_random_shuffle_len", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_random_shuffle_len() {\n    // check whether output is the same length as the input\n    const FILE: &str = \"default_unsorted_ints.expected\";\n    let (at, _ucmd) = at_and_ucmd!();\n    let result = new_ucmd!().arg(\"-R\").arg(FILE).run().stdout_move_str();\n    let expected = at.read(FILE);\n\n    assert_ne!(result, expected);\n    assert_eq!(result.len(), expected.len());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_not_a_directory", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_rmdir_not_a_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.touch(\"file\");\n\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(\"file\")\n        .fails()\n        .no_stdout()\n        .stderr_is(format!(\n            \"rmdir: failed to remove 'file': {NOT_A_DIRECTORY}\\n\"\n        ));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_for", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_for() {\n    let mut context = Context::new();\n    let mut map = BTreeMap::new();\n    map.insert(\"name\", \"bob\");\n    map.insert(\"age\", \"18\");\n\n    context.insert(\"data\", &vec![1, 2, 3]);\n    context.insert(\"notes\", &vec![1, 2, 3]);\n    context.insert(\"vectors\", &vec![vec![0, 3, 6], vec![1, 4, 7]]);\n    context.insert(\"vectors_some_empty\", &vec![vec![0, 3, 6], vec![], vec![1, 4, 7]]);\n    context.insert(\"map\", &map);\n    context.insert(\"truthy\", &2);\n\n    let inputs = vec![\n        (\"{% for i in data %}{{i}}{% endfor %}\", \"123\"),\n        (\"{% for key, val in map %}{{key}}:{{val}} {% endfor %}\", \"age:18 name:bob \"),\n        (\n            \"{% for i in data %}{{loop.index}}{{loop.index0}}{{loop.first}}{{loop.last}}{% endfor %}\",\n            \"10truefalse21falsefalse32falsetrue\"\n        ),\n        (\n            \"{% for vector in vectors %}{% for j in vector %}{{ j }}{% endfor %}{% endfor %}\",\n            \"036147\"\n        ),\n        (\n            \"{% for vector in vectors_some_empty %}{% for j in vector %}{{ j }}{% endfor %}{% endfor %}\",\n            \"036147\"\n        ),\n        (\n            \"{% for val in data %}{% if val == truthy %}on{% else %}off{% endif %}{% endfor %}\",\n            \"offonoff\"\n        ),\n        (\"{% for i in range(end=5) %}{{i}}{% endfor %}\", \"01234\"),\n        (\"{% for i in range(end=5) | reverse %}{{i}}{% endfor %}\", \"43210\"),\n        (\n            \"{% set looped = 0 %}{% for i in range(end=5) %}{% set looped = i %}{{looped}}{% endfor%}{{looped}}\",\n            \"012340\"\n        ),\n        // https://github.com/Keats/tera/issues/184\n        (\"{% for note in notes %}{{ note }}{% endfor %}\", \"123\"),\n        (\"{% for note in notes | reverse %}{{ note }}{% endfor %}\", \"321\"),\n        (\"{% for v in vectors %}{{ v.0 }}{% endfor %}\", \"01\"),\n        // Loop control (`break` and `continue`)\n        // https://github.com/Keats/tera/issues/267\n        (\n            \"{% for i in data %}{{ i }}{% if i == 2 %}{% break %}{% endif %}{% endfor %}\",\n            \"12\"\n        ),\n        (\n            \"{% for i in data %}{% if i == 2 %}{% continue %}{% endif %}{{ i }}{% endfor %}\",\n            \"13\"\n        ),\n        (\n            \"{% for v in vectors %}{% for i in v %}{% if i == 3 %}{% break %}{% endif %}{{ i }}{% endfor %}{% endfor %}\",\n            \"0147\"\n        ),\n        (\n            \"{% for v in vectors %}{% for i in v %}{% if i == 3 %}{% continue %}{% endif %}{{ i }}{% endfor %}{% endfor %}\",\n            \"06147\"\n        ),\n        (\n            \"{% for a in [1, true, 1.1, 'hello'] %}{{a}}{% endfor %}\",\n            \"1true1.1hello\"\n        ),\n        // https://github.com/Keats/tera/issues/301\n        (\n            \"{% set start = 0 %}{% set end = start + 3 %}{% for i in range(start=start, end=end) %}{{ i }}{% endfor%}\",\n            \"012\"\n        ),\n        // https://github.com/Keats/tera/issues/395\n        (\n            \"{% for a in [] %}{{a}}{% else %}hello{% endfor %}\",\n            \"hello\"\n        ),\n        (\n            \"{% for a in undefined_variable | default(value=[]) %}{{a}}{% else %}hello{% endfor %}\",\n            \"hello\"\n        ),\n        (\n            \"{% for a in [] %}{{a}}{% else %}{% if 1 == 2 %}A{% else %}B{% endif %}{% endfor %}\",\n            \"B\"\n        ),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::lint_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn lint_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_pre_handshake", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn client_respects_buffer_limit_pre_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    client.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        12\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_union_except_intersect", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_union_except_intersect() {\n    // TODO: add assertions\n    verified_stmt(\"SELECT 1 UNION SELECT 2\");\n    verified_stmt(\"SELECT 1 UNION ALL SELECT 2\");\n    verified_stmt(\"SELECT 1 UNION DISTINCT SELECT 1\");\n    verified_stmt(\"SELECT 1 EXCEPT SELECT 2\");\n    verified_stmt(\"SELECT 1 EXCEPT ALL SELECT 2\");\n    verified_stmt(\"SELECT 1 EXCEPT DISTINCT SELECT 1\");\n    verified_stmt(\"SELECT 1 INTERSECT SELECT 2\");\n    verified_stmt(\"SELECT 1 INTERSECT ALL SELECT 2\");\n    verified_stmt(\"SELECT 1 INTERSECT DISTINCT SELECT 1\");\n    verified_stmt(\"SELECT 1 UNION SELECT 2 UNION SELECT 3\");\n    verified_stmt(\"SELECT 1 EXCEPT SELECT 2 UNION SELECT 3\"); // Union[Except[1,2], 3]\n    verified_stmt(\"SELECT 1 INTERSECT (SELECT 2 EXCEPT SELECT 3)\");\n    verified_stmt(\"WITH cte AS (SELECT 1 AS foo) (SELECT foo FROM cte ORDER BY 1 LIMIT 1)\");\n    verified_stmt(\"SELECT 1 UNION (SELECT 2 ORDER BY 1 LIMIT 1)\");\n    verified_stmt(\"SELECT 1 UNION SELECT 2 INTERSECT SELECT 3\"); // Union[1, Intersect[2,3]]\n    verified_stmt(\"SELECT foo FROM tab UNION SELECT bar FROM TAB\");\n    verified_stmt(\"(SELECT * FROM new EXCEPT SELECT * FROM old) UNION ALL (SELECT * FROM old EXCEPT SELECT * FROM new) ORDER BY 1\");\n    verified_stmt(\"(SELECT * FROM new EXCEPT DISTINCT SELECT * FROM old) UNION DISTINCT (SELECT * FROM old EXCEPT DISTINCT SELECT * FROM new) ORDER BY 1\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_let_object", "code": "pub fn concat(&self, items: &[JsValue], context: &mut Context<'_>) -> JsResult<Self> {\n        let object = Array::concat(&self.inner.clone().into(), items, context)?\n            .as_object()\n            .cloned()\n            .expect(\"Array.prototype.filter should always return object\");\n\n        Self::from_object(object)\n    }", "test": "fn for_in_let_object() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let obj = { a: \"a\", b: 2};\n                for (let i in obj) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['a', 'b'])\"),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_trailing_dot", "code": "fn run(args: &[&str], expected: &[u8]) {\n    let mut cmd = new_ucmd!();\n    let mut child = cmd.args(args).set_stdout(Stdio::piped()).run_no_wait();\n    let buf = child.stdout_exact_bytes(expected.len());\n    child.close_stdout();\n    child.wait().unwrap().success();\n    assert_eq!(buf.as_slice(), expected);\n}", "test": "fn test_mkdir_trailing_dot() {\n    let _guard = TEST_MUTEX.lock();\n\n    new_ucmd!().arg(\"-p\").arg(\"-v\").arg(\"test_dir\").succeeds();\n\n    new_ucmd!()\n        .arg(\"-p\")\n        .arg(\"-v\")\n        .arg(\"test_dir_a/.\")\n        .succeeds()\n        .stdout_contains(\"created directory 'test_dir_a'\");\n\n    new_ucmd!()\n        .arg(\"-p\")\n        .arg(\"-v\")\n        .arg(\"test_dir_b/..\")\n        .succeeds()\n        .stdout_contains(\"created directory 'test_dir_b'\");\n\n    let scene = TestScenario::new(\"ls\");\n    let result = scene.ucmd().arg(\"-al\").run();\n    println!(\"ls dest {}\", result.stdout_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_closes_file_descriptors", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_closes_file_descriptors() {\n    use procfs::process::Process;\n    let me = Process::myself().unwrap();\n\n    // The test suite runs in parallel, we have pipe, sockets\n    // opened by other tests.\n    // So, we take in account the various fd to increase the limit\n    let number_file_already_opened: u64 = me.fd_count().unwrap().try_into().unwrap();\n    let limit_fd: u64 = number_file_already_opened + 9;\n\n    // For debugging purposes:\n    #[cfg(not(target_os = \"android\"))]\n    for f in me.fd().unwrap() {\n        let fd = f.unwrap();\n        println!(\"{:?} {:?}\", fd, fd.mode());\n    }\n\n    new_ucmd!()\n        .arg(\"-r\")\n        .arg(\"--reflink=auto\")\n        .arg(\"dir_with_10_files/\")\n        .arg(\"dir_with_10_files_new/\")\n        .limit(Resource::NOFILE, limit_fd, limit_fd)\n        .succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_false.rs::test_exit_code", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_exit_code() {\n    new_ucmd!().fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_not_add_newline_when_line_less_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_not_add_newline_when_line_less_than_fold() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"1234\")\n        .succeeds()\n        .stdout_is(\"1234\");\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_1_other", "code": "fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n}", "test": "fn remove_entry_multi_1_other() {\n    let mut headers = HeaderMap::new();\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 1);\n    assert_eq!(headers.len(), 1);\n\n    let vias = remove_all_values(&mut headers, VIA);\n    assert_eq!(vias.len(), 1);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_3339", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_3339() {\n    let scene = TestScenario::new(util_name!());\n\n    let rfc_regexp = concat!(\n        r#\"(\\d+)-(0[1-9]|1[012])-(0[1-9]|[12]\\d|3[01])\\s([01]\\d|2[0-3]):\"#,\n        r#\"([0-5]\\d):([0-5]\\d|60)(\\.\\d+)?(([Zz])|([\\+|\\-]([01]\\d|2[0-3])))\"#\n    );\n    let re = Regex::new(rfc_regexp).unwrap();\n\n    // Check that the output matches the regexp\n    for param in [\"--rfc-3339\", \"--rfc-3\"] {\n        scene\n            .ucmd()\n            .arg(format!(\"{param}=ns\"))\n            .succeeds()\n            .stdout_matches(&re);\n\n        scene\n            .ucmd()\n            .arg(format!(\"{param}=seconds\"))\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/crashtest/mod.rs::crashtest", "code": "pub fn decode(&mut self) -> Result<Vec<u8>> {\n        WorkerScope::with(|worker| self.decode_internal(false, worker))\n    }", "test": "fn crashtest() {\n    let files = common::test_files(&Path::new(\"tests\").join(\"crashtest\").join(\"images\"));\n\n    for path in &files {\n        let file = File::open(path).unwrap();\n        let mut decoder = jpeg::Decoder::new(BufReader::new(file));\n        let _ = decoder.decode();\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/sats.rs::sats_from_tsv_file_not_found", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn sats_from_tsv_file_not_found() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  CommandBuilder::new(\"--index-sats wallet sats --tsv foo.tsv\")\n    .rpc_server(&rpc_server)\n    .expected_exit_code(1)\n    .stderr_regex(\"error: I/O error reading `.*`\\nbecause: .*\\n\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_option_quiet", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_option_quiet() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--quiet\", \"numbers50.txt\", \"13\", \"%25%\", \"/0$/\"])\n        .succeeds()\n        .no_stdout();\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 13));\n    assert_eq!(at.read(\"xx01\"), generate(25, 30));\n    assert_eq!(at.read(\"xx02\"), generate(30, 51));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_if_tag", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_if_tag() {\n    assert_err_msg(r#\"{% if true %}sd\"#, &[\"1:16\", r#\"expected tag or some content\"#]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_catch_up_logs_leader_election", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_node_merge_catch_up_logs_leader_election() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 25;\n    cluster.cfg.raft_store.raft_log_gc_threshold = 12;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(12);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(100);\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_on_store1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let state1 = cluster.truncated_state(1000, 1);\n    // let the entries committed but not applied\n    fail::cfg(\"on_handle_apply_1003\", \"pause\").unwrap();\n    for i in 2..20 {\n        cluster.must_put(format!(\"k1{}\", i).as_bytes(), b\"v\");\n    }\n\n    // wait to trigger compact raft log\n    cluster.wait_log_truncated(1000, 1, state1.get_index() + 1);\n\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k11\", b\"v11\");\n    must_get_none(&cluster.get_engine(3), b\"k11\");\n\n    // let peer not destroyed before election timeout\n    fail::cfg(\"before_peer_destroy_1003\", \"pause\").unwrap();\n    fail::remove(\"on_handle_apply_1003\");\n    pd_client.must_merge(left.get_id(), right.get_id());\n\n    // wait election timeout\n    thread::sleep(Duration::from_millis(500));\n    fail::remove(\"before_peer_destroy_1003\");\n\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v11\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_new_leader_ignore_pessimistic_lock", "code": "fn to_vec(&self) -> Vec<Option<Bytes>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            x.push(self.get(i).map(|x| x.to_owned()));\n        }\n        x\n    }", "test": "fn test_new_leader_ignore_pessimistic_lock() {\n    let (mut cluster, pd_client, leader_client) = prepare_for_stale_read(new_peer(1, 1));\n\n    // Write (`key1`, `value1`)\n    leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Leave a pessimistic lock on the region\n    leader_client.must_kv_pessimistic_lock(b\"key2\".to_vec(), get_tso(&pd_client));\n\n    // Transfer to a new leader\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    let mut follower_client3 = PeerClient::new(&cluster, 1, new_peer(3, 3));\n    follower_client3.ctx.set_stale_read(true);\n    // The new leader should be able to update `safe_ts` so we can read `key1` with\n    // the newest ts\n    follower_client3.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_multiple_files", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_multiple_file_a\";\n    let file_b = \"test_rm_multiple_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a).arg(file_b).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_trace_apply.rs::test_data_recovery", "code": "fn count_info_log(path: &Path) -> usize {\n    count_file(path, |path| {\n        path.file_name()\n            .unwrap()\n            .to_string_lossy()\n            .starts_with(\"LOG\")\n    })\n}", "test": "fn test_data_recovery() {\n    let mut cluster = Cluster::default();\n    let registry = cluster.node(0).tablet_registry();\n    let tablet_2_path = registry.tablet_path(2, RAFT_INIT_LOG_INDEX);\n    // The rocksdb is a bootstrapped tablet, so it will be opened and closed in\n    // bootstrap, and then open again in fsm initialization.\n    assert_eq!(count_info_log(&tablet_2_path), 2);\n    let router = &mut cluster.routers[0];\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    // Write 100 keys to default CF and not flush.\n    let header = Box::new(router.new_request_for(2).take_header());\n    for i in 0..100 {\n        let mut put = SimpleWriteEncoder::with_capacity(64);\n        put.put(\n            CF_DEFAULT,\n            format!(\"key{}\", i).as_bytes(),\n            format!(\"value{}\", i).as_bytes(),\n        );\n        router\n            .send(2, PeerMsg::simple_write(header.clone(), put.encode()).0)\n            .unwrap();\n    }\n\n    // Write 100 keys to write CF and flush half.\n    let mut sub = None;\n    for i in 0..50 {\n        let mut put = SimpleWriteEncoder::with_capacity(64);\n        put.put(\n            CF_WRITE,\n            format!(\"key{}\", i).as_bytes(),\n            format!(\"value{}\", i).as_bytes(),\n        );\n        let (msg, s) = PeerMsg::simple_write(header.clone(), put.encode());\n        router.send(2, msg).unwrap();\n        sub = Some(s);\n    }\n    let resp = block_on(sub.take().unwrap().result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    let mut cached = cluster.node(0).tablet_registry().get(2).unwrap();\n    cached.latest().unwrap().flush_cf(CF_WRITE, true).unwrap();\n    let router = &mut cluster.routers[0];\n    for i in 50..100 {\n        let mut put = SimpleWriteEncoder::with_capacity(64);\n        put.put(\n            CF_WRITE,\n            format!(\"key{}\", i).as_bytes(),\n            format!(\"value{}\", i).as_bytes(),\n        );\n        router\n            .send(2, PeerMsg::simple_write(header.clone(), put.encode()).0)\n            .unwrap();\n    }\n\n    // Write 100 keys to lock CF and flush all.\n    for i in 0..100 {\n        let mut put = SimpleWriteEncoder::with_capacity(64);\n        put.put(\n            CF_LOCK,\n            format!(\"key{}\", i).as_bytes(),\n            format!(\"value{}\", i).as_bytes(),\n        );\n        let (msg, s) = PeerMsg::simple_write(header.clone(), put.encode());\n        router.send(2, msg).unwrap();\n        sub = Some(s);\n    }\n    let resp = block_on(sub.take().unwrap().result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    cached = cluster.node(0).tablet_registry().get(2).unwrap();\n    cached.latest().unwrap().flush_cf(CF_LOCK, true).unwrap();\n\n    // Make sure all keys must be written.\n    let router = &mut cluster.routers[0];\n    let snap = router.stale_snapshot(2);\n    for cf in DATA_CFS {\n        for i in 0..100 {\n            let key = format!(\"key{}\", i);\n            let value = snap.get_value_cf(cf, key.as_bytes()).unwrap();\n            assert_eq!(\n                value.as_deref(),\n                Some(format!(\"value{}\", i).as_bytes()),\n                \"{} {}\",\n                cf,\n                key\n            );\n        }\n    }\n    let registry = cluster.node(0).tablet_registry();\n    cached = registry.get(2).unwrap();\n    cached\n        .latest()\n        .unwrap()\n        .set_db_options(&[(\"avoid_flush_during_shutdown\", \"true\")])\n        .unwrap();\n    drop((snap, cached));\n\n    cluster.restart(0);\n\n    let registry = cluster.node(0).tablet_registry();\n    cached = registry.get(2).unwrap();\n    cached\n        .latest()\n        .unwrap()\n        .set_db_options(&[(\"avoid_flush_during_shutdown\", \"true\")])\n        .unwrap();\n    let router = &mut cluster.routers[0];\n\n    // Write another key to ensure all data are recovered.\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key101\", b\"value101\");\n    let resp = router.simple_write(2, header, put).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    // After being restarted, all unflushed logs should be applied again. So there\n    // should be no missing data.\n    let snap = router.stale_snapshot(2);\n    for cf in DATA_CFS {\n        for i in 0..100 {\n            let key = format!(\"key{}\", i);\n            let value = snap.get_value_cf(cf, key.as_bytes()).unwrap();\n            assert_eq!(\n                value.as_deref(),\n                Some(format!(\"value{}\", i).as_bytes()),\n                \"{} {}\",\n                cf,\n                key\n            );\n        }\n    }\n\n    // There is a restart, so LOG file should be rotate.\n    assert_eq!(count_info_log(&tablet_2_path), 3);\n    // We only trigger Flush twice, so there should be only 2 files. And because WAL\n    // is disabled, so when rocksdb is restarted, there should be no WAL to recover,\n    // so no additional flush will be triggered.\n    assert_eq!(count_sst(&tablet_2_path), 2);\n\n    cached = cluster.node(0).tablet_registry().get(2).unwrap();\n    cached.latest().unwrap().flush_cfs(DATA_CFS, true).unwrap();\n\n    // Although all CFs are triggered again, but recovery should only write:\n    // 1. [0, 101) to CF_DEFAULT\n    // 2. [50, 100) to CF_WRITE\n    //\n    // So there will be only 2 memtables to be flushed.\n    assert_eq!(count_sst(&tablet_2_path), 4);\n\n    drop((snap, cached));\n\n    cluster.restart(0);\n\n    let router = &mut cluster.routers[0];\n\n    assert_eq!(count_info_log(&tablet_2_path), 4);\n    // Because data is flushed before restarted, so all data can be read\n    // immediately.\n    let snap = router.stale_snapshot(2);\n    for cf in DATA_CFS {\n        for i in 0..100 {\n            let key = format!(\"key{}\", i);\n            let value = snap.get_value_cf(cf, key.as_bytes()).unwrap();\n            assert_eq!(\n                value.as_deref(),\n                Some(format!(\"value{}\", i).as_bytes()),\n                \"{} {}\",\n                cf,\n                key\n            );\n        }\n    }\n    // Trigger flush again.\n    cached = cluster.node(0).tablet_registry().get(2).unwrap();\n    cached.latest().unwrap().flush_cfs(DATA_CFS, true).unwrap();\n\n    // There is no recovery, so there should be nothing to flush.\n    assert_eq!(count_sst(&tablet_2_path), 4);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_basic_write.rs::test_basic_write", "code": "pub async fn wait_proposed(&mut self) -> bool {\n        WaitEvent {\n            event: CmdResChannel::PROPOSED_EVENT,\n            core: &self.core,\n        }\n        .await\n    }", "test": "fn test_basic_write() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    let header = Box::new(router.new_request_for(2).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    // Good proposal should be committed.\n    let (msg, mut sub) = PeerMsg::simple_write(header.clone(), put.clone().encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub.wait_proposed()));\n    assert!(block_on(sub.wait_committed()));\n    let resp = block_on(sub.result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    // Store id should be checked.\n    let mut invalid_header = header.clone();\n    invalid_header.set_peer(new_peer(3, 3));\n    let resp = router.simple_write(2, invalid_header, put.clone()).unwrap();\n    assert!(\n        resp.get_header().get_error().has_store_not_match(),\n        \"{:?}\",\n        resp\n    );\n\n    // Peer id should be checked.\n    invalid_header = header.clone();\n    invalid_header.set_peer(new_peer(1, 1));\n    let resp = router.simple_write(2, invalid_header, put.clone()).unwrap();\n    assert!(resp.get_header().has_error(), \"{:?}\", resp);\n\n    // Epoch should be checked.\n    invalid_header = header.clone();\n    invalid_header\n        .mut_region_epoch()\n        .set_version(INIT_EPOCH_VER - 1);\n    let resp = router.simple_write(2, invalid_header, put.clone()).unwrap();\n    assert!(\n        resp.get_header().get_error().has_epoch_not_match(),\n        \"{:?}\",\n        resp\n    );\n\n    // Term should be checked if set.\n    invalid_header = header.clone();\n    invalid_header.set_term(1);\n    let resp = router.simple_write(2, invalid_header, put.clone()).unwrap();\n    assert!(\n        resp.get_header().get_error().has_stale_command(),\n        \"{:?}\",\n        resp\n    );\n\n    // Too large message can cause regression and should be rejected.\n    let mut invalid_put = SimpleWriteEncoder::with_capacity(9 * 1024 * 1024);\n    invalid_put.put(CF_DEFAULT, b\"key\", &vec![0; 8 * 1024 * 1024]);\n    let resp = router.simple_write(2, header.clone(), invalid_put).unwrap();\n    assert!(\n        resp.get_header().get_error().has_raft_entry_too_large(),\n        \"{:?}\",\n        resp\n    );\n\n    // Make it step down and follower should reject write.\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(2);\n    msg.set_to_peer(new_peer(1, 3));\n    msg.mut_region_epoch().set_conf_ver(INIT_EPOCH_CONF_VER);\n    msg.set_from_peer(new_peer(2, 4));\n    let raft_message = msg.mut_message();\n    raft_message.set_msg_type(raft::prelude::MessageType::MsgHeartbeat);\n    raft_message.set_from(4);\n    raft_message.set_term(8);\n    router.send_raft_message(msg).unwrap();\n    let resp = router.simple_write(2, header, put).unwrap();\n    assert!(resp.get_header().get_error().has_not_leader(), \"{:?}\", resp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_invalid_option", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_option() {\n    // truncate: cli parsing error returns 1\n    new_ucmd!()\n        .args(&[\"--this-arg-does-not-exist\"])\n        .fails()\n        .code_is(1);\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::ods", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn ods() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.ods\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Ods<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"datatypes\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.)],\n            [Float(1.5)],\n            [String(\"ab\".to_string())],\n            [Bool(false)],\n            [String(\"test\".to_string())],\n            [DateTimeIso(\"2016-10-20T00:00:00\".to_string())]\n        ]\n    );\n\n    let range = excel.worksheet_range(\"issue2\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.), String(\"a\".to_string())],\n            [Float(2.), String(\"b\".to_string())],\n            [Float(3.), String(\"c\".to_string())]\n        ]\n    );\n\n    let range = excel.worksheet_range(\"issue5\").unwrap().unwrap();\n    range_eq!(range, [[Float(0.5)]]);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/create.rs::wallet_creates_correct_mainnet_taproot_descriptor", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn wallet_creates_correct_mainnet_taproot_descriptor() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new(\"wallet create\")\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Output>();\n\n  assert_eq!(rpc_server.descriptors().len(), 2);\n  assert_regex_match!(\n    &rpc_server.descriptors()[0],\n    r\"tr\\(\\[[[:xdigit:]]{8}/86'/0'/0'\\]xprv[[:alnum:]]*/0/\\*\\)#[[:alnum:]]{8}\"\n  );\n  assert_regex_match!(\n    &rpc_server.descriptors()[1],\n    r\"tr\\(\\[[[:xdigit:]]{8}/86'/0'/0'\\]xprv[[:alnum:]]*/1/\\*\\)#[[:alnum:]]{8}\"\n  );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tr.rs::test_to_upper", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_to_upper() {\n    new_ucmd!()\n        .args(&[\"a-z\", \"A-Z\"])\n        .pipe_in(\"!abcd!\")\n        .run()\n        .stdout_is(\"!ABCD!\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_proposal_prevent_sleep", "code": "pub fn leader_of_region(&mut self, region_id: u64) -> Option<metapb::Peer> {\n        let timer = Instant::now_coarse();\n        let timeout = Duration::from_secs(5);\n        let mut store_ids = None;\n        while timer.saturating_elapsed() < timeout {\n            match self.voter_store_ids_of_region(region_id) {\n                None => thread::sleep(Duration::from_millis(10)),\n                Some(ids) => {\n                    store_ids = Some(ids);\n                    break;\n                }\n            }\n        }\n        let store_ids = store_ids?;\n        if let Some(l) = self.leaders.get(&region_id) {\n            // leader may be stopped in some tests.\n            if self.valid_leader_id(region_id, l.get_store_id()) {\n                return Some(l.clone());\n            }\n        }\n        self.reset_leader_of_region(region_id);\n        let mut leader = None;\n        let mut leaders = HashMap::default();\n\n        let node_ids = self.sim.rl().get_node_ids();\n        // For some tests, we stop the node but pd still has this information,\n        // and we must skip this.\n        let alive_store_ids: Vec<_> = store_ids\n            .iter()\n            .filter(|id| node_ids.contains(id))\n            .cloned()\n            .collect();\n        while timer.saturating_elapsed() < timeout {\n            for store_id in &alive_store_ids {\n                let l = match self.query_leader(*store_id, region_id, Duration::from_secs(1)) {\n                    None => continue,\n                    Some(l) => l,\n                };\n                leaders\n                    .entry(l.get_id())\n                    .or_insert((l, vec![]))\n                    .1\n                    .push(*store_id);\n            }\n            if let Some((_, (l, c))) = leaders.iter().max_by_key(|(_, (_, c))| c.len()) {\n                if c.contains(&l.get_store_id()) {\n                    leader = Some(l.clone());\n                    // Technically, correct calculation should use two quorum when in joint\n                    // state. Here just for simplicity.\n                    if c.len() > store_ids.len() / 2 {\n                        break;\n                    }\n                }\n            }\n            debug!(\"failed to detect leaders\"; \"leaders\" => ?leaders, \"store_ids\" => ?store_ids);\n            sleep_ms(10);\n            leaders.clear();\n        }\n\n        if let Some(l) = leader {\n            self.leaders.insert(region_id, l);\n        }\n\n        self.leaders.get(&region_id).cloned()\n    }", "test": "fn test_proposal_prevent_sleep() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Wait till leader peer goes to sleep.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1).direction(Direction::Send),\n    ));\n    let region = block_on(cluster.pd_client.get_region_by_id(1))\n        .unwrap()\n        .unwrap();\n\n    let put = new_put_cmd(b\"k2\", b\"v2\");\n    let mut req = new_request(1, region.get_region_epoch().clone(), vec![put], true);\n    req.mut_header().set_peer(new_peer(1, 1));\n    // ignore error, we just want to send this command to peer (1, 1),\n    // and the command can't be executed because we have only one peer,\n    // so here will return timeout error, we should ignore it.\n    let _ = cluster.call_command(req, Duration::from_millis(10));\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n    assert_eq!(cluster.leader_of_region(1), Some(new_peer(1, 1)));\n\n    // Wait till leader peer goes to sleep.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1).direction(Direction::Send),\n    ));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_read_index_cmd()],\n        true,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    // send to peer 2\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    thread::sleep(Duration::from_millis(10));\n    cluster.clear_send_filters();\n    let resp = rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    assert!(\n        !resp.get_header().has_error(),\n        \"{:?}\",\n        resp.get_header().get_error()\n    );\n\n    // Wait till leader peer goes to sleep.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1).direction(Direction::Send),\n    ));\n    let conf_change = new_change_peer_request(ConfChangeType::RemoveNode, new_peer(3, 3));\n    let mut admin_req = new_admin_request(1, region.get_region_epoch(), conf_change);\n    admin_req.mut_header().set_peer(new_peer(1, 1));\n    let (cb, _rx) = make_cb(&admin_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, admin_req, cb)\n        .unwrap();\n    thread::sleep(Duration::from_millis(10));\n    cluster.clear_send_filters();\n    cluster.pd_client.must_none_peer(1, new_peer(3, 3));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_missing_xs_tmpdir_template", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_missing_xs_tmpdir_template() {\n    let scene = TestScenario::new(util_name!());\n    scene\n        .ucmd()\n        .arg(\"--tmpdir\")\n        .arg(TEST_TEMPLATE3)\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"too few X's in template\");\n    scene\n        .ucmd()\n        .arg(\"--tmpdir=foobar\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"failed to create file via template\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::ial_records_out() {\n    ", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "artial_records_out() {\n    new_ucmd!()\n        .args(&[\"bs=2\", \"status=noxfer\"])\n        .pipe_in(\"abc\")\n        .succeeds()\n        .stdout_is(\"abc\")\n        .stderr_is(\"1+1 records in\\n1+1 records out\\n\");\n}\n\n#[test]"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_copy_from_stdin", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_copy_from_stdin() {\n    let sql = r#\"COPY public.actor (actor_id, first_name, last_name, last_update, value) FROM stdin;\n1    PENELOPE    GUINESS    2006-02-15 09:34:33 0.11111\n2    NICK    WAHLBERG    2006-02-15 09:34:33 0.22222\n3    ED    CHASE    2006-02-15 09:34:33 0.312323\n4    JENNIFER    DAVIS    2006-02-15 09:34:33 0.3232\n5    JOHNNY    LOLLOBRIGIDA    2006-02-15 09:34:33 1.343\n6    BETTE    NICHOLSON    2006-02-15 09:34:33 5.0\n7    GRACE    MOSTEL    2006-02-15 09:34:33 6.0\n8    MATTHEW    JOHANSSON    2006-02-15 09:34:33 7.0\n9    JOE    SWANK    2006-02-15 09:34:33 8.0\n10    CHRISTIAN    GABLE    2006-02-15 09:34:33 9.1\n11    ZERO    CAGE    2006-02-15 09:34:33 10.001\n12    KARL    BERRY    2017-11-02 19:15:42.308637+08 11.001\nA Fateful Reflection of a Waitress And a Boat who must Discover a Sumo Wrestler in Ancient China\nKwara & Kogi\n{\"Deleted Scenes\",\"Behind the Scenes\"}\n'awe':5 'awe-inspir':4 'barbarella':1 'cat':13 'conquer':16 'dog':18 'feminist':10 'inspir':6 'monasteri':21 'must':15 'stori':7 'streetcar':2\nPHP    \u20b1 USD $\n\\N  Some other value\n\\\\.\"#;\n    let ast = pg_and_generic().one_statement_parses_to(sql, \"\");\n    println!(\"{ast:#?}\");\n    //assert_eq!(sql, ast.to_string());\n}\n\n"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_loop_return", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_loop_return() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            function foo() {\n                for (let a = 1; a < 5; a++) {\n                    if (a == 3) {\n                        return a;\n                    }\n                }\n            }\n            foo();\n        \"#},\n        3,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_info_v2", "code": "fn get_raft_state(&self, raft_group_id: u64) -> Result<Option<RaftLocalState>> {\n        panic!()\n    }", "test": "fn test_debug_region_info_v2() {\n    let (cluster, debug_client, store_id) = test_raftstore_v2::must_new_cluster_and_debug_client();\n\n    let raft_engine = cluster.get_raft_engine(store_id);\n    let region_id = 100;\n    let mut raft_state = raft_serverpb::RaftLocalState::default();\n    raft_state.set_last_index(42);\n    let mut lb = raft_engine.log_batch(10);\n    lb.put_raft_state(region_id, &raft_state).unwrap();\n\n    let mut apply_state = raft_serverpb::RaftApplyState::default();\n    apply_state.set_applied_index(42);\n    lb.put_apply_state(region_id, 42, &apply_state).unwrap();\n\n    let mut region_state = raft_serverpb::RegionLocalState::default();\n    region_state.set_state(raft_serverpb::PeerState::Tombstone);\n    lb.put_region_state(region_id, 42, &region_state).unwrap();\n\n    raft_engine.consume(&mut lb, false).unwrap();\n    assert_eq!(\n        raft_engine.get_raft_state(region_id).unwrap().unwrap(),\n        raft_state\n    );\n\n    assert_eq!(\n        raft_engine\n            .get_apply_state(region_id, u64::MAX)\n            .unwrap()\n            .unwrap(),\n        apply_state\n    );\n\n    assert_eq!(\n        raft_engine\n            .get_region_state(region_id, u64::MAX)\n            .unwrap()\n            .unwrap(),\n        region_state\n    );\n\n    // Debug region_info\n    let mut req = debugpb::RegionInfoRequest::default();\n    req.set_region_id(region_id);\n    let mut resp = debug_client.region_info(&req).unwrap();\n    assert_eq!(resp.take_raft_local_state(), raft_state);\n    assert_eq!(resp.take_raft_apply_state(), apply_state);\n    assert_eq!(resp.take_region_local_state(), region_state);\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_info(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_l", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_semicolon_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=;\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_target_dir", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_target_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_target_dir_dir\";\n    let file_a = \"test_mv_target_dir_file_a\";\n    let file_b = \"test_mv_target_dir_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n    ucmd.arg(\"-t\")\n        .arg(dir)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{dir}/{file_a}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file_b}\")));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_nan_comparison", "code": "pub(crate) fn test_same(source_text: &str) {\n    test(source_text, source_text);\n}", "test": "fn test_nan_comparison() {\n    test_wcb(\"NaN < 1\", \"false;\");\n    test_wcb(\"NaN <= 1\", \"false;\");\n    test_wcb(\"NaN > 1\", \"false;\");\n    test_wcb(\"NaN >= 1\", \"false;\");\n    test_wcb(\"NaN < 1n\", \"false;\");\n    test_wcb(\"NaN <= 1n\", \"false;\");\n    test_wcb(\"NaN > 1n\", \"false;\");\n    test_wcb(\"NaN >= 1n\", \"false;\");\n\n    test_wcb(\"NaN < NaN\", \"false;\");\n    test_wcb(\"NaN >= NaN\", \"false;\");\n    test_wcb(\"NaN == NaN\", \"false;\");\n    test_wcb(\"NaN === NaN\", \"false;\");\n\n    test_wcb(\"NaN < null\", \"false;\");\n    test_wcb(\"null >= NaN\", \"false;\");\n    test_wcb(\"NaN == null\", \"false;\");\n    test_wcb(\"null != NaN\", \"true;\");\n    test_wcb(\"null === NaN\", \"false;\");\n\n    test_wcb(\"NaN < undefined\", \"false;\");\n    test_wcb(\"undefined >= NaN\", \"false;\");\n    test_wcb(\"NaN == undefined\", \"false;\");\n    test_wcb(\"undefined != NaN\", \"true;\");\n    test_wcb(\"undefined === NaN\", \"false;\");\n\n    test_same(\"NaN<x;\");\n    test_same(\"x>=NaN;\");\n    test_same(\"NaN==x;\");\n    test_same(\"x!=NaN;\");\n    test_wcb(\"NaN === x\", \"false;\");\n    test_wcb(\"x !== NaN\", \"true;\");\n    test_same(\"NaN==foo();\");\n}"}
{"test_id": "dtolnay-proc-macro2/dtolnay-proc-macro2-c323f12/tests/comments.rs::closed_immediately", "code": "pub fn is_empty(&self) -> bool {\n        self.inner.len() == 0\n    }", "test": "fn closed_immediately() {\n    let stream = \"/**/\".parse::<TokenStream>().unwrap();\n    let tokens = stream.into_iter().collect::<Vec<_>>();\n    assert!(tokens.is_empty(), \"not empty -- {:?}\", tokens);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_2() {\n    let original = r##\"# with the ID {#myh1}\n## with a class {.myclass}\n### multiple! {.myclass1 #myh3 .myclass2}\n\"##;\n    let expected = r##\"<h1 id=\"myh1\">with the ID</h1>\n<h2 class=\"myclass\">with a class</h2>\n<h3 id=\"myh3\" class=\"myclass1 myclass2\">multiple!</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_bad_utf8_lines", "code": "pub fn stdout_is_bytes<T: AsRef<[u8]>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout, msg.as_ref(),\n            \"stdout as bytes wasn't equal to expected bytes. Result as strings:\\nstdout  ='{:?}'\\nexpected='{:?}'\",\n            std::str::from_utf8(&self.stdout),\n            std::str::from_utf8(msg.as_ref()),\n        );\n        self\n    }", "test": "fn test_bad_utf8_lines() {\n    let input: &[u8] =\n        b\"\\xfc\\x80\\x80\\x80\\x80\\xaf\\nb\\xfc\\x80\\x80\\x80\\x80\\xaf\\nb\\xfc\\x80\\x80\\x80\\x80\\xaf\";\n    let output = b\"\\xfc\\x80\\x80\\x80\\x80\\xaf\\nb\\xfc\\x80\\x80\\x80\\x80\\xaf\\n\";\n    new_ucmd!()\n        .args(&[\"-n\", \"2\"])\n        .pipe_in(input)\n        .succeeds()\n        .stdout_is_bytes(output);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_after_write", "code": "pub fn is_some(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_some(),\n            }\n        }\n    }", "test": "fn save_point_rollback_after_write() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.set_save_point();\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.write().unwrap();\n\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_some());\n\n    db.engine.delete(b\"a\").unwrap();\n\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    wb.set_save_point();\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n\n    db.engine.delete(b\"a\").unwrap();\n    for i in 0..max_keys {\n        db.engine.delete(&i.to_be_bytes()).unwrap();\n    }\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_none());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_none());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_append() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let record2 = record2;\n\n    let result = io_loop\n        .block_on(client.append(record2.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_numbering_option_with_number_width", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_numbering_option_with_number_width() {\n    let test_file_path = \"test_num_page.log\";\n    let expected_test_file_path = \"test_num_page_2.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"-n\", \"2\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_invalid_numbers", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_invalid_numbers() {\n    new_ucmd!()\n        .args(&[\"-s\", \"0X\", \"file\"])\n        .fails()\n        .stderr_contains(\"Invalid number: '0X'\");\n    new_ucmd!()\n        .args(&[\"-s\", \"0XB\", \"file\"])\n        .fails()\n        .stderr_contains(\"Invalid number: '0XB'\");\n    new_ucmd!()\n        .args(&[\"-s\", \"0B\", \"file\"])\n        .fails()\n        .stderr_contains(\"Invalid number: '0B'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_non_empty_directory", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_non_empty_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_non_empty_dir\";\n    let file_a = &format!(\"{dir}/test_rm_non_empty_file_a\");\n\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    ucmd.arg(\"-d\")\n        .arg(dir)\n        .fails()\n        .stderr_contains(&format!(\"cannot remove '{dir}': Directory not empty\"));\n    assert!(at.file_exists(file_a));\n    assert!(at.dir_exists(dir));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_unsorted_ints", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_unsorted_ints() {\n    test_helper(\n        \"numeric_unsorted_ints\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::_bytes() {\n    ", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "eek_bytes() {\n    // Since the output file is stdout, seeking forward by eight bytes\n    // results in a prefix of eight null bytes.\n    new_ucmd!()\n        .args(&[\"seek=8\", \"oflag=seek_bytes\"])\n        .pipe_in(\"abcdefghijklm\\n\")\n        .succeeds()\n        .stdout_is(\"\\0\\0\\0\\0\\0\\0\\0\\0abcdefghijklm\\n\");\n}\n\n/// Tes"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/iterators.rs::async_iterator_close_in_continue_is_awaited", "code": "fn run_jobs(&self, context: &mut boa_engine::Context<'_>) {\n        // Early return in case there were no jobs scheduled.\n        if self.jobs.borrow().is_empty() && self.futures.borrow().is_empty() {\n            return;\n        }\n\n        let context = RefCell::new(context);\n\n        future::block_on(self.executor.run(async move {\n            // Used to sync the finalization of both tasks\n            let finished = Cell::new(0b00u8);\n\n            let fqueue = async {\n                loop {\n                    if self.futures.borrow().is_empty() {\n                        finished.set(finished.get() | 0b01);\n                        if finished.get() >= 0b11 {\n                            // All possible futures and jobs were completed. Exit.\n                            return;\n                        }\n                        // All possible jobs were completed, but `jqueue` could have\n                        // pending jobs. Yield to the executor to try to progress on\n                        // `jqueue` until we have more pending futures.\n                        future::yield_now().await;\n                        continue;\n                    }\n                    finished.set(finished.get() & 0b10);\n\n                    // Blocks on all the enqueued futures, driving them all to completion.\n                    let futures = &mut std::mem::take(&mut *self.futures.borrow_mut());\n                    while let Some(job) = futures.next().await {\n                        // Important to schedule the returned `job` into the job queue, since that's\n                        // what allows updating the `Promise` seen by ECMAScript for when the future\n                        // completes.\n                        self.enqueue_promise_job(job, &mut context.borrow_mut());\n                    }\n                }\n            };\n\n            let jqueue = async {\n                loop {\n                    if self.jobs.borrow().is_empty() {\n                        finished.set(finished.get() | 0b10);\n                        if finished.get() >= 0b11 {\n                            // All possible futures and jobs were completed. Exit.\n                            return;\n                        }\n                        // All possible jobs were completed, but `fqueue` could have\n                        // pending futures. Yield to the executor to try to progress on\n                        // `fqueue` until we have more pending jobs.\n                        future::yield_now().await;\n                        continue;\n                    };\n                    finished.set(finished.get() & 0b01);\n\n                    let jobs = std::mem::take(&mut *self.jobs.borrow_mut());\n                    for job in jobs {\n                        if let Err(e) = job.call(&mut context.borrow_mut()) {\n                            eprintln!(\"Uncaught {e}\");\n                        }\n                        future::yield_now().await;\n                    }\n                }\n            };\n\n            // Wait for both queues to complete\n            future::zip(fqueue, jqueue).await;\n        }))\n    }", "test": "fn async_iterator_close_in_continue_is_awaited() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n            var actual = [];\n\n            var asyncIter = {\n                [Symbol.asyncIterator]() {\n                    return this;\n                },\n                next() {\n                    actual.push(\"async call next\");\n                    return {\n                        done: false,\n                    };\n                },\n                get return() {\n                    actual.push(\"get async return\");\n                    return function () {\n                        actual.push(\"async return call\");\n                        return {\n                            done: true\n                        };\n                    }\n                }\n            };\n\n            Promise.resolve(0)\n                .then(() => actual.push(\"tick 1\"))\n                .then(() => actual.push(\"tick 2\"))\n                .then(() => actual.push(\"tick 3\"));\n\n            void async function f() {\n                actual.push(\"async fn start\");\n                let count = 0;\n                loop: while (count === 0) {\n                    count++;\n                    for await (__ of asyncIter) {\n                        continue loop;\n                    }\n                }\n                actual.push(\"async fn end\");\n            }();\n        \"#}),\n        #[allow(clippy::redundant_closure_for_method_calls)]\n        TestAction::inspect_context(|ctx| ctx.run_jobs()),\n        TestAction::assert(indoc! {r#\"\n            arrayEquals(\n                actual,\n                [\n                    \"async fn start\",\n                    \"async call next\",\n                    \"tick 1\",\n                    \"get async return\",\n                    \"async return call\",\n                    \"tick 2\",\n                    \"async fn end\",\n                    \"tick 3\"\n                ]\n            )\n        \"#}),\n    ]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression17", "code": "fn new () -> Self { Self { savepoints : vec ! [] , uncommitted_persistent : Default :: default () , persistent_countdown : MAX_PERSISTENT_SAVEPOINTS , } }", "test": "fn regression17() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0; 4578];\n        t.insert(&671325, value.as_slice()).unwrap();\n\n        let mut value = t.insert_reserve(&723904, 2246).unwrap();\n        value.as_mut().fill(0xFF);\n    }\n    tx.abort().unwrap();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::does_not_format_if_files_are_listed_in_ignore_option", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn does_not_format_if_files_are_listed_in_ignore_option() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_FORMATTER_AND_FILES_IGNORE.as_bytes(),\n    );\n\n    let file_path_test1 = Path::new(\"test1.js\");\n    fs.insert(file_path_test1.into(), UNFORMATTED.as_bytes());\n\n    let file_path_test2 = Path::new(\"test2.js\");\n    fs.insert(file_path_test2.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                file_path_test1.as_os_str().to_str().unwrap(),\n                file_path_test2.as_os_str().to_str().unwrap(),\n                (\"--write\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path_test1)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, UNFORMATTED);\n\n    let mut buffer = String::new();\n    fs.open(file_path_test2)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, UNFORMATTED);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_not_format_if_files_are_listed_in_ignore_option\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_append", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_append() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = client\n        .append(record.clone(), origin.clone(), false)\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = *rr.data().unwrap() {\n            ip == A::new(100, 10, 100, 10)\n        } else {\n            false\n        }));\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    let result = client\n        .append(record.clone(), origin, true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_callback_when_destroyed", "code": "fn is_empty(&self) -> bool {\n        match &self.batch {\n            Either::Left(batch) => batch.is_empty(),\n            Either::Right(keys) => keys.is_empty(),\n        }\n    }", "test": "fn test_node_callback_when_destroyed() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    // Increase the election tick to make this test case running reliably.\n    configure_for_lease_read(&mut cluster.cfg, None, Some(50));\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n    let leader = cluster.leader_of_region(1).unwrap();\n    let cc = new_change_peer_request(ConfChangeType::RemoveNode, leader.clone());\n    let epoch = cluster.get_region_epoch(1);\n    let req = new_admin_request(1, &epoch, cc);\n    // so the leader can't commit the conf change yet.\n    let block = Arc::new(AtomicBool::new(true));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, leader.get_store_id())\n            .msg_type(MessageType::MsgAppendResponse)\n            .direction(Direction::Recv)\n            .when(Arc::clone(&block)),\n    ));\n    let mut filter = LeaseReadFilter::default();\n    filter.take = true;\n    // so the leader can't perform read index.\n    cluster.add_send_filter(CloneFilterFactory(filter.clone()));\n    // it always timeout, no need to wait.\n    let _ = cluster.call_command_on_leader(req, Duration::from_millis(500));\n\n    // To make sure `get` is handled before destroy leader, we must issue\n    // `get` then unblock append responses.\n    let leader_node_id = leader.get_store_id();\n    let get = new_get_cmd(b\"k1\");\n    let mut req = new_request(1, epoch, vec![get], true);\n    req.mut_header().set_peer(leader);\n    let (cb, mut rx) = make_cb(&req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(leader_node_id, req, cb)\n        .unwrap();\n    // Unblock append responses after we issue the req.\n    block.store(false, Ordering::SeqCst);\n    let resp = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n\n    assert!(\n        !filter.ctx.rl().is_empty(),\n        \"read index should be performed\"\n    );\n    assert!(\n        resp.get_header().get_error().has_region_not_found(),\n        \"{:?}\",\n        resp\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_state.rs::test_state_lookup_global", "code": "pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n                .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n                .unwrap_or_else(|| context!());\n            slf.inner\n                .lock()\n                .unwrap()\n                .env\n                .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n                .map_err(to_py_error)\n        })\n    }", "test": "fn test_state_lookup_global() {\n    let mut env = Environment::new();\n    env.add_function(\"lookup_global\", |state: &State| -> Value {\n        state.lookup(\"the_global\").unwrap_or_default()\n    });\n    env.add_global(\"the_global\", true);\n    let rv = env.render_str(\"[{{ lookup_global() }}]\", ()).unwrap();\n    assert_eq!(rv, \"[true]\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_term_matching", "code": "pub fn check(path: &OsStr, settings: &GlobalSettings) -> UResult<()> {\n    let max_allowed_cmp = if settings.unique {\n        // If `unique` is enabled, the previous line must compare _less_ to the next one.\n        Ordering::Less\n    } else {\n        // Otherwise, the line previous line must compare _less or equal_ to the next one.\n        Ordering::Equal\n    };\n    let file = open(path)?;\n    let (recycled_sender, recycled_receiver) = sync_channel(2);\n    let (loaded_sender, loaded_receiver) = sync_channel(2);\n    thread::spawn({\n        let settings = settings.clone();\n        move || reader(file, &recycled_receiver, &loaded_sender, &settings)\n    });\n    for _ in 0..2 {\n        let _ = recycled_sender.send(RecycledChunk::new(if settings.buffer_size < 100 * 1024 {\n            // when the buffer size is smaller than 100KiB we choose it instead of the default.\n            // this improves testability.\n            settings.buffer_size\n        } else {\n            100 * 1024\n        }));\n    }\n\n    let mut prev_chunk: Option<Chunk> = None;\n    let mut line_idx = 0;\n    for chunk in loaded_receiver {\n        line_idx += 1;\n        if let Some(prev_chunk) = prev_chunk.take() {\n            // Check if the first element of the new chunk is greater than the last\n            // element from the previous chunk\n            let prev_last = prev_chunk.lines().last().unwrap();\n            let new_first = chunk.lines().first().unwrap();\n\n            if compare_by(\n                prev_last,\n                new_first,\n                settings,\n                prev_chunk.line_data(),\n                chunk.line_data(),\n            ) > max_allowed_cmp\n            {\n                return Err(SortError::Disorder {\n                    file: path.to_owned(),\n                    line_number: line_idx,\n                    line: new_first.line.to_owned(),\n                    silent: settings.check_silent,\n                }\n                .into());\n            }\n            let _ = recycled_sender.send(prev_chunk.recycle());\n        }\n\n        for (a, b) in chunk.lines().iter().tuple_windows() {\n            line_idx += 1;\n            if compare_by(a, b, settings, chunk.line_data(), chunk.line_data()) > max_allowed_cmp {\n                return Err(SortError::Disorder {\n                    file: path.to_owned(),\n                    line_number: line_idx,\n                    line: b.line.to_owned(),\n                    silent: settings.check_silent,\n                }\n                .into());\n            }\n        }\n\n        prev_chunk = Some(chunk);\n    }\n    Ok(())\n}", "test": "fn test_term_matching() {\n    fn check(term_pattern: &str, term: &str, expectation: &str) {\n        let theme = format!(\n            \"\nTERM {term_pattern}\n\n.term_matching    00;38;5;61\n\"\n        );\n\n        new_ucmd!()\n            .env(\"TERM\", term)\n            .pipe_in(theme)\n            .args(&[\"-b\", \"-\"])\n            .succeeds()\n            .stdout_is(expectation)\n            .no_stderr();\n    }\n\n    let expectation_if_match = r#\"\nLS_COLORS='*.term_matching=00;38;5;61:';\nexport LS_COLORS\n\"#\n    .trim_start();\n    let expectation_if_no_match = r#\"\nLS_COLORS='';\nexport LS_COLORS\n\"#\n    .trim_start();\n\n    // sanity checks\n    check(\"matches\", \"matches\", expectation_if_match);\n    check(\"matches\", \"no_match\", expectation_if_no_match);\n    // character set negation should treat ^ like !\n    check(\"[!a]_negation\", \"a_negation\", expectation_if_no_match);\n    check(\"[!a]_negation\", \"b_negation\", expectation_if_match);\n    check(\"[^a]_negation\", \"a_negation\", expectation_if_no_match);\n    check(\"[^a]_negation\", \"b_negation\", expectation_if_match);\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_basic_struct", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_basic_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Basic {\n        x: isize,\n        y: String,\n        z: bool,\n    }\n    let thing = Basic {\n        x: -4,\n        y: \"hi\\tquoted\".to_owned(),\n        z: true,\n    };\n    let yaml = indoc! {r#\"\n        x: -4\n        y: \"hi\\tquoted\"\n        z: true\n    \"#};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_life.rs::test_life_by_message", "code": "pub fn assert_tombstone(raft_engine: &impl RaftEngine, region_id: u64, peer: &metapb::Peer) {\n        let mut buf = vec![];\n        raft_engine.get_all_entries_to(region_id, &mut buf).unwrap();\n        assert!(buf.is_empty(), \"{:?}\", buf);\n        assert_matches!(raft_engine.get_raft_state(region_id), Ok(None));\n        assert_matches!(raft_engine.get_apply_state(region_id, u64::MAX), Ok(None));\n        let region_state = raft_engine\n            .get_region_state(region_id, u64::MAX)\n            .unwrap()\n            .unwrap();\n        assert_matches!(region_state.get_state(), PeerState::Tombstone);\n        assert!(\n            region_state.get_region().get_peers().contains(peer),\n            \"{:?}\",\n            region_state\n        );\n    }", "test": "fn test_life_by_message() {\n    let mut cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    let test_region_id = 4;\n    let test_peer_id = 5;\n    let test_leader_id = 6;\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n\n    // Build a correct message.\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(test_region_id);\n    msg.set_to_peer(new_peer(1, test_peer_id));\n    msg.mut_region_epoch().set_conf_ver(1);\n    msg.set_from_peer(new_peer(2, test_leader_id));\n    let raft_message = msg.mut_message();\n    raft_message.set_msg_type(raft::prelude::MessageType::MsgHeartbeat);\n    raft_message.set_from(6);\n    raft_message.set_term(5);\n\n    let assert_wrong = |f: &dyn Fn(&mut RaftMessage)| {\n        let mut wrong_msg = msg.clone();\n        f(&mut wrong_msg);\n        router.send_raft_message(wrong_msg).unwrap();\n        assert_peer_not_exist(test_region_id, test_peer_id, router);\n    };\n\n    // Check mismatch store id.\n    assert_wrong(&|msg| msg.mut_to_peer().set_store_id(4));\n\n    // Check missing region epoch.\n    assert_wrong(&|msg| {\n        msg.take_region_epoch();\n    });\n\n    // Correct message will create a peer, but the peer will not be initialized.\n    router.send_raft_message(msg.clone()).unwrap();\n    let timeout = Duration::from_secs(3);\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.region_state.id, test_region_id);\n    assert_eq!(meta.raft_status.id, test_peer_id);\n    assert_eq!(meta.region_state.tablet_index, 0);\n    // But leader should be set.\n    assert_eq!(meta.raft_status.soft_state.leader_id, test_leader_id);\n\n    // The peer should survive restart.\n    cluster.restart(0);\n    let router = &cluster.routers[0];\n    let meta = router\n        .must_query_debug_info(test_region_id, timeout)\n        .unwrap();\n    assert_eq!(meta.raft_status.id, test_peer_id);\n    let raft_engine = &cluster.node(0).running_state().unwrap().raft_engine;\n    raft_engine.get_raft_state(test_region_id).unwrap().unwrap();\n    raft_engine\n        .get_apply_state(test_region_id, 0)\n        .unwrap()\n        .unwrap();\n\n    // The peer should be destroyed by tombstone message.\n    let mut tombstone_msg = msg.clone();\n    tombstone_msg.set_is_tombstone(true);\n    router.send_raft_message(tombstone_msg).unwrap();\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    assert_tombstone(raft_engine, test_region_id, &new_peer(1, test_peer_id));\n\n    // Restart should not recreate tombstoned peer.\n    cluster.restart(0);\n    let router = &cluster.routers[0];\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    let raft_engine = &cluster.node(0).running_state().unwrap().raft_engine;\n    assert_tombstone(raft_engine, test_region_id, &new_peer(1, test_peer_id));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::find_dot_justfile", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn find_dot_justfile() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo bad\n    \",\n    )\n    .tree(tree! {\n      dir: {\n        \".justfile\": \"\n          foo:\n            echo ok\n        \"\n      }\n    })\n    .current_dir(\"dir\")\n    .stderr(\"echo ok\\n\")\n    .stdout(\"ok\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_exclude_invalid_syntax", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_du_exclude_invalid_syntax() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.mkdir_all(\"azerty/xcwww/azeaze\");\n\n    ts.ucmd()\n        .arg(\"--exclude=a[ze\")\n        .arg(\"azerty\")\n        .fails()\n        .stderr_contains(\"du: Invalid exclude syntax\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_float_f64_rounding", "code": "pub fn compute_float64(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f64, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f64_rounding() {\n    // Also need to check halfway cases **inside** that exponent range.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1076, 2));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1077, 2));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_float64(0, 9007199254740991), (1075, 4503599627370495));\n    assert_eq!(compute_float64(0, 9223372036854776831), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776832), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776833), (1086, 1));\n    assert_eq!(compute_float64(-42, 9123456727292927), (936, 1854521741541368));\n    assert_eq!(compute_float64(-43, 91234567272929275), (936, 1854521741541369));\n    assert_eq!(compute_float64(-42, 9123456727292928), (936, 1854521741541369));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1076, 2));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_fs", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_sync_fs() {\n    let temporary_directory = tempdir().unwrap();\n    let temporary_path = fs::canonicalize(temporary_directory.path()).unwrap();\n    new_ucmd!()\n        .arg(\"--file-system\")\n        .arg(&temporary_path)\n        .succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_number_old_form", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "test": "fn test_kill_with_signal_number_old_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-9\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(9));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::delete_table", "code": "pub(crate) fn delete_table(\n        &mut self,\n        name: &str,\n        table_type: TableType,\n    ) -> Result<bool, TableError> {\n        if let Some(definition) = self.get_table_untyped(name, table_type)? {\n            if let Some((table_root, _)) = definition.get_root() {\n                let iter = AllPageNumbersBtreeIter::new(\n                    table_root,\n                    definition.fixed_key_size,\n                    definition.fixed_value_size,\n                    self.mem,\n                )?;\n                let mut freed_pages = self.freed_pages.lock().unwrap();\n                for page_number in iter {\n                    freed_pages.push(page_number?);\n                }\n            }\n\n            self.pending_table_updates.remove(name);\n\n            let found = self.tree.remove(&name)?.is_some();\n            return Ok(found);\n        }\n\n        Ok(false)\n    }", "test": "fn delete_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let y_def: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"y\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        let mut multitable = write_txn.open_multimap_table(y_def).unwrap();\n        multitable.insert(\"hello2\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    assert!(write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(!write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(write_txn.delete_multimap_table(y_def).unwrap());\n    assert!(!write_txn.delete_multimap_table(y_def).unwrap());\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let result = read_txn.open_table(STR_TABLE);\n    assert!(result.is_err());\n    let result = read_txn.open_multimap_table(y_def);\n    assert!(result.is_err());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_for_if_nodes_with_else", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn handle_ws_for_if_nodes_with_else() {\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![\n        Node::Text(\"C \".to_string()),\n        Node::If(\n            If {\n                conditions: vec![\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: false },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                ],\n                otherwise: Some((\n                    WS { left: true, right: true },\n                    vec![Node::Text(\" a \".to_string())],\n                )),\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"C\".to_string()),\n            Node::If(\n                If {\n                    conditions: vec![\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: false },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\" a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                    ],\n                    otherwise: Some((\n                        WS { left: true, right: true },\n                        vec![Node::Text(\"a\".to_string())],\n                    )),\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_hard_logical", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_hard_logical() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"file1\";\n    let link = \"symlink1\";\n    let target = \"hard-to-a\";\n    let target2 = \"hard-to-a2\";\n    at.touch(file_a);\n    at.symlink_file(file_a, link);\n\n    ucmd.args(&[\"-P\", \"-L\", link, target]);\n    assert!(!at.is_symlink(target));\n\n    ucmd.args(&[\"-P\", \"-L\", \"-s\", link, target2]);\n    assert!(!at.is_symlink(target2));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_create_function", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_create_function() {\n    let sql = \"CREATE TEMPORARY FUNCTION mydb.myfunc AS 'org.random.class.Name' USING JAR 'hdfs://somewhere.com:8020/very/far'\";\n    match hive().verified_stmt(sql) {\n        Statement::CreateFunction {\n            temporary,\n            name,\n            params,\n            ..\n        } => {\n            assert!(temporary);\n            assert_eq!(name.to_string(), \"mydb.myfunc\");\n            assert_eq!(\n                params,\n                CreateFunctionBody {\n                    as_: Some(FunctionDefinition::SingleQuotedDef(\n                        \"org.random.class.Name\".to_string()\n                    )),\n                    using: Some(CreateFunctionUsing::Jar(\n                        \"hdfs://somewhere.com:8020/very/far\".to_string()\n                    )),\n                    ..Default::default()\n                }\n            )\n        }\n        _ => unreachable!(),\n    }\n\n    assert_eq!(\n        generic(None).parse_sql_statements(sql).unwrap_err(),\n        ParserError::ParserError(\n            \"Expected an object type after CREATE, found: FUNCTION\".to_string()\n        )\n    );\n\n    let sql = \"CREATE TEMPORARY FUNCTION mydb.myfunc AS 'org.random.class.Name' USING JAR\";\n    assert_eq!(\n        hive().parse_sql_statements(sql).unwrap_err(),\n        ParserError::ParserError(\"Expected literal string, found: EOF\".to_string()),\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_space_separated_list", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_space_separated_list() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \"3 6 9\"])\n        .pipe_in(\"a\\tb\\tc\\td\\te\")\n        .succeeds()\n        .stdout_is(\"a  b  c  d e\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_arch.rs::test_arch_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_arch_help() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .succeeds()\n        .stdout_contains(\"architecture name\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn file_too_large() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement();\\n\".repeat(80660).as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                file_path.as_os_str().to_str().unwrap(),\n                (\"--write\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_server_remove_leader_with_uncommitted_log", "code": "fn test_remove_leader_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // stop peer 2 replicate messages.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv),\n    ));\n    // peer 2 can't step to leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgRequestVote)\n            .direction(Direction::Send),\n    ));\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.remove_peer(1, new_peer(1, 1));\n\n    // wait for the leader receive the remove order.\n    sleep_ms(1000);\n\n    let region = cluster.get_region(b\"\");\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let mut put = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        reqs,\n        false,\n    );\n    debug!(\"requesting: {:?}\", put);\n    put.mut_header().set_peer(new_peer(1, 1));\n    cluster.clear_send_filters();\n    let resp = cluster.call_command(put, Duration::from_secs(5)).unwrap();\n    assert!(resp.get_header().has_error());\n    assert!(\n        resp.get_header().get_error().has_region_not_found(),\n        \"{:?} should have region not found\",\n        resp\n    );\n}", "test": "fn test_server_remove_leader_with_uncommitted_log() {\n    let mut cluster = new_server_cluster(0, 2);\n    test_remove_leader_with_uncommitted_log(&mut cluster);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::assign_to_object_decl", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn assign_to_object_decl() {\n    run_test_actions([TestAction::assert_native_error(\n        \"{a: 3} = {a: 5};\",\n        JsNativeErrorKind::Syntax,\n        \"unexpected token '=', primary expression at line 1, col 8\",\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/security.rs::test_check_cn_fail", "code": "pub fn kv_get(&self, req: &super::kvrpcpb::GetRequest) -> ::grpcio::Result<super::kvrpcpb::GetResponse> {\n        self.kv_get_opt(req, ::grpcio::CallOption::default())\n    }", "test": "fn test_check_cn_fail() {\n    let mut cluster = new_server_cluster(0, 1);\n    let mut allowed_cn = HashSet::default();\n    allowed_cn.insert(\"invaild-server\".to_owned());\n    cluster.cfg.security = test_util::new_security_cfg(Some(allowed_cn));\n    cluster.run();\n\n    let leader = cluster.get_region(b\"\").get_peers()[0].clone();\n    let addr = cluster.sim.rl().get_addr(leader.get_store_id());\n\n    let env = Arc::new(Environment::new(1));\n    let cred = test_util::new_channel_cred();\n    let channel = ChannelBuilder::new(env).secure_connect(&addr, cred);\n\n    let client = TikvClient::new(channel);\n    let status = client.kv_get(&GetRequest::default());\n    status.unwrap_err();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_no_match4", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_no_match4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%\", \"/4/\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_scheduler_leader_change_twice", "code": "pub fn has_stale_command(&self) -> bool {\n        self.stale_command.is_some()\n    }", "test": "fn test_scheduler_leader_change_twice() {\n    let snapshot_fp = \"scheduler_async_snapshot_finish\";\n    let mut cluster = new_server_cluster(0, 2);\n    cluster.run();\n    let region0 = cluster.get_region(b\"\");\n    let peers = region0.get_peers();\n    cluster.must_transfer_leader(region0.get_id(), peers[0].clone());\n    let engine0 = cluster.sim.rl().storages[&peers[0].get_id()].clone();\n    let storage0 =\n        TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine0, MockLockManager::new())\n            .build()\n            .unwrap();\n\n    let mut ctx0 = Context::default();\n    ctx0.set_region_id(region0.get_id());\n    ctx0.set_region_epoch(region0.get_region_epoch().clone());\n    ctx0.set_peer(peers[0].clone());\n    let (prewrite_tx, prewrite_rx) = channel();\n    fail::cfg(snapshot_fp, \"pause\").unwrap();\n    storage0\n        .sched_txn_command(\n            commands::Prewrite::new(\n                vec![Mutation::make_put(Key::from_raw(b\"k\"), b\"v\".to_vec())],\n                b\"k\".to_vec(),\n                10.into(),\n                0,\n                false,\n                0,\n                TimeStamp::default(),\n                TimeStamp::default(),\n                None,\n                false,\n                AssertionLevel::Off,\n                ctx0,\n            ),\n            Box::new(move |res: storage::Result<_>| {\n                prewrite_tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    // Sleep to make sure the failpoint is triggered.\n    thread::sleep(Duration::from_millis(2000));\n    // Transfer leader twice, then unblock snapshot.\n    cluster.must_transfer_leader(region0.get_id(), peers[1].clone());\n    cluster.must_transfer_leader(region0.get_id(), peers[0].clone());\n    fail::remove(snapshot_fp);\n\n    match prewrite_rx.recv_timeout(Duration::from_secs(5)).unwrap() {\n        Err(Error(box ErrorInner::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n            box KvErrorInner::Request(ref e),\n        ))))))\n        | Err(Error(box ErrorInner::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n            box MvccErrorInner::Kv(KvError(box KvErrorInner::Request(ref e))),\n        ))))))\n        | Err(Error(box ErrorInner::Kv(KvError(box KvErrorInner::Request(ref e))))) => {\n            assert!(e.has_stale_command(), \"{:?}\", e);\n        }\n        res => {\n            panic!(\"expect stale command, but got {:?}\", res);\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_repeat_over", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_repeat_over() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\", \"{50}\"])\n        .fails()\n        .stdout_is(\"16\\n29\\n30\\n30\\n30\\n6\\n\")\n        .stderr_is(\"csplit: '/9$/': match not found on repetition 5\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\", \"{50}\", \"-k\"])\n        .fails()\n        .stdout_is(\"16\\n29\\n30\\n30\\n30\\n6\\n\")\n        .stderr_is(\"csplit: '/9$/': match not found on repetition 5\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 6);\n    assert_eq!(at.read(\"xx00\"), generate(1, 9));\n    assert_eq!(at.read(\"xx01\"), generate(9, 19));\n    assert_eq!(at.read(\"xx02\"), generate(19, 29));\n    assert_eq!(at.read(\"xx03\"), generate(29, 39));\n    assert_eq!(at.read(\"xx04\"), generate(39, 49));\n    assert_eq!(at.read(\"xx05\"), generate(49, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header_error_if_non_numeric", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_header_error_if_non_numeric() {\n    new_ucmd!()\n        .args(&[\"--header=two\"])\n        .run()\n        .stderr_is(\"numfmt: invalid header value 'two'\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_preserve_all", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_cp_preserve_all() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let src_file = \"a\";\n    let dst_file = \"b\";\n\n    // Prepare the source file\n    at.touch(src_file);\n    #[cfg(unix)]\n    at.set_mode(src_file, 0o0500);\n\n    // TODO: create a destination that does not allow copying of xattr and context\n    // Copy\n    ucmd.arg(src_file)\n        .arg(dst_file)\n        .arg(\"--preserve=all\")\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        // Assert that the mode, ownership, and timestamps are preserved\n        // NOTICE: the ownership is not modified on the src file, because that requires root permissions\n        let metadata_src = at.metadata(src_file);\n        let metadata_dst = at.metadata(dst_file);\n        assert_metadata_eq!(metadata_src, metadata_dst);\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::client_alpn_unset", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn client_alpn_unset() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(err) }) if err.error_code == TransportErrorCode::crypto(0x78)\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_schema", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_drop_schema() {\n    let sql = \"DROP SCHEMA X\";\n\n    match verified_stmt(sql) {\n        Statement::Drop { object_type, .. } => assert_eq!(object_type, ObjectType::Schema),\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_enum", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_parse_enum() {\n    test_parse_ok(vec![\n        (\"\\\"Dog\\\"\", Animal::Dog),\n        (\" \\\"Dog\\\" \", Animal::Dog),\n        (\n            \"{\\\"Frog\\\":[\\\"Henry\\\",[]]}\",\n            Animal::Frog(\"Henry\".to_string(), vec![]),\n        ),\n        (\n            \" { \\\"Frog\\\": [ \\\"Henry\\\" , [ 349, 102 ] ] } \",\n            Animal::Frog(\"Henry\".to_string(), vec![349, 102]),\n        ),\n        (\n            \"{\\\"Cat\\\": {\\\"age\\\": 5, \\\"name\\\": \\\"Kate\\\"}}\",\n            Animal::Cat {\n                age: 5,\n                name: \"Kate\".to_string(),\n            },\n        ),\n        (\n            \" { \\\"Cat\\\" : { \\\"age\\\" : 5 , \\\"name\\\" : \\\"Kate\\\" } } \",\n            Animal::Cat {\n                age: 5,\n                name: \"Kate\".to_string(),\n            },\n        ),\n        (\n            \" { \\\"AntHive\\\" : [\\\"Bob\\\", \\\"Stuart\\\"] } \",\n            Animal::AntHive(vec![\"Bob\".to_string(), \"Stuart\".to_string()]),\n        ),\n    ]);\n\n    test_parse_unusual_ok(vec![\n        (\"{\\\"Dog\\\":null}\", Animal::Dog),\n        (\" { \\\"Dog\\\" : null } \", Animal::Dog),\n    ]);\n\n    test_parse_ok(vec![(\n        concat!(\n            \"{\",\n            \"  \\\"a\\\": \\\"Dog\\\",\",\n            \"  \\\"b\\\": {\\\"Frog\\\":[\\\"Henry\\\", []]}\",\n            \"}\"\n        ),\n        treemap!(\n            \"a\".to_string() => Animal::Dog,\n            \"b\".to_string() => Animal::Frog(\"Henry\".to_string(), vec![]),\n        ),\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_pop_rollback", "code": "pub fn is_none(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_none(),\n            }\n        }\n    }", "test": "fn save_point_pop_rollback() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.set_save_point();\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.pop_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n    let err = wb.pop_save_point();\n    assert_engine_error(err);\n    wb.write().unwrap();\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n    let val = db.engine.get_value(b\"b\").unwrap();\n    assert!(val.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.set_save_point();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.pop_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n    let err = wb.pop_save_point();\n    assert_engine_error(err);\n    wb.write().unwrap();\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n    let val = db.engine.get_value(b\"b\").unwrap();\n    assert!(val.is_none());\n    for i in 0..512_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_restart_leader_secure", "code": "fn restart_leader(mgr: SecurityManager) {\n    let mgr = Arc::new(mgr);\n    // Service has only one GetMembersResponse, so the leader never changes.\n    let mut server =\n        MockServer::<Service>::with_configuration(&mgr, vec![(\"127.0.0.1\".to_owned(), 0); 3], None);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), Some(Arc::clone(&mgr)));\n    // Put a region.\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer);\n    client.bootstrap_cluster(store, region.clone()).unwrap();\n\n    let region = block_on(client.get_region_by_id(region.get_id()))\n        .unwrap()\n        .unwrap();\n\n    // Stop servers and restart them again.\n    server.stop();\n    server.start(&mgr, eps);\n\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let region = block_on(client.get_region_by_id(region.get_id())).unwrap();\n    assert_eq!(region.unwrap().get_id(), region_id);\n}", "test": "fn test_restart_leader_secure() {\n    let security_cfg = test_util::new_security_cfg(None);\n    let mgr = SecurityManager::new(&security_cfg).unwrap();\n    restart_leader(mgr)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_cannot_be_zero", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_tabs_cannot_be_zero() {\n    new_ucmd!()\n        .arg(\"--tabs=0\")\n        .fails()\n        .stderr_contains(\"tab size cannot be 0\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_backward_range", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_backward_range() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"c\", b\"a\").unwrap();\n    recover_safe(|| {\n        wb.write().unwrap();\n    })\n    .unwrap_err();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.delete_range(b\"c\", b\"a\").unwrap();\n    wb.delete_range(&256_usize.to_be_bytes(), &0_usize.to_be_bytes())\n        .unwrap();\n\n    recover_safe(|| {\n        wb.write().unwrap();\n    })\n    .unwrap_err();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_some());\n    for i in 0..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_it", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_it() {\n    // Test iterators that skip single, internal or trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4_5_.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_full_day", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_format_full_day() {\n    let re = Regex::new(r\"\\S+ \\d{4}-\\d{2}-\\d{2}\").unwrap();\n    new_ucmd!()\n        .arg(\"+'%a %Y-%m-%d'\")\n        .succeeds()\n        .stdout_matches(&re);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_no_match", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_no_match() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/nope/': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_a_package_that_uses_an_atom_from_a_dependency", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn run_a_package_that_uses_an_atom_from_a_dependency() {\n    let js_script_dir = project_root()\n        .join(\"tests\")\n        .join(\"integration\")\n        .join(\"cli\")\n        .join(\"tests\")\n        .join(\"packages\")\n        .join(\"js-script\");\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(&js_script_dir)\n        .arg(\"--registry=wasmer.io\")\n        .env(\"RUST_LOG\", &*RUST_LOG)\n        .assert();\n\n    assert.success().stdout(contains(\"Hello, World!\"));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_rejects_adt_keys", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_serialize_rejects_adt_keys() {\n    let map = treemap!(\n        Some(\"a\") => 2,\n        Some(\"b\") => 4,\n        None => 6,\n    );\n\n    let err = to_vec(&map).unwrap_err();\n    assert_eq!(err.to_string(), \"key must be a string\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_must_be_ascending", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_tabs_must_be_ascending() {\n    new_ucmd!()\n        .arg(\"--tabs=1,1\")\n        .fails()\n        .stderr_contains(\"tab sizes must be ascending\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_kv_service.rs::test_undetermined_write_err", "code": "pub fn to_string(&self) -> Result<String> {\n        let s = match *self {\n            Datum::I64(i) => format!(\"{}\", i),\n            Datum::U64(u) => format!(\"{}\", u),\n            Datum::F64(f) => format!(\"{}\", f),\n            Datum::Bytes(ref bs) => String::from_utf8(bs.to_vec())?,\n            Datum::Time(t) => format!(\"{}\", t),\n            Datum::Dur(ref d) => format!(\"{}\", d),\n            Datum::Dec(ref d) => format!(\"{}\", d),\n            Datum::Json(ref d) => d.to_string(),\n            Datum::Enum(ref e) => e.to_string(),\n            Datum::Set(ref s) => s.to_string(),\n            ref d => return Err(invalid_type!(\"can't convert {} to string\", d)),\n        };\n        Ok(s)\n    }", "test": "fn test_undetermined_write_err() {\n    let (cluster, leader, ctx) = must_new_cluster_mul(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env)\n        .keepalive_time(Duration::from_millis(500))\n        .keepalive_timeout(Duration::from_millis(500))\n        .connect(&cluster.sim.read().unwrap().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.set_key(b\"k\".to_vec());\n    mutation.set_value(b\"v\".to_vec());\n    fail::cfg(\"applied_cb_return_undetermined_err\", \"return()\").unwrap();\n    let err = try_kv_prewrite_with_impl(\n        &client,\n        ctx,\n        vec![mutation],\n        b\"k\".to_vec(),\n        10,\n        0,\n        false,\n        false,\n    )\n    .unwrap_err();\n    assert_eq!(err.to_string(), \"RpcFailure: 1-CANCELLED CANCELLED\",);\n    fail::remove(\"applied_cb_return_undetermined_err\");\n    // The previous panic hasn't been captured.\n    assert!(std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| drop(cluster))).is_err());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_one_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_one_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_rm_one_file\";\n\n    at.touch(file);\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_can_send_3_inital_packets", "code": "pub(super) fn drive(&mut self) {\n        while self.step() {}\n    }", "test": "fn server_can_send_3_inital_packets() {\n    let _guard = subscribe();\n\n    let (cert, key) = big_cert_and_key();\n    let server = server_config_with_cert(cert.clone(), key);\n    let client = client_config_with_certs(vec![cert]);\n    let mut pair = Pair::new(Default::default(), server);\n\n    let client_ch = pair.begin_connect(client);\n    // Client sends initial\n    pair.drive_client();\n    // Server sends first flight, gets blocked on anti-amplification\n    pair.drive_server();\n    // Server should have queued 3 packets at this time\n    assert_eq!(pair.client.inbound.len(), 3);\n\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::version", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn version() {\n    new_ucmd!().arg(\"--version\").succeeds();\n    new_ucmd!().arg(\"-V\").succeeds();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/init.rs::exists", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn exists() {\n  let output = Test::new()\n    .no_justfile()\n    .arg(\"--init\")\n    .stderr_regex(\"Wrote justfile to `.*`\\n\")\n    .run();\n\n  Test::with_tempdir(output.tempdir)\n    .no_justfile()\n    .arg(\"--init\")\n    .status(EXIT_FAILURE)\n    .stderr_regex(\"error: Justfile `.*` already exists\\n\")\n    .run();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::undefined_comparison1", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn undefined_comparison1() {\n    test(\"undefined == undefined\", \"!0;\");\n    test(\"undefined == null\", \"!0;\");\n    test(\"undefined == void 0\", \"!0;\");\n\n    test(\"undefined == 0\", \"!1;\");\n    test(\"undefined == 1\", \"!1;\");\n    test(\"undefined == 'hi'\", \"!1;\");\n    test(\"undefined == true\", \"!1;\");\n    test(\"undefined == false\", \"!1;\");\n\n    test(\"undefined === undefined\", \"!0;\");\n    test(\"undefined === null\", \"!1;\");\n    test(\"undefined === void 0\", \"!0;\");\n\n    // origin was `test_same(\"undefined == this;\");`\n    test(\"undefined == this\", \"void 0==this;\");\n    // origin was `test_same(\"undefined == x;\");`\n    test(\"undefined == x\", \"void 0==x;\");\n\n    test(\"undefined != undefined\", \"!1;\");\n    test(\"undefined != null\", \"!1;\");\n    test(\"undefined != void 0\", \"!1;\");\n\n    test(\"undefined != 0\", \"!0;\");\n    test(\"undefined != 1\", \"!0;\");\n    test(\"undefined != 'hi'\", \"!0;\");\n    test(\"undefined != true\", \"!0;\");\n    test(\"undefined != false\", \"!0;\");\n\n    test(\"undefined !== undefined\", \"!1;\");\n    test(\"undefined !== void 0\", \"!1;\");\n    test(\"undefined !== null\", \"!0;\");\n\n    // origin was `test_same(\"undefined != this;\");`\n    test(\"undefined != this\", \"void 0!=this;\");\n    // origin was `test_same(\"undefined != x;\");`\n    test(\"undefined != x\", \"void 0!=x;\");\n\n    test(\"undefined < undefined\", \"!1;\");\n    test(\"undefined > undefined\", \"!1;\");\n    test(\"undefined >= undefined\", \"!1;\");\n    test(\"undefined <= undefined\", \"!1;\");\n\n    test(\"0 < undefined\", \"!1;\");\n    test(\"true > undefined\", \"!1;\");\n    test(\"'hi' >= undefined\", \"!1;\");\n    test(\"null <= undefined\", \"!1;\");\n\n    test(\"undefined < 0\", \"!1;\");\n    test(\"undefined > true\", \"!1;\");\n    test(\"undefined >= 'hi'\", \"!1;\");\n    test(\"undefined <= null\", \"!1;\");\n\n    test(\"null == undefined\", \"!0;\");\n    test(\"0 == undefined\", \"!1;\");\n    test(\"1 == undefined\", \"!1;\");\n    test(\"'hi' == undefined\", \"!1;\");\n    test(\"true == undefined\", \"!1;\");\n    test(\"false == undefined\", \"!1;\");\n    test(\"null === undefined\", \"!1;\");\n    test(\"void 0 === undefined\", \"!0;\");\n\n    test(\"undefined == NaN\", \"!1;\");\n    test(\"NaN == undefined\", \"!1;\");\n    test(\"undefined == Infinity\", \"!1;\");\n    test(\"Infinity == undefined\", \"!1;\");\n    test(\"undefined == -Infinity\", \"!1;\");\n    test(\"-Infinity == undefined\", \"!1;\");\n    test(\"({}) == undefined\", \"!1;\");\n    test(\"undefined == ({})\", \"!1;\");\n    test(\"([]) == undefined\", \"!1;\");\n    test(\"undefined == ([])\", \"!1;\");\n    test(\"(/a/g) == undefined\", \"!1;\");\n    test(\"undefined == (/a/g)\", \"!1;\");\n    test(\"(function(){}) == undefined\", \"!1;\");\n    test(\"undefined == (function(){})\", \"!1;\");\n\n    test(\"undefined != NaN\", \"!0;\");\n    test(\"NaN != undefined\", \"!0;\");\n    test(\"undefined != Infinity\", \"!0;\");\n    test(\"Infinity != undefined\", \"!0;\");\n    test(\"undefined != -Infinity\", \"!0;\");\n    test(\"-Infinity != undefined\", \"!0;\");\n    test(\"({}) != undefined\", \"!0;\");\n    test(\"undefined != ({})\", \"!0;\");\n    test(\"([]) != undefined\", \"!0;\");\n    test(\"undefined != ([])\", \"!0;\");\n    test(\"(/a/g) != undefined\", \"!0;\");\n    test(\"undefined != (/a/g)\", \"!0;\");\n    test(\"(function(){}) != undefined\", \"!0;\");\n    test(\"undefined != (function(){})\", \"!0;\");\n\n    // origin was `test_same(\"this == undefined;\");`\n    test(\"this == undefined\", \"this==void 0;\");\n    // origin was `test_same(\"x == undefined;\");`\n    test(\"x == undefined\", \"x==void 0;\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_untagged_b_de", "code": "fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n}", "test": "fn test_untagged_b_de() {\n    let s = \"(foo:1,bar:2)\";\n    let e = EnumStructUntagged::VariantB { foo: 1, bar: 2 };\n    test_de(s, e);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_deps", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn newline_escape_deps() {\n  Test::new()\n    .justfile(\n      \"\n      default: a \\\\\n               b \\\\\n               c\n      a:\n        echo a\n      b:\n        echo b\n      c:\n        echo c\n    \",\n    )\n    .stdout(\"a\\nb\\nc\\n\")\n    .stderr(\"echo a\\necho b\\necho c\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_existing_require_directories", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_relative_existing_require_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"dir1\");\n    at.touch(\"dir1/f\");\n    ucmd.args(&[\"-e\", \"--relative-base=.\", \"--relative-to=dir1/f\", \".\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"directory\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_snowflake_stage_object_names", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_snowflake_stage_object_names() {\n    let allowed_formatted_names = [\n        \"my_company.emp_basic\",\n        \"@namespace.%table_name\",\n        \"@namespace.%table_name/path\",\n        \"@namespace.stage_name/path\",\n        \"@~/path\",\n    ];\n    let mut allowed_object_names = vec![\n        ObjectName(vec![Ident::new(\"my_company\"), Ident::new(\"emp_basic\")]),\n        ObjectName(vec![Ident::new(\"@namespace\"), Ident::new(\"%table_name\")]),\n        ObjectName(vec![\n            Ident::new(\"@namespace\"),\n            Ident::new(\"%table_name/path\"),\n        ]),\n        ObjectName(vec![\n            Ident::new(\"@namespace\"),\n            Ident::new(\"stage_name/path\"),\n        ]),\n        ObjectName(vec![Ident::new(\"@~/path\")]),\n    ];\n\n    for it in allowed_formatted_names\n        .iter()\n        .zip(allowed_object_names.iter_mut())\n    {\n        let (formatted_name, object_name) = it;\n        let sql = format!(\n            \"COPY INTO {} FROM 'gcs://mybucket/./../a.csv'\",\n            formatted_name\n        );\n        match snowflake().verified_stmt(&sql) {\n            Statement::CopyIntoSnowflake { into, .. } => {\n                assert_eq!(into.0, object_name.0)\n            }\n            _ => unreachable!(),\n        }\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_against_concurrency", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_against_concurrency() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(1))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client.recv_frame(frames::headers(2).response(200)).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 4).request(\"GET\", \"https://http2.akamai.com/style2.css\"),\n            )\n            .await;\n        client.recv_frame(frames::data(2, &b\"\"[..]).eos()).await;\n        client\n            .recv_frame(frames::headers(4).response(200).eos())\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Promise stream 2 and start response (concurrency limit reached)\n        let mut s2_tx = {\n            let req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let mut pushed_stream = stream.push_request(req).unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            pushed_stream.send_response(rsp, false).unwrap()\n        };\n\n        // Promise stream 4 and push response\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style2.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // Send and finish response for stream 1\n        {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream.send_response(rsp, true).unwrap();\n        }\n\n        // Finish response for stream 2 (at which point stream 4 will be sent)\n        s2_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_subquery_function_argument", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_subquery_function_argument() {\n    // Snowflake allows passing an unparenthesized subquery as the single\n    // argument to a function.\n    snowflake().one_statement_parses_to(\n        \"SELECT parse_json(SELECT '{}')\",\n        \"SELECT parse_json((SELECT '{}'))\",\n    );\n\n    // Subqueries that begin with WITH work too.\n    snowflake().one_statement_parses_to(\n        \"SELECT parse_json(WITH q AS (SELECT '{}' AS foo) SELECT foo FROM q)\",\n        \"SELECT parse_json((WITH q AS (SELECT '{}' AS foo) SELECT foo FROM q))\",\n    );\n\n    // Commas are parsed as part of the subquery, not additional arguments to\n    // the function.\n    snowflake().one_statement_parses_to(\"SELECT func(SELECT 1, 2)\", \"SELECT func((SELECT 1, 2))\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stdbuf.rs::test_stdbuf_invalid_mode_fails", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_stdbuf_invalid_mode_fails() {\n    let options = [\"--input\", \"--output\", \"--error\"];\n    for option in &options {\n        new_ucmd!()\n            .args(&[*option, \"1024R\", \"head\"])\n            .fails()\n            .code_is(125)\n            .stderr_only(\"stdbuf: invalid mode '1024R'\\n\");\n        #[cfg(not(target_pointer_width = \"128\"))]\n        new_ucmd!()\n            .args(&[*option, \"1Y\", \"head\"])\n            .fails()\n            .code_is(125)\n            .stderr_contains(\"stdbuf: invalid mode '1Y': Value too large for defined data type\");\n        #[cfg(target_pointer_width = \"32\")]\n        {\n            new_ucmd!()\n                .args(&[*option, \"5GB\", \"head\"])\n                .fails()\n                .code_is(125)\n                .stderr_contains(\n                    \"stdbuf: invalid mode '5GB': Value too large for defined data type\",\n                );\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_follow_multiple_untailable", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_follow_multiple_untailable() {\n    // $ tail -f DIR1 DIR2\n    // ==> DIR1 <==\n    // tail: error reading 'DIR1': Is a directory\n    // tail: DIR1: cannot follow end of this type of file; giving up on this name\n    //\n    // ==> DIR2 <==\n    // tail: error reading 'DIR2': Is a directory\n    // tail: DIR2: cannot follow end of this type of file; giving up on this name\n    // tail: no files remaining\n\n    let expected_stdout = \"==> DIR1 <==\\n\\n==> DIR2 <==\\n\";\n    let expected_stderr = \"tail: error reading 'DIR1': Is a directory\\n\\\n        tail: DIR1: cannot follow end of this type of file; giving up on this name\\n\\\n        tail: error reading 'DIR2': Is a directory\\n\\\n        tail: DIR2: cannot follow end of this type of file; giving up on this name\\n\\\n        tail: no files remaining\\n\";\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"DIR1\");\n    at.mkdir(\"DIR2\");\n    ucmd.arg(\"-f\")\n        .arg(\"DIR1\")\n        .arg(\"DIR2\")\n        .fails()\n        .stderr_is(expected_stderr)\n        .stdout_is(expected_stdout)\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dirname.rs::test_path_without_trailing_slashes", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_path_without_trailing_slashes() {\n    new_ucmd!()\n        .arg(\"/root/alpha/beta/gamma/delta/epsilon/omega\")\n        .run()\n        .stdout_is(\"/root/alpha/beta/gamma/delta/epsilon\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_declaration", "code": "pub fn concat(&self, items: &[JsValue], context: &mut Context<'_>) -> JsResult<Self> {\n        let object = Array::concat(&self.inner.clone().into(), items, context)?\n            .as_object()\n            .cloned()\n            .expect(\"Array.prototype.filter should always return object\");\n\n        Self::from_object(object)\n    }", "test": "fn for_in_declaration() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let obj = { a: \"a\", b: 2};\n                var i;\n                for (i in obj) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['a', 'b'])\"),\n    ]);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_substring", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_substring() {\n    let from_for_supported_dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(SnowflakeDialect {}),\n            Box::new(HiveDialect {}),\n            Box::new(RedshiftSqlDialect {}),\n            Box::new(MySqlDialect {}),\n            Box::new(BigQueryDialect {}),\n            Box::new(SQLiteDialect {}),\n            Box::new(DuckDbDialect {}),\n        ],\n        options: None,\n    };\n\n    let from_for_unsupported_dialects = TestedDialects {\n        dialects: vec![Box::new(MsSqlDialect {})],\n        options: None,\n    };\n\n    from_for_supported_dialects\n        .one_statement_parses_to(\"SELECT SUBSTRING('1')\", \"SELECT SUBSTRING('1')\");\n\n    from_for_supported_dialects.one_statement_parses_to(\n        \"SELECT SUBSTRING('1' FROM 1)\",\n        \"SELECT SUBSTRING('1' FROM 1)\",\n    );\n\n    from_for_supported_dialects.one_statement_parses_to(\n        \"SELECT SUBSTRING('1' FROM 1 FOR 3)\",\n        \"SELECT SUBSTRING('1' FROM 1 FOR 3)\",\n    );\n\n    from_for_unsupported_dialects\n        .one_statement_parses_to(\"SELECT SUBSTRING('1', 1, 3)\", \"SELECT SUBSTRING('1', 1, 3)\");\n\n    from_for_supported_dialects\n        .one_statement_parses_to(\"SELECT SUBSTRING('1' FOR 3)\", \"SELECT SUBSTRING('1' FOR 3)\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_demote_non_exist_voters", "code": "pub fn get_role(&self, f: Box<dyn FnOnce(Role) + Send>) {\n        self.notify_scheduler(Task::GetRole(f));\n    }", "test": "fn test_unsafe_recovery_demote_non_exist_voters() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n    let peer_on_store2 = find_peer(&region, nodes[2]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store2.clone());\n    cluster.stop_node(nodes[1]);\n    cluster.stop_node(nodes[2]);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n    cluster.must_enter_force_leader(region.get_id(), nodes[0], vec![nodes[1], nodes[2]]);\n\n    let mut plan = pdpb::RecoveryPlan::default();\n    let mut demote = pdpb::DemoteFailedVoters::default();\n    demote.set_region_id(region.get_id());\n    let mut peer = metapb::Peer::default();\n    peer.set_id(12345);\n    peer.set_store_id(region.get_id());\n    peer.set_role(metapb::PeerRole::Voter);\n    demote.mut_failed_voters().push(peer);\n    plan.mut_demotes().push(demote);\n    pd_client.must_set_unsafe_recovery_plan(nodes[0], plan);\n    cluster.must_send_store_heartbeat(nodes[0]);\n\n    let mut store_report = None;\n    for _ in 0..20 {\n        store_report = pd_client.must_get_store_report(nodes[0]);\n        if store_report.is_some() {\n            break;\n        }\n        sleep_ms(100);\n    }\n    assert_ne!(store_report, None);\n    let report = store_report.unwrap();\n    let peer_reports = report.get_peer_reports();\n    assert_eq!(peer_reports.len(), 1);\n    let reported_region = peer_reports[0].get_region_state().get_region();\n    assert_eq!(reported_region.get_id(), region.get_id());\n    assert_eq!(reported_region.get_peers().len(), 3);\n    let demoted = reported_region\n        .get_peers()\n        .iter()\n        .any(|peer| peer.get_role() != metapb::PeerRole::Voter);\n    assert_eq!(demoted, false);\n\n    let region_in_pd = block_on(pd_client.get_region_by_id(region.get_id()))\n        .unwrap()\n        .unwrap();\n    assert_eq!(region_in_pd.get_peers().len(), 3);\n    let demoted = region_in_pd\n        .get_peers()\n        .iter()\n        .any(|peer| peer.get_role() != metapb::PeerRole::Voter);\n    assert_eq!(demoted, false);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_cname_lookup_preserve", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }", "test": "fn test_cname_lookup_preserve() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(\n        resp_query,\n        vec![cname_record.clone(), v4_record],\n        vec![],\n        vec![],\n    );\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, true),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    let mut iter = lookup.iter();\n    assert_eq!(iter.next().unwrap(), cname_record.data().unwrap());\n    assert_eq!(*iter.next().unwrap(), RData::A(A::new(93, 184, 216, 34)));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_29", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_29() {\n    let original = r##\"# H1 \\{.foo}\n## H2 \\\\{.bar}\n### stray backslash at the end is preserved \\\n\"##;\n    let expected = r##\"<h1 class=\"foo\">H1 \\</h1>\n<h2 class=\"bar\">H2 \\</h2>\n<h3>stray backslash at the end is preserved \\</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents_with_permissions_copy_file", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_cp_parents_with_permissions_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"dir\";\n    let file = \"p1/p2/file\";\n\n    at.mkdir(dir);\n    at.mkdir_all(\"p1/p2\");\n    at.touch(file);\n\n    #[cfg(unix)]\n    {\n        let p1_mode = 0o0777;\n        let p2_mode = 0o0711;\n        let file_mode = 0o0702;\n\n        at.set_mode(\"p1\", p1_mode);\n        at.set_mode(\"p1/p2\", p2_mode);\n        at.set_mode(file, file_mode);\n    }\n\n    ucmd.arg(\"-p\")\n        .arg(\"--parents\")\n        .arg(file)\n        .arg(dir)\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        let p1_metadata = at.metadata(\"p1\");\n        let p2_metadata = at.metadata(\"p1/p2\");\n        let file_metadata = at.metadata(file);\n\n        assert_metadata_eq!(p1_metadata, at.metadata(\"dir/p1\"));\n        assert_metadata_eq!(p2_metadata, at.metadata(\"dir/p1/p2\"));\n        assert_metadata_eq!(file_metadata, at.metadata(\"dir/p1/p2/file\"));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_hex_lowercase_uppercase", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hex_lowercase_uppercase() {\n    new_ucmd!()\n        .args(&[\"0xa\", \"0xA\"])\n        .succeeds()\n        .stdout_is(\"10\\n\");\n    new_ucmd!()\n        .args(&[\"0Xa\", \"0XA\"])\n        .succeeds()\n        .stdout_is(\"10\\n\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/250_variant_newtypes.rs::test_serialise_tuple_newtypes", "code": "fn assert_eq_serialize_roundtrip<\n    S: Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,\n>(\n    value: S,\n    extensions: Extensions,\n) {\n    assert_eq!(\n        from_str::<S>(\n            &to_string_pretty(&value, PrettyConfig::default().extensions(extensions)).unwrap()\n        )\n        .unwrap(),\n        value,\n    );\n}", "test": "fn test_serialise_tuple_newtypes() {\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeUnit(Unit),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n        Extensions::UNWRAP_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n        Extensions::UNWRAP_VARIANT_NEWTYPES | Extensions::UNWRAP_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeTuple((4, false)),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeTupleStruct(TupleStruct(4, false)),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeStruct(Struct { a: 4, b: false }),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeEnum(Enum::A),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeEnum(Enum::B(Struct { a: 4, b: false })),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeEnum(Enum::C(4, false)),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeEnum(Enum::D { a: 4, b: false }),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeOption(None),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeOption(Some(Struct { a: 4, b: false })),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeOption(Some(Struct { a: 4, b: false })),\n        Extensions::IMPLICIT_SOME,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeOption(Some(Struct { a: 4, b: false })),\n        Extensions::UNWRAP_VARIANT_NEWTYPES | Extensions::IMPLICIT_SOME,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeSeq(vec![]),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeSeq(vec![Struct { a: 4, b: false }]),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeMap(vec![].into_iter().collect()),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n    assert_eq_serialize_roundtrip(\n        TestEnum::TupleNewtypeMap(vec![(2, Struct { a: 4, b: false })].into_iter().collect()),\n        Extensions::UNWRAP_VARIANT_NEWTYPES,\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::new", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn new() {\n    test_formatting(\n        r#\"\n        function MyClass() {}\n        let inst = new MyClass();\n        \"#,\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_floor_number", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_floor_number() {\n    verified_stmt(\"SELECT FLOOR(1.5)\");\n    verified_stmt(\"SELECT FLOOR(float_column) FROM my_table\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_infinity_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_infinity_test() {\n    let mut builder = OptionsBuilder::default();\n    builder =\n        builder.infinity_string(Some(b\"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf\"));\n    assert!(!builder.is_valid());\n    builder = builder.infinity_string(Some(b\"nan\"));\n    assert!(!builder.is_valid());\n    builder = builder.infinity_string(Some(b\"i\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"infi000nity\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.inf_string(Some(b\"i\"));\n    assert!(builder.is_valid());\n    builder = builder.infinity_string(Some(b\"infinity\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.infinity_string(None);\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(None);\n    assert!(builder.is_valid());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtd_spec_test", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "test": "fn sqrtd_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtd(-1.0).is_nan());\n    assert!(libm::sqrtd(f64::NAN).is_nan());\n    for f in [0.0, -0.0, f64::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtd(f), f);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_on_hibernated_follower", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_on_hibernated_follower() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    // wait a while to hibernate\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 3,\n    ));\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::test_absolute_path_resolves", "code": "pub(crate) fn to_str(self) -> &'static str {\n    self.into()\n  }", "test": "fn test_absolute_path_resolves() {\n  let test_object = Test::new()\n    .justfile(\"path := absolute_path('./test_file')\")\n    .args([\"--evaluate\", \"path\"]);\n\n  let mut tempdir = test_object.tempdir.path().to_owned();\n\n  // Just retrieves the current directory via env::current_dir(), which\n  // does the moral equivalent of canonicalize, which will remove symlinks.\n  // So, we have to canonicalize here, so that we can match it.\n  if cfg!(unix) {\n    tempdir = tempdir.canonicalize().unwrap();\n  }\n\n  test_object\n    .stdout(tempdir.join(\"test_file\").to_str().unwrap().to_owned())\n    .run();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::no_join_condition", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn no_join_condition() {\n    let join = \"SELECT a, b FROM db.table_name JOIN a\";\n    hive().verified_stmt(join);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_read_execution_tracker.rs::test_read_execution_tracking", "code": "pub fn get_read_index_propose_wait_nanos(&self) -> u64 {\n        self.read_index_propose_wait_nanos\n    }", "test": "fn test_read_execution_tracking() {\n    let (_cluster, client, ctx) = must_new_cluster_and_kv_client();\n    let (k1, v1) = (b\"k1\".to_vec(), b\"v1\".to_vec());\n    let (k2, v2) = (b\"k2\".to_vec(), b\"v2\".to_vec());\n\n    // write entries\n    let mut mutation1 = Mutation::default();\n    mutation1.set_op(Op::Put);\n    mutation1.set_key(k1.clone());\n    mutation1.set_value(v1);\n\n    let mut mutation2 = Mutation::default();\n    mutation2.set_op(Op::Put);\n    mutation2.set_key(k2.clone());\n    mutation2.set_value(v2);\n\n    must_kv_prewrite(\n        &client,\n        ctx.clone(),\n        vec![mutation1, mutation2],\n        k1.clone(),\n        10,\n    );\n    must_kv_commit(\n        &client,\n        ctx.clone(),\n        vec![k1.clone(), k2.clone()],\n        10,\n        30,\n        30,\n    );\n\n    let lease_read_checker = |scan_detail: &ScanDetailV2| {\n        assert!(\n            scan_detail.get_read_index_propose_wait_nanos() == 0,\n            \"resp lease read propose wait time={:?}\",\n            scan_detail.get_read_index_propose_wait_nanos()\n        );\n\n        assert!(\n            scan_detail.get_read_index_confirm_wait_nanos() == 0,\n            \"resp lease read confirm wait time={:?}\",\n            scan_detail.get_read_index_confirm_wait_nanos()\n        );\n\n        assert!(\n            scan_detail.get_read_pool_schedule_wait_nanos() > 0,\n            \"resp read pool scheduling wait time={:?}\",\n            scan_detail.get_read_pool_schedule_wait_nanos()\n        );\n    };\n\n    fail::cfg(\"perform_read_local\", \"return()\").unwrap();\n\n    // should perform lease read\n    let resp = kv_read(&client, ctx.clone(), k1.clone(), 100);\n\n    lease_read_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    // should perform lease read\n    let resp = kv_batch_read(&client, ctx.clone(), vec![k1.clone(), k2.clone()], 100);\n\n    lease_read_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    let product = ProductTable::new();\n    init_with_data(&product, &[(1, Some(\"name:0\"), 2)]);\n    let mut coprocessor_request = DagSelect::from(&product).build();\n    coprocessor_request.set_context(ctx.clone());\n    coprocessor_request.set_start_ts(100);\n\n    // should perform lease read\n    let resp = client.coprocessor(&coprocessor_request).unwrap();\n\n    lease_read_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    fail::remove(\"perform_read_local\");\n\n    let read_index_checker = |scan_detail: &ScanDetailV2| {\n        assert!(\n            scan_detail.get_read_index_propose_wait_nanos() > 0,\n            \"resp lease read propose wait time={:?}\",\n            scan_detail.get_read_index_propose_wait_nanos()\n        );\n\n        assert!(\n            scan_detail.get_read_index_confirm_wait_nanos() > 0,\n            \"resp lease read confirm wait time={:?}\",\n            scan_detail.get_read_index_confirm_wait_nanos()\n        );\n\n        assert!(\n            scan_detail.get_read_pool_schedule_wait_nanos() > 0,\n            \"resp read pool scheduling wait time={:?}\",\n            scan_detail.get_read_pool_schedule_wait_nanos()\n        );\n    };\n\n    fail::cfg(\"perform_read_index\", \"return()\").unwrap();\n\n    // should perform read index\n    let resp = kv_read(&client, ctx.clone(), k1.clone(), 100);\n\n    read_index_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    // should perform read index\n    let resp = kv_batch_read(&client, ctx, vec![k1, k2], 100);\n\n    read_index_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    // should perform read index\n    let resp = client.coprocessor(&coprocessor_request).unwrap();\n\n    read_index_checker(resp.get_exec_details_v2().get_scan_detail_v2());\n\n    fail::remove(\"perform_read_index\");\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_close_notify", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_close_notify() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that alerts don't overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n        server.send_close_notify();\n\n        transfer(&mut server, &mut client);\n        let io_state = client.process_new_packets().unwrap();\n        assert!(io_state.peer_has_closed());\n        check_read_and_close(&mut client.reader(), b\"from-server!\");\n\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/store.rs::into_inner", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn into_inner() {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    assert_eq!(HITS.load(SeqCst), 0);\n    drop(Store::new(&engine, A));\n    assert_eq!(HITS.load(SeqCst), 1);\n    Store::new(&engine, A).into_data();\n    assert_eq!(HITS.load(SeqCst), 2);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::shl_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn shl_test() {\n    // Pattern generated via `''.join([\"1\" +\"0\"*i for i in range(20)])`\n    let mut x = VecType::from_u64(0xD2210408);\n    bigint::shl(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x44208100, 0x1A]);\n    assert_eq!(&*x, &*expected);\n\n    bigint::shl(&mut x, 32);\n    let expected: VecType = vec_from_u32(&[0, 0x44208100, 0x1A]);\n    assert_eq!(&*x, &*expected);\n\n    bigint::shl(&mut x, 27);\n    let expected: VecType = vec_from_u32(&[0, 0, 0xD2210408]);\n    assert_eq!(&*x, &*expected);\n\n    // 96-bits of previous pattern\n    let mut x: VecType = vec_from_u32(&[0x20020010, 0x8040100, 0xD2210408]);\n    bigint::shl(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[0x400200, 0x802004, 0x44208101, 0x1A]);\n    assert_eq!(&*x, &*expected);\n\n    bigint::shl(&mut x, 32);\n    let expected: VecType = vec_from_u32(&[0, 0x400200, 0x802004, 0x44208101, 0x1A]);\n    assert_eq!(&*x, &*expected);\n\n    bigint::shl(&mut x, 27);\n    let expected: VecType = vec_from_u32(&[0, 0, 0x20020010, 0x8040100, 0xD2210408]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::active_borrows_at_end_of_call", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn active_borrows_at_end_of_call() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core module $m\n                    (func (export \"f\") (param i32))\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(1);\n    f.call(&mut store, (&resource,))?;\n    let err = f.post_return(&mut store).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"borrow handles still remain at the end of the call\",\n    );\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w4\", \"-s\"])\n        .pipe_in(\"one two\")\n        .succeeds()\n        .stdout_is(\"one \\ntwo\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_linter_is_disabled", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn no_lint_if_linter_is_disabled() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::zero_length_cid", "code": "pub fn connect(\n        &mut self,\n        config: ClientConfig,\n        remote: SocketAddr,\n        server_name: &str,\n    ) -> Result<(ConnectionHandle, Connection), ConnectError> {\n        if self.is_full() {\n            return Err(ConnectError::TooManyConnections);\n        }\n        if remote.port() == 0 || remote.ip().is_unspecified() {\n            return Err(ConnectError::InvalidRemoteAddress(remote));\n        }\n        if !self.config.supported_versions.contains(&config.version) {\n            return Err(ConnectError::UnsupportedVersion);\n        }\n\n        let remote_id = RandomConnectionIdGenerator::new(MAX_CID_SIZE).generate_cid();\n        trace!(initial_dcid = %remote_id);\n\n        let loc_cid = self.new_cid();\n        let params = TransportParameters::new(\n            &config.transport,\n            &self.config,\n            self.local_cid_generator.as_ref(),\n            loc_cid,\n            None,\n        );\n        let tls = config\n            .crypto\n            .start_session(config.version, server_name, &params)?;\n\n        let (ch, conn) = self.add_connection(\n            config.version,\n            remote_id,\n            loc_cid,\n            remote_id,\n            FourTuple {\n                remote,\n                local_ip: None,\n            },\n            Instant::now(),\n            tls,\n            None,\n            config.transport,\n        );\n        Ok((ch, conn))\n    }", "test": "fn zero_length_cid() {\n    let _guard = subscribe();\n    let cid_generator_factory: fn() -> Box<dyn ConnectionIdGenerator> =\n        || Box::new(RandomConnectionIdGenerator::new(0));\n    let mut pair = Pair::new(\n        Arc::new(EndpointConfig {\n            connection_id_generator_factory: Arc::new(cid_generator_factory),\n            ..EndpointConfig::default()\n        }),\n        server_config(),\n    );\n    let (client_ch, server_ch) = pair.connect();\n    // Ensure we can reconnect after a previous connection is cleaned up\n    info!(\"closing\");\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(42), Bytes::new());\n    pair.drive();\n    pair.server\n        .connections\n        .get_mut(&server_ch)\n        .unwrap()\n        .close(pair.time, VarInt(42), Bytes::new());\n    pair.connect();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_scan_key_only", "code": "pub fn scan_key_only_ok(\n        &self,\n        start_key: &[u8],\n        end_key: Option<&[u8]>,\n        limit: usize,\n        ts: impl Into<TimeStamp>,\n        expect: Vec<Option<&[u8]>>,\n    ) {\n        let start_key = Key::from_raw(start_key);\n        let end_key = end_key.map(Key::from_raw);\n        let result = self\n            .store\n            .scan(self.ctx.clone(), start_key, end_key, limit, true, ts.into())\n            .unwrap();\n        let result: Vec<Option<KvPair>> = result.into_iter().map(Result::ok).collect();\n        let expect: Vec<Option<KvPair>> = expect\n            .into_iter()\n            .map(|x| x.map(|k| (k.to_vec(), vec![])))\n            .collect();\n        assert_eq!(result, expect);\n    }", "test": "fn test_txn_store_scan_key_only() {\n    let store = AssertionStorage::default();\n    store.put_ok(b\"A\", b\"A\", 5, 10);\n    store.put_ok(b\"B\", b\"B\", 5, 10);\n    store.put_ok(b\"C\", b\"C\", 5, 10);\n    store.scan_key_only_ok(b\"AA\", None, 2, 10, vec![Some(b\"B\"), Some(b\"C\")]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_twice_on_different_peers", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_force_leader_twice_on_different_peers() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    // restart to clean lease\n    cluster.stop_node(1);\n    cluster.run_node(1).unwrap();\n    cluster.stop_node(2);\n    cluster.run_node(2).unwrap();\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // enter force leader on a different peer\n    cluster.enter_force_leader(region.get_id(), 2, vec![3, 4, 5]);\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap(),\n        *find_peer(&region, 1).unwrap()\n    );\n\n    let conf_change = new_change_peer_request(ConfChangeType::RemoveNode, new_peer(3, 3));\n    let mut req = new_admin_request(region.get_id(), region.get_region_epoch(), conf_change);\n    req.mut_header()\n        .set_peer(find_peer(&region, 2).unwrap().clone());\n    let resp = cluster\n        .call_command(req, Duration::from_millis(10))\n        .unwrap();\n    let mut not_leader = kvproto::errorpb::NotLeader {\n        region_id: region.get_id(),\n        ..Default::default()\n    };\n    not_leader.set_leader(find_peer(&region, 1).unwrap().clone());\n    assert_eq!(resp.get_header().get_error().get_not_leader(), &not_leader,);\n\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uptime.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::delete", "code": "fn get_vec(\n    table: &impl ReadableMultimapTable<&'static str, &'static str>,\n    key: &str,\n) -> Vec<String> {\n    let mut result = vec![];\n    let mut iter = table.get(key).unwrap();\n    loop {\n        let item = iter.next();\n        if let Some(item_value) = item {\n            result.push(item_value.unwrap().value().to_string());\n        } else {\n            return result;\n        }\n    }\n}", "test": "fn delete() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello\", \"world2\").unwrap();\n        table.insert(\"hello\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\n            \"world\".to_string(),\n            \"world2\".to_string(),\n            \"world3\".to_string()\n        ],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 3);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.remove(\"hello\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\"world\".to_string(), \"world3\".to_string()],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 2);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        let mut iter = table.remove_all(\"hello\").unwrap();\n        assert_eq!(\"world\", iter.next().unwrap().unwrap().value());\n        assert_eq!(\"world3\", iter.next().unwrap().unwrap().value());\n        assert!(iter.next().is_none());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert!(table.is_empty().unwrap());\n    let empty: Vec<String> = vec![];\n    assert_eq!(empty, get_vec(&table, \"hello\"));\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_padding", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_padding() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 16, 0, 0x8, 0, 0, 0, 1,\n            5,       // Pad length\n            \"helloworld\", // Data\n            \"\\0\\0\\0\\0\\0\", // Padding\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"helloworld\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_read_from_directory_error", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_read_from_directory_error() {\n    #[cfg(not(windows))]\n    const STDERR: &str = \".: Is a directory\";\n    #[cfg(windows)]\n    const STDERR: &str = \".: Permission denied\";\n\n    #[cfg(not(windows))]\n    const STDOUT: &str = \"      0       0       0 .\\n\";\n    #[cfg(windows)]\n    const STDOUT: &str = \"\";\n\n    new_ucmd!()\n        .args(&[\".\"])\n        .fails()\n        .stderr_contains(STDERR)\n        .stdout_is(STDOUT);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::gnu_tests", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn gnu_tests() {\n    let cases = [\n        TestCase {\n            name: \"1\",\n            args: &[],\n            input: \"\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"2\",\n            args: &[],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"3\",\n            args: &[],\n            input: \"a\\na\",\n            stdout: Some(\"a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"4\",\n            args: &[],\n            input: \"a\\nb\",\n            stdout: Some(\"a\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"5\",\n            args: &[],\n            input: \"a\\na\\nb\",\n            stdout: Some(\"a\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"6\",\n            args: &[],\n            input: \"b\\na\\na\\n\",\n            stdout: Some(\"b\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"7\",\n            args: &[],\n            input: \"a\\nb\\nc\\n\",\n            stdout: Some(\"a\\nb\\nc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"2z\",\n            args: &[\"-z\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"3z\",\n            args: &[\"-z\"],\n            input: \"a\\na\",\n            stdout: Some(\"a\\na\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"4z\",\n            args: &[\"-z\"],\n            input: \"a\\nb\",\n            stdout: Some(\"a\\nb\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"5z\",\n            args: &[\"-z\"],\n            input: \"a\\na\\nb\",\n            stdout: Some(\"a\\na\\nb\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"10z\",\n            args: &[\"-z\", \"-f1\"],\n            input: \"a\\nb\\n\\0c\\nb\\n\\0\",\n            stdout: Some(\"a\\nb\\n\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"20z\",\n            args: &[\"-dz\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"8\",\n            args: &[],\n            input: \"\u00f6\\nv\\n\",\n            stdout: Some(\"\u00f6\\nv\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"9\",\n            args: &[\"-u\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"10\",\n            args: &[\"-u\"],\n            input: \"a\\nb\\n\",\n            stdout: Some(\"a\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"11\",\n            args: &[\"-u\"],\n            input: \"a\\nb\\na\\n\",\n            stdout: Some(\"a\\nb\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"12\",\n            args: &[\"-u\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"13\",\n            args: &[\"-u\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"20\",\n            args: &[\"-d\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"21\",\n            args: &[\"-d\"],\n            input: \"a\\nb\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"22\",\n            args: &[\"-d\"],\n            input: \"a\\nb\\na\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"23\",\n            args: &[\"-d\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        // Obsolete syntax for \"-f 1\"\n        TestCase {\n            name: \"obs30\",\n            args: &[\"-1\"],\n            input: \"a a\\nb a\\n\",\n            stdout: Some(\"a a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"31\",\n            args: &[\"-f\", \"1\"],\n            input: \"a a\\nb a\\n\",\n            stdout: Some(\"a a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"32\",\n            args: &[\"-f\", \"1\"],\n            input: \"a a\\nb b\\n\",\n            stdout: Some(\"a a\\nb b\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"33\",\n            args: &[\"-f\", \"1\"],\n            input: \"a a a\\nb a c\\n\",\n            stdout: Some(\"a a a\\nb a c\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"34\",\n            args: &[\"-f\", \"1\"],\n            input: \"b a\\na a\\n\",\n            stdout: Some(\"b a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"35\",\n            args: &[\"-f\", \"2\"],\n            input: \"a a c\\nb a c\\n\",\n            stdout: Some(\"a a c\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        // // Obsolete syntax for \"-s 1\"\n        // TestCase {\n        //     name: \"obs-plus40\",\n        //     args: &[\"+1\"],\n        //     input: \"aaa\\naaa\\n\",\n        //     stdout: Some(\"aaa\\n\"),\n        //     stderr: None,\n        //     exit: None,\n        // },\n        // TestCase {\n        //     name: \"obs-plus41\",\n        //     args: &[\"+1\"],\n        //     input: \"baa\\naaa\\n\",\n        //     stdout: Some(\"baa\\n\"),\n        //     stderr: None,\n        //     exit: None,\n        // },\n        TestCase {\n            name: \"42\",\n            args: &[\"-s\", \"1\"],\n            input: \"aaa\\naaa\\n\",\n            stdout: Some(\"aaa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"43\",\n            args: &[\"-s\", \"2\"],\n            input: \"baa\\naaa\\n\",\n            stdout: Some(\"baa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        /*\n        // Obsolete syntax for \"-s 1\"\n        TestCase {\n            name: \"obs-plus44\",\n            args: &[\"+1\", \"--\"],\n            input: \"aaa\\naaa\\n\",\n            stdout: Some(\"aaa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"obs-plus45\",\n            args: &[\"+1\", \"--\"],\n            input: \"baa\\naaa\\n\",\n            stdout: Some(\"baa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        */\n        TestCase {\n            name: \"50\",\n            args: &[\"-f\", \"1\", \"-s\", \"1\"],\n            input: \"a aaa\\nb ab\\n\",\n            stdout: Some(\"a aaa\\nb ab\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"51\",\n            args: &[\"-f\", \"1\", \"-s\", \"1\"],\n            input: \"a aaa\\nb aaa\\n\",\n            stdout: Some(\"a aaa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"52\",\n            args: &[\"-s\", \"1\", \"-f\", \"1\"],\n            input: \"a aaa\\nb ab\\n\",\n            stdout: Some(\"a aaa\\nb ab\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"53\",\n            args: &[\"-s\", \"1\", \"-f\", \"1\"],\n            input: \"a aaa\\nb aaa\\n\",\n            stdout: Some(\"a aaa\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"54\",\n            args: &[\"-s\", \"4\"],\n            input: \"abc\\nabcd\\n\",\n            stdout: Some(\"abc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"55\",\n            args: &[\"-s\", \"0\"],\n            input: \"abc\\nabcd\\n\",\n            stdout: Some(\"abc\\nabcd\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"56\",\n            args: &[\"-s\", \"0\"],\n            input: \"abc\\n\",\n            stdout: Some(\"abc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"57\",\n            args: &[\"-w\", \"0\"],\n            input: \"abc\\nabcd\\n\",\n            stdout: Some(\"abc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"60\",\n            args: &[\"-w\", \"1\"],\n            input: \"a a\\nb a\\n\",\n            stdout: Some(\"a a\\nb a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"61\",\n            args: &[\"-w\", \"3\"],\n            input: \"a a\\nb a\\n\",\n            stdout: Some(\"a a\\nb a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"62\",\n            args: &[\"-w\", \"1\", \"-f\", \"1\"],\n            input: \"a a a\\nb a c\\n\",\n            stdout: Some(\"a a a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"63\",\n            args: &[\"-f\", \"1\", \"-w\", \"1\"],\n            input: \"a a a\\nb a c\\n\",\n            stdout: Some(\"a a a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"64\",\n            args: &[\"-f\", \"1\", \"-w\", \"4\"],\n            input: \"a a a\\nb a c\\n\",\n            stdout: Some(\"a a a\\nb a c\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"65\",\n            args: &[\"-f\", \"1\", \"-w\", \"3\"],\n            input: \"a a a\\nb a c\\n\",\n            stdout: Some(\"a a a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"90\",\n            args: &[],\n            input: \"a\\0a\\na\\n\",\n            stdout: Some(\"a\\0a\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"91\",\n            args: &[],\n            input: \"a\\ta\\na a\\n\",\n            stdout: Some(\"a\\ta\\na a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"92\",\n            args: &[\"-f\", \"1\"],\n            input: \"a\\ta\\na a\\n\",\n            stdout: Some(\"a\\ta\\na a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"93\",\n            args: &[\"-f\", \"2\"],\n            input: \"a\\ta a\\na a a\\n\",\n            stdout: Some(\"a\\ta a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"94\",\n            args: &[\"-f\", \"1\"],\n            input: \"a\\ta\\na\\ta\\n\",\n            stdout: Some(\"a\\ta\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"101\",\n            args: &[\"-c\"],\n            input: \"a\\nb\\n\",\n            stdout: Some(\"      1 a\\n      1 b\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"102\",\n            args: &[\"-c\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"      2 a\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"110\",\n            args: &[\"-D\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"111\",\n            args: &[\"-D\", \"-w1\"],\n            input: \"a a\\na b\\n\",\n            stdout: Some(\"a a\\na b\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        /*\n        Disable as it fails too often. See:\n        https://github.com/uutils/coreutils/issues/3509\n        TestCase {\n            name: \"112\",\n            args: &[\"-D\", \"-c\"],\n            input: \"a a\\na b\\n\",\n            stdout: Some(\"\"),\n            stderr: Some(\"uniq: printing all duplicated lines and repeat counts is meaningless\"),\n            exit: Some(1),\n        },*/\n        TestCase {\n            name: \"113\",\n            args: &[\"--all-repeated=separate\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"114\",\n            args: &[\"--all-repeated=separate\"],\n            input: \"a\\na\\nb\\nc\\nc\\n\",\n            stdout: Some(\"a\\na\\n\\nc\\nc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"115\",\n            args: &[\"--all-repeated=separate\"],\n            input: \"a\\na\\nb\\nb\\nc\\n\",\n            stdout: Some(\"a\\na\\n\\nb\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"116\",\n            args: &[\"--all-repeated=prepend\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\\na\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"117\",\n            args: &[\"--all-repeated=prepend\"],\n            input: \"a\\na\\nb\\nc\\nc\\n\",\n            stdout: Some(\"\\na\\na\\n\\nc\\nc\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"118\",\n            args: &[\"--all-repeated=prepend\"],\n            input: \"a\\nb\\n\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        // \\x08 is the backspace char\n        TestCase {\n            name: \"120\",\n            args: &[\"-d\", \"-u\"],\n            input: \"a\\na\\n\\x08\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"123\",\n            args: &[\"--zero-terminated\"],\n            input: \"a\\na\\nb\",\n            stdout: Some(\"a\\na\\nb\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"124\",\n            args: &[\"--zero-terminated\"],\n            input: \"a\\0a\\0b\",\n            stdout: Some(\"a\\0b\\0\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"125\",\n            args: &[],\n            input: \"A\\na\\n\",\n            stdout: Some(\"A\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"126\",\n            args: &[\"-i\"],\n            input: \"A\\na\\n\",\n            stdout: Some(\"A\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"127\",\n            args: &[\"--ignore-case\"],\n            input: \"A\\na\\n\",\n            stdout: Some(\"A\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"128\",\n            args: &[\"--group=prepend\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"\\na\\na\\n\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"129\",\n            args: &[\"--group=append\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"a\\na\\n\\nb\\n\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"130\",\n            args: &[\"--group=separate\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"a\\na\\n\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"131\",\n            args: &[\"--group\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"a\\na\\n\\nb\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"132\",\n            args: &[\"--group=both\"],\n            input: \"a\\na\\nb\\n\",\n            stdout: Some(\"\\na\\na\\n\\nb\\n\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"133\",\n            args: &[\"--group=prepend\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"\\na\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"134\",\n            args: &[\"--group=append\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"135\",\n            args: &[\"--group=separate\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"136\",\n            args: &[\"--group\"],\n            input: \"a\\na\\n\",\n            stdout: Some(\"a\\na\\n\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"137\",\n            args: &[\"--group=prepend\"],\n            input: \"\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"138\",\n            args: &[\"--group=append\"],\n            input: \"\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"139\",\n            args: &[\"--group=separate\"],\n            input: \"\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n        TestCase {\n            name: \"140\",\n            args: &[\"--group=both\"],\n            input: \"\",\n            stdout: Some(\"\"),\n            stderr: None,\n            exit: None,\n        },\n    ];\n\n    for case in cases {\n        eprintln!(\"Test {}\", case.name);\n        let result = new_ucmd!().args(case.args).run_piped_stdin(case.input);\n        if let Some(stdout) = case.stdout {\n            result.stdout_is(stdout);\n        }\n        if let Some(stderr) = case.stderr {\n            result.stderr_contains(stderr);\n        }\n        if let Some(exit) = case.exit {\n            result.code_is(exit);\n        }\n    }\n}\n"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_normalize", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_normalize() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--to=si\"])\n        .pipe_in(\"10000000K\\n0.001K\")\n        .run()\n        .stdout_is(\"10G\\n1\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_restart_leader_insecure", "code": "fn restart_leader(mgr: SecurityManager) {\n    let mgr = Arc::new(mgr);\n    // Service has only one GetMembersResponse, so the leader never changes.\n    let mut server =\n        MockServer::<Service>::with_configuration(&mgr, vec![(\"127.0.0.1\".to_owned(), 0); 3], None);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), Some(Arc::clone(&mgr)));\n    // Put a region.\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer);\n    client.bootstrap_cluster(store, region.clone()).unwrap();\n\n    let region = block_on(client.get_region_by_id(region.get_id()))\n        .unwrap()\n        .unwrap();\n\n    // Stop servers and restart them again.\n    server.stop();\n    server.start(&mgr, eps);\n\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let region = block_on(client.get_region_by_id(region.get_id())).unwrap();\n    assert_eq!(region.unwrap().get_id(), region_id);\n}", "test": "fn test_restart_leader_insecure() {\n    let mgr = SecurityManager::new(&SecurityConfig::default()).unwrap();\n    restart_leader(mgr)\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_comment_starting_with_gt", "code": "fn as_ref(&self) -> &[u8] {\n        self.0\n    }", "test": "fn test_comment_starting_with_gt() {\n    let src = \"<a /><!-->-->\";\n    let mut r = Reader::from_str(src);\n    r.trim_text(true);\n    loop {\n        match r.read_event() {\n            Ok(Comment(e)) => {\n                assert_eq!(e.as_ref(), b\">\");\n                break;\n            }\n            Ok(Eof) => panic!(\"Expecting Comment\"),\n            _ => (),\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_join.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::comma_operator", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn comma_operator() {\n    run_test_actions([\n        TestAction::assert_eq(\n            indoc! {r#\"\n                var a, b;\n                b = 10;\n                a = (b++, b);\n                a\n            \"#},\n            11,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                var a, b;\n                b = 10;\n                a = (b += 5, b /= 3, b - 3);\n                a\n            \"#},\n            2,\n        ),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_true.rs::test_exit_code", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_exit_code() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_read_index_after_write", "code": "pub fn get_read_index(&self) -> u64 {\n        self.read_index\n    }", "test": "fn test_read_index_after_write() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10));\n    let heartbeat_interval = cluster.cfg.raft_store.raft_heartbeat_interval();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let region_on_store1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), region_on_store1.clone());\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    // Add heartbeat msg filter to prevent the leader to reply the read index\n    // response.\n    let filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 2)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgHeartbeat),\n    );\n    cluster.sim.wl().add_recv_filter(2, filter);\n\n    let mut req = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_read_index_cmd()],\n        true,\n    );\n    req.mut_header()\n        .set_peer(new_peer(1, region_on_store1.get_id()));\n    // Don't care about the first one's read index\n    let (cb, _) = make_cb(&req);\n    cluster.sim.rl().async_command_on_node(1, req, cb).unwrap();\n\n    cluster.must_put(b\"k2\", b\"v2\");\n    let applied_index = cluster.apply_state(region.get_id(), 1).get_applied_index();\n\n    let mut req = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_read_index_cmd()],\n        true,\n    );\n    req.mut_header()\n        .set_peer(new_peer(1, region_on_store1.get_id()));\n    let (cb, mut rx) = make_cb(&req);\n    cluster.sim.rl().async_command_on_node(1, req, cb).unwrap();\n\n    cluster.sim.wl().clear_recv_filters(2);\n\n    let response = rx.recv_timeout(heartbeat_interval).unwrap();\n    assert!(\n        response.get_responses()[0]\n            .get_read_index()\n            .get_read_index()\n            >= applied_index\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::simple_try", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn simple_try() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                a = 20;\n            } catch {\n                a = 30;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_whoami.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::create_table_like", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn create_table_like() {\n    let like = \"CREATE TABLE db.table_name LIKE db.other_table\";\n    hive().verified_stmt(like);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test1", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test1() {\n    test_helper(\"test1\", \"gnome\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_default_unsorted_ints", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_default_unsorted_ints() {\n    test_helper(\"default_unsorted_ints\", &[\"\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_existing_error", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_realpath_existing_error() {\n    new_ucmd!().arg(\"-e\").arg(GIBBERISH).fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname_full", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_hostname_full() {\n    let ls_short_res = new_ucmd!().arg(\"-s\").succeeds();\n    assert!(!ls_short_res.stdout_str().trim().is_empty());\n\n    new_ucmd!()\n        .arg(\"-f\")\n        .succeeds()\n        .stdout_contains(ls_short_res.stdout_str().trim());\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap_multi", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_compare_and_swap_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut current = RecordSet::with_ttl(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n\n    let current1 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 10)))\n        .clone();\n    let current2 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 11)))\n        .clone();\n    let current = current;\n\n    let result = io_loop\n        .block_on(client.create(current.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let mut new = RecordSet::with_ttl(current.name().clone(), current.record_type(), current.ttl());\n    let new1 = new.new_record(&RData::A(A::new(100, 10, 101, 10))).clone();\n    let new2 = new.new_record(&RData::A(A::new(100, 10, 101, 11))).clone();\n    let new = new;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(result.answers().iter().any(|rr| *rr == new2));\n    assert!(!result.answers().iter().any(|rr| *rr == current1));\n    assert!(!result.answers().iter().any(|rr| *rr == current2));\n\n    // check the it fails if tried again.\n    let mut not = new1.clone();\n    not.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n    let not = not;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current, not.clone(), origin))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(!result.answers().iter().any(|rr| *rr == not));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_decimal", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_literal_decimal() {\n    // These numbers were explicitly chosen to not roundtrip if represented as\n    // f64s (i.e., as 64-bit binary floating point numbers).\n    let sql = \"SELECT 0.300000000000000004, 9007199254740993.0\";\n    let select = verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(number(\"0.300000000000000004\")),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Value(number(\"9007199254740993.0\")),\n        expr_from_projection(&select.projection[1]),\n    )\n}"}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/tests.rs::roundtrip_decode_trailing_10_bytes", "code": "fn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError> {\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> Result<Vec<u8>, DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n            let mut buffer = vec![0; estimate.decoded_len_estimate()];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, &mut buffer, estimate)?\n                .decoded_len;\n\n            buffer.truncate(bytes_written);\n\n            Ok(buffer)\n        }\n\n        inner(self, input.as_ref())\n    }", "test": "fn roundtrip_decode_trailing_10_bytes() {\n    // This is a special case because we decode 8 byte blocks of input at a time as much as we can,\n    // ideally unrolled to 32 bytes at a time, in stages 1 and 2. Since we also write a u64's worth\n    // of bytes (8) to the output, we always write 2 garbage bytes that then will be overwritten by\n    // the NEXT block. However, if the next block only contains 2 bytes, it will decode to 1 byte,\n    // and therefore be too short to cover up the trailing 2 garbage bytes. Thus, we have stage 3\n    // to handle that case.\n\n    for num_quads in 0..25 {\n        let mut s: String = \"ABCD\".repeat(num_quads);\n        s.push_str(\"EFGHIJKLZg\");\n\n        let engine = GeneralPurpose::new(&alphabet::STANDARD, NO_PAD);\n        let decoded = engine.decode(&s).unwrap();\n        assert_eq!(num_quads * 3 + 7, decoded.len());\n\n        assert_eq!(s, engine.encode(&decoded));\n    }\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_index_lifetime", "code": "fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }", "test": "fn capture_index_lifetime() {\n    // This is a test of whether the types on `caps[\"...\"]` are general\n    // enough. If not, this will fail to typecheck.\n    fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }\n    assert_eq!(3, inner(\"123\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_update_resoved_ts_before_apply_index", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_update_resoved_ts_before_apply_index() {\n    let (mut cluster, pd_client, mut leader_client) = prepare_for_stale_read(new_peer(1, 1));\n    let mut follower_client2 = PeerClient::new(&cluster, 1, new_peer(2, 2));\n    leader_client.ctx.set_stale_read(true);\n    follower_client2.ctx.set_stale_read(true);\n\n    // Write `(key1, value1)`\n    let commit_ts1 = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), commit_ts1);\n\n    // Return before handling `apply_res`, to stop the leader updating the apply\n    // index\n    let on_apply_res_fp = \"on_apply_res\";\n    fail::cfg(on_apply_res_fp, \"return()\").unwrap();\n    // Stop replicate data to follower 2\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n\n    // Write `(key1, value2)`\n    let commit_ts2 = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value2\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Wait `resolved_ts` be updated\n    sleep_ms(100);\n\n    // The leader can't handle stale read with `commit_ts2` because its `safe_ts`\n    // can't update due to its `apply_index` not update\n    let resp = leader_client.kv_read(b\"key1\".to_vec(), commit_ts2);\n    assert!(resp.get_region_error().has_data_is_not_ready(),);\n    // The follower can't handle stale read with `commit_ts2` because it don't\n    // have enough data\n    let resp = follower_client2.kv_read(b\"key1\".to_vec(), commit_ts2);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    fail::remove(on_apply_res_fp);\n    cluster.clear_send_filters();\n\n    leader_client.must_kv_read_equal(b\"key1\".to_vec(), b\"value2\".to_vec(), commit_ts2);\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value2\".to_vec(), commit_ts2);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_no_padding", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_no_padding() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 0, 0, 0, 0, 1,\n            \"hello\",\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"hello\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pending_peers.rs::test_pending_peers", "code": "pub fn new_peer(store_id: u64, peer_id: u64) -> Peer {\n    let mut peer = Peer::default();\n    peer.set_store_id(store_id);\n    peer.set_id(peer_id);\n    peer.set_role(PeerRole::Voter);\n    peer\n}", "test": "fn test_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n\n    let region_worker_fp = \"region_apply_snap\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let region_id = cluster.run_conf_change();\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n\n    // To ensure peer 2 is not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n\n    fail::cfg(region_worker_fp, \"sleep(2000)\").unwrap();\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    sleep_ms(1000);\n    let pending_peers = pd_client.get_pending_peers();\n    // Region worker is not started, snapshot should not be applied yet.\n    assert_eq!(pending_peers[&3], new_peer(3, 3));\n    // But it will be applied finally.\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    sleep_ms(100);\n    let pending_peers = pd_client.get_pending_peers();\n    assert!(pending_peers.is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_backup_dir_dir_a\";\n    let dir_b = \"test_mv_backup_dir_dir_b\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    ucmd.arg(\"-vbT\")\n        .arg(dir_a)\n        .arg(dir_b)\n        .succeeds()\n        .stdout_only(format!(\n            \"renamed '{dir_a}' -> '{dir_b}' (backup: '{dir_b}~')\\n\"\n        ));\n\n    assert!(!at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n    assert!(at.dir_exists(&format!(\"{dir_b}~\")));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::mock_nameserver", "code": "fn mock_nameserver_on_send_nx<O: OnSend + Unpin>(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    options: ResolverOpts,\n    on_send: O,\n    addr: IpAddr,\n    trust_negative_responses: bool,\n) -> MockedNameServer<O> {\n    let conn_provider = MockConnProvider {\n        on_send: on_send.clone(),\n        _p: Default::default(),\n    };\n    let client = MockClientHandle::mock_on_send(messages, on_send);\n\n    NameServer::from_conn(\n        NameServerConfig {\n            socket_addr: SocketAddr::new(addr, 0),\n            protocol: Protocol::Udp,\n            tls_dns_name: None,\n            trust_negative_responses,\n            #[cfg(any(feature = \"dns-over-rustls\", feature = \"dns-over-https-rustls\"))]\n            tls_config: None,\n            bind_addr: None,\n        },\n        options,\n        client,\n        conn_provider,\n    )\n}", "test": "fn mock_nameserver(\n    messages: Vec<Result<DnsResponse, ResolveError>>,\n    options: ResolverOpts,\n) -> MockedNameServer<DefaultOnSend> {\n    mock_nameserver_on_send_nx(messages, options, DefaultOnSend, DEFAULT_SERVER_ADDR, false)\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_before_finish", "code": "pub(crate) fn finish(\n        self,\n        header_crypto: Option<&dyn crypto::HeaderKey>,\n    ) -> Result<Packet, PacketDecodeError> {\n        use self::PlainHeader::*;\n        let Self {\n            plain_header,\n            mut buf,\n        } = self;\n\n        if let Initial {\n            dst_cid,\n            src_cid,\n            token_pos,\n            version,\n            ..\n        } = plain_header\n        {\n            let number = Self::decrypt_header(&mut buf, header_crypto.unwrap())?;\n            let header_len = buf.position() as usize;\n            let mut bytes = buf.into_inner();\n\n            let header_data = bytes.split_to(header_len).freeze();\n            let token = header_data.slice(token_pos.start..token_pos.end);\n            return Ok(Packet {\n                header: Header::Initial {\n                    dst_cid,\n                    src_cid,\n                    token,\n                    number,\n                    version,\n                },\n                header_data,\n                payload: bytes,\n            });\n        }\n\n        let header = match plain_header {\n            Long {\n                ty,\n                dst_cid,\n                src_cid,\n                version,\n                ..\n            } => Header::Long {\n                ty,\n                dst_cid,\n                src_cid,\n                number: Self::decrypt_header(&mut buf, header_crypto.unwrap())?,\n                version,\n            },\n            Retry {\n                dst_cid,\n                src_cid,\n                version,\n            } => Header::Retry {\n                dst_cid,\n                src_cid,\n                version,\n            },\n            Short { spin, dst_cid, .. } => {\n                let number = Self::decrypt_header(&mut buf, header_crypto.unwrap())?;\n                let key_phase = buf.get_ref()[0] & KEY_PHASE_BIT != 0;\n                Header::Short {\n                    spin,\n                    key_phase,\n                    dst_cid,\n                    number,\n                }\n            }\n            VersionNegotiate {\n                random,\n                dst_cid,\n                src_cid,\n            } => Header::VersionNegotiate {\n                random,\n                dst_cid,\n                src_cid,\n            },\n            Initial { .. } => unreachable!(),\n        };\n\n        let header_len = buf.position() as usize;\n        let mut bytes = buf.into_inner();\n        Ok(Packet {\n            header,\n            header_data: bytes.split_to(header_len).freeze(),\n            payload: bytes,\n        })\n    }", "test": "fn stop_before_finish() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"stopping stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.client_send(client_ch, s).finish(),\n        Err(FinishError::Stopped(ERROR))\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fmt.rs::exported_parameter", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn exported_parameter() {\n  Test::new()\n    .justfile(\"foo +$f:\")\n    .args([\"--dump\"])\n    .stdout(\"foo +$f:\\n\")\n    .run();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::memory_zeroed", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "test": "fn memory_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(1).table_elements(0);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 1))\"#)?;\n\n    // Instantiate the module repeatedly after writing data to the entire memory\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n        assert_eq!(memory.size(&store,), 1);\n        assert_eq!(memory.data_size(&store), 65536);\n\n        let ptr = memory.data_mut(&mut store).as_mut_ptr();\n\n        unsafe {\n            for i in 0..8192 {\n                assert_eq!(*ptr.cast::<u64>().offset(i), 0);\n            }\n            std::ptr::write_bytes(ptr, 0xFE, memory.data_size(&store));\n        }\n    }\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_number_chunks_short_concatenated_with_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_split_number_chunks_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n3\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_overwrite_dir_fail", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_symlink_overwrite_dir_fail() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let path_a = \"test_symlink_overwrite_dir_a\";\n    let path_b = \"test_symlink_overwrite_dir_b\";\n\n    at.touch(path_a);\n    at.mkdir(path_b);\n\n    assert!(!ucmd\n        .args(&[\"-s\", \"-T\", path_a, path_b])\n        .fails()\n        .stderr_str()\n        .is_empty());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_include", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn can_remove_whitespace_include() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\"Hi {%- include \"include\" -%} \"#, \"HiIncluded\"),\n        (r#\"Hi {% include \"include\" -%} \"#, \"Hi Included\"),\n        (r#\"Hi {% include \"include\" %} \"#, \"Hi Included \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![(\"include\", \"Included\"), (\"tpl\", input)]).unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::continuations_iwth_echo_comments_false", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn continuations_iwth_echo_comments_false() {\n  Test::new()\n    .justfile(\n      \"\n      set ignore-comments\n\n      some_recipe:\n        # Comment lines ignore line continuations \\\\\n        echo something-useful\n    \",\n    )\n    .stdout(\"something-useful\\n\")\n    .stderr(\"echo something-useful\\n\")\n    .run();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::decimal_precision", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn decimal_precision() {\n    let query = \"SELECT CAST(a AS DECIMAL(18,2)) FROM db.table\";\n    hive().verified_stmt(query);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_interactive", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_cp_arg_update_interactive() {\n    new_ucmd!()\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"-i\")\n        .arg(\"--update\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_true.rs::test_conflict", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_conflict() {\n    new_ucmd!()\n        .args(&[\"--help\", \"--version\"])\n        .succeeds()\n        .stdout_is(\"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_combined_file_set_unset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_combined_file_set_unset() {\n    let out = new_ucmd!()\n        .arg(\"-u\")\n        .arg(\"BAR\")\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .arg(\"FOO=bar.alt\")\n        .succeeds()\n        .stdout_move_str();\n\n    assert_eq!(\n        out.lines()\n            .filter(|&line| line == \"FOO=bar.alt\" || line.starts_with(\"BAR=\"))\n            .count(),\n        1\n    );\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::set_comprehension", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn set_comprehension() {\n    let source = \"{x for x in numbers}\";\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_26", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_26() {\n    let original = r##\"H1 {} {}\n=====\n\n## H2 {} {}\n\"##;\n    let expected = r##\"<h1>H1 {}</h1>\n<h2>H2 {}</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::N() {\n    l", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "le_N() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    scene.ucmd().args(&[\"-N\", \"regular_file\"]).fails();\n    // The file will have different create/modified data\n    // so, test -N will return 0\n    sleep(std::time::Duration::from_millis(1000));\n    at.touch(\"regular_file\");\n    scene.ucmd().args(&[\"-N\", \"regular_file\"]).succeeds();\n}\n\n#[test]\n"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_btc_fails_if_lock_unspent_fails", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn send_btc_fails_if_lock_unspent_fails() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n    .fail_lock_unspent(true)\n    .build();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 1btc\")\n    .rpc_server(&rpc_server)\n    .expected_stderr(\"error: failed to lock ordinal UTXOs\\n\")\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_truncate", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_truncate() {\n    let truncate = r#\"TRUNCATE TABLE db.table\"#;\n    hive().verified_stmt(truncate);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::dont_evaluate_comments", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dont_evaluate_comments() {\n  Test::new()\n    .justfile(\n      \"\n      set ignore-comments\n\n      some_recipe:\n        # {{ error('foo') }}\n    \",\n    )\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_with_posixly_correct", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_mktemp_with_posixly_correct() {\n    let scene = TestScenario::new(util_name!());\n\n    scene\n        .ucmd()\n        .env(\"POSIXLY_CORRECT\", \"1\")\n        .args(&[\"aXXXX\", \"--suffix=b\"])\n        .fails()\n        .usage_error(\"too many templates\");\n\n    scene\n        .ucmd()\n        .env(\"POSIXLY_CORRECT\", \"1\")\n        .args(&[\"--suffix=b\", \"aXXXX\"])\n        .succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_no_trailing_newline", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_no_trailing_newline() {\n    new_ucmd!()\n        .arg(\"-n\")\n        .arg(\"hi\")\n        .succeeds()\n        .no_stderr()\n        .stdout_only(\"hi\");\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::parens_test", "code": "pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}", "test": "fn parens_test() {\n  assert_eq!(\n    expr(\" ( 1 + 2 ) *  3 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"([(1 + 2)] * 3)\")))\n  );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/bf16_tests.rs::from_f32_test", "code": "pub const fn to_bits(self) -> u16 {\n        self.bits\n    }", "test": "fn from_f32_test() {\n    assert_eq!(bf16::from_f32(4.5917e-41f32).to_bits(), 0);\n    assert_eq!(bf16::from_f32(4.5918e-41f32).to_bits(), 0);\n    assert_eq!(bf16::from_f32(4.5919e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18354e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18355e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18356e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(1.37752e-40f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(1.37753e-40f32).to_bits(), 2);\n    assert_eq!(bf16::from_f32(1.37754e-40f32).to_bits(), 2);\n    assert!(bf16::from_f32(f32::NAN).is_nan());\n    assert!(bf16::from_f32(f32::INFINITY).is_inf());\n    assert!(bf16::from_f32(f32::NEG_INFINITY).is_inf());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_basic", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_basic() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file1 = \"source_file1\";\n    let file2 = \"source_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.mkdir(dir);\n    ucmd.arg(file1).arg(file2).arg(dir).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.file_exists(format!(\"{dir}/{file1}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file2}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_word_boundary_only_whitespace_preserve_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_word_boundary_only_whitespace_preserve_final_newline() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-s\"])\n        .pipe_in(\"    \\n\")\n        .succeeds()\n        .stdout_is(\"  \\n  \\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_server_pair_isolated", "code": "fn test_pair_isolated<T: Simulator>(cluster: &mut Cluster<T>) {\n    let region = 1;\n    let pd_client = Arc::clone(&cluster.pd_client);\n\n    // Given some nodes A, B, C, D, E, we partition the cluster such that D, E are\n    // isolated from the rest.\n    cluster.run();\n    // Choose a predictable leader so we don't accidentally partition the leader.\n    cluster.must_transfer_leader(region, new_peer(1, 1));\n    cluster.partition(vec![1, 2, 3], vec![4, 5]);\n\n    // Then, add a policy to PD that it should ask the Raft leader to remove the\n    // peer from the group.\n    pd_client.must_remove_peer(region, new_peer(4, 4));\n    pd_client.must_remove_peer(region, new_peer(5, 5));\n\n    // Verify the nodes have self removed.\n    cluster.must_remove_region(4, region);\n    cluster.must_remove_region(5, region);\n}", "test": "fn test_server_pair_isolated() {\n    let mut cluster = new_server_cluster(0, 5);\n    test_pair_isolated(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_numbered_if_existing_backup_existing", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_cp_numbered_if_existing_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let existing_backup = &format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\");\n    at.touch(existing_backup);\n\n    ucmd.arg(\"--backup=existing\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(TEST_HOW_ARE_YOU_SOURCE));\n    assert!(at.file_exists(existing_backup));\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~2~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_bool_ops", "code": "pub fn end_sc_bool(&mut self) {\n        let end = self.next_instruction();\n        if let Some(PendingBlock::ScBool(instructions)) = self.pending_block.pop() {\n            for instr in instructions {\n                match self.instructions.get_mut(instr) {\n                    Some(Instruction::JumpIfFalseOrPop(ref mut target))\n                    | Some(Instruction::JumpIfTrueOrPop(ref mut target)) => {\n                        *target = end;\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", "test": "fn test_bool_ops() {\n    let mut c = CodeGenerator::new(\"<unknown>\", \"\");\n\n    c.start_sc_bool();\n    c.add(Instruction::Lookup(\"first\"));\n    c.sc_bool(true);\n    c.add(Instruction::Lookup(\"second\"));\n    c.sc_bool(false);\n    c.add(Instruction::Lookup(\"third\"));\n    c.end_sc_bool();\n\n    insta::assert_debug_snapshot!(&c.finish());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_random_restart", "code": "fn test_multi_random_restart<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    node_count: usize,\n    restart_count: u32,\n) {\n    cluster.run();\n\n    let mut rng = rand::thread_rng();\n    let mut value = [0u8; 5];\n\n    for i in 1..restart_count {\n        let id = 1 + rng.gen_range(0..node_count as u64);\n        cluster.stop_node(id);\n\n        let key = i.to_string().into_bytes();\n\n        rng.fill_bytes(&mut value);\n        cluster.must_put(&key, &value);\n        assert_eq!(cluster.get(&key), Some(value.to_vec()));\n\n        cluster.run_node(id).unwrap();\n\n        // verify whether data is actually being replicated and waiting for node online.\n        must_get_equal(&cluster.get_engine(id), &key, &value);\n\n        cluster.must_delete(&key);\n        assert_eq!(cluster.get(&key), None);\n    }\n}", "test": "fn test_multi_server_random_restart() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_random_restart(&mut cluster, count, 10);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_config_is_clone", "code": "fn make_server_config(\n    params: &BenchmarkParam,\n    client_auth: ClientAuth,\n    resume: ResumptionParam,\n    max_fragment_size: Option<usize>,\n) -> ServerConfig {\n    let client_auth = match client_auth {\n        ClientAuth::Yes => {\n            let roots = params.key_type.get_chain();\n            let mut client_auth_roots = RootCertStore::empty();\n            for root in roots {\n                client_auth_roots.add(&root).unwrap();\n            }\n            Arc::new(AllowAnyAuthenticatedClient::new(client_auth_roots))\n        }\n        ClientAuth::No => NoClientAuth::boxed(),\n    };\n\n    let mut cfg = ServerConfig::builder()\n        .with_safe_default_cipher_suites()\n        .with_safe_default_kx_groups()\n        .with_protocol_versions(&[params.version])\n        .unwrap()\n        .with_client_cert_verifier(client_auth)\n        .with_single_cert(params.key_type.get_chain(), params.key_type.get_key())\n        .expect(\"bad certs/private key?\");\n\n    if resume == ResumptionParam::SessionID {\n        cfg.session_storage = ServerSessionMemoryCache::new(128);\n    } else if resume == ResumptionParam::Tickets {\n        cfg.ticketer = Ticketer::new().unwrap();\n    } else {\n        cfg.session_storage = Arc::new(NoServerSessionStorage {});\n    }\n\n    cfg.max_fragment_size = max_fragment_size;\n    cfg\n}", "test": "fn server_config_is_clone() {\n    let _ = make_server_config(KeyType::Rsa);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_overflow_bytes_size", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_overflow_bytes_size() {\n    #[cfg(not(target_pointer_width = \"128\"))]\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"test_split_overflow_bytes_size\";\n    RandomFile::new(&at, name).add_bytes(1000);\n    ucmd.args(&[\"-b\", \"1Y\", name]).succeeds();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 1);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_string", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_literal_string() {\n    let sql = \"SELECT 'one', N'national string', X'deadBEEF'\";\n    let select = verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedString(\"one\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::NationalStringLiteral(\"national string\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Value(Value::HexStringLiteral(\"deadBEEF\".to_string())),\n        expr_from_projection(&select.projection[2])\n    );\n\n    one_statement_parses_to(\"SELECT x'deadBEEF'\", \"SELECT X'deadBEEF'\");\n    one_statement_parses_to(\"SELECT n'national string'\", \"SELECT N'national string'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_trailing_slash_symlink_loop", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_canonicalize_trailing_slash_symlink_loop() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.relative_symlink_file(\"link5\", \"link5\");\n    for query in [\"link5\", \"./link5/\", \"link5/more\", \"./link5/more/\"] {\n        scene\n            .ucmd()\n            .args(&[\"-f\", query])\n            .fails()\n            .code_is(1)\n            .no_stdout();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_by_bytes_short_concatenated_with_value", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_by_bytes_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_by_bytes_short_concatenated_with_value\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    ucmd.args(&[\"-b1000\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 1000);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::pop", "code": "pub fn pop_first(&mut self) -> Result<Option<(AccessGuard<K>, AccessGuard<V>)>> {\n        // TODO: optimize this\n        let first = self\n            .iter()?\n            .next()\n            .map(|x| x.map(|(key, _)| K::as_bytes(&key.value()).as_ref().to_vec()));\n        if let Some(owned_key) = first {\n            let owned_key = owned_key?;\n            let key = K::from_bytes(&owned_key);\n            let value = self.remove(&key)?.unwrap();\n            drop(key);\n            Ok(Some((AccessGuard::with_owned_value(owned_key), value)))\n        } else {\n            Ok(None)\n        }\n    }", "test": "fn pop() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n\n        assert!(table.pop_first().unwrap().is_none());\n        assert!(table.pop_last().unwrap().is_none());\n\n        table.insert(\"a\", \"world\").unwrap();\n        table.insert(\"b\", \"world2\").unwrap();\n        table.insert(\"c\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        {\n            let (key, value) = table.pop_first().unwrap().unwrap();\n            assert_eq!(key.value(), \"a\");\n            assert_eq!(value.value(), \"world\");\n        }\n        {\n            let (key, value) = table.pop_last().unwrap().unwrap();\n            assert_eq!(key.value(), \"c\");\n            assert_eq!(value.value(), \"world3\");\n        }\n        {\n            let (key, value) = table.pop_last().unwrap().unwrap();\n            assert_eq!(key.value(), \"b\");\n            assert_eq!(value.value(), \"world2\");\n        }\n\n        assert!(table.pop_first().unwrap().is_none());\n        assert!(table.pop_last().unwrap().is_none());\n    }\n    write_txn.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_multiple_hyphen_values", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_multiple_hyphen_values() {\n    new_ucmd!()\n        .args(&[\"-abc\", \"-def\", \"-edf\"])\n        .succeeds()\n        .stdout_is(\"-abc -def -edf\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_add_multiple_partitions", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_add_multiple_partitions() {\n    let add = \"ALTER TABLE db.table ADD IF NOT EXISTS PARTITION (`a` = 'asdf', `b` = 2) PARTITION (`a` = 'asdh', `b` = 3)\";\n    hive().verified_stmt(add);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/num.rs::integer_test", "code": "fn check_integer<T: Integer>(x: T) {\n    // Bitwise operations\n    let _ = x & T::ZERO;\n}", "test": "fn integer_test() {\n    check_integer(65u32);\n    check_integer(65u64);\n    check_integer(65u128);\n    check_integer(65usize);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/errors.rs::test_lists_inside_code_spans", "code": "fn parse(md: &str) {\n    let parser = Parser::new(md);\n\n    for _ in parser {}\n}", "test": "fn test_lists_inside_code_spans() {\n    parse(\n        r\"- `\nx\n**\n  *\n  `\",\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::imul_small_test", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "test": "fn imul_small_test() {\n    // No overflow check, 1-int.\n    let mut x = Bigint {\n        data: from_u32(&[5]),\n    };\n    x.imul_small(7);\n    assert_eq!(x.data, from_u32(&[35]));\n\n    // No overflow check, 2-ints.\n    let mut x = Bigint::from_u64(0x4000000040000);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[0x00140000, 0x140000]));\n\n    // Overflow, 1 carry.\n    let mut x = Bigint {\n        data: from_u32(&[0x33333334]),\n    };\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 1]));\n\n    // Overflow, 1 carry, internal.\n    let mut x = Bigint::from_u64(0x133333334);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 6]));\n\n    // Overflow, 2 carries.\n    let mut x = Bigint::from_u64(0x3333333333333334);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 0, 1]));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_preserve_root", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_preserve_root() {\n    // It's weird that on OS X, `realpath /etc/..` returns '/private'\n    for d in [\n        \"/\",\n        \"/////dev///../../../../\",\n        \"../../../../../../../../../../../../../../\",\n        \"./../../../../../../../../../../../../../../\",\n    ] {\n        new_ucmd!()\n            .arg(\"--preserve-root\")\n            .arg(\"-R\")\n            .arg(\"bin\").arg(d)\n            .fails()\n            .stderr_is(\"chgrp: it is dangerous to operate recursively on '/'\\nchgrp: use --no-preserve-root to override this failsafe\\n\");\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_cte_renamed_columns", "code": "pub fn verified_query(&self, sql: &str) -> Query {\n        match self.verified_stmt(sql) {\n            Statement::Query(query) => *query,\n            _ => panic!(\"Expected Query\"),\n        }\n    }", "test": "fn parse_cte_renamed_columns() {\n    let sql = \"WITH cte (col1, col2) AS (SELECT foo, bar FROM baz) SELECT * FROM cte\";\n    let query = all_dialects().verified_query(sql);\n    assert_eq!(\n        vec![Ident::new(\"col1\"), Ident::new(\"col2\")],\n        query\n            .with\n            .unwrap()\n            .cte_tables\n            .first()\n            .unwrap()\n            .alias\n            .columns\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_dangling_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_dangling_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_dangling_file\";\n    let link = \"test_symlink_dangling_file_link\";\n\n    ucmd.args(&[\"-s\", file, link]).succeeds().no_stderr();\n    assert!(!at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::invoke_error_function", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn invoke_error_function() {\n  Test::new()\n    .justfile(\n      \"\n        foo:\n          echo foo\n\n        bar:\n          echo bar\n      \",\n    )\n    .stderr_regex(\n      r\"error: Chooser `/ -cu fzf --multi --preview 'just --show \\{\\}'` invocation failed: .*\\n\",\n    )\n    .status(EXIT_FAILURE)\n    .shell(false)\n    .args([\"--shell\", \"/\", \"--choose\"])\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_basics_subdir", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_basics_subdir() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(SUB_DIR).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_basics_subdir(result.stdout_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_ignore_environment", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_ignore_environment() {\n    let scene = TestScenario::new(util_name!());\n\n    scene.ucmd().arg(\"-i\").succeeds().no_stdout();\n    scene.ucmd().arg(\"-\").succeeds().no_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_not_add_newline_when_line_equal_to_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_not_add_newline_when_line_equal_to_fold() {\n    new_ucmd!()\n        .args(&[\"-w1\", \"-b\"])\n        .pipe_in(\" \")\n        .succeeds()\n        .stdout_is(\" \");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_short_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_short_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), new_content);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_shuf_invalid_input_range_one", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_shuf_invalid_input_range_one() {\n    new_ucmd!()\n        .args(&[\"-i\", \"0\"])\n        .fails()\n        .stderr_contains(\"invalid input range\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname_ip", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_hostname_ip() {\n    let result = new_ucmd!().arg(\"-i\").succeeds();\n    assert!(!result.stdout_str().trim().is_empty());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_get_regions_in_range", "code": "pub fn stop(&mut self) {\n        self.handle.stop_observing();\n    }", "test": "fn test_region_collection_get_regions_in_range() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n        .sim\n        .wl()\n        .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        let result = engine.get_regions_in_range(b\"\", b\"\").unwrap();\n        assert_eq!(result, regions);\n\n        let result = engine.get_regions_in_range(b\"k1\", b\"k3\").unwrap();\n        assert_eq!(&result, &regions[1..3]);\n\n        let result = engine.get_regions_in_range(b\"k3\", b\"k8\").unwrap();\n        assert_eq!(&result, &regions[2..5]);\n\n        let result = engine.get_regions_in_range(b\"k6\", b\"k8\").unwrap();\n        assert_eq!(&result, &regions[3..5]);\n\n        let result = engine.get_regions_in_range(b\"k7\", b\"k99\").unwrap();\n        assert_eq!(&result, &regions[4..6]);\n\n        let result = engine.get_regions_in_range(b\"k99\", b\"\").unwrap();\n        assert_eq!(&result, &regions[5..6]);\n    }\n\n    for (_, p) in region_info_providers {\n        p.stop();\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::throw", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn throw() {\n    test_formatting(\n        r#\"\n        try {\n            throw \"hello\";\n        } catch(e) {\n            console.log(e);\n        }\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_files0_from_with_stdin_try_read_from_stdin", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_files0_from_with_stdin_try_read_from_stdin() {\n    const MSG: &str = \"when reading file names from stdin, no file name of '-' allowed\";\n    new_ucmd!()\n        .args(&[\"--files0-from=-\"])\n        .pipe_in(\"-\")\n        .fails()\n        .stderr_contains(MSG)\n        .stdout_is(\"\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/gc_worker.rs::test_gc_bypass_raft", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn test_gc_bypass_raft() {\n    let (cluster, leader, ctx) = must_new_cluster_mul(2);\n    cluster.pd_client.disable_default_operator();\n\n    let env = Arc::new(Environment::new(1));\n    let leader_store = leader.get_store_id();\n    let channel = ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader_store));\n    let client = TikvClient::new(channel);\n\n    let pk = b\"k1\".to_vec();\n    let value = vec![b'x'; 300];\n    let engine = cluster.engines.get(&leader_store).unwrap();\n\n    for &start_ts in &[10, 20, 30, 40] {\n        let commit_ts = start_ts + 5;\n        let muts = vec![new_mutation(Op::Put, b\"k1\", &value)];\n\n        must_kv_prewrite(&client, ctx.clone(), muts, pk.clone(), start_ts);\n        let keys = vec![pk.clone()];\n        must_kv_commit(&client, ctx.clone(), keys, start_ts, commit_ts, commit_ts);\n\n        let key = Key::from_raw(b\"k1\").append_ts(start_ts.into());\n        let key = data_key(key.as_encoded());\n        assert!(engine.kv.get_value(&key).unwrap().is_some());\n\n        let key = Key::from_raw(b\"k1\").append_ts(commit_ts.into());\n        let key = data_key(key.as_encoded());\n        assert!(engine.kv.get_value_cf(CF_WRITE, &key).unwrap().is_some());\n    }\n\n    let node_ids = cluster.get_node_ids();\n    for store_id in node_ids {\n        let gc_sched = cluster.sim.rl().get_gc_worker(store_id).scheduler();\n\n        let mut region = cluster.get_region(b\"a\");\n        region.set_start_key(b\"k1\".to_vec());\n        region.set_end_key(b\"k2\".to_vec());\n        sync_gc(&gc_sched, region, 200.into()).unwrap();\n\n        let engine = cluster.engines.get(&store_id).unwrap();\n        for &start_ts in &[10, 20, 30] {\n            let commit_ts = start_ts + 5;\n            let key = Key::from_raw(b\"k1\").append_ts(start_ts.into());\n            let key = data_key(key.as_encoded());\n            assert!(engine.kv.get_value(&key).unwrap().is_none());\n\n            let key = Key::from_raw(b\"k1\").append_ts(commit_ts.into());\n            let key = data_key(key.as_encoded());\n            assert!(engine.kv.get_value_cf(CF_WRITE, &key).unwrap().is_none());\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_no_match7", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_no_match7() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%+5\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%+5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_node_base", "code": "fn test_multi_base<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_node_base() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_multi_base(&mut cluster)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_no_create_file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_no_create_file_exists() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_no_create_file_exists\";\n\n    at.touch(file);\n    assert!(at.file_exists(file));\n\n    ucmd.arg(\"-c\").arg(file).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::multimap_stats", "code": "fn stats(&self) -> Result<TableStats> {\n        let tree_stats = multimap_btree_stats(\n            self.tree.get_root().map(|(p, _)| p),\n            self.mem,\n            K::fixed_width(),\n            V::fixed_width(),\n        )?;\n\n        Ok(TableStats {\n            tree_height: tree_stats.tree_height,\n            leaf_pages: tree_stats.leaf_pages,\n            branch_pages: tree_stats.branch_pages,\n            stored_leaf_bytes: tree_stats.stored_leaf_bytes,\n            metadata_bytes: tree_stats.metadata_bytes,\n            fragmented_bytes: tree_stats.fragmented_bytes,\n        })\n    }", "test": "fn multimap_stats() {\n    let tmpfile = create_tempfile();\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n\n    let table_def: MultimapTableDefinition<u128, u128> = MultimapTableDefinition::new(\"x\");\n\n    let mut last_size = 0;\n    for i in 0..1000 {\n        let mut txn = db.begin_write().unwrap();\n        txn.set_durability(Durability::None);\n        let mut table = txn.open_multimap_table(table_def).unwrap();\n        table.insert(0, i).unwrap();\n        drop(table);\n        txn.commit().unwrap();\n\n        let txn = db.begin_write().unwrap();\n        let bytes = txn.stats().unwrap().stored_bytes();\n        assert!(bytes > last_size, \"{i}\");\n        last_size = bytes;\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_undefined.rs::test_lenient_undefined", "code": "pub fn undefined_behavior(&self) -> UndefinedBehavior {\n        self.env.undefined_behavior()\n    }", "test": "fn test_lenient_undefined() {\n    let mut env = Environment::new();\n    env.add_filter(\"test\", |state: &State, value: String| -> String {\n        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Lenient);\n        assert_eq!(value, \"\");\n        value\n    });\n\n    assert_eq!(env.undefined_behavior(), UndefinedBehavior::Lenient);\n    assert_eq!(render!(in env, \"<{{ true.missing_attribute }}>\"), \"<>\");\n    assert_eq!(\n        env.render_str(\"{{ undefined.missing_attribute }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        render!(in env, \"<{% for x in undefined %}...{% endfor %}>\"),\n        \"<>\"\n    );\n    assert_eq!(render!(in env, \"<{{ undefined }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ undefined is undefined }}\"), \"true\");\n    assert_eq!(render!(in env, \"{{ undefined|list }}\"), \"[]\");\n    assert_eq!(render!(in env, \"<{{ undefined|test }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ 42 in undefined }}\"), \"false\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_continue", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_continue() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (var i of [1, 2, 3]) {\n                    if (i == 3)\n                        continue;\n                    result = i\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 2),\n        TestAction::assert_eq(\"i\", 3),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_alias", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_hex_suffix_alias() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--hex=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression9", "code": "fn commit(self) {\n        self.file.sync_all().unwrap();\n        self.inner.commit().unwrap();\n    }", "test": "fn regression9() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 118665];\n        t.insert(&452, v.as_slice()).unwrap();\n        t.len().unwrap();\n    }\n    tx.commit().unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_pd_heartbeat.rs::test_store_heartbeat", "code": "pub fn get_capacity(&self) -> u64 {\n        self.capacity\n    }", "test": "fn test_store_heartbeat() {\n    let region_id = 2;\n    let cluster = Cluster::with_node_count(1, None);\n    let store_id = cluster.node(0).id();\n    let router = &cluster.routers[0];\n    // load data to split bucket.\n    let header = Box::new(router.new_request_for(region_id).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n    let data = put.encode();\n    let write_bytes = data.data_size();\n    let (msg, sub) = PeerMsg::simple_write(header, data);\n    router.send(region_id, msg).unwrap();\n    let _resp = block_on(sub.result()).unwrap();\n\n    // report store heartbeat to pd.\n    std::thread::sleep(std::time::Duration::from_millis(50));\n    router\n        .store_router()\n        .send_control(StoreMsg::Tick(StoreTick::PdStoreHeartbeat))\n        .unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(50));\n\n    let stats = block_on(cluster.node(0).pd_client().get_store_stats_async(store_id)).unwrap();\n    if stats.get_start_time() > 0 {\n        assert_ne!(stats.get_capacity(), 0);\n        assert_ne!(stats.get_used_size(), 0);\n        assert_eq!(stats.get_keys_written(), 1);\n        assert!(stats.get_bytes_written() > write_bytes.try_into().unwrap());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_solo_not", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_solo_not() {\n    new_ucmd!().arg(\"!\").succeeds();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_33", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_33() {\n    let original = r##\"# H1 {.foo#bar}\n## H2 {#foo.bar}\n### H3 {.a\"b'c&d}\n\"##;\n    let expected = r##\"<h1 class=\"foo#bar\">H1</h1>\n<h2 id=\"foo.bar\">H2</h2>\n<h3 class=\"a&quot;b'c&amp;d\">H3</h3>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_preserve_empty_line_without_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_preserve_empty_line_without_final_newline() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-b\"])\n        .pipe_in(\"123\\n\\n45\")\n        .succeeds()\n        .stdout_is(\"12\\n3\\n\\n45\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_pd_heartbeat.rs::test_report_buckets", "code": "pub fn get_leader(&self) -> &super::metapb::Peer {\n        self.leader.as_ref().unwrap_or_else(|| super::metapb::Peer::default_instance())\n    }", "test": "fn test_report_buckets() {\n    let region_id = 2;\n    let mut cop_cfg = CopConfig::default();\n    cop_cfg.enable_region_bucket = Some(true);\n    cop_cfg.region_bucket_size = ReadableSize::kb(1);\n    let mut config = v2_default_config();\n    config.region_split_check_diff = Some(ReadableSize::kb(1));\n    let cluster = Cluster::with_cop_cfg(Some(config), cop_cfg);\n    let store_id = cluster.node(0).id();\n    let router = &cluster.routers[0];\n\n    // When there is only one peer, it should campaign immediately.\n    let mut req = RaftCmdRequest::default();\n    req.mut_header().set_peer(new_peer(store_id, 3));\n    req.mut_status_request()\n        .set_cmd_type(StatusCmdType::RegionLeader);\n    let res = router.query(region_id, req.clone()).unwrap();\n    let status_resp = res.response().unwrap().get_status_response();\n    assert_eq!(\n        *status_resp.get_region_leader().get_leader(),\n        new_peer(store_id, 3)\n    );\n    router.wait_applied_to_current_term(region_id, Duration::from_secs(3));\n\n    // load data to split bucket.\n    let mut suffix = String::from(\"\");\n    for _ in 0..200 {\n        suffix.push_str(\"fake \");\n    }\n\n    let repeat: u64 = 10;\n    let bytes = write_keys(&cluster, region_id, &suffix, repeat.try_into().unwrap());\n    // To find the split keys, it should flush memtable manually.\n    let mut cached = cluster.node(0).tablet_registry().get(region_id).unwrap();\n    cached.latest().unwrap().flush_cf(CF_DEFAULT, true).unwrap();\n    // send split region check to split bucket.\n    router\n        .send(region_id, PeerMsg::Tick(PeerTick::SplitRegionCheck))\n        .unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(50));\n    // report buckets to pd.\n    router\n        .send(region_id, PeerMsg::Tick(PeerTick::ReportBuckets))\n        .unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(50));\n\n    let resp = block_on(cluster.node(0).pd_client().get_buckets_by_id(region_id)).unwrap();\n    let mut buckets_tmp = vec![];\n    let mut bucket_ranges = vec![];\n    if let Some(buckets) = resp {\n        assert!(buckets.get_keys().len() > 2);\n        assert_eq!(buckets.get_region_id(), region_id);\n        let write_bytes = buckets.get_stats().get_write_bytes();\n        let write_keys = buckets.get_stats().get_write_keys();\n        for i in 0..buckets.keys.len() - 1 {\n            assert!(write_bytes[i] >= bytes);\n            assert!(write_keys[i] >= repeat);\n        }\n        for i in 0..buckets.keys.len() - 1 {\n            buckets_tmp.push(raftstore::store::Bucket::default());\n            let bucket_range =\n                raftstore::store::BucketRange(buckets.keys[i].clone(), buckets.keys[i + 1].clone());\n            bucket_ranges.push(bucket_range);\n        }\n    }\n\n    // report buckets to pd again, the write bytes and keys should be zero.\n    router\n        .send(region_id, PeerMsg::Tick(PeerTick::ReportBuckets))\n        .unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(50));\n\n    let resp = block_on(cluster.node(0).pd_client().get_buckets_by_id(region_id)).unwrap();\n    if let Some(buckets) = resp {\n        assert_eq!(buckets.get_region_id(), region_id);\n        let write_bytes = buckets.get_stats().get_write_bytes();\n        let write_keys = buckets.get_stats().get_write_keys();\n        for i in 0..buckets.keys.len() - 1 {\n            assert!(write_bytes[i] == 0);\n            assert!(write_keys[i] == 0);\n        }\n    }\n\n    // send the same region buckets to refresh which needs to merge the last.\n    let resp = block_on(cluster.node(0).pd_client().get_region_by_id(region_id)).unwrap();\n    if let Some(region) = resp {\n        let region_epoch = region.get_region_epoch().clone();\n        for _ in 0..2 {\n            let msg = PeerMsg::RefreshRegionBuckets {\n                region_epoch: region_epoch.clone(),\n                buckets: buckets_tmp.clone(),\n                bucket_ranges: Some(bucket_ranges.clone()),\n            };\n            router.send(region_id, msg).unwrap();\n            std::thread::sleep(std::time::Duration::from_millis(50));\n        }\n    }\n    // report buckets to pd again, the write bytes and keys should be zero.\n    router\n        .send(region_id, PeerMsg::Tick(PeerTick::ReportBuckets))\n        .unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(50));\n\n    let resp = block_on(cluster.node(0).pd_client().get_buckets_by_id(region_id)).unwrap();\n    if let Some(buckets) = resp {\n        assert_eq!(buckets.get_region_id(), region_id);\n        let write_bytes = buckets.get_stats().get_write_bytes();\n        let write_keys = buckets.get_stats().get_write_keys();\n        assert_eq!(write_bytes.len(), 1);\n        assert_eq!(write_keys.len(), 1);\n    }\n\n    fn write_keys(cluster: &Cluster, region_id: u64, suffix: &str, repeat: usize) -> u64 {\n        let router = &cluster.routers[0];\n        let header = Box::new(router.new_request_for(region_id).take_header());\n        for i in 0..repeat {\n            let mut put = SimpleWriteEncoder::with_capacity(64);\n            let mut key = format!(\"key-{}\", i);\n            key.push_str(suffix);\n            put.put(CF_DEFAULT, key.as_bytes(), b\"value\");\n            let (msg, sub) = PeerMsg::simple_write(header.clone(), put.clone().encode());\n            router.send(region_id, msg).unwrap();\n            let _resp = block_on(sub.result()).unwrap();\n        }\n        ((suffix.as_bytes().len() + 10) * repeat)\n            .try_into()\n            .unwrap()\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::reject_self_signed_server_cert", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn reject_self_signed_server_cert() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config_with_certs(vec![]));\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::TransportError(ref error)})\n                    if error.code == TransportErrorCode::crypto(AlertDescription::UnknownCA.get_u8()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nproc.rs::test_nproc", "code": "pub fn parse(mode_string: &str, considering_dir: bool, umask: u32) -> Result<u32, String> {\n    if mode_string.chars().any(|c| c.is_ascii_digit()) {\n        mode::parse_numeric(0, mode_string, considering_dir)\n    } else {\n        mode::parse_symbolic(0, mode_string, umask, considering_dir)\n    }\n}", "test": "fn test_nproc() {\n    let nproc: u8 = new_ucmd!().succeeds().stdout_str().trim().parse().unwrap();\n    assert!(nproc > 0);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::apply_suggested_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn apply_suggested_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), APPLY_SUGGESTED_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply-unsafe\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_suggested_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_block_cache_backward_compatible", "code": "pub fn is_none(&self) -> bool {\n        !self.is_some()\n    }", "test": "fn test_block_cache_backward_compatible() {\n    let content = read_file_in_project_dir(\"integrations/config/test-cache-compatible.toml\");\n    let mut cfg: TikvConfig = toml::from_str(&content).unwrap();\n    assert!(cfg.storage.block_cache.capacity.is_none());\n    cfg.compatible_adjust();\n    assert!(cfg.storage.block_cache.capacity.is_some());\n    assert_eq!(\n        cfg.storage.block_cache.capacity.unwrap().0,\n        cfg.rocksdb.defaultcf.block_cache_size.0\n            + cfg.rocksdb.writecf.block_cache_size.0\n            + cfg.rocksdb.lockcf.block_cache_size.0\n            + cfg.raftdb.defaultcf.block_cache_size.0\n    );\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/escape.rs::test_escape_basic", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_escape_basic() {\n    assert_eq!(to_string(&\"\\x07\").unwrap(), \"\\\"\\\\u{7}\\\"\");\n\n    assert_eq!(from_str::<String>(\"\\\"\\\\x07\\\"\").unwrap(), \"\\x07\");\n    assert_eq!(from_str::<String>(\"\\\"\\\\u{7}\\\"\").unwrap(), \"\\x07\");\n\n    assert_eq!(from_str::<char>(\"\\'\\\\x07\\'\").unwrap(), '\\x07');\n    assert_eq!(from_str::<char>(\"\\'\\\\u{7}\\'\").unwrap(), '\\x07');\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::bitwise_and", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn bitwise_and() {\n    test(\"a & b & c\", \"a&b&c;\");\n    test(\"((a & b) & c) & d\", \"a&b&c&d;\");\n    test(\"a & (b & (c & d))\", \"a&b&c&d;\");\n    test(\"a & b == c\", \"a&b==c;\");\n    test(\"a & (b == c)\", \"a&b==c;\");\n    test(\"a == b & c\", \"a==b&c;\");\n    test(\"(a == b) & c\", \"a==b&c;\");\n    test(\"a ^ b & c\", \"a^b&c;\");\n    test(\"(a ^ b) & c\", \"(a^b)&c;\");\n    test(\"(a, b) & (c, d)\", \"(a,b)&(c,d);\");\n    test(\"a, b & c, d\", \"a,b&c,d;\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query_edns", "code": "pub fn eq_case(&self, other: &Self) -> bool {\n        self.cmp_with_f::<CaseSensitive>(other) == Ordering::Equal\n    }", "test": "fn test_query_edns(client: &mut AsyncClient) -> impl Future<Output = ()> {\n    let name = Name::from_ascii(\"WWW.example.com\").unwrap();\n    let mut edns = Edns::new();\n    // garbage subnet value, but lets check\n    edns.options_mut()\n        .insert(EdnsOption::Subnet(\"1.2.0.0/16\".parse().unwrap()));\n\n    // TODO: write builder\n    let mut msg = Message::new();\n    msg.add_query({\n        let mut query = Query::query(name.clone(), RecordType::A);\n        query.set_query_class(DNSClass::IN);\n        query\n    })\n    .set_id(rand::random::<u16>())\n    .set_message_type(MessageType::Query)\n    .set_op_code(OpCode::Query)\n    .set_recursion_desired(true)\n    .set_edns(edns)\n    .extensions_mut()\n    .as_mut()\n    .map(|edns| edns.set_max_payload(1232).set_version(0));\n\n    client\n        .send(msg)\n        .first_answer()\n        .map_ok(move |response| {\n            println!(\"response records: {response:?}\");\n            assert!(response\n                .queries()\n                .first()\n                .expect(\"expected query\")\n                .name()\n                .eq_case(&name));\n\n            let record = &response.answers()[0];\n            assert_eq!(record.name(), &name);\n            assert_eq!(record.record_type(), RecordType::A);\n            assert_eq!(record.dns_class(), DNSClass::IN);\n            assert!(response.extensions().is_some());\n            assert_eq!(\n                response\n                    .extensions()\n                    .as_ref()\n                    .unwrap()\n                    .option(EdnsCode::Subnet)\n                    .unwrap(),\n                &EdnsOption::Subnet(\"1.2.0.0/16\".parse().unwrap())\n            );\n            if let RData::A(ref address) = *record.data().unwrap() {\n                assert_eq!(address, &A::new(93, 184, 216, 34))\n            } else {\n                panic!();\n            }\n        })\n        .map(|r: Result<_, _>| r.expect(\"query failed\"))\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raft_storage.rs::test_raft_storage_store_not_match", "code": "fn clone(&self) -> Self {\n        let refs = self.refs.fetch_add(1, atomic::Ordering::SeqCst);\n\n        trace!(\n            \"Storage referenced\"; \"original_ref\" => refs\n        );\n\n        Self {\n            engine: self.engine.clone(),\n            sched: self.sched.clone(),\n            read_pool: self.read_pool.clone(),\n            refs: self.refs.clone(),\n            max_key_size: self.max_key_size,\n            concurrency_manager: self.concurrency_manager.clone(),\n            api_version: self.api_version,\n            causal_ts_provider: self.causal_ts_provider.clone(),\n            resource_tag_factory: self.resource_tag_factory.clone(),\n            quota_limiter: self.quota_limiter.clone(),\n            _phantom: PhantomData,\n        }\n    }", "test": "fn test_raft_storage_store_not_match() {\n    let (_cluster, storage, mut ctx) = new_raft_storage();\n\n    let key = Key::from_raw(b\"key\");\n    assert_eq!(storage.get(ctx.clone(), &key, 5).unwrap().0, None);\n    storage\n        .prewrite(\n            ctx.clone(),\n            vec![Mutation::make_put(key.clone(), b\"value\".to_vec())],\n            b\"key\".to_vec(),\n            10,\n        )\n        .unwrap();\n    storage\n        .commit(ctx.clone(), vec![key.clone()], 10, 15)\n        .unwrap();\n    assert_eq!(\n        storage.get(ctx.clone(), &key, 20).unwrap().0.unwrap(),\n        b\"value\".to_vec()\n    );\n\n    // Test store not match.\n    let mut peer = ctx.get_peer().clone();\n    let store_id = peer.get_store_id();\n\n    peer.set_store_id(store_id + 1);\n    ctx.set_peer(peer);\n    storage.get(ctx.clone(), &key, 20).unwrap_err();\n    let res = storage.get(ctx.clone(), &key, 20);\n    if let StorageError(box StorageErrorInner::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n        box KvErrorInner::Request(ref e),\n    ))))) = *res.as_ref().err().unwrap()\n    {\n        assert!(e.has_store_not_match());\n    } else {\n        panic!(\"expect store_not_match, but got {:?}\", res);\n    }\n    storage\n        .batch_get(ctx.clone(), &[key.clone()], 20)\n        .unwrap_err();\n    storage\n        .scan(ctx.clone(), key, None, 1, false, 20)\n        .unwrap_err();\n    storage.scan_locks(ctx, 20, None, None, 100).unwrap_err();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_rm_interactive_file_a\";\n    let file_b = \"test_rm_interactive_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"n\")\n        .succeeds();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"Yesh\") // spell-checker:disable-line\n        .succeeds();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_invoke", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn timeout_in_invoke() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-invoke.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::circular_include", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn circular_include() {\n  Test::new()\n    .justfile(\"!include a\")\n    .tree(tree! {\n      a: \"!include b\",\n      b: \"!include a\",\n    })\n    .arg(\"--unstable\")\n    .status(EXIT_FAILURE)\n    .stderr_regex(path_for_regex(\n      \"error: Include `.*/a` in `.*/b` is a circular include\\n\",\n    ))\n    .run();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::unary_operations_on_this", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn unary_operations_on_this() {\n    // https://tc39.es/ecma262/#sec-assignment-operators-static-semantics-early-errors\n    run_test_actions([\n        TestAction::assert_native_error(\n            \"++this\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 1\",\n        ),\n        TestAction::assert_native_error(\n            \"--this\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 1\",\n        ),\n        TestAction::assert_native_error(\n            \"this++\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 5\",\n        ),\n        TestAction::assert_native_error(\n            \"this--\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 5\",\n        ),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_directory_no_parents", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_ignore_nonempty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n    at.touch(DIR_FILE);\n\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(DIR)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(DIR));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=none\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert!(!at.file_exists(format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pathchk.rs::test_posix_special", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_posix_special() {\n    // test the posix special mode\n\n    // accept some reasonable default\n    new_ucmd!().args(&[\"-P\", \"dir/file\"]).succeeds().no_stdout();\n\n    // accept non-portable chars\n    new_ucmd!()\n        .args(&[\"-P\", \"dir#/$file\"])\n        .succeeds()\n        .no_stdout();\n\n    // accept non-leading hyphen\n    new_ucmd!()\n        .args(&[\"-P\", \"dir/file-name\"])\n        .succeeds()\n        .no_stdout();\n\n    // fail on long path\n    new_ucmd!()\n        .args(&[\"-P\", \"dir\".repeat(libc::PATH_MAX as usize + 1).as_str()])\n        .fails()\n        .no_stdout();\n\n    // fail on long filename\n    new_ucmd!()\n        .args(&[\n            \"-P\",\n            format!(\"dir/{}\", \"file\".repeat(libc::FILENAME_MAX as usize + 1)).as_str(),\n        ])\n        .fails()\n        .no_stdout();\n\n    // fail on leading hyphen char\n    new_ucmd!().args(&[\"-P\", \"dir/-file\"]).fails().no_stdout();\n\n    // fail on empty path\n    new_ucmd!().args(&[\"-P\", \"\"]).fails().no_stdout();\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::issue_4", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn issue_4() {\n    setup();\n\n    // test if sheet is resolved with only one row\n    let path = format!(\"{}/tests/issues.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"issue5\").unwrap().unwrap();\n    range_eq!(range, [[Float(0.5)]]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printf.rs::escaped_slash", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn escaped_slash() {\n    new_ucmd!()\n        .args(&[\"hello\\\\\\\\ world\"])\n        .succeeds()\n        .stdout_only(\"hello\\\\ world\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::floor_log5_pow2_test", "code": "fn dragonbox_log5_2(q: i32) -> i32 {\n    let c = floor_shift(0, 0x6e40d1a4143dcb94, 20);\n    let s = floor_shift(0, 0, 20);\n    (q * c - s) >> 20\n}", "test": "fn floor_log5_pow2_test() {\n    for q in -1492i32..=1492 {\n        let actual = algorithm::floor_log5_pow2(q);\n        let expected = dragonbox_log5_2(q);\n        assert_eq!(actual, expected);\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/quote.rs::quoted_strings_can_be_used_as_arguments", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn quoted_strings_can_be_used_as_arguments() {\n  Test::new()\n    .justfile(\n      r#\"\n      file := quote(\"foo ' bar\")\n\n      @foo:\n        touch {{ file }}\n        ls -1\n    \"#,\n    )\n    .stdout(\"foo ' bar\\njustfile\\n\")\n    .run();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_select_star_replace", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_select_star_replace() {\n    clickhouse().verified_stmt(\"SELECT * REPLACE (i + 1 AS i) FROM columns_transformers\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_elided", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_too_small_line_num_elided() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"-z\", \"/20/\", \"10\", \"/40/\"])\n        .succeeds()\n        .stdout_only(\"48\\n60\\n33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), generate(20, 40));\n    assert_eq!(at.read(\"xx02\"), generate(40, 51));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/table.rs::table_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn table_test_2() {\n    let original = r##\"Test|Table\n----|-----\n\"##;\n    let expected = r##\"<table><thead><tr><th>Test</th><th>Table</th></tr></thead>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_hex", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_hex() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\x41\"])\n        .succeeds()\n        .stdout_only(\"A\\n\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::non_durable_read_isolation", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn non_durable_read_isolation() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut write_txn = db.begin_write().unwrap();\n    write_txn.set_durability(Durability::None);\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let read_table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", read_table.get(\"hello\").unwrap().unwrap().value());\n\n    let mut write_txn = db.begin_write().unwrap();\n    write_txn.set_durability(Durability::None);\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.remove(\"hello\").unwrap();\n        table.insert(\"hello2\", \"world2\").unwrap();\n        table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let read_table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(read_table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\n        \"world2\",\n        read_table2.get(\"hello2\").unwrap().unwrap().value()\n    );\n    assert_eq!(\n        \"world3\",\n        read_table2.get(\"hello3\").unwrap().unwrap().value()\n    );\n    assert_eq!(read_table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", read_table.get(\"hello\").unwrap().unwrap().value());\n    assert!(read_table.get(\"hello2\").unwrap().is_none());\n    assert!(read_table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(read_table.len().unwrap(), 1);\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/rayon.rs::decoding_in_limited_threadpool_does_not_deadlock", "code": "pub fn decode(&mut self) -> Result<Vec<u8>> {\n        WorkerScope::with(|worker| self.decode_internal(false, worker))\n    }", "test": "fn decoding_in_limited_threadpool_does_not_deadlock() {\n    let path = Path::new(\"tests\").join(\"reftest\").join(\"images\").join(\"mozilla\").join(\"jpg-progressive.jpg\");\n\n    let pool = rayon::ThreadPoolBuilder::new()\n        .num_threads(1)\n        .build()\n        .unwrap();\n    pool.install(|| {\n        let mut decoder = Decoder::new(File::open(&path).unwrap());\n        let _ = decoder.decode().unwrap();\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_after_delete.rs::test_node_compact_after_delete", "code": "fn test_compact_after_delete<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.region_compact_check_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.region_compact_min_tombstones = 500;\n    cluster.cfg.raft_store.region_compact_tombstones_percent = 50;\n    cluster.cfg.raft_store.region_compact_check_step = Some(1);\n    cluster.cfg.rocksdb.titan.enabled = true;\n    cluster.run();\n\n    for i in 0..1000 {\n        let (k, v) = (format!(\"k{}\", i), format!(\"value{}\", i));\n        let (k, v) = gen_mvcc_put_kv(k.as_bytes(), v.as_bytes(), 1.into(), 2.into());\n        cluster.must_put_cf(CF_WRITE, &k, &v);\n    }\n    for engines in cluster.engines.values() {\n        engines.kv.flush_cf(CF_WRITE, true).unwrap();\n    }\n    let (sender, receiver) = mpsc::channel();\n    let sync_sender = Mutex::new(sender);\n    fail::cfg_callback(\n        \"raftstore::compact::CheckAndCompact:AfterCompact\",\n        move || {\n            let sender = sync_sender.lock().unwrap();\n            sender.send(true).unwrap();\n        },\n    )\n    .unwrap();\n    for i in 0..1000 {\n        let k = format!(\"k{}\", i);\n        let k = gen_delete_k(k.as_bytes(), 2.into());\n        cluster.must_delete_cf(CF_WRITE, &k);\n    }\n    for engines in cluster.engines.values() {\n        engines.kv.flush_cf(CF_WRITE, true).unwrap();\n    }\n\n    // wait for compaction.\n    receiver.recv_timeout(Duration::from_millis(5000)).unwrap();\n\n    for engines in cluster.engines.values() {\n        let cf_handle = get_cf_handle(engines.kv.as_inner(), CF_WRITE).unwrap();\n        let approximate_size = engines\n            .kv\n            .as_inner()\n            .get_approximate_sizes_cf(cf_handle, &[Range::new(b\"\", DATA_MAX_KEY)])[0];\n        assert_eq!(approximate_size, 0);\n    }\n}", "test": "fn test_node_compact_after_delete() {\n    let count = 1;\n    let mut cluster = new_node_cluster(0, count);\n    test_compact_after_delete(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_too_large", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_too_large() {\n    new_ucmd!()\n        .args(&[\"-b1-18446744073709551615\", \"/dev/null\"])\n        .fails()\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_final_newline_when_line_equal_to_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_final_newline_when_line_equal_to_fold() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"1\\n\")\n        .succeeds()\n        .stdout_is(\"1\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_human_block_sizes", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_human_block_sizes() {\n    test_helper(\n        \"human_block_sizes\",\n        &[\"-h\", \"--human-numeric-sort\", \"--sort=human-numeric\"],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_cluster_restart", "code": "fn test_multi_cluster_restart<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    assert_eq!(cluster.get(key), None);\n    cluster.must_put(key, value);\n\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    cluster.shutdown();\n\n    // avoid TIMEWAIT\n    sleep_ms(500);\n\n    cluster.start().unwrap();\n\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n}", "test": "fn test_multi_server_cluster_restart() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_cluster_restart(&mut cluster)\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_fetch.rs::test_node_async_fetch", "code": "pub fn get_index(&self) -> u64 {\n        self.index\n    }", "test": "fn test_node_async_fetch() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100000);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 50;\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize::mb(20));\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.raft_log_reserve_max_ticks = 2;\n    cluster.cfg.raft_store.raft_entry_cache_life_time = ReadableDuration::millis(100);\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let mut before_states = HashMap::default();\n\n    for (&id, engines) in &cluster.engines {\n        must_get_equal(&engines.kv, b\"k1\", b\"v1\");\n        let mut state: RaftApplyState = engines\n            .kv\n            .get_msg_cf(CF_RAFT, &keys::apply_state_key(1))\n            .unwrap()\n            .unwrap_or_default();\n        let state = state.take_truncated_state();\n        // compact should not start\n        assert_eq!(RAFT_INIT_LOG_INDEX, state.get_index());\n        assert_eq!(RAFT_INIT_LOG_TERM, state.get_term());\n        before_states.insert(id, state);\n    }\n\n    cluster.stop_node(1);\n\n    for i in 1..60u32 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n    }\n\n    // wait log gc.\n    sleep_ms(500);\n\n    let (sender, receiver) = mpsc::channel();\n    let sync_sender = Mutex::new(sender);\n    fail::cfg_callback(\"on_async_fetch_return\", move || {\n        let sender = sync_sender.lock().unwrap();\n        sender.send(true).unwrap();\n    })\n    .unwrap();\n    cluster.run_node(1).unwrap();\n\n    // limit has not reached, should not gc.\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = engines\n            .kv\n            .get_msg_cf(CF_RAFT, &keys::apply_state_key(1))\n            .unwrap()\n            .unwrap_or_default();\n        let after_state = state.take_truncated_state();\n\n        let before_state = &before_states[&id];\n        let idx = after_state.get_index();\n        assert_eq!(idx, before_state.get_index());\n    }\n\n    assert_eq!(\n        receiver.recv_timeout(Duration::from_millis(500)).unwrap(),\n        true\n    );\n\n    // logs should be replicated to node 1 successfully.\n    for i in 1..60u32 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        must_get_equal(&cluster.engines[&1].kv, &k, &v);\n    }\n\n    for i in 60..500u32 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n        let v2 = cluster.get(&k);\n        assert_eq!(v2, Some(v));\n\n        if i > 100\n            && check_compacted(\n                &cluster.engines,\n                &before_states,\n                1,\n                false, // must_compacted\n            )\n        {\n            return;\n        }\n    }\n    check_compacted(\n        &cluster.engines,\n        &before_states,\n        1,\n        true, // must_compacted\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_twice_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_twice_dir() {\n    let dir = \"dir\";\n    let scene = TestScenario::new(util_name!());\n\n    scene.ucmd().arg(\"-d\").arg(dir).succeeds();\n    scene.ucmd().arg(\"-d\").arg(dir).succeeds();\n    let at = &scene.fixtures;\n\n    assert!(at.dir_exists(dir));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::prints_correct_error_message_when_recipe_not_found", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn prints_correct_error_message_when_recipe_not_found() {\n  Test::new()\n    .tree(tree! {\n      bar: {\n        justfile: \"\n          set fallback := true\n\n          bar:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\n      \"\n      bar:\n        echo root\n    \",\n    )\n    .args([\"foo\"])\n    .current_dir(\"bar\")\n    .status(EXIT_FAILURE)\n    .stderr(\n      \"\n      error: Justfile does not contain recipe `foo`.\n    \",\n    )\n    .run();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_with_non_existent_parent_inscription", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_with_non_existent_parent_inscription() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  let parent_id = \"0000000000000000000000000000000000000000000000000000000000000000i0\";\n\n  CommandBuilder::new(format!(\n    \"wallet inscribe --fee-rate 1.0 --parent {parent_id} --file child.png\"\n  ))\n  .write(\"child.png\", [1; 520])\n  .rpc_server(&rpc_server)\n  .expected_stderr(format!(\"error: parent {parent_id} does not exist\\n\"))\n  .expected_exit_code(1)\n  .run_and_extract_stdout();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_with_uncommitted_conf_change", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_with_uncommitted_conf_change() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 10;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(90);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    // an uncommitted conf-change\n    let cmd = new_change_peer_request(\n        ConfChangeType::RemoveNode,\n        find_peer(&region, 2).unwrap().clone(),\n    );\n    let req = new_admin_request(region.get_id(), region.get_region_epoch(), cmd);\n    cluster\n        .call_command_on_leader(req, Duration::from_millis(10))\n        .unwrap_err();\n\n    // wait election timeout\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 2,\n    ));\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // the uncommitted conf-change is committed successfully after being force\n    // leader\n    cluster\n        .pd_client\n        .must_none_peer(region.get_id(), find_peer(&region, 2).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), Some(b\"v2\".to_vec()));\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_mkdir", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_mkdir_mkdir() {\n    let _guard = TEST_MUTEX.lock();\n    new_ucmd!().arg(\"test_dir\").succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_stream_batch_row_limit", "code": "pub fn get_ranges(&self) -> &[KeyRange] {\n        &self.ranges\n    }", "test": "fn test_stream_batch_row_limit() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n        (8, Some(\"name:2\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let stream_row_limit = 2;\n    let (_, endpoint, _) = {\n        let engine = TestEngineBuilder::new().build().unwrap();\n        let mut cfg = Config::default();\n        cfg.end_point_stream_batch_row_limit = stream_row_limit;\n        init_data_with_details(Context::default(), engine, &product, &data, true, &cfg)\n    };\n\n    let req = DagSelect::from(&product).build();\n    assert_eq!(req.get_ranges().len(), 1);\n\n    // only ignore first 7 bytes of the row id\n    let ignored_suffix_len = tidb_query_datatype::codec::table::RECORD_ROW_KEY_LEN - 1;\n\n    // `expected_ranges_last_bytes` checks those assertions:\n    // 1. We always fetch no more than stream_row_limit rows.\n    // 2. The responses' key ranges are disjoint.\n    // 3. Each returned key range should cover the returned rows.\n    let mut expected_ranges_last_bytes: Vec<(&[u8], &[u8])> = vec![\n        (b\"\\x00\", b\"\\x02\\x00\"),\n        (b\"\\x02\\x00\", b\"\\x05\\x00\"),\n        (b\"\\x05\\x00\", b\"\\xFF\"),\n    ];\n    let check_range = move |resp: &Response| {\n        let (start_last_bytes, end_last_bytes) = expected_ranges_last_bytes.remove(0);\n        let start = resp.get_range().get_start();\n        let end = resp.get_range().get_end();\n        assert_eq!(&start[ignored_suffix_len..], start_last_bytes);\n\n        assert_eq!(&end[ignored_suffix_len..], end_last_bytes);\n    };\n\n    let resps = handle_streaming_select(&endpoint, req, check_range);\n    assert_eq!(resps.len(), 3);\n    let expected_output_counts = vec![vec![2_i64], vec![2_i64], vec![1_i64]];\n    for (i, resp) in resps.into_iter().enumerate() {\n        let mut chunk = Chunk::default();\n        chunk.merge_from_bytes(resp.get_data()).unwrap();\n        assert_eq!(\n            resp.get_output_counts(),\n            expected_output_counts[i].as_slice(),\n        );\n\n        let chunks = vec![chunk];\n        let chunk_data_limit = stream_row_limit * 3; // we have 3 fields.\n        check_chunk_datum_count(&chunks, chunk_data_limit);\n\n        let spliter = DagChunkSpliter::new(chunks, 3);\n        let j = cmp::min((i + 1) * stream_row_limit, data.len());\n        let cur_data = &data[i * stream_row_limit..j];\n        for (row, &(id, name, cnt)) in spliter.zip(cur_data) {\n            let name_datum = name.map(|s| s.as_bytes()).into();\n            let expected_encoded = datum::encode_value(\n                &mut EvalContext::default(),\n                &[Datum::I64(id), name_datum, cnt.into()],\n            )\n            .unwrap();\n            let result_encoded = datum::encode_value(&mut EvalContext::default(), &row).unwrap();\n            assert_eq!(result_encoded, &*expected_encoded);\n        }\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_weak_gc_test", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "test": "fn eph_weak_gc_test() {\n    run_test(|| {\n        let gc_value = Gc::new(3);\n\n        {\n            let cloned_gc = gc_value.clone();\n\n            let weak = WeakGc::new(&cloned_gc);\n\n            assert_eq!(*weak.upgrade().expect(\"Is live currently\"), 3);\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(*weak.upgrade().expect(\"WeakGc is still live here\"), 3);\n\n            drop(gc_value);\n            force_collect();\n\n            assert!(weak.upgrade().is_none());\n        }\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_io.rs::test_async_io_delay_destroy_after_conf_change", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_async_io_delay_destroy_after_conf_change() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let on_handle_apply_fp = \"on_handle_apply\";\n    fail::cfg(on_handle_apply_fp, \"pause\").unwrap();\n\n    // Remove leader itself.\n    pd_client.remove_peer(r1, new_peer(1, 1));\n    // Wait for sending the conf change to other peers\n    sleep_ms(100);\n    // Peer 1 can not be removed because the conf change can not apply\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    let raft_before_save_on_store_1_fp = \"raft_before_save_on_store_1\";\n    fail::cfg(raft_before_save_on_store_1_fp, \"pause\").unwrap();\n\n    for i in 2..10 {\n        cluster\n            .async_put(format!(\"k{}\", i).as_bytes(), b\"v\")\n            .unwrap();\n    }\n\n    fail::remove(on_handle_apply_fp);\n    // Wait for applying conf change\n    sleep_ms(100);\n    // Peer 1 should not be destroyed now due to delay destroy\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n    fail::remove(raft_before_save_on_store_1_fp);\n    // Peer 1 should be destroyed as expected\n    must_get_none(&cluster.get_engine(1), b\"k1\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_single_tab_should_not_add_extra_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_single_tab_should_not_add_extra_newline() {\n    new_ucmd!()\n        .arg(\"-w1\")\n        .pipe_in(\"\\t\")\n        .succeeds()\n        .stdout_is(\"\\t\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/list.rs::output_not_found", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn output_not_found() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  CommandBuilder::new(\n    \"--index-sats list 0000000000000000000000000000000000000000000000000000000000000000:0\",\n  )\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(\"error: output not found\\n\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_plus_long_columns", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_trailing_plus_long_columns() {\n    new_ucmd!()\n        .arg(\"--tabs=1,+3\")\n        .pipe_in(\"\\taaaa\\tbbbb\\tcccc\")\n        .succeeds()\n        //          0         1\n        //          012345678901234567\n        .stdout_is(\" aaaa  bbbb  cccc\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_default_shell", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_default_shell() {\n    // NOTE: This test intends to trigger code which can only be reached with root permissions.\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let dir = \"CHROOT_DIR\";\n    at.mkdir(dir);\n\n    let shell = std::env::var(\"SHELL\").unwrap_or_else(|_| \"/bin/sh\".to_string());\n    let expected = format!(\"chroot: failed to run command '{shell}': No such file or directory\");\n\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir]) {\n        result.stderr_contains(expected);\n    } else {\n        print!(\"TEST SKIPPED\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_stdin_all_counts", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_stdin_all_counts() {\n    new_ucmd!()\n        .args(&[\"-c\", \"-m\", \"-l\", \"-L\", \"-w\"])\n        .pipe_in_fixture(\"alice_in_wonderland.txt\")\n        .run()\n        .stdout_is(\"      5      57     302     302      66\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::test_labelled_block", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn test_labelled_block() {\n    run_test_actions([TestAction::assert(indoc! {r#\"\n            let result = true;\n            {\n                let x = 2;\n                L: {\n                    let x = 3;\n                    result &&= (x === 3);\n                    break L;\n                    result &&= (false);\n                }\n                result &&= (x === 2);\n            }\n            result;\n        \"#})]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_type_option", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_type_option() {\n    let fs_types = new_ucmd!()\n        .arg(\"--output=fstype\")\n        .succeeds()\n        .stdout_move_str();\n    let fs_type = fs_types.lines().nth(1).unwrap().trim();\n\n    new_ucmd!().args(&[\"-t\", fs_type]).succeeds();\n    new_ucmd!()\n        .args(&[\"-t\", fs_type, \"-t\", \"nonexisting\"])\n        .succeeds();\n    new_ucmd!()\n        .args(&[\"-t\", \"nonexisting\"])\n        .fails()\n        .stderr_contains(\"no file systems processed\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_verbose_nested_failure", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_verbose_nested_failure() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(\"dir/ect/file\");\n\n    ucmd.arg(\"-pv\")\n        .arg(NESTED_DIR)\n        .fails()\n        .stdout_is(\n            \"rmdir: removing directory, 'dir/ect/ory'\\n\\\n             rmdir: removing directory, 'dir/ect'\\n\",\n        )\n        .stderr_is(format!(\"rmdir: failed to remove 'dir/ect': {NOT_EMPTY}\\n\"));\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_b_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_internally_b_ser() {\n    let v = EnumStructInternally::VariantB { foo: 1, bar: 2 };\n    let e = \"(type:\\\"VariantB\\\",foo:1,bar:2)\";\n    test_ser(&v, e);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_change_observer.rs::test_region_change_observer", "code": "fn test_region_change_observer_impl(mut cluster: Cluster<NodeCluster>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let receiver: Receiver<(Region, RegionChangeEvent)>;\n    let r1;\n    {\n        let (tx, rx) = channel();\n\n        cluster\n            .sim\n            .wl()\n            .post_create_coprocessor_host(Box::new(move |id, host| {\n                if id == 1 {\n                    let (sender, receiver) = sync_channel(10);\n                    host.registry.register_region_change_observer(\n                        1,\n                        BoxRegionChangeObserver::new(TestObserver { sender }),\n                    );\n                    tx.send(receiver).unwrap();\n                }\n            }));\n        r1 = cluster.run_conf_change();\n\n        // Only one node has node_id = 1\n        receiver = rx.recv().unwrap();\n        rx.try_recv().unwrap_err();\n    }\n\n    // Init regions\n    let init_region_event = receiver.recv().unwrap();\n    receiver.try_recv().unwrap_err();\n    assert_eq!(init_region_event.1, RegionChangeEvent::Create);\n    assert_eq!(init_region_event.0.get_id(), r1);\n    assert_eq!(init_region_event.0.get_peers().len(), 1);\n\n    // Change peer\n    pd_client.must_add_peer(r1, new_peer(2, 10));\n    let add_peer_event = receiver.recv().unwrap();\n    receiver.try_recv().unwrap_err();\n    assert_eq!(\n        add_peer_event.1,\n        RegionChangeEvent::Update(RegionChangeReason::ChangePeer)\n    );\n    assert_eq!(add_peer_event.0.get_id(), r1);\n    assert_eq!(add_peer_event.0.get_peers().len(), 2);\n    assert_ne!(\n        add_peer_event.0.get_region_epoch(),\n        init_region_event.0.get_region_epoch()\n    );\n\n    // Split\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    cluster.must_split(&add_peer_event.0, b\"k2\");\n    let mut split_update = receiver.recv().unwrap();\n    let mut split_create = receiver.recv().unwrap();\n    // We should receive an `Update` and a `Create`. The order of them is not\n    // important.\n    if split_update.1 != RegionChangeEvent::Update(RegionChangeReason::Split) {\n        mem::swap(&mut split_update, &mut split_create);\n    }\n    // No more events\n    receiver.try_recv().unwrap_err();\n    assert_eq!(\n        split_update.1,\n        RegionChangeEvent::Update(RegionChangeReason::Split)\n    );\n    assert_eq!(split_update.0.get_id(), r1);\n    assert_ne!(\n        split_update.0.get_region_epoch(),\n        add_peer_event.0.get_region_epoch()\n    );\n    let r2 = split_create.0.get_id();\n    assert_ne!(r2, r1);\n    assert_eq!(split_create.1, RegionChangeEvent::Create);\n    if split_update.0.get_start_key().is_empty() {\n        assert_eq!(split_update.0.get_end_key(), b\"k2\");\n        assert_eq!(split_create.0.get_start_key(), b\"k2\");\n        assert!(split_create.0.get_end_key().is_empty());\n    } else {\n        assert_eq!(split_update.0.get_start_key(), b\"k2\");\n        assert!(split_update.0.get_end_key().is_empty());\n        assert!(split_create.0.get_start_key().is_empty());\n        assert_eq!(split_create.0.get_end_key(), b\"k2\");\n    }\n\n    // Merge\n    pd_client.must_merge(split_update.0.get_id(), split_create.0.get_id());\n    // An `Update` produced by PrepareMerge. Ignore it.\n    assert_eq!(\n        receiver.recv().unwrap().1,\n        RegionChangeEvent::Update(RegionChangeReason::PrepareMerge)\n    );\n    let mut merge_update = receiver.recv().unwrap();\n    let mut merge_destroy = receiver.recv().unwrap();\n    // We should receive an `Update` and a `Destroy`. The order of them is not\n    // important.\n    if merge_update.1 != RegionChangeEvent::Update(RegionChangeReason::CommitMerge) {\n        mem::swap(&mut merge_update, &mut merge_destroy);\n    }\n    // No more events\n    receiver.try_recv().unwrap_err();\n    assert_eq!(\n        merge_update.1,\n        RegionChangeEvent::Update(RegionChangeReason::CommitMerge)\n    );\n    assert!(merge_update.0.get_start_key().is_empty());\n    assert!(merge_update.0.get_end_key().is_empty());\n    assert_eq!(merge_destroy.1, RegionChangeEvent::Destroy);\n    if merge_update.0.get_id() == split_update.0.get_id() {\n        assert_eq!(merge_destroy.0.get_id(), split_create.0.get_id());\n        assert_ne!(\n            merge_update.0.get_region_epoch(),\n            split_update.0.get_region_epoch()\n        );\n    } else {\n        assert_eq!(merge_update.0.get_id(), split_create.0.get_id());\n        assert_eq!(merge_destroy.0.get_id(), split_update.0.get_id());\n        assert_ne!(\n            merge_update.0.get_region_epoch(),\n            split_create.0.get_region_epoch()\n        );\n    }\n\n    // Move out from this node\n    // After last time calling \"must_add_peer\", this region must have two peers\n    assert_eq!(merge_update.0.get_peers().len(), 2);\n    let r = merge_update.0.get_id();\n\n    pd_client.must_remove_peer(r, find_peer(&merge_update.0, 1).unwrap().clone());\n\n    let remove_peer_update = receiver.recv().unwrap();\n    // After being removed from the region's peers, an update is triggered at first.\n    assert_eq!(\n        remove_peer_update.1,\n        RegionChangeEvent::Update(RegionChangeReason::ChangePeer)\n    );\n    assert!(find_peer(&remove_peer_update.0, 1).is_none());\n\n    let remove_peer_destroy = receiver.recv().unwrap();\n    receiver.try_recv().unwrap_err();\n    assert_eq!(remove_peer_destroy.1, RegionChangeEvent::Destroy);\n    assert_eq!(remove_peer_destroy.0.get_id(), r);\n\n    pd_client.must_add_peer(r, new_peer(1, 2333));\n    let add_peer_event = receiver.recv().unwrap();\n    receiver.try_recv().unwrap_err();\n    assert_eq!(add_peer_event.1, RegionChangeEvent::Create);\n    assert_eq!(add_peer_event.0.get_id(), r);\n    assert_eq!(find_peer(&add_peer_event.0, 1).unwrap().get_id(), 2333);\n\n    // No more messages\n    receiver.recv_timeout(Duration::from_secs(1)).unwrap_err();\n}", "test": "fn test_region_change_observer() {\n    let cluster = new_node_cluster(1, 3);\n    test_region_change_observer_impl(cluster);\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/json.rs::json_string", "code": "fn string(input: &str) -> IResult<&str, String> {\n  delimited(\n    char('\"'),\n    fold_many0(character, String::new, |mut string, c| {\n      string.push(c);\n      string\n    }),\n    char('\"'),\n  )(input)\n}", "test": "fn json_string() {\n  assert_eq!(string(\"\\\"\\\"\"), Ok((\"\", \"\".to_string())));\n  assert_eq!(string(\"\\\"abc\\\"\"), Ok((\"\", \"abc\".to_string())));\n  assert_eq!(\n    string(\"\\\"abc\\\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0001\\\\u2014\\u{2014}def\\\"\"),\n    Ok((\"\", \"abc\\\"\\\\/\\x08\\x0C\\n\\r\\t\\x01\u2014\u2014def\".to_string())),\n  );\n  assert_eq!(string(\"\\\"\\\\uD83D\\\\uDE10\\\"\"), Ok((\"\", \"\ud83d\ude10\".to_string())));\n\n  assert!(string(\"\\\"\").is_err());\n  assert!(string(\"\\\"abc\").is_err());\n  assert!(string(\"\\\"\\\\\\\"\").is_err());\n  assert!(string(\"\\\"\\\\u123\\\"\").is_err());\n  assert!(string(\"\\\"\\\\uD800\\\"\").is_err());\n  assert!(string(\"\\\"\\\\uD800\\\\uD800\\\"\").is_err());\n  assert!(string(\"\\\"\\\\uDC00\\\"\").is_err());\n}\n\n#[tes"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_no_clobber_force_last_arg_wins", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_interactive_no_clobber_force_last_arg_wins() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"a.txt\";\n    let file_b = \"b.txt\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-f\", \"-i\", \"-n\"])\n        .fails()\n        .stderr_is(format!(\"mv: not replacing '{file_b}'\\n\"));\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-n\", \"-f\", \"-i\"])\n        .fails()\n        .stderr_is(format!(\"mv: overwrite '{file_b}'? \"));\n\n    at.write(file_a, \"aa\");\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-i\", \"-n\", \"-f\"])\n        .succeeds()\n        .no_output();\n\n    assert!(!at.file_exists(file_a));\n    assert_eq!(\"aa\", at.read(file_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_invalid_argument", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_argument() {\n    new_ucmd!().arg(\"--invalid\").fails().code_is(125);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscriptions_page_is_sorted", "code": "pub(crate) fn assert_response_regex(&self, path: impl AsRef<str>, regex: impl AsRef<str>) {\n    self.sync_server();\n\n    let response = reqwest::blocking::get(self.url().join(path.as_ref()).unwrap()).unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n    assert_regex_match!(response.text().unwrap(), regex.as_ref());\n  }", "test": "fn inscriptions_page_is_sorted() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let mut regex = String::new();\n\n  for _ in 0..8 {\n    let (inscription, _) = inscribe(&rpc_server);\n    regex.insert_str(0, &format!(\".*<a href=/inscription/{inscription}>.*\"));\n  }\n\n  TestServer::spawn_with_args(&rpc_server, &[]).assert_response_regex(\"/inscriptions\", &regex);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::empty_let_decl_undefined", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn empty_let_decl_undefined() {\n    run_test_actions([TestAction::assert_eq(\"let a; a\", JsValue::undefined())]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::first_last", "code": "fn first(&self) -> Result<Option<(AccessGuard<K>, AccessGuard<V>)>> {\n        self.iter()?.next().transpose()\n    }", "test": "fn first_last() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert!(table.first().unwrap().is_none());\n        assert!(table.last().unwrap().is_none());\n        table.insert(\"a\", \"world1\").unwrap();\n        assert_eq!(table.first().unwrap().unwrap().0.value(), \"a\");\n        assert_eq!(table.last().unwrap().unwrap().0.value(), \"a\");\n        table.insert(\"b\", \"world2\").unwrap();\n        table.insert(\"c\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(table.first().unwrap().unwrap().0.value(), \"a\");\n    assert_eq!(table.last().unwrap().unwrap().0.value(), \"c\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_resource_group", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_resource_group() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let resource_manager = ResourceGroupManager::default();\n\n    let get_group = |name: &str, read_tokens: u64, write_tokens: u64| -> ResourceGroup {\n        let mut group = ResourceGroup::new();\n        group.set_name(name.to_string());\n        group.set_mode(GroupMode::RawMode);\n        let mut resource_setting = GroupRawResourceSettings::new();\n        resource_setting\n            .mut_cpu()\n            .mut_settings()\n            .set_fill_rate(read_tokens);\n        resource_setting\n            .mut_io_write()\n            .mut_settings()\n            .set_fill_rate(write_tokens);\n        group.set_raw_resource_settings(resource_setting);\n        group\n    };\n\n    resource_manager.add_resource_group(get_group(\"group1\", 10, 10));\n    resource_manager.add_resource_group(get_group(\"group2\", 100, 100));\n\n    let mut cfg = Config::default();\n    cfg.pool_size = 1;\n    let (router, mut system) = batch_system::create_system(\n        &cfg,\n        control_tx,\n        control_fsm,\n        Some(resource_manager.derive_controller(\"test\".to_string(), false)),\n    );\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    let state_cnt = Arc::new(AtomicUsize::new(0));\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                r.register(1, BasicMailbox::new(tx, runner, state_cnt.clone()));\n                let (tx2, runner2) = Runner::new(10);\n                r.register(2, BasicMailbox::new(tx2, runner2, state_cnt));\n                tx_.send(0).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    let tx_ = tx.clone();\n    let (tx1, rx1) = std::sync::mpsc::sync_channel(0);\n    // block the thread\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                tx_.send(0).unwrap();\n                tx1.send(0).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    router\n        .send(1, Message::Resource(\"group1\".to_string(), 1))\n        .unwrap();\n    let tx_ = tx.clone();\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx_.send(1).unwrap();\n            })),\n        )\n        .unwrap();\n\n    router\n        .send(2, Message::Resource(\"group2\".to_string(), 1))\n        .unwrap();\n    router\n        .send(\n            2,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(2).unwrap();\n            })),\n        )\n        .unwrap();\n\n    // pause the blocking thread\n    assert_eq!(rx1.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    // should recv from group2 first, because group2 has more tokens and it would be\n    // handled with higher priority.\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(2));\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/num.rs::float_test", "code": "fn check_float<T: Float>(x: T) {\n    // Check functions\n    let _ = x.pow10(5);\n    let _ = x.to_bits();\n    assert!(T::from_bits(x.to_bits()) == x);\n\n    // Check properties\n    let _ = x.to_bits() & T::SIGN_MASK;\n    let _ = x.to_bits() & T::EXPONENT_MASK;\n    let _ = x.to_bits() & T::HIDDEN_BIT_MASK;\n    let _ = x.to_bits() & T::MANTISSA_MASK;\n}", "test": "fn float_test() {\n    check_float(123f32);\n    check_float(123f64);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_merge_with_delimiter", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "test": "fn test_merge_with_delimiter() {\n    let sql = \"MERGE INTO target_table USING source_table \\\n    ON target_table.id = source_table.oooid \\\n    WHEN MATCHED THEN \\\n        UPDATE SET target_table.description = source_table.description \\\n    WHEN NOT MATCHED THEN \\\n        INSERT (ID, description) VALUES (source_table.id, source_table.description);\";\n\n    match parse_sql_statements(sql) {\n        Ok(_) => {}\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/simple_use.rs::check_simple_use", "code": "pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    }", "test": "fn check_simple_use() {\n    let rules = [\n        \"-advertisement-icon.\",\n        \"-advertisement-management/\",\n        \"-advertisement.\",\n        \"-advertisement/script.\",\n    ];\n\n    let engine = Engine::from_rules(rules, Default::default());\n\n    let request = Request::new(\n        \"http://example.com/-advertisement-icon.\",\n        \"http://example.com/helloworld\",\n        \"image\",\n    ).unwrap();\n    let blocker_result = engine.check_network_request(&request);\n    assert!(blocker_result.matched);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_double_not_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_double_not_is_false() {\n    new_ucmd!().args(&[\"!\", \"!\"]).run().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_spaces_follow_tabs_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_spaces_follow_tabs_1() {\n    // evil\n    // Explanation of what is going on here:\n    //      'a' -> 'a'          // first tabstop (1)\n    //    ' \\t' -> '\\t'         // second tabstop (4)\n    //      ' ' -> '\\t'         // third tabstop (5)\n    // '  B \\t' -> '  B \\t'     // after the list is exhausted, nothing must change\n    new_ucmd!()\n        .args(&[\"-t1,4,5\"])\n        .pipe_in(\"a \\t   B \\t\")\n        .run()\n        .stdout_is(\"a\\t\\t  B \\t\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_repeat_twice", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_repeat_twice() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\", \"{2}\"])\n        .succeeds()\n        .stdout_only(\"16\\n29\\n30\\n66\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 9));\n    assert_eq!(at.read(\"xx01\"), generate(9, 19));\n    assert_eq!(at.read(\"xx02\"), generate(19, 29));\n    assert_eq!(at.read(\"xx03\"), generate(29, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_invalid_bytes_size", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_split_invalid_bytes_size() {\n    new_ucmd!()\n        .args(&[\"-b\", \"1024R\"])\n        .fails()\n        .code_is(1)\n        .stderr_only(\"split: invalid number of bytes: '1024R'\\n\");\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let sizes = [\"1000G\", \"10T\"];\n        for size in &sizes {\n            new_ucmd!().args(&[\"-b\", size]).succeeds();\n        }\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/private.rs::private_attribute_for_alias", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn private_attribute_for_alias() {\n  Test::new()\n    .justfile(\n      \"\n      [private]\n      alias f := foo\n\n      foo:\n      \",\n    )\n    .args([\"--list\"])\n    .stdout(\n      \"\n      Available recipes:\n          foo\n      \",\n    )\n    .run();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::post_return_string", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "test": "fn post_return_string() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (memory (export \"memory\") 1)\n                (func (export \"get\") (result i32)\n                    (i32.store offset=0 (i32.const 8) (i32.const 100))\n                    (i32.store offset=4 (i32.const 8) (i32.const 11))\n                    i32.const 8\n                )\n\n                (func (export \"post\") (param i32)\n                    local.get 0\n                    i32.const 8\n                    i32.ne\n                    if unreachable end)\n\n                (data (i32.const 100) \"hello world\")\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"get\") (result string)\n                (canon lift\n                    (core func $i \"get\")\n                    (post-return (func $i \"post\"))\n                    (memory $i \"memory\")\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let get = instance.get_typed_func::<(), (WasmStr,)>(&mut store, \"get\")?;\n    let s = get.call(&mut store, ())?.0;\n    assert_eq!(s.to_str(&store)?, \"hello world\");\n    get.post_return(&mut store)?;\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\"])\n        .succeeds()\n        .stdout_only(\"16\\n125\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 9));\n    assert_eq!(at.read(\"xx01\"), generate(9, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_file_and_links", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_realpath_file_and_links() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    scene.ucmd().arg(\"foo\").succeeds().stdout_contains(\"foo\\n\");\n    scene.ucmd().arg(\"bar\").succeeds().stdout_contains(\"foo\\n\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::send_data_without_requesting_capacity", "code": "pub fn capacity(&self, stream: &mut store::Ptr) -> WindowSize {\n        stream.capacity(self.prioritize.max_buffer_size())\n    }", "test": "async fn send_data_without_requesting_capacity() {\n    h2_support::trace_init!();\n\n    let payload = vec![0; 1024];\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        .write(&[\n            // POST /\n            0, 0, 16, 1, 4, 0, 0, 0, 1, 131, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25, 151,\n            33, 233, 132,\n        ])\n        .write(&[\n            // DATA\n            0, 4, 0, 0, 1, 0, 0, 0, 1,\n        ])\n        .write(&payload[..])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[0, 0, 1, 1, 5, 0, 0, 0, 1, 0x89])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    let request = Request::builder()\n        .method(Method::POST)\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    // The capacity should be immediately allocated\n    assert_eq!(stream.capacity(), 0);\n\n    // Send the data\n    stream.send_data(payload.into(), true).unwrap();\n\n    // Get the response\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::NO_CONTENT);\n\n    h2.await.unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_info", "code": "fn get_raft_state(&self, raft_group_id: u64) -> Result<Option<RaftLocalState>> {\n        panic!()\n    }", "test": "fn test_debug_region_info() {\n    let (cluster, debug_client, store_id) = must_new_cluster_and_debug_client();\n\n    let raft_engine = cluster.get_raft_engine(store_id);\n    let kv_engine = cluster.get_engine(store_id);\n\n    let region_id = 100;\n    let mut raft_state = raft_serverpb::RaftLocalState::default();\n    raft_state.set_last_index(42);\n    let mut lb = raft_engine.log_batch(0);\n    lb.put_raft_state(region_id, &raft_state).unwrap();\n    raft_engine.consume(&mut lb, false).unwrap();\n    assert_eq!(\n        raft_engine.get_raft_state(region_id).unwrap().unwrap(),\n        raft_state\n    );\n\n    let apply_state_key = keys::apply_state_key(region_id);\n    let mut apply_state = raft_serverpb::RaftApplyState::default();\n    apply_state.set_applied_index(42);\n    kv_engine\n        .put_msg_cf(CF_RAFT, &apply_state_key, &apply_state)\n        .unwrap();\n    assert_eq!(\n        kv_engine\n            .get_msg_cf::<raft_serverpb::RaftApplyState>(CF_RAFT, &apply_state_key)\n            .unwrap()\n            .unwrap(),\n        apply_state\n    );\n\n    let region_state_key = keys::region_state_key(region_id);\n    let mut region_state = raft_serverpb::RegionLocalState::default();\n    region_state.set_state(raft_serverpb::PeerState::Tombstone);\n    kv_engine\n        .put_msg_cf(CF_RAFT, &region_state_key, &region_state)\n        .unwrap();\n    assert_eq!(\n        kv_engine\n            .get_msg_cf::<raft_serverpb::RegionLocalState>(CF_RAFT, &region_state_key)\n            .unwrap()\n            .unwrap(),\n        region_state\n    );\n\n    // Debug region_info\n    let mut req = debugpb::RegionInfoRequest::default();\n    req.set_region_id(region_id);\n    let mut resp = debug_client.region_info(&req).unwrap();\n    assert_eq!(resp.take_raft_local_state(), raft_state);\n    assert_eq!(resp.take_raft_apply_state(), apply_state);\n    assert_eq!(resp.take_region_local_state(), region_state);\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_info(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_16", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_16() {\n    let original = r##\"# H1 {#first #second #last}\n\"##;\n    let expected = r##\"<h1 id=\"last\">H1</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_scan_lock", "code": "pub fn scan_locks_ok(\n        &self,\n        max_ts: impl Into<TimeStamp>,\n        start_key: &[u8],\n        end_key: &[u8],\n        limit: usize,\n        expect: Vec<LockInfo>,\n    ) {\n        let start_key = if start_key.is_empty() {\n            None\n        } else {\n            Some(Key::from_raw(start_key))\n        };\n        let end_key = if end_key.is_empty() {\n            None\n        } else {\n            Some(Key::from_raw(end_key))\n        };\n\n        assert_eq!(\n            self.store\n                .scan_locks(self.ctx.clone(), max_ts.into(), start_key, end_key, limit)\n                .unwrap(),\n            expect\n        );\n    }", "test": "fn test_txn_store_scan_lock() {\n    let store = AssertionStorage::default();\n\n    store.put_ok(b\"k1\", b\"v1\", 1, 2);\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p1\"), b\"v5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s1\"), b\"v5\".to_vec()),\n        ],\n        b\"p1\",\n        5,\n    );\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p2\"), b\"v10\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s2\"), b\"v10\".to_vec()),\n        ],\n        b\"p2\",\n        10,\n    );\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p3\"), b\"v20\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s3\"), b\"v20\".to_vec()),\n        ],\n        b\"p3\",\n        20,\n    );\n    // scan should return locks.\n    store.scan_ok(\n        b\"\",\n        None,\n        10,\n        15,\n        vec![Some((b\"k1\", b\"v1\")), None, None, None, None],\n    );\n\n    store.scan_locks_ok(10, b\"\", b\"\", 1, vec![lock(b\"p1\", b\"p1\", 5)]);\n\n    store.scan_locks_ok(\n        10,\n        b\"s\",\n        b\"\",\n        2,\n        vec![lock(b\"s1\", b\"p1\", 5), lock(b\"s2\", b\"p2\", 10)],\n    );\n\n    store.scan_locks_ok(\n        10,\n        b\"\",\n        b\"\",\n        0,\n        vec![\n            lock(b\"p1\", b\"p1\", 5),\n            lock(b\"p2\", b\"p2\", 10),\n            lock(b\"s1\", b\"p1\", 5),\n            lock(b\"s2\", b\"p2\", 10),\n        ],\n    );\n\n    store.scan_locks_ok(\n        10,\n        b\"\",\n        b\"\",\n        100,\n        vec![\n            lock(b\"p1\", b\"p1\", 5),\n            lock(b\"p2\", b\"p2\", 10),\n            lock(b\"s1\", b\"p1\", 5),\n            lock(b\"s2\", b\"p2\", 10),\n        ],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pd_client_legacy.rs::test_load_global_config", "code": "pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    }", "test": "fn test_load_global_config() {\n    let (mut _server, client) = new_test_server_and_client(ReadableDuration::millis(100));\n    let global_items = vec![(\"test1\", \"val1\"), (\"test2\", \"val2\"), (\"test3\", \"val3\")];\n    let check_items = global_items.clone();\n    if let Err(err) = futures::executor::block_on(\n        client.store_global_config(\n            String::from(\"global\"),\n            global_items\n                .iter()\n                .map(|(name, value)| {\n                    let mut item = GlobalConfigItem::default();\n                    item.set_name(name.to_string());\n                    item.set_payload(value.as_bytes().into());\n                    item\n                })\n                .collect::<Vec<GlobalConfigItem>>(),\n        ),\n    ) {\n        panic!(\"error occur {:?}\", err);\n    }\n\n    let (res, revision) =\n        futures::executor::block_on(client.load_global_config(String::from(\"global\"))).unwrap();\n    assert!(\n        res.iter()\n            .zip(check_items)\n            .all(|(item1, item2)| item1.name == item2.0 && item1.payload == item2.1.as_bytes())\n    );\n    assert_eq!(revision, 3);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/jit/tests/basic.rs::libcall_function", "code": "pub fn finalize_definitions(&mut self) -> ModuleResult<()> {\n        for func in std::mem::take(&mut self.functions_to_finalize) {\n            let decl = self.declarations.get_function_decl(func);\n            assert!(decl.linkage.is_definable());\n            let func = self.compiled_functions[func]\n                .as_ref()\n                .expect(\"function must be compiled before it can be finalized\");\n            func.perform_relocations(\n                |name| self.get_address(name),\n                |name| self.get_got_address(name).as_ptr().cast(),\n                |name| self.get_plt_address(name),\n            );\n        }\n\n        for data in std::mem::take(&mut self.data_objects_to_finalize) {\n            let decl = self.declarations.get_data_decl(data);\n            assert!(decl.linkage.is_definable());\n            let data = self.compiled_data_objects[data]\n                .as_ref()\n                .expect(\"data object must be compiled before it can be finalized\");\n            data.perform_relocations(\n                |name| self.get_address(name),\n                |name| self.get_got_address(name).as_ptr().cast(),\n                |name| self.get_plt_address(name),\n            );\n        }\n\n        // Now that we're done patching, prepare the memory for execution!\n        self.memory.readonly.set_readonly()?;\n        self.memory.code.set_readable_and_executable()?;\n\n        for update in self.pending_got_updates.drain(..) {\n            unsafe { update.entry.as_ref() }.store(update.ptr as *mut _, Ordering::SeqCst);\n        }\n        Ok(())\n    }", "test": "fn libcall_function() {\n    let mut flag_builder = settings::builder();\n    flag_builder.set(\"use_colocated_libcalls\", \"false\").unwrap();\n    // FIXME set back to true once the x64 backend supports it.\n    flag_builder.set(\"is_pic\", \"false\").unwrap();\n    let isa_builder = cranelift_native::builder().unwrap_or_else(|msg| {\n        panic!(\"host machine is not supported: {}\", msg);\n    });\n    let isa = isa_builder\n        .finish(settings::Flags::new(flag_builder))\n        .unwrap();\n    let mut module = JITModule::new(JITBuilder::with_isa(isa, default_libcall_names()));\n\n    let sig = Signature {\n        params: vec![],\n        returns: vec![],\n        call_conv: CallConv::SystemV,\n    };\n\n    let func_id = module\n        .declare_function(\"function\", Linkage::Local, &sig)\n        .unwrap();\n\n    let mut ctx = Context::new();\n    ctx.func = Function::with_name_signature(UserFuncName::user(0, func_id.as_u32()), sig);\n\n    let mut func_ctx = FunctionBuilderContext::new();\n    {\n        let mut bcx: FunctionBuilder = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n        let block = bcx.create_block();\n        bcx.switch_to_block(block);\n\n        let int = module.target_config().pointer_type();\n        let zero = bcx.ins().iconst(I16, 0);\n        let size = bcx.ins().iconst(int, 10);\n\n        let mut signature = module.make_signature();\n        signature.params.push(AbiParam::new(int));\n        signature.returns.push(AbiParam::new(int));\n        let callee = module\n            .declare_function(\"malloc\", Linkage::Import, &signature)\n            .expect(\"declare malloc function\");\n        let local_callee = module.declare_func_in_func(callee, &mut bcx.func);\n        let argument_exprs = vec![size];\n        let call = bcx.ins().call(local_callee, &argument_exprs);\n        let buffer = bcx.inst_results(call)[0];\n\n        bcx.call_memset(module.target_config(), buffer, zero, size);\n\n        bcx.ins().return_(&[]);\n    }\n\n    module\n        .define_function_with_control_plane(func_id, &mut ctx, &mut Default::default())\n        .unwrap();\n\n    module.finalize_definitions().unwrap();\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_new", "code": "pub fn new(lifetime: Lifetime) -> Self {\n        LifetimeParam {\n            attrs: Vec::new(),\n            lifetime,\n            colon_token: None,\n            bounds: Punctuated::new(),\n        }\n    }", "test": "fn ident_new() {\n    new(\"String\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/snapshot_basic.rs::snapshot_get_value", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn snapshot_get_value() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"aa\").unwrap();\n\n    let snap = db.engine.snapshot();\n\n    let value = snap.get_value(b\"a\").unwrap();\n    let value = value.unwrap();\n    assert_eq!(value, b\"aa\");\n\n    let value = snap.get_value(b\"b\").unwrap();\n    assert!(value.is_none());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_overflow", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_date_overflow() {\n    new_ucmd!()\n        .arg(\"-d68888888888888sms\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"invalid date\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_carriage_return_overwritten_char_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_carriage_return_overwritten_char_should_be_preserved() {\n    new_ucmd!().pipe_in(\"x\\ry\").succeeds().stdout_is(\"x\\ry\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_read_source_region_after_target_region_merged", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_read_source_region_after_target_region_merged() {\n    let (mut cluster, pd_client, leader_client) =\n        prepare_for_stale_read_before_run(new_peer(1, 1), Some(Box::new(configure_for_merge)));\n\n    // Write on source region\n    let k1_commit_ts1 = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    cluster.must_split(&cluster.get_region(&[]), b\"key3\");\n    let source = pd_client.get_region(b\"key1\").unwrap();\n    let target = pd_client.get_region(b\"key5\").unwrap();\n    // Transfer the target region leader to store 1 and the source region leader to\n    // store 2\n    cluster.must_transfer_leader(target.get_id(), new_peer(1, 1));\n    cluster.must_transfer_leader(source.get_id(), find_peer(&source, 2).unwrap().clone());\n    // Get the source region follower on store 3\n    let mut source_follower_client3 = PeerClient::new(\n        &cluster,\n        source.get_id(),\n        find_peer(&source, 3).unwrap().clone(),\n    );\n    source_follower_client3.ctx.set_stale_read(true);\n    source_follower_client3.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), k1_commit_ts1);\n\n    // Pause on source region `prepare_merge` on store 2 and store 3\n    let apply_before_prepare_merge_2_3 = \"apply_before_prepare_merge_2_3\";\n    fail::cfg(apply_before_prepare_merge_2_3, \"pause\").unwrap();\n\n    // Merge source region into target region\n    pd_client.must_merge(source.get_id(), target.get_id());\n\n    // Leave a lock on the original source region key range through the target\n    // region leader\n    let target_leader = PeerClient::new(&cluster, target.get_id(), new_peer(1, 1));\n    let k1_prewrite_ts2 = get_tso(&pd_client);\n    target_leader.must_kv_prewrite(\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value2\"[..])],\n        b\"key1\".to_vec(),\n        k1_prewrite_ts2,\n    );\n\n    // Wait for the source region leader to update `safe_ts` (if it can)\n    sleep_ms(50);\n\n    // We still can read `key1` with `k1_commit_ts1` through source region\n    source_follower_client3.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), k1_commit_ts1);\n    // But can't read `key2` with `k1_prewrite_ts2` because the source leader can't\n    // update `safe_ts` after source region is merged into target region even\n    // though the source leader didn't know the merge is complement\n    let resp = source_follower_client3.kv_read(b\"key1\".to_vec(), k1_prewrite_ts2);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    fail::remove(apply_before_prepare_merge_2_3);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_no_start_wasm_report_error", "code": "pub(crate) fn stderr(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDERR_FILENO)\n    }", "test": "fn run_no_start_wasm_report_error() {\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::wat_no_start())\n        .assert()\n        .failure();\n\n    assert.stderr(contains(\"The module doesn't contain a \\\"_start\\\" function\"));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_object", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_object() {\n    test_encode_ok(&[\n        (treemap!(), \"{}\"),\n        (treemap!(\"a\".to_string() => true), \"{\\\"a\\\":true}\"),\n        (\n            treemap!(\n                \"a\".to_string() => true,\n                \"b\".to_string() => false,\n            ),\n            \"{\\\"a\\\":true,\\\"b\\\":false}\",\n        ),\n    ]);\n\n    test_encode_ok(&[\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![],\n            ],\n            \"{\\\"a\\\":{},\\\"b\\\":{},\\\"c\\\":{}}\",\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![],\n            ],\n            \"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":[1,2,3]},\\\"b\\\":{},\\\"c\\\":{}},\\\"b\\\":{},\\\"c\\\":{}}\",\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n                \"c\".to_string() => treemap![],\n            ],\n            \"{\\\"a\\\":{},\\\"b\\\":{\\\"a\\\":{\\\"a\\\":[1,2,3]},\\\"b\\\":{},\\\"c\\\":{}},\\\"c\\\":{}}\",\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n            ],\n            \"{\\\"a\\\":{},\\\"b\\\":{},\\\"c\\\":{\\\"a\\\":{\\\"a\\\":[1,2,3]},\\\"b\\\":{},\\\"c\\\":{}}}\",\n        ),\n    ]);\n\n    test_encode_ok(&[(treemap!['c' => ()], \"{\\\"c\\\":null}\")]);\n\n    test_pretty_encode_ok(&[\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![],\n            ],\n            pretty_str!({\n                \"a\": {},\n                \"b\": {},\n                \"c\": {}\n            }),\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![],\n            ],\n            pretty_str!({\n                \"a\": {\n                    \"a\": {\n                        \"a\": [\n                            1,\n                            2,\n                            3\n                        ]\n                    },\n                    \"b\": {},\n                    \"c\": {}\n                },\n                \"b\": {},\n                \"c\": {}\n            }),\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n                \"c\".to_string() => treemap![],\n            ],\n            pretty_str!({\n                \"a\": {},\n                \"b\": {\n                    \"a\": {\n                        \"a\": [\n                            1,\n                            2,\n                            3\n                        ]\n                    },\n                    \"b\": {},\n                    \"c\": {}\n                },\n                \"c\": {}\n            }),\n        ),\n        (\n            treemap![\n                \"a\".to_string() => treemap![],\n                \"b\".to_string() => treemap![],\n                \"c\".to_string() => treemap![\n                    \"a\".to_string() => treemap![\"a\" => vec![1,2,3]],\n                    \"b\".to_string() => treemap![],\n                    \"c\".to_string() => treemap![],\n                ],\n            ],\n            pretty_str!({\n                \"a\": {},\n                \"b\": {},\n                \"c\": {\n                    \"a\": {\n                        \"a\": [\n                            1,\n                            2,\n                            3\n                        ]\n                    },\n                    \"b\": {},\n                    \"c\": {}\n                }\n            }),\n        ),\n    ]);\n\n    test_pretty_encode_ok(&[\n        (treemap!(), \"{}\"),\n        (\n            treemap!(\"a\".to_string() => true),\n            pretty_str!({\n                \"a\": true\n            }),\n        ),\n        (\n            treemap!(\n                \"a\".to_string() => true,\n                \"b\".to_string() => false,\n            ),\n            pretty_str!( {\n                \"a\": true,\n                \"b\": false\n            }),\n        ),\n    ]);\n\n    let complex_obj = json!({\n        \"b\": [\n            {\"c\": \"\\x0c\\x1f\\r\"},\n            {\"d\": \"\"}\n        ]\n    });\n\n    test_encode_ok(&[(\n        complex_obj.clone(),\n        json_str!({\n            \"b\": [\n                {\n                    \"c\": (r#\"\"\\f\\u001f\\r\"\"#)\n                },\n                {\n                    \"d\": \"\"\n                }\n            ]\n        }),\n    )]);\n\n    test_pretty_encode_ok(&[(\n        complex_obj,\n        pretty_str!({\n            \"b\": [\n                {\n                    \"c\": (r#\"\"\\f\\u001f\\r\"\"#)\n                },\n                {\n                    \"d\": \"\"\n                }\n            ]\n        }),\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_zero_len_of_empty", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_zero_len_of_empty() {\n    new_ucmd!().args(&[\"-z\", \"\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_not_and_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_not_and_is_false() {\n    // `-a` is a literal here & has nonzero length\n    new_ucmd!().args(&[\"!\", \"-a\"]).run().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_complement", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_complement() {\n    for param in [\"--complement\", \"--com\"] {\n        new_ucmd!()\n            .args(&[\"-d_\", param, \"-f\", \"2\"])\n            .pipe_in(\"9_1\\n8_2\\n7_3\")\n            .succeeds()\n            .stdout_only(\"9\\n8\\n7\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_directory_permissions", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_directory_permissions() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let result = ucmd.args(&[\"-d\", \"XXX\"]).succeeds();\n    let dirname = result.no_stderr().stdout_str().trim_end();\n    assert_matches_template!(\"XXX\", dirname);\n    let metadata = at.metadata(dirname);\n    assert!(metadata.is_dir());\n    assert_eq!(metadata.permissions().mode(), 0o40700);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_backup_force", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_backup_force() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.write(\"a\", \"a\\n\");\n    at.write(\"b\", \"b2\\n\");\n\n    scene.ucmd().args(&[\"-s\", \"b\", \"b~\"]).succeeds().no_stderr();\n    assert!(at.file_exists(\"a\"));\n    assert!(at.file_exists(\"b\"));\n    assert!(at.file_exists(\"b~\"));\n    scene\n        .ucmd()\n        .args(&[\"-s\", \"-f\", \"--b=simple\", \"a\", \"b\"])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(\"a\"));\n    assert!(at.file_exists(\"b\"));\n    assert!(at.file_exists(\"b~\"));\n    assert_eq!(at.read(\"a\"), \"a\\n\");\n    assert_eq!(at.read(\"b\"), \"a\\n\");\n    // we should have the same content as b as we had time to do a backup\n    assert_eq!(at.read(\"b~\"), \"b2\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_trailing_slash_missing", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_canonicalize_trailing_slash_missing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.relative_symlink_file(\"missing\", \"link3\");\n    for name in [\"missing\", \"link3\"] {\n        scene\n            .ucmd()\n            .args(&[\"-f\", name])\n            .succeeds()\n            .stdout_contains(\"missing\");\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"./{name}/\")])\n            .succeeds()\n            .stdout_contains(\"missing\");\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"{name}/more\")])\n            .fails()\n            .code_is(1)\n            .no_stdout();\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"./{name}/more/\")])\n            .fails()\n            .code_is(1)\n            .no_stdout();\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_stream_write", "code": "fn test_client_stream_write(stream_kind: StreamKind) {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n        let data = b\"hello\";\n        {\n            let mut pipe = OtherSession::new(&mut server);\n            let mut stream: Box<dyn Write> = match stream_kind {\n                StreamKind::Ref => Box::new(Stream::new(&mut client, &mut pipe)),\n                StreamKind::Owned => Box::new(StreamOwned::new(client, pipe)),\n            };\n            assert_eq!(stream.write(data).unwrap(), 5);\n        }\n        check_read(&mut server.reader(), data);\n    }\n}", "test": "fn client_stream_write() {\n    test_client_stream_write(StreamKind::Ref);\n    test_client_stream_write(StreamKind::Owned);\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_invalid", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse_invalid() {\n    parse(\"a#\").unwrap_err();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_file", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_file() {\n    new_ucmd!()\n        .args(&[\"/etc/passwd\"])\n        .succeeds()\n        .stdout_only(\"passwd\\n\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_iterators.rs::iter", "code": "fn next_back(&mut self) -> Option<Self::Item> {\n        self.last\n            .next()\n            .map(Pair::End)\n            .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))\n    }", "test": "fn iter() {\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    check_exact_size_iterator!(p.iter());\n    check_exact_size_iterator!(p.iter_mut());\n    check_exact_size_iterator!(p.into_iter());\n\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    assert_eq!(p.iter().next_back(), Some(&4));\n    assert_eq!(p.iter_mut().next_back(), Some(&mut 4));\n    assert_eq!(p.into_iter().next_back(), Some(4));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::right_variable_name_is_needed_in_for_loop", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn right_variable_name_is_needed_in_for_loop() {\n    let mut data = HashMap::new();\n    data.insert(\"content\", \"hello\");\n    let mut context = Context::new();\n    context.insert(\"comments\", &vec![data]);\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- for comment in comments -%}\n<p>{{ comment.content }}</p>\n<p>{{ whocares.content }}</p>\n<p>{{ doesntmatter.content }}</p>\n{% endfor -%}\"#,\n    )\n    .unwrap();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `whocares.content` not found in context while rendering \\'tpl\\'\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_empty_range", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_empty_range() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"b\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.delete_range(b\"b\", b\"b\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &1_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_some());\n    for i in 0..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_both() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_both\";\n\n    ucmd.args(&[\"-t\", \"201501011234\", \"-a\", \"-m\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_interactive", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_mv_arg_update_interactive() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_a = \"test_mv_replace_file_a\";\n    let file_b = \"test_mv_replace_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a)\n        .arg(file_b)\n        .arg(\"-i\")\n        .arg(\"--update\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_var_simple", "code": "pub fn test(self) {\n        let res: Result<_, _> = self.into();\n\n        res.unwrap();\n    }", "test": "fn test_var_simple() {\n    SemanticTester::js(\"let x; { let y; }\")\n        .has_some_symbol(\"x\")\n        .intersects_flags(SymbolFlags::Variable)\n        .contains_flags(SymbolFlags::BlockScopedVariable)\n        .test();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/create.rs::detect_wrong_descriptors", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn detect_wrong_descriptors() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new(\"wallet create\")\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Output>();\n\n  rpc_server.import_descriptor(\"wpkh([aslfjk])#a23ad2l\".to_string());\n\n  CommandBuilder::new(\"wallet transactions\")\n    .rpc_server(&rpc_server)\n    .stderr_regex(\n      r#\"error: wallet \"ord\" contains unexpected output descriptors, and does not appear to be an `ord` wallet, create a new wallet with `ord wallet create`\\n\"#,\n    )\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_before_async_write_deadline", "code": "pub fn send(&self, addr: u64, msg: N::Message) -> Result<(), TrySendError<N::Message>> {\n        match self.try_send(addr, msg) {\n            Either::Left(res) => res,\n            Either::Right(m) => Err(TrySendError::Disconnected(m)),\n        }\n    }", "test": "fn test_before_async_write_deadline() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster\n        .sim\n        .read()\n        .unwrap()\n        .storages\n        .get(&1)\n        .unwrap()\n        .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n    ctx.max_execution_duration_ms = 200;\n    let (tx, rx) = channel();\n    fail::cfg(\"cleanup\", \"sleep(500)\").unwrap();\n    storage\n        .sched_txn_command(\n            commands::Rollback::new(vec![Key::from_raw(b\"k\")], 10.into(), ctx),\n            Box::new(move |res: storage::Result<_>| {\n                tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n\n    assert!(matches!(\n        rx.recv().unwrap(),\n        Err(StorageError(box StorageErrorInner::DeadlineExceeded))\n    ));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::total_core_instances_limit", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn total_core_instances_limit() -> Result<()> {\n    const INSTANCE_LIMIT: u32 = 10;\n    let mut pool = crate::small_pool_config();\n    pool.total_core_instances(INSTANCE_LIMIT);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module)\"#)?;\n\n    // Instantiate to the limit\n    {\n        let mut store = Store::new(&engine, ());\n\n        for _ in 0..INSTANCE_LIMIT {\n            Instance::new(&mut store, &module, &[])?;\n        }\n\n        match Instance::new(&mut store, &module, &[]) {\n            Ok(_) => panic!(\"instantiation should fail\"),\n            Err(e) => assert_eq!(\n                e.to_string(),\n                format!(\n                    \"maximum concurrent core instance limit of {} reached\",\n                    INSTANCE_LIMIT\n                )\n            ),\n        }\n    }\n\n    // With the above store dropped, ensure instantiations can be made\n\n    let mut store = Store::new(&engine, ());\n\n    for _ in 0..INSTANCE_LIMIT {\n        Instance::new(&mut store, &module, &[])?;\n    }\n\n    Ok(())\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_next_back", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn drain_next_back() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let mut table = write_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.drain(0..10).unwrap();\n    for i in (0..10).rev() {\n        let (k, v) = iter.next_back().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_query", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn range_query() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(SLICE_U64_TABLE).unwrap();\n        for i in 0..5 {\n            table.insert(b\"0\".as_slice(), &i).unwrap();\n        }\n        for i in 5..10 {\n            table.insert(b\"1\".as_slice(), &i).unwrap();\n        }\n        for i in 10..15 {\n            table.insert(b\"2\".as_slice(), &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(SLICE_U64_TABLE).unwrap();\n    let start = b\"0\".as_ref();\n    let end = b\"1\".as_ref();\n    let mut iter = table.range(start..=end).unwrap();\n\n    {\n        let (key, mut values) = iter.next().unwrap().unwrap();\n        for i in 0..5 {\n            assert_eq!(b\"0\", key.value());\n            let value = values.next().unwrap().unwrap();\n            assert_eq!(i, value.value());\n        }\n    }\n    {\n        let (key, mut values) = iter.next().unwrap().unwrap();\n        for i in 5..10 {\n            assert_eq!(b\"1\", key.value());\n            let value = values.next().unwrap().unwrap();\n            assert_eq!(i, value.value());\n        }\n    }\n    assert!(iter.next().is_none());\n\n    let mut total: u64 = 0;\n    for item in table.range(start..=end).unwrap() {\n        let (_, values) = item.unwrap();\n        total += values.map(|x| x.unwrap().value()).sum::<u64>();\n    }\n    assert_eq!(total, 45);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::subquery_vars", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn subquery_vars() {\n    let needle = \"{int $i = _($i+$i);}\";\n    let source = \"char b(){int foo = 100*17-f(bar+bar);}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_default", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_default() {\n    new_ucmd!().arg(\"hi\").succeeds().stdout_only(\"hi\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_create_procedure", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_create_procedure() {\n    let sql = \"CREATE OR ALTER PROCEDURE test (@foo INT, @bar VARCHAR(256)) AS BEGIN SELECT 1 END\";\n\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::CreateProcedure {\n            or_alter: true,\n            body: vec![Statement::Query(Box::new(Query {\n                with: None,\n                limit: None,\n                limit_by: vec![],\n                offset: None,\n                fetch: None,\n                locks: vec![],\n                order_by: vec![],\n                body: Box::new(SetExpr::Select(Box::new(Select {\n                    distinct: None,\n                    top: None,\n                    projection: vec![SelectItem::UnnamedExpr(Expr::Value(number(\"1\")))],\n                    into: None,\n                    from: vec![],\n                    lateral_views: vec![],\n                    selection: None,\n                    group_by: GroupByExpr::Expressions(vec![]),\n                    cluster_by: vec![],\n                    distribute_by: vec![],\n                    sort_by: vec![],\n                    having: None,\n                    named_window: vec![],\n                    qualify: None\n                })))\n            }))],\n            params: Some(vec![\n                ProcedureParam {\n                    name: Ident {\n                        value: \"@foo\".into(),\n                        quote_style: None\n                    },\n                    data_type: DataType::Int(None)\n                },\n                ProcedureParam {\n                    name: Ident {\n                        value: \"@bar\".into(),\n                        quote_style: None\n                    },\n                    data_type: DataType::Varchar(Some(CharacterLength {\n                        length: 256,\n                        unit: None\n                    }))\n                }\n            ]),\n            name: ObjectName(vec![Ident {\n                value: \"test\".into(),\n                quote_style: None\n            }])\n        }\n    )\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_yes.rs::test_version", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_version() {\n    new_ucmd!().arg(\"--version\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_empty_line_without_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_empty_line_without_final_newline() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"12\\n\\n34\")\n        .succeeds()\n        .stdout_is(\"12\\n\\n34\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/format_builder_tests.rs::decimal_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn decimal_test() {\n    const FORMAT: u128 = NumberFormatBuilder::decimal();\n    let format = NumberFormat::<FORMAT> {};\n    assert!(format.is_valid());\n    assert_eq!(format.radix(), 10);\n    assert_eq!(format.mantissa_radix(), 10);\n    assert_eq!(format.exponent_base(), 10);\n    assert_eq!(format.exponent_radix(), 10);\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_split_for_impl", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "test": "fn test_split_for_impl() {\n    let input = quote! {\n        struct S<'a, 'b: 'a, #[may_dangle] T: 'a = ()> where T: Debug;\n    };\n\n    snapshot!(input as DeriveInput, @r###\"\n    DeriveInput {\n        vis: Visibility::Inherited,\n        ident: \"S\",\n        generics: Generics {\n            lt_token: Some,\n            params: [\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"a\",\n                    },\n                }),\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"b\",\n                    },\n                    colon_token: Some,\n                    bounds: [\n                        Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                }),\n                GenericParam::Type(TypeParam {\n                    attrs: [\n                        Attribute {\n                            style: AttrStyle::Outer,\n                            meta: Meta::Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"may_dangle\",\n                                    },\n                                ],\n                            },\n                        },\n                    ],\n                    ident: \"T\",\n                    colon_token: Some,\n                    bounds: [\n                        TypeParamBound::Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                    eq_token: Some,\n                    default: Some(Type::Tuple),\n                }),\n            ],\n            gt_token: Some,\n            where_clause: Some(WhereClause {\n                predicates: [\n                    WherePredicate::Type(PredicateType {\n                        bounded_ty: Type::Path {\n                            path: Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"T\",\n                                    },\n                                ],\n                            },\n                        },\n                        bounds: [\n                            TypeParamBound::Trait(TraitBound {\n                                path: Path {\n                                    segments: [\n                                        PathSegment {\n                                            ident: \"Debug\",\n                                        },\n                                    ],\n                                },\n                            }),\n                        ],\n                    }),\n                ],\n            }),\n        },\n        data: Data::Struct {\n            fields: Fields::Unit,\n            semi_token: Some,\n        },\n    }\n    \"###);\n\n    let generics = input.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n    let generated = quote! {\n        impl #impl_generics MyTrait for Test #ty_generics #where_clause {}\n    };\n    let expected = quote! {\n        impl<'a, 'b: 'a, #[may_dangle] T: 'a> MyTrait\n        for Test<'a, 'b, T>\n        where\n            T: Debug\n        {}\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n\n    let turbofish = ty_generics.as_turbofish();\n    let generated = quote! {\n        Test #turbofish\n    };\n    let expected = quote! {\n        Test::<'a, 'b, T>\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::issue_2", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn issue_2() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"issue2\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.), String(\"a\".to_string())],\n            [Float(2.), String(\"b\".to_string())],\n            [Float(3.), String(\"c\".to_string())]\n        ]\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_null", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_null() {\n    let tests = &[((), \"null\")];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_check_md5sum", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_check_md5sum() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    #[cfg(not(windows))]\n    {\n        for f in &[\"a\", \" b\", \"*c\", \"dd\", \" \"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"60b725f10c9c85c70d97880dfe8191b3  a\\n\\\n             bf35d7536c785cf06730d5a40301eba2   b\\n\\\n             f5b61709718c1ecf8db1aea8547d4698  *c\\n\\\n             b064a020db8018f18ff5ae367d01b212  dd\\n\\\n             d784fa8b6d98d27699781bd9a7cf19f0   \",\n        );\n        scene\n            .ccmd(\"md5sum\")\n            .arg(\"--strict\")\n            .arg(\"-c\")\n            .arg(\"check.md5sum\")\n            .succeeds()\n            .stdout_is(\"a: OK\\n b: OK\\n*c: OK\\ndd: OK\\n : OK\\n\")\n            .stderr_is(\"\");\n    }\n    #[cfg(windows)]\n    {\n        for f in &[\"a\", \" b\", \"dd\"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"60b725f10c9c85c70d97880dfe8191b3  a\\n\\\n             bf35d7536c785cf06730d5a40301eba2   b\\n\\\n             b064a020db8018f18ff5ae367d01b212  dd\",\n        );\n        scene\n            .ccmd(\"md5sum\")\n            .arg(\"--strict\")\n            .arg(\"-c\")\n            .arg(\"check.md5sum\")\n            .succeeds()\n            .stdout_is(\"a: OK\\n b: OK\\ndd: OK\\n\")\n            .stderr_is(\"\");\n    }\n}"}
{"test_id": "pyfisch-cbor/pyfisch-cbor-347a3f0/tests/ser.rs::test_integer", "code": "fn serialize_and_compare<T: Serialize>(value: T, expected: &[u8]) {\n    let mut slice = [0u8; 64];\n    let writer = SliceWrite::new(&mut slice);\n    let mut serializer = Serializer::new(writer);\n    value.serialize(&mut serializer).unwrap();\n    let writer = serializer.into_inner();\n    let end = writer.bytes_written();\n    let slice = writer.into_inner();\n    assert_eq!(&slice[..end], expected);\n}", "test": "fn test_integer() {\n    // u8\n    serialize_and_compare(24, b\"\\x18\\x18\");\n    // i8\n    serialize_and_compare(-5, b\"\\x24\");\n    // i16\n    serialize_and_compare(-300, b\"\\x39\\x01\\x2b\");\n    // i32\n    serialize_and_compare(-23567997, b\"\\x3a\\x01\\x67\\x9e\\x7c\");\n    // u64\n    serialize_and_compare(::core::u64::MAX, b\"\\x1b\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_months_whitespace", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_months_whitespace() {\n    test_helper(\"months-whitespace\", &[\"-M\", \"--month-sort\", \"--sort=month\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_short_no_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), new_content);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_repeat_always", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_repeat_always() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/\", \"{*}\"])\n        .succeeds()\n        .stdout_only(\"16\\n29\\n30\\n30\\n30\\n6\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 6);\n    assert_eq!(at.read(\"xx00\"), generate(1, 9));\n    assert_eq!(at.read(\"xx01\"), generate(9, 19));\n    assert_eq!(at.read(\"xx02\"), generate(19, 29));\n    assert_eq!(at.read(\"xx03\"), generate(29, 39));\n    assert_eq!(at.read(\"xx04\"), generate(39, 49));\n    assert_eq!(at.read(\"xx05\"), generate(49, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_mdhm_time", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_mdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_mdhm_time\";\n\n    ucmd.args(&[\"-t\", \"01011234\", file]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\n        \"%Y%m%d%H%M\",\n        &format!(\"{}01010000\", time::OffsetDateTime::now_utc().year()),\n    );\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow2_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u16_pow2_test() {\n    let values: &[u16] = &[\n        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,\n        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,\n        16383, 16384, 16385, 32767, 32768, 32769, 65535,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/client_request.rs::recv_too_big_headers", "code": "pub fn reason(&self) -> Option<Reason> {\n        match self.kind {\n            Kind::Reset(_, reason, _) | Kind::GoAway(_, reason, _) | Kind::Reason(reason) => {\n                Some(reason)\n            }\n            _ => None,\n        }\n    }", "test": "async fn recv_too_big_headers() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_frame_eq(settings, frames::settings().max_header_list_size(10));\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.recv_frame(\n            frames::headers(3)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200).eos()).await;\n        srv.send_frame(frames::headers(3).response(200)).await;\n        // no reset for 1, since it's closed anyway\n        // but reset for 3, since server hasn't closed stream\n        srv.recv_frame(frames::reset(3).refused()).await;\n        idle_ms(10).await;\n    };\n\n    let client = async move {\n        let (mut client, mut conn) = client::Builder::new()\n            .max_header_list_size(10)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req1 = client.send_request(request, true);\n        let req1 = async move {\n            let err = req1.expect(\"send_request\").0.await.expect_err(\"response1\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req2 = client.send_request(request, true);\n        let req2 = async move {\n            let err = req2.expect(\"send_request\").0.await.expect_err(\"response2\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        conn.drive(join(req1, req2)).await;\n        conn.await.expect(\"client\");\n    };\n    join(srv, client).await;\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/mod.rs::arrow", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn arrow() {\n    test_formatting(\n        r#\"\n        let arrow_func = (a, b) => {\n            console.log(\"in multi statement arrow\");\n            console.log(b);\n        };\n        let arrow_func_2 = (a, b) => {};\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_failing_not_dir", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_install_failing_not_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"file1\";\n    let file2 = \"file2\";\n    let file3 = \"file3\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(file3)\n        .fails()\n        .stderr_contains(\"not a directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_bytes_stdin", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_bytes_stdin() {\n    new_ucmd!()\n        .pipe_in_fixture(FOOBAR_TXT)\n        .arg(\"-c\")\n        .arg(\"13\")\n        .run()\n        .stdout_is_fixture(\"foobar_bytes_stdin.expected\")\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_from_env", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_from_env() {\n    fn get_header(env_var: &str, env_value: &str) -> String {\n        let output = new_ucmd!()\n            .arg(\"--output=size\")\n            .env(env_var, env_value)\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(\"DF_BLOCK_SIZE\", \"111\"), \"111B-blocks\");\n    assert_eq!(get_header(\"BLOCK_SIZE\", \"222\"), \"222B-blocks\");\n    assert_eq!(get_header(\"BLOCKSIZE\", \"333\"), \"333B-blocks\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_string_human", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_string_human() {\n    let date_formats = vec![\n        \"1 year ago\",\n        \"1 year\",\n        \"2 months ago\",\n        \"15 days ago\",\n        \"1 week ago\",\n        \"5 hours ago\",\n        \"30 minutes ago\",\n        \"10 seconds\",\n    ];\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}\\n$\").unwrap();\n    for date_format in date_formats {\n        new_ucmd!()\n            .arg(\"-d\")\n            .arg(date_format)\n            .arg(\"+%Y-%m-%d %S:%M\")\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_request_snapshot_after_reboot", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_request_snapshot_after_reboot() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.check_request_snapshot_interval = ReadableDuration::millis(20);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n    // nonwitness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    std::thread::sleep(Duration::from_millis(100));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    // witness -> nonwitness\n    let fp = \"ignore request snapshot\";\n    fail::cfg(fp, \"return\").unwrap();\n    cluster\n        .pd_client\n        .switch_witnesses(region.get_id(), vec![peer_on_store3.get_id()], vec![false]);\n    std::thread::sleep(Duration::from_millis(500));\n    // as we ignore request snapshot, so snapshot should still not applied yet\n    assert_eq!(cluster.pd_client.get_pending_peers().len(), 1);\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    cluster.stop_node(nodes[2]);\n    fail::remove(fp);\n    std::thread::sleep(Duration::from_millis(100));\n    // the PeerState is Unavailable, so it will request snapshot immediately after\n    // start.\n    cluster.run_node(nodes[2]).unwrap();\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    std::thread::sleep(Duration::from_millis(500));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    assert_eq!(cluster.pd_client.get_pending_peers().len(), 0);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/status_code.rs::is_server_error", "code": "fn is_server_error() {\n    assert!(status_code(500).is_server_error());\n    assert!(status_code(599).is_server_error());\n\n    assert!(!status_code(499).is_server_error());\n    assert!(!status_code(600).is_server_error());\n}", "test": "fn is_server_error() {\n    assert!(status_code(500).is_server_error());\n    assert!(status_code(599).is_server_error());\n\n    assert!(!status_code(499).is_server_error());\n    assert!(!status_code(600).is_server_error());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_one_node_renew_lease", "code": "fn test_renew_lease<T: Simulator>(cluster: &mut Cluster<T>) {\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    // Use large election timeout to make leadership stable.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    // Override max leader lease to 2 seconds.\n    let max_lease = Duration::from_secs(2);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);\n    cluster.cfg.raft_store.renew_leader_lease_advance_duration = ReadableDuration::secs(0);\n\n    let node_id = 1u64;\n    let store_id = 1u64;\n    let peer = new_peer(store_id, node_id);\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let key = b\"k\";\n    cluster.must_put(key, b\"v0\");\n    for id in 2..=cluster.engines.len() as u64 {\n        cluster.pd_client.must_add_peer(region_id, new_peer(id, id));\n        must_get_equal(&cluster.get_engine(id), key, b\"v0\");\n    }\n\n    // Write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n    let state = cluster.raft_local_state(region_id, store_id);\n    let last_index = state.get_last_index();\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n    assert_eq!(detector.ctx.rl().len(), 0);\n\n    let mut expect_lease_read = 0;\n\n    if cluster.engines.len() > 1 {\n        // Wait for the leader lease to expire.\n        thread::sleep(max_lease);\n\n        // Issue a read request and check the value on response.\n        must_read_on_peer(cluster, peer.clone(), region.clone(), key, b\"v1\");\n\n        // Check if the leader does a index read and renewed its lease.\n        assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n        expect_lease_read += 1;\n        assert_eq!(detector.ctx.rl().len(), expect_lease_read);\n    }\n\n    // Wait for the leader lease to expire.\n    thread::sleep(max_lease);\n\n    // Issue a write request.\n    cluster.must_put(key, b\"v2\");\n\n    // Check if the leader has renewed its lease so that it can do lease read.\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n    let state = cluster.raft_local_state(region_id, store_id);\n    assert_eq!(state.get_last_index(), last_index + 1);\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(cluster, peer, region, key, b\"v2\");\n\n    // Check if the leader does a local read.\n    assert_eq!(detector.ctx.rl().len(), expect_lease_read);\n}", "test": "fn test_one_node_renew_lease() {\n    let count = 1;\n    let mut cluster = new_node_cluster(0, count);\n    test_renew_lease(&mut cluster);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_cluster_by", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_cluster_by() {\n    let cluster = \"SELECT a FROM db.table CLUSTER BY a, b\";\n    hive().verified_stmt(cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_simple", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=simple\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_resolve_lock", "code": "pub fn scan_locks_ok(\n        &self,\n        max_ts: impl Into<TimeStamp>,\n        start_key: &[u8],\n        end_key: &[u8],\n        limit: usize,\n        expect: Vec<LockInfo>,\n    ) {\n        let start_key = if start_key.is_empty() {\n            None\n        } else {\n            Some(Key::from_raw(start_key))\n        };\n        let end_key = if end_key.is_empty() {\n            None\n        } else {\n            Some(Key::from_raw(end_key))\n        };\n\n        assert_eq!(\n            self.store\n                .scan_locks(self.ctx.clone(), max_ts.into(), start_key, end_key, limit)\n                .unwrap(),\n            expect\n        );\n    }", "test": "fn test_txn_store_resolve_lock() {\n    let store = AssertionStorage::default();\n\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p1\"), b\"v5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s1\"), b\"v5\".to_vec()),\n        ],\n        b\"p1\",\n        5,\n    );\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p2\"), b\"v10\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s2\"), b\"v10\".to_vec()),\n        ],\n        b\"p2\",\n        10,\n    );\n    store.resolve_lock_ok(5, None::<TimeStamp>);\n    store.resolve_lock_ok(10, Some(20));\n    store.get_none(b\"p1\", 20);\n    store.get_none(b\"s1\", 30);\n    store.get_ok(b\"p2\", 20, b\"v10\");\n    store.get_ok(b\"s2\", 30, b\"v10\");\n    store.scan_locks_ok(30, b\"\", b\"\", 100, vec![]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_more.rs::test_argument_from_file", "code": "pub fn stdout_does_not_contain<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            !self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' contains '{}' but should not\",\n            self.stdout_str(),\n            cmp.as_ref(),\n        );\n        self\n    }", "test": "fn test_argument_from_file() {\n    if std::io::stdout().is_terminal() {\n        let scene = TestScenario::new(util_name!());\n        let at = &scene.fixtures;\n\n        let file = \"test_file\";\n\n        at.write(file, \"1\\n2\");\n\n        // output all lines\n        scene\n            .ucmd()\n            .arg(\"-F\")\n            .arg(\"0\")\n            .arg(file)\n            .succeeds()\n            .no_stderr()\n            .stdout_contains(\"1\")\n            .stdout_contains(\"2\");\n\n        // output only the second line\n        scene\n            .ucmd()\n            .arg(\"-F\")\n            .arg(\"2\")\n            .arg(file)\n            .succeeds()\n            .no_stderr()\n            .stdout_contains(\"2\")\n            .stdout_does_not_contain(\"1\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_crash_when_snapshot", "code": "pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    }", "test": "fn test_node_merge_crash_when_snapshot() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(11);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(50);\n    // Make merge check resume quickly.\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 10;\n    // election timeout must be greater than lease\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(90);\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration::millis(500);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let on_raft_gc_log_tick_fp = \"on_raft_gc_log_tick\";\n    fail::cfg(on_raft_gc_log_tick_fp, \"return()\").unwrap();\n\n    cluster.run();\n\n    let mut region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    region = pd_client.get_region(b\"k2\").unwrap();\n    cluster.must_split(&region, b\"k3\");\n\n    region = pd_client.get_region(b\"k3\").unwrap();\n    cluster.must_split(&region, b\"k4\");\n\n    region = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&region, b\"k5\");\n\n    let r1 = pd_client.get_region(b\"k1\").unwrap();\n    let r1_on_store1 = find_peer(&r1, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(r1.get_id(), r1_on_store1);\n    let r2 = pd_client.get_region(b\"k2\").unwrap();\n    let r2_on_store1 = find_peer(&r2, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(r2.get_id(), r2_on_store1);\n    let r3 = pd_client.get_region(b\"k3\").unwrap();\n    let r3_on_store1 = find_peer(&r3, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(r3.get_id(), r3_on_store1);\n    let r4 = pd_client.get_region(b\"k4\").unwrap();\n    let r4_on_store1 = find_peer(&r4, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(r4.get_id(), r4_on_store1);\n    let r5 = pd_client.get_region(b\"k5\").unwrap();\n    let r5_on_store1 = find_peer(&r5, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(r5.get_id(), r5_on_store1);\n\n    for i in 1..5 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v\");\n        must_get_equal(&cluster.get_engine(3), format!(\"k{}\", i).as_bytes(), b\"v\");\n    }\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_merge(r2.get_id(), r3.get_id());\n    pd_client.must_merge(r4.get_id(), r3.get_id());\n    pd_client.must_merge(r1.get_id(), r3.get_id());\n    pd_client.must_merge(r5.get_id(), r3.get_id());\n\n    for i in 1..5 {\n        for j in 1..20 {\n            cluster.must_put(format!(\"k{}{}\", i, j).as_bytes(), b\"vvv\");\n        }\n    }\n\n    region = pd_client.get_region(b\"k1\").unwrap();\n\n    let state1 = cluster.truncated_state(region.get_id(), 1);\n    // Remove log compaction failpoint\n    fail::remove(on_raft_gc_log_tick_fp);\n    // Wait to trigger compact raft log\n    cluster.wait_log_truncated(region.get_id(), 1, state1.get_index() + 1);\n\n    let on_region_worker_apply_fp = \"on_region_worker_apply\";\n    fail::cfg(on_region_worker_apply_fp, \"return()\").unwrap();\n    let on_region_worker_destroy_fp = \"on_region_worker_destroy\";\n    fail::cfg(on_region_worker_destroy_fp, \"return()\").unwrap();\n\n    cluster.clear_send_filters();\n    let timer = Instant::now();\n    loop {\n        let local_state = cluster.region_local_state(region.get_id(), 3);\n        if local_state.get_state() == PeerState::Applying {\n            break;\n        }\n        if timer.saturating_elapsed() > Duration::from_secs(1) {\n            panic!(\"not become applying state after 1 seconds.\");\n        }\n        sleep_ms(10);\n    }\n    cluster.stop_node(3);\n    fail::remove(on_region_worker_apply_fp);\n    fail::remove(on_region_worker_destroy_fp);\n    cluster.run_node(3).unwrap();\n\n    for i in 1..5 {\n        for j in 1..20 {\n            must_get_equal(\n                &cluster.get_engine(3),\n                format!(\"k{}{}\", i, j).as_bytes(),\n                b\"vvv\",\n            );\n        }\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_snapshot_must_be_later_than_updating_max_ts", "code": "pub fn recv(&self) -> Result<T, RecvError> {\n        match self {\n            Receiver::Vanilla(receiver) => receiver.recv(),\n            Receiver::Priority(receiver) => receiver.recv(),\n        }\n    }", "test": "fn test_snapshot_must_be_later_than_updating_max_ts() {\n    let engine = TestEngineBuilder::new().build().unwrap();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    // Suppose snapshot was before updating max_ts, after sleeping for 500ms the\n    // following prewrite should complete.\n    fail::cfg(\"after-snapshot\", \"sleep(500)\").unwrap();\n    let read_ts = 20.into();\n    let get_fut = storage.get(Context::default(), Key::from_raw(b\"j\"), read_ts);\n    thread::sleep(Duration::from_millis(100));\n    fail::remove(\"after-snapshot\");\n    let (prewrite_tx, prewrite_rx) = channel();\n    storage\n        .sched_txn_command(\n            commands::Prewrite::new(\n                vec![Mutation::make_put(Key::from_raw(b\"j\"), b\"v\".to_vec())],\n                b\"j\".to_vec(),\n                10.into(),\n                20000,\n                false,\n                1,\n                TimeStamp::default(),\n                TimeStamp::default(),\n                Some(vec![]),\n                false,\n                AssertionLevel::Off,\n                Context::default(),\n            ),\n            Box::new(move |res| {\n                prewrite_tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    let has_lock = block_on(get_fut).is_err();\n    let res = prewrite_rx.recv().unwrap().unwrap();\n    // We must make sure either the lock is visible to the reader or min_commit_ts >\n    // read_ts.\n    assert!(res.min_commit_ts > read_ts || has_lock);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_array_agg_func", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_array_agg_func() {\n    let supported_dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(DuckDbDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(HiveDialect {}),\n        ],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT ARRAY_AGG(x ORDER BY x) AS a FROM T\",\n        \"SELECT ARRAY_AGG(x ORDER BY x LIMIT 2) FROM tbl\",\n        \"SELECT ARRAY_AGG(DISTINCT x ORDER BY x LIMIT 2) FROM tbl\",\n        \"SELECT ARRAY_AGG(x ORDER BY x, y) AS a FROM T\",\n        \"SELECT ARRAY_AGG(x ORDER BY x ASC, y DESC) AS a FROM T\",\n    ] {\n        supported_dialects.verified_stmt(sql);\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_double_equal", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_double_equal() {\n    clickhouse().one_statement_parses_to(\n        r#\"SELECT foo FROM bar WHERE buz == 'buz'\"#,\n        r#\"SELECT foo FROM bar WHERE buz = 'buz'\"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_stdin_stdout_count_w_multiplier", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_stdin_stdout_count_w_multiplier() {\n    let input = build_ascii_block(5 * 1024);\n    let output = String::from_utf8(input[..2 * 1024].to_vec()).unwrap();\n    new_ucmd!()\n        .args(&[\"status=none\", \"count=2KiB\", \"iflag=count_bytes\"])\n        .pipe_in(input)\n        .run()\n        .no_stderr()\n        .stdout_is(output)\n        .success();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_while_applying_snapshot", "code": "pub fn has_data_is_not_ready(&self) -> bool {\n        self.data_is_not_ready.is_some()\n    }", "test": "fn test_stale_read_while_applying_snapshot() {\n    let (mut cluster, pd_client, leader_client) =\n        prepare_for_stale_read_before_run(new_peer(1, 1), Some(Box::new(configure_for_snapshot)));\n    let mut follower_client2 = PeerClient::new(&cluster, 1, new_peer(2, 2));\n    follower_client2.ctx.set_stale_read(true);\n\n    let k1_commit_ts = leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), k1_commit_ts);\n\n    // Stop replicate data to follower 2\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Prewrite on `key3` but not commit yet\n    let k2_prewrite_ts = get_tso(&pd_client);\n    leader_client.must_kv_prewrite(\n        vec![new_mutation(Op::Put, &b\"key2\"[..], &b\"value1\"[..])],\n        b\"key2\".to_vec(),\n        k2_prewrite_ts,\n    );\n\n    // Compact logs to force requesting snapshot after clearing send filters.\n    let gc_limit = cluster.cfg.raft_store.raft_log_gc_count_limit();\n    for i in 1..gc_limit * 2 {\n        let (k, v) = (\n            format!(\"k{}\", i).into_bytes(),\n            format!(\"v{}\", i).into_bytes(),\n        );\n        leader_client.must_kv_write(&pd_client, vec![new_mutation(Op::Put, &k, &v)], k);\n    }\n    let last_index_on_store_2 = cluster.raft_local_state(1, 2).last_index;\n    cluster.wait_log_truncated(1, 1, last_index_on_store_2 + 1);\n\n    // Pasuse before applying snapshot is finish\n    let raft_before_applying_snap_finished = \"raft_before_applying_snap_finished\";\n    fail::cfg(raft_before_applying_snap_finished, \"pause\").unwrap();\n    cluster.clear_send_filters();\n\n    // Wait follower 2 start applying snapshot\n    cluster.wait_log_truncated(1, 2, last_index_on_store_2 + 1);\n    sleep_ms(100);\n\n    // We can't read while applying snapshot and the `safe_ts` should reset to 0\n    let resp = follower_client2.kv_read(b\"key1\".to_vec(), k1_commit_ts);\n    assert!(resp.get_region_error().has_data_is_not_ready());\n    assert_eq!(\n        0,\n        resp.get_region_error()\n            .get_data_is_not_ready()\n            .get_safe_ts()\n    );\n\n    // Resume applying snapshot\n    fail::remove(raft_before_applying_snap_finished);\n\n    let last_index_on_store_1 = cluster.raft_local_state(1, 1).last_index;\n    cluster.wait_last_index(1, 2, last_index_on_store_1, Duration::from_secs(3));\n\n    // We can read `key1` after applied snapshot\n    follower_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), k1_commit_ts);\n    // There is still lock on the region, we can't read `key1` with the newest ts\n    let resp = follower_client2.kv_read(b\"key1\".to_vec(), get_tso(&pd_client));\n    assert!(resp.get_region_error().has_data_is_not_ready());\n\n    // Commit `key2`\n    leader_client.must_kv_commit(vec![b\"key2\".to_vec()], k2_prewrite_ts, get_tso(&pd_client));\n    // We can read `key1` with the newest ts now\n    follower_client2.must_kv_read_equal(b\"key2\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_apply_log.rs::test_apply_twice", "code": "fn apply(&mut self, _ctx: RpcContext<'_>, req: ApplyRequest, sink: UnarySink<ApplyResponse>) {\n        let label = \"apply\";\n        let start = Instant::now();\n        let importer = self.importer.clone();\n        let limiter = self.limiter.clone();\n        let max_raft_size = self.raft_entry_max_size.0 as usize;\n        let applier = self.writer.clone();\n\n        let handle_task = async move {\n            // Records how long the apply task waits to be scheduled.\n            sst_importer::metrics::IMPORTER_APPLY_DURATION\n                .with_label_values(&[\"queue\"])\n                .observe(start.saturating_elapsed().as_secs_f64());\n\n            let mut resp = ApplyResponse::default();\n\n            match Self::apply_imp(req, importer, applier, limiter, max_raft_size).await {\n                Ok(Some(r)) => resp.set_range(r),\n                Err(e) => resp.set_error(e),\n                _ => {}\n            }\n\n            debug!(\"finished apply kv file with {:?}\", resp);\n            crate::send_rpc_response!(Ok(resp), sink, label, start);\n        };\n        self.threads.spawn(handle_task);\n    }", "test": "fn test_apply_twice() {\n    let (_cluster, ctx, tikv, import) = util::new_cluster_and_tikv_import_client();\n    let tmp = TempDir::new().unwrap();\n    let storage = LocalStorage::new(tmp.path()).unwrap();\n    let default = [(\n        b\"k1\",\n        b\"In this case, we are going to test write twice, but with different rewrite rule.\",\n        1,\n    )];\n    let default_fst = [(\n        b\"r1\",\n        b\"In this case, we are going to test write twice, but with different rewrite rule.\",\n        1,\n    )];\n    let default_snd = [(\n        b\"z1\",\n        b\"In this case, we are going to test write twice, but with different rewrite rule.\",\n        1,\n    )];\n\n    let mut sst_meta =\n        util::make_plain_file(&storage, \"file2.log\", IntoIterator::into_iter(default));\n    util::register_range_for(&mut sst_meta, b\"k1\", b\"k1a\");\n    let mut req = ApplyRequest::new();\n    req.set_context(ctx.clone());\n    req.set_rewrite_rules(vec![util::rewrite_for(&mut sst_meta, b\"k\", b\"r\")].into());\n    req.set_metas(vec![sst_meta.clone()].into());\n    req.set_storage_backend(util::local_storage(&tmp));\n    import.apply(&req).unwrap();\n    util::check_applied_kvs_cf(&tikv, &ctx, CF_DEFAULT, default_fst.iter().copied());\n\n    util::register_range_for(&mut sst_meta, b\"k1\", b\"k1a\");\n    req.set_rewrite_rules(vec![util::rewrite_for(&mut sst_meta, b\"k\", b\"z\")].into());\n    req.set_metas(vec![sst_meta].into());\n    import.apply(&req).unwrap();\n    util::check_applied_kvs_cf(\n        &tikv,\n        &ctx,\n        CF_DEFAULT,\n        IntoIterator::into_iter(default_fst).chain(IntoIterator::into_iter(default_snd)),\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_existing", "code": "pub fn root_dir_resolved(&self) -> String {\n        log_info(\"current_directory_resolved\", \"\");\n        let s = self\n            .subdir\n            .canonicalize()\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .to_owned();\n\n        // Due to canonicalize()'s use of GetFinalPathNameByHandleW() on Windows, the resolved path\n        // starts with '\\\\?\\' to extend the limit of a given path to 32,767 wide characters.\n        //\n        // To address this issue, we remove this prepended string if available.\n        //\n        // Source:\n        // http://stackoverflow.com/questions/31439011/getfinalpathnamebyhandle-without-prepended\n        let prefix = \"\\\\\\\\?\\\\\";\n\n        if let Some(stripped) = s.strip_prefix(prefix) {\n            String::from(stripped)\n        } else {\n            s\n        }\n    }", "test": "fn test_realpath_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(\"-e\")\n        .arg(\".\")\n        .succeeds()\n        .stdout_only(at.plus_as_string(format!(\"{}\\n\", at.root_dir_resolved())));\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/restore.rs::restore_generates_same_descriptors", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn restore_generates_same_descriptors() {\n  let (mnemonic, descriptors) = {\n    let rpc_server = test_bitcoincore_rpc::spawn();\n\n    let create::Output { mnemonic, .. } = CommandBuilder::new(\"wallet create\")\n      .rpc_server(&rpc_server)\n      .run_and_deserialize_output();\n\n    (mnemonic, rpc_server.descriptors())\n  };\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new([\"wallet\", \"restore\", &mnemonic.to_string()])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Empty>();\n\n  assert_eq!(rpc_server.descriptors(), descriptors);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_str", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_str() {\n    let tests = &[(\"\", \"\\\"\\\"\"), (\"foo\", \"\\\"foo\\\"\")];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ignores_unknown_file", "code": "pub fn assert_cli_snapshot(payload: SnapshotPayload<'_>) {\n    let module_path = payload.module_path.to_owned();\n    let test_name = payload.test_name;\n    let cli_snapshot = CliSnapshot::from(payload);\n\n    let content = cli_snapshot.emit_content_snapshot();\n\n    let module_path = module_path.replace(\"::\", \"_\");\n    let snapshot_path = PathBuf::from(\"snapshots\").join(module_path);\n\n    insta::with_settings!({\n        prepend_module_to_snapshot => false,\n        snapshot_path => snapshot_path\n    }, {\n        insta::assert_snapshot!(test_name, content);\n\n    });\n}", "test": "fn ignores_unknown_file() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path1 = Path::new(\"test.txt\");\n    fs.insert(file_path1.into(), *b\"content\");\n\n    let file_path2 = Path::new(\"test.js\");\n    fs.insert(file_path2.into(), *b\"console.log('bar');\\n\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n                \"--files-ignore-unknown=true\",\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignores_unknown_file\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_equalize_widths_floats", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_equalize_widths_floats() {\n    new_ucmd!()\n        .args(&[\"-w\", \"5\", \"10.0\"])\n        .run()\n        .stdout_is(\"05\\n06\\n07\\n08\\n09\\n10\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_add_column", "code": "pub fn alter_table_op(stmt: Statement) -> AlterTableOperation {\n    alter_table_op_with_name(stmt, \"tab\")\n}", "test": "fn parse_alter_table_add_column() {\n    match alter_table_op(verified_stmt(\"ALTER TABLE tab ADD foo TEXT\")) {\n        AlterTableOperation::AddColumn { column_keyword, .. } => {\n            assert!(!column_keyword);\n        }\n        _ => unreachable!(),\n    };\n\n    match alter_table_op(verified_stmt(\"ALTER TABLE tab ADD COLUMN foo TEXT\")) {\n        AlterTableOperation::AddColumn { column_keyword, .. } => {\n            assert!(column_keyword);\n        }\n        _ => unreachable!(),\n    };\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_invalid_date_string", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_invalid_date_string() {\n    new_ucmd!()\n        .arg(\"-d\")\n        .arg(\"foo\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"invalid date\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_simple_or", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_simple_or() {\n    new_ucmd!().args(&[\"foo\", \"-o\", \"\"]).succeeds();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_allocation_chains", "code": "pub fn map(&self) -> JsObject {\n        self.map.clone()\n    }", "test": "fn eph_allocation_chains() {\n    run_test(|| {\n        let gc_value = Gc::new(String::from(\"foo\"));\n\n        {\n            let cloned_gc = gc_value.clone();\n            let weak = WeakGc::new(&cloned_gc);\n            let wrap = Gc::new(weak);\n\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n\n            let eph = Ephemeron::new(&wrap, 3);\n\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n            assert_eq!(eph.value(), Some(3));\n\n            drop(gc_value);\n            force_collect();\n            assert!(wrap.upgrade().is_none());\n            assert_eq!(eph.value(), Some(3));\n\n            drop(wrap);\n            force_collect();\n            assert!(eph.value().is_none());\n        }\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_consistency_check", "code": "fn test_consistency_check() {\n        let path = Builder::new().prefix(\"tikv-store-test\").tempdir().unwrap();\n        let db = new_engine(path.path().to_str().unwrap(), ALL_CFS).unwrap();\n\n        let mut region = Region::default();\n        region.mut_peers().push(Peer::default());\n\n        let (tx, rx) = mpsc::sync_channel(100);\n        let mut host =\n            CoprocessorHost::<KvTestEngine>::new(tx.clone(), crate::coprocessor::Config::default());\n        host.registry.register_consistency_check_observer(\n            100,\n            BoxConsistencyCheckObserver::new(RawConsistencyCheckObserver::default()),\n        );\n        let mut runner = Runner::new(tx, host);\n        let mut digest = crc32fast::Hasher::new();\n        let kvs = vec![(b\"k1\", b\"v1\"), (b\"k2\", b\"v2\")];\n        for (k, v) in kvs {\n            let key = keys::data_key(k);\n            db.put(&key, v).unwrap();\n            // hash should contain all kvs\n            digest.update(&key);\n            digest.update(v);\n        }\n\n        // hash should also contains region state key.\n        digest.update(&keys::region_state_key(region.get_id()));\n        let sum = digest.finalize();\n        runner.run(Task::<<KvTestEngine as KvEngine>::Snapshot>::ComputeHash {\n            index: 10,\n            context: vec![ConsistencyCheckMethod::Raw as u8],\n            region: region.clone(),\n            snap: db.snapshot(),\n        });\n        let mut checksum_bytes = vec![];\n        checksum_bytes.write_u32::<BigEndian>(sum).unwrap();\n\n        let res = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_matches!(res, SchedTask::UpdateComputeHashResult { region_id, index, hash, context} if\n            region_id == region.get_id() && index == 10 && context == vec![0] && hash == checksum_bytes\n        );\n    }", "test": "fn test_node_consistency_check() {\n    let mut cluster = new_node_cluster(0, 2);\n    test_consistency_check(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_multi_files", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_multi_files() {\n    let args = [\n        \"-c\",\n        NORMAL_FORMAT_STR,\n        \"/dev\",\n        \"/usr/lib\",\n        #[cfg(target_os = \"linux\")]\n        \"/etc/fstab\",\n        \"/var\",\n    ];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon_tests.rs::compute_float_f32_test", "code": "pub fn compute_float32(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f32>(&num);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (111 + f32::INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (111 + f32::INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(\n        compute_float32(-10, 167772170000000000),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(\n        compute_float32(-10, 167772190000000000),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_tiff", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_tiff() {\n    truncate_images(\"tiff\")\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/compatibility-tests/tests/tsig_tests.rs::test_create", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_create() {\n    use hickory_client::rr::rdata::A;\n\n    let (_process, port) = named_process();\n    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n    let conn = UdpClientConnection::new(socket).unwrap();\n\n    let client = create_tsig_ready_client(conn);\n    let origin = Name::from_str(\"example.net.\").unwrap();\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.net.\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client.create(record, origin).expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_multiple_election_rounds", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_multiple_election_rounds() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(30);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 5;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(40);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // wait election timeout\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 2,\n    ));\n    cluster.enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // wait multiple election rounds\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 6,\n    ));\n\n    cluster.clear_send_filters();\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_basic_clone_test", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "test": "fn eph_basic_clone_test() {\n    run_test(|| {\n        let init_gc = Gc::new(String::from(\"bar\"));\n\n        let weak = WeakGc::new(&init_gc);\n\n        let new_gc = weak.upgrade().expect(\"Weak is live\");\n        let new_weak = weak.clone();\n\n        drop(weak);\n        force_collect();\n\n        assert_eq!(*new_gc, *new_weak.upgrade().expect(\"weak should be live\"));\n        assert_eq!(\n            *init_gc,\n            *new_weak.upgrade().expect(\"weak_should be live still\")\n        );\n    });\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_retry_rpc_client", "code": "pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    }", "test": "fn test_retry_rpc_client() {\n    let eps_count = 1;\n    let mut server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let m_eps = eps.clone();\n    let mgr = Arc::new(SecurityManager::new(&SecurityConfig::default()).unwrap());\n    let m_mgr = mgr.clone();\n    server.stop();\n    let child = thread::spawn(move || {\n        let cfg = new_config(m_eps);\n        RpcClient::new(&cfg, None, m_mgr).unwrap();\n    });\n    thread::sleep(Duration::from_millis(500));\n    server.start(&mgr, eps);\n    child.join().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix_alias", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_numeric_suffix_alias() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--numeric=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x10\"), \"b\");\n    assert_eq!(at.read(\"x11\"), \"c\");\n    assert_eq!(at.read(\"x12\"), \"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_default", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_default() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_default\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_bytes_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_bytes_chars() {\n    new_ucmd!()\n        .arg(\"-cm\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"    442     513\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_write_sst", "code": "fn run_test_write_sst(ctx: Context, tikv: TikvClient, import: ImportSstClient) {\n    let mut meta = new_sst_meta(0, 0);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    let mut keys = vec![];\n    let mut values = vec![];\n    let sst_range = (0, 10);\n    for i in sst_range.0..sst_range.1 {\n        keys.push(vec![i]);\n        values.push(vec![i]);\n    }\n    let resp = send_write_sst(&import, &meta, keys, values, 1).unwrap();\n\n    for m in resp.metas.into_iter() {\n        let mut ingest = IngestRequest::default();\n        ingest.set_context(ctx.clone());\n        ingest.set_sst(m.clone());\n        let resp = import.ingest(&ingest).unwrap();\n        assert!(!resp.has_error());\n    }\n    check_ingested_txn_kvs(&tikv, &ctx, sst_range, 2);\n}", "test": "fn test_write_sst() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n\n    run_test_write_sst(ctx, tikv, import);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_one", "code": "pub fn is_none(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_none(),\n            }\n        }\n    }", "test": "fn save_point_rollback_one() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.set_save_point();\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n    let err = wb.pop_save_point();\n    assert_engine_error(err);\n    wb.write().unwrap();\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.set_save_point();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n    let err = wb.pop_save_point();\n    assert_engine_error(err);\n    wb.write().unwrap();\n    for i in 0..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n    let val = db.engine.get_value(b\"a\").unwrap();\n    assert!(val.is_none());\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_safe_string_roundtrip", "code": "pub fn is_safe(&self) -> bool {\n        matches!(&self.0, ValueRepr::String(_, StringType::Safe))\n    }", "test": "fn test_safe_string_roundtrip() {\n    let v = Value::from_safe_string(\"<b>HTML</b>\".into());\n    let v2 = Value::from_serializable(&v);\n    assert!(v.is_safe());\n    assert!(v2.is_safe());\n    assert_eq!(v.to_string(), v2.to_string());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_existing", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=existing\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_hyphen_values_inside_string", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_hyphen_values_inside_string() {\n    new_ucmd!()\n        .arg(\"'\\\"\\n'CXXFLAGS=-g -O2'\\n\\\"'\") // spell-checker:disable-line\n        .succeeds()\n        .stdout_contains(\"CXXFLAGS\"); // spell-checker:disable-line\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::_ebcdic_implies_block() {\n    ", "code": "pub fn stdout_is_bytes<T: AsRef<[u8]>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout, msg.as_ref(),\n            \"stdout as bytes wasn't equal to expected bytes. Result as strings:\\nstdout  ='{:?}'\\nexpected='{:?}'\",\n            std::str::from_utf8(&self.stdout),\n            std::str::from_utf8(msg.as_ref()),\n        );\n        self\n    }", "test": "onv_ebcdic_implies_block() {\n    // 0x40 = 0o100 =  64, which is the result of converting from ' '\n    // 0xc1 = 0o301 = 193, which is the result of converting from 'A'\n    //\n    // `conv=ebcdic` implies `conv=block`, which means trailing spaces\n    // are added to pad each block.\n    //\n    // `cbs=4` means use a conversion block size of 4 bytes per block.\n    new_ucmd!()\n        .args(&[\"conv=ebcdic\", \"cbs=4\"])\n        .pipe_in(\" A A\\n A\\n\")\n        .succeeds()\n        .stdout_is_bytes(b\"\\x40\\xc1\\x40\\xc1\\x40\\xc1\\x40\\x40\");\n}\n\n/// Tes"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_invalid_block_size", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_invalid_block_size() {\n    new_ucmd!()\n        .arg(\"--block-size=x\")\n        .fails()\n        .stderr_contains(\"invalid --block-size argument 'x'\");\n\n    new_ucmd!()\n        .arg(\"--block-size=0\")\n        .fails()\n        .stderr_contains(\"invalid --block-size argument '0'\");\n\n    new_ucmd!()\n        .arg(\"--block-size=0K\")\n        .fails()\n        .stderr_contains(\"invalid --block-size argument '0K'\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::logical_assignment", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn logical_assignment() {\n    run_test_actions([\n        TestAction::assert(\"{ let a = false; a &&= 10; !a }\"),\n        TestAction::assert_eq(\"{ let a = 20; a &&= 10; a }\", 10),\n        TestAction::assert_eq(\"{ let a = null; a ||= 10; a }\", 10),\n        TestAction::assert_eq(\"{ let a = 20; a ||= 10; a }\", 20),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_hex32", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hex32() {\n    let input: [u8; 9] = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xff];\n    let expected_output = unindent(\n        \"\n            0000000 67452301 efcdab89 000000ff\n            0000011\n            \",\n    );\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-X\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tac.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_inf_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_inf_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.inf_string(Some(b\"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"nan\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"in00f\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.inf_string(Some(b\"inf\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.inf_string(None);\n    assert!(builder.is_valid());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_raftkv", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_raftkv() {\n    let count = 1;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.run();\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(b\"k1\"), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader_id = cluster.leader_of_region(region.get_id()).unwrap();\n    let mut storage = cluster.sim.rl().storages[&leader_id.get_id()].clone();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(region.get_peers()[0].clone());\n    let snap_ctx = SnapContext {\n        pb_ctx: &ctx,\n        ..Default::default()\n    };\n\n    get_put(snap_ctx.clone(), &mut storage);\n    batch(snap_ctx.clone(), &mut storage);\n    seek(snap_ctx.clone(), &mut storage);\n    near_seek(snap_ctx.clone(), &mut storage);\n    cf(snap_ctx, &mut storage);\n    empty_write(&ctx, &storage);\n    wrong_context(&ctx, &storage);\n    // TODO: test multiple node\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_increase_async_ios", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_increase_async_ios() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 1;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // Save current async-io tids before shrinking\n    let org_writers_tids = get_async_writers_tids();\n    assert_eq!(1, org_writers_tids.len());\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    // Update config, expand from 1 to 2\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-io-pool-size\".to_owned(), \"2\".to_owned());\n            change\n        };\n\n        cfg_controller.update(change).unwrap();\n        assert_eq!(\n            cfg_controller.get_current().raft_store.store_io_pool_size,\n            2\n        );\n        // Wait for the completion of increasing async-ios\n        std::thread::sleep(std::time::Duration::from_secs(1));\n    }\n    // Save current async-io tids after scaling up, and compared with the\n    // orginial one before scaling up, the thread num should be added up to TWO.\n    let cur_writers_tids = get_async_writers_tids();\n    assert_eq!(cur_writers_tids.len() - 1, org_writers_tids.len());\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::create_local_directory", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn create_local_directory() {\n    let query =\n        \"INSERT OVERWRITE LOCAL DIRECTORY '/home/blah' STORED AS TEXTFILE SELECT * FROM db.table\";\n    hive().verified_stmt(query);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_limit", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_limit() {\n    verified_stmt(\"SELECT * FROM user LIMIT 1\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::should_type_error_when_new_is_not_constructor", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn should_type_error_when_new_is_not_constructor() {\n    run_test_actions([TestAction::assert_native_error(\n        \"new ''()\",\n        JsNativeErrorKind::Type,\n        \"not a constructor\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_quick", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fmt_quick() {\n    for param in [\"-q\", \"--quick\"] {\n        new_ucmd!()\n            .args(&[\"one-word-per-line.txt\", param])\n            .succeeds()\n            .stdout_is(\"this is a file with one word per line\\n\");\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/undefined_variables.rs::parameter_default_unknown_variable_in_expression", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn parameter_default_unknown_variable_in_expression() {\n  Test::new()\n    .justfile(\"foo a=(b+''):\")\n    .stderr(\n      \"\n      error: Variable `b` not defined\n        |\n      1 | foo a=(b+''):\n        |        ^\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_byte_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_byte_syntax() {\n    new_ucmd!()\n        .args(&[\"-1c\"])\n        .pipe_in(\"abc\")\n        .run()\n        .stdout_is(\"a\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_sync.rs::test_sync_host_func", "code": "fn into(self) -> MemArg {\n        match self {\n            StackAMode::FPOffset(off, _ty) => MemArg::InitialSPOffset { off },\n            StackAMode::NominalSPOffset(off, _ty) => MemArg::NominalSPOffset { off },\n            StackAMode::SPOffset(off, _ty) => {\n                MemArg::reg_plus_off(stack_reg(), off, MemFlags::trusted())\n            }\n        }\n    }", "test": "fn test_sync_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    atoms::add_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"int_float_args_shim\")\n        .unwrap()\n        .call(&mut store, &[0i32.into(), 123.45f32.into()], &mut results)\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"int_float_args errno\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_first_1000_integers", "code": "fn finalize<T>(\n    output: &mut Output,\n    rstat: ReadStat,\n    wstat: WriteStat,\n    start: Instant,\n    prog_tx: &mpsc::Sender<ProgUpdate>,\n    output_thread: thread::JoinHandle<T>,\n) -> std::io::Result<()> {\n    // Flush the output, if configured to do so.\n    output.sync()?;\n\n    // Truncate the file to the final cursor location.\n    //\n    // Calling `set_len()` may result in an error (for example,\n    // when calling it on `/dev/null`), but we don't want to\n    // terminate the process when that happens. Instead, we\n    // suppress the error by calling `Result::ok()`. This matches\n    // the behavior of GNU `dd` when given the command-line\n    // argument `of=/dev/null`.\n    if !output.settings.oconv.notrunc {\n        output.dst.truncate().ok();\n    }\n\n    // Print the final read/write statistics.\n    let prog_update = ProgUpdate::new(rstat, wstat, start.elapsed(), true);\n    prog_tx.send(prog_update).unwrap_or(());\n    // Wait for the output thread to finish\n    output_thread\n        .join()\n        .expect(\"Failed to join with the output thread.\");\n    Ok(())\n}", "test": "fn test_first_1000_integers() {\n    use hex_literal::hex;\n    use sha1::{Digest, Sha1};\n\n    let n_integers = 1000;\n    let mut input_string = String::new();\n    for i in 0..=n_integers {\n        input_string.push_str(&(format!(\"{i} \"))[..]);\n    }\n\n    println!(\"STDIN='{input_string}'\");\n    let result = new_ucmd!().pipe_in(input_string.as_bytes()).succeeds();\n\n    // `seq 0 1000 | factor | sha1sum` => \"c734327bd18b90fca5762f671672b5eda19f7dca\"\n    let mut hasher = Sha1::new();\n    hasher.update(result.stdout());\n    let hash_check = hasher.finalize();\n    assert_eq!(\n        hash_check[..],\n        hex!(\"c734327bd18b90fca5762f671672b5eda19f7dca\")\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_division_by_zero_size_only", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_division_by_zero_size_only() {\n    new_ucmd!()\n        .args(&[\"-s\", \"/0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"division by zero\");\n    new_ucmd!()\n        .args(&[\"-s\", \"%0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"division by zero\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression8", "code": "fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n                            fixed_key_size,\n                            fixed_value_size,\n                        );\n                        let entry = if reverse {\n                            child_accessor.num_pairs() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Leaf {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            entry,\n                            parent,\n                        }))\n                    }\n                    BRANCH => {\n                        let child_accessor = BranchAccessor::new(&child_page, fixed_key_size);\n                        let child = if reverse {\n                            child_accessor.count_children() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Internal {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            child,\n                            parent,\n                        }))\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", "test": "fn regression8() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 1585];\n        t.insert(&565922, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 2040];\n        t.insert(&94937, v.as_slice()).unwrap();\n        let v = vec![0u8; 2058];\n        t.insert(&130571, v.as_slice()).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 947];\n        t.insert(&118749, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let t = tx.open_table(table_def).unwrap();\n        let mut iter = t.range(118749..142650).unwrap();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 118749);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 130571);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fmt() {\n    new_ucmd!()\n        .arg(\"one-word-per-line.txt\")\n        .succeeds()\n        .stdout_is(\"this is a file with one word per line\\n\");\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/reference_images.rs::check_references", "code": "pub fn as_bytes(&self) -> &[u8] {\n        // we can do this because every variant contains an `ImageBuffer<_, Vec<_>>`\n        dynamic_map!(*self, |ref image_buffer| bytemuck::cast_slice(\n            image_buffer.as_raw().as_ref()\n        ))\n    }", "test": "fn check_references() {\n    process_images(REFERENCE_DIR, Some(\"png\"), |base, path, decoder| {\n        println!(\"check_references {}\", path.display());\n\n        let ref_img = match image::open(&path) {\n            Ok(img) => img,\n            // Do not fail on unsupported error\n            // This might happen because the testsuite contains unsupported images\n            // or because a specific decoder included via a feature.\n            Err(image::ImageError::Unsupported(_)) => return,\n            Err(err) => panic!(\"{}\", err),\n        };\n\n        let (filename, testsuite) = {\n            let mut path: Vec<_> = path.components().collect();\n            (path.pop().unwrap(), path.pop().unwrap())\n        };\n\n        // Parse the file name to obtain the test case information\n        let filename_str = filename.as_os_str().to_str().unwrap();\n        let case: ReferenceTestCase = filename_str.parse().unwrap();\n\n        let mut img_path = base.clone();\n        img_path.push(IMAGE_DIR);\n        img_path.push(decoder);\n        img_path.push(testsuite.as_os_str());\n        img_path.push(case.orig_filename);\n\n        // Load the test image\n        let mut test_img = None;\n\n        match case.kind {\n            ReferenceTestKind::AnimatedFrame { frame: frame_num } => {\n                let format = image::io::Reader::open(&img_path)\n                    .unwrap()\n                    .with_guessed_format()\n                    .unwrap()\n                    .format();\n\n                #[cfg(feature = \"gif\")]\n                if format == Some(image::ImageFormat::Gif) {\n                    // Interpret the input file as an animation file\n                    use image::AnimationDecoder;\n                    let stream = io::BufReader::new(fs::File::open(&img_path).unwrap());\n                    let decoder = match image::codecs::gif::GifDecoder::new(stream) {\n                        Ok(decoder) => decoder,\n                        Err(image::ImageError::Unsupported(_)) => return,\n                        Err(err) => {\n                            panic!(\"decoding of {:?} failed with: {}\", img_path, err)\n                        }\n                    };\n\n                    let mut frames = match decoder.into_frames().collect_frames() {\n                        Ok(frames) => frames,\n                        Err(image::ImageError::Unsupported(_)) => return,\n                        Err(err) => {\n                            panic!(\"collecting frames of {:?} failed with: {}\", img_path, err)\n                        }\n                    };\n\n                    // Select a single frame\n                    let frame = frames.drain(frame_num..).nth(0).unwrap();\n\n                    // Convert the frame to a`RgbaImage`\n                    test_img = Some(DynamicImage::from(frame.into_buffer()));\n                }\n\n                #[cfg(feature = \"png\")]\n                if format == Some(image::ImageFormat::Png) {\n                    // Interpret the input file as an animation file\n                    use image::AnimationDecoder;\n                    let stream = io::BufReader::new(fs::File::open(&img_path).unwrap());\n                    let decoder = match image::codecs::png::PngDecoder::new(stream) {\n                        Ok(decoder) => decoder.apng(),\n                        Err(image::ImageError::Unsupported(_)) => return,\n                        Err(err) => {\n                            panic!(\"decoding of {:?} failed with: {}\", img_path, err)\n                        }\n                    };\n\n                    let mut frames = match decoder.into_frames().collect_frames() {\n                        Ok(frames) => frames,\n                        Err(image::ImageError::Unsupported(_)) => return,\n                        Err(err) => {\n                            panic!(\"collecting frames of {:?} failed with: {}\", img_path, err)\n                        }\n                    };\n\n                    // Select a single frame\n                    let frame = frames.drain(frame_num..).nth(0).unwrap();\n\n                    // Convert the frame to a`RgbaImage`\n                    test_img = Some(DynamicImage::from(frame.into_buffer()));\n                }\n\n                if test_img.is_none() {\n                    println!(\"Skipping - GIF codec is not enabled\");\n                    return;\n                }\n            }\n\n            ReferenceTestKind::SingleImage => {\n                // Read the input file as a single image\n                match image::open(&img_path) {\n                    Ok(img) => test_img = Some(img),\n                    // Do not fail on unsupported error\n                    // This might happen because the testsuite contains unsupported images\n                    // or because a specific decoder included via a feature.\n                    Err(image::ImageError::Unsupported(_)) => return,\n                    Err(err) => panic!(\"decoding of {:?} failed with: {}\", img_path, err),\n                };\n            }\n        }\n\n        let test_img = match test_img.as_ref() {\n            Some(img) => img,\n            None => return,\n        };\n\n        let test_crc_actual = {\n            let mut hasher = Crc32::new();\n            hasher.update(test_img.as_bytes());\n            hasher.finalize()\n        };\n\n        if test_crc_actual != case.crc {\n            panic!(\n                \"The decoded image's hash does not match (expected = {:08x}, actual = {:08x}).\",\n                case.crc, test_crc_actual\n            );\n        }\n\n        if ref_img.as_bytes() != test_img.as_bytes() {\n            panic!(\"Reference rendering does not match.\");\n        }\n    })\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_leader", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_witness_leader() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // can't make leader to witness\n    cluster\n        .pd_client\n        .switch_witnesses(region.get_id(), vec![peer_on_store1.get_id()], vec![true]);\n\n    std::thread::sleep(Duration::from_millis(100));\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap().store_id,\n        1\n    );\n    // leader changes to witness failed, so still can get the value\n    must_get_equal(&cluster.get_engine(nodes[0]), b\"k1\", b\"v1\");\n\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    // can't transfer leader to witness\n    cluster.transfer_leader(region.get_id(), peer_on_store3);\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap().store_id,\n        nodes[0],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_log.rs::test_node_compact_size_limit", "code": "fn test_compact_size_limit<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100000);\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize::mb(1));\n    cluster.run();\n    cluster.stop_node(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let mut before_states = HashMap::default();\n\n    for (&id, engines) in &cluster.engines {\n        if id == 1 {\n            continue;\n        }\n        must_get_equal(&engines.kv, b\"k1\", b\"v1\");\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        let state = state.take_truncated_state();\n        // compact should not start\n        assert_eq!(RAFT_INIT_LOG_INDEX, state.get_index());\n        assert_eq!(RAFT_INIT_LOG_TERM, state.get_term());\n        before_states.insert(id, state);\n    }\n\n    let key = vec![1; 100];\n    let value = vec![1; 10240];\n    // 25 * 10240 = 250KiB < 1MiB\n    for _ in 0..25 {\n        cluster.must_put(&key, &value);\n    }\n\n    // wait log gc.\n    sleep_ms(500);\n\n    // limit has not reached, should not gc.\n    for (&id, engines) in &cluster.engines {\n        if id == 1 {\n            continue;\n        }\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        let after_state = state.take_truncated_state();\n\n        let before_state = &before_states[&id];\n        let idx = after_state.get_index();\n        assert_eq!(idx, before_state.get_index());\n    }\n\n    // 100 * 10240 + 250KiB > 1MiB\n    for _ in 0..100 {\n        cluster.must_put(&key, &value);\n    }\n\n    sleep_ms(500);\n\n    // Size exceed max limit, every peer must have compacted logs,\n    // so the truncate log state index/term must > than before.\n    for (&id, engines) in &cluster.engines {\n        if id == 1 {\n            continue;\n        }\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        let after_state = state.take_truncated_state();\n\n        let before_state = &before_states[&id];\n        let idx = after_state.get_index();\n        assert!(idx > before_state.get_index());\n    }\n}", "test": "fn test_node_compact_size_limit() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_compact_size_limit(&mut cluster);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/psbt.rs::bip174_psbt_workflow", "code": "fn combine_lexicographically() {\n    let psbt_1_hex = include_str!(\"data/lex_psbt_1_hex\");\n    let psbt_2_hex = include_str!(\"data/lex_psbt_2_hex\");\n\n    let expected_psbt_hex = include_str!(\"data/lex_combine_psbt_hex\");\n    let expected_psbt = hex_psbt!(expected_psbt_hex).unwrap();\n\n    let v = Vec::from_hex(psbt_1_hex).unwrap();\n    let mut psbt_1 = Psbt::deserialize(&v).expect(\"failed to deserialize psbt 1\");\n\n    let v = Vec::from_hex(psbt_2_hex).unwrap();\n    let psbt_2 = Psbt::deserialize(&v).expect(\"failed to deserialize psbt 2\");\n\n    psbt_1.combine(psbt_2).expect(\"failed to combine PSBTs\");\n\n    assert_eq!(psbt_1, expected_psbt);\n}", "test": "fn bip174_psbt_workflow() {\n    let secp = Secp256k1::new();\n\n    //\n    // Step 0: Create the extended private key from the test vector data.\n    //\n\n    let ext_priv = build_extended_private_key();\n    let ext_pub = Xpub::from_priv(&secp, &ext_priv);\n    let parent_fingerprint = ext_pub.fingerprint();\n\n    //\n    // Step 1: The creator.\n    //\n\n    let tx = create_transaction();\n    let psbt = create_psbt(tx);\n\n    //\n    // Step 2: The first updater.\n    //\n\n    let psbt = update_psbt(psbt, parent_fingerprint);\n\n    //\n    // Step 3: The second updater.\n    //\n\n    let psbt = update_psbt_with_sighash_all(psbt);\n\n    //\n    // Step 4: The first signer.\n    //\n\n    // Strings from BIP 174 test vector.\n    let test_vector = vec![\n        (\"cP53pDbR5WtAD8dYAW9hhTjuvvTVaEiQBdrz9XPrgLBeRFiyCbQr\", \"m/0h/0h/0h\"), // from_priv, into_derivation_path?\n        (\"cR6SXDoyfQrcp4piaiHE97Rsgta9mNhGTen9XeonVgwsh4iSgw6d\", \"m/0h/0h/2h\"),\n    ];\n\n    // We pass the keys to the signer after doing verification to make explicit\n    // that signer is only using these two keys.\n    let keys = parse_and_verify_keys(&ext_priv, &test_vector);\n    let psbt_1 = signer_one_sign(psbt.clone(), keys);\n\n    //\n    // Step 5: The second signer.\n    //\n\n    // Strings from BIP 174 test vector.\n    let test_vector = vec![\n        (\"cT7J9YpCwY3AVRFSjN6ukeEeWY6mhpbJPxRaDaP5QTdygQRxP9Au\", \"m/0h/0h/1h\"),\n        (\"cNBc3SWUip9PPm1GjRoLEJT6T41iNzCYtD7qro84FMnM5zEqeJsE\", \"m/0h/0h/3h\"),\n    ];\n\n    let keys = parse_and_verify_keys(&ext_priv, &test_vector);\n    let psbt_2 = signer_two_sign(psbt, keys);\n\n    //\n    // Step 6: Combiner the two signed PSBTs.\n    //\n\n    let combined = combine(psbt_1, psbt_2);\n\n    //\n    // Step 7: Finalize the PSBT.\n    //\n\n    let finalized = finalize(combined);\n\n    //\n    // Step 8: Extract the transaction.\n    //\n\n    let _tx = extract_transaction(finalized);\n\n    //\n    // Step 9: Test lexicographical PSBT combiner.\n    //\n    // Combine would be done earlier, at Step 6, in typical workflow.\n    // We define it here to reflect the order of test vectors in BIP 174.\n    //\n\n    combine_lexicographically();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/fuel.rs::manual_fuel", "code": "pub fn fuel_consumed(&self) -> Option<u64> {\n        self.inner.fuel_consumed()\n    }", "test": "fn manual_fuel() {\n    let mut config = Config::new();\n    config.consume_fuel(true);\n    let engine = Engine::new(&config).unwrap();\n    let mut store = Store::new(&engine, ());\n    store.add_fuel(10_000).unwrap();\n    assert_eq!(store.fuel_consumed(), Some(0));\n    assert_eq!(store.fuel_remaining(), Some(10_000));\n    assert_eq!(store.consume_fuel(1).unwrap(), 9_999);\n    assert_eq!(store.fuel_consumed(), Some(1));\n    assert_eq!(store.fuel_remaining(), Some(9_999));\n    assert!(store.consume_fuel(10_000).is_err());\n    assert_eq!(store.consume_fuel(999).unwrap(), 9_000);\n    assert!(store.consume_fuel(10_000).is_err());\n    assert_eq!(store.consume_fuel(8998).unwrap(), 2);\n    assert!(store.consume_fuel(3).is_err());\n    assert_eq!(store.consume_fuel(1).unwrap(), 1);\n    assert_eq!(store.consume_fuel(1).unwrap(), 0);\n    assert_eq!(store.consume_fuel(0).unwrap(), 0);\n    assert_eq!(store.fuel_remaining(), Some(0));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_should_report_invalid_empty_number_on_blank_stdin", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_should_report_invalid_empty_number_on_blank_stdin() {\n    new_ucmd!()\n        .args(&[\"--from=auto\"])\n        .pipe_in(\"  \\t  \\n\")\n        .run()\n        .stderr_is(\"numfmt: invalid number: ''\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_preserve_root_symlink", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_preserve_root_symlink() {\n    let file = \"test_chgrp_symlink2root\";\n    for d in [\n        \"/\",\n        \"////dev//../../../../\",\n        \"..//../../..//../..//../../../../../../../../\",\n        \".//../../../../../../..//../../../../../../../\",\n    ] {\n        let (at, mut ucmd) = at_and_ucmd!();\n        at.symlink_file(d, file);\n        ucmd.arg(\"--preserve-root\")\n            .arg(\"-HR\")\n            .arg(\"bin\").arg(file)\n            .fails()\n            .stderr_is(\"chgrp: it is dangerous to operate recursively on '/'\\nchgrp: use --no-preserve-root to override this failsafe\\n\");\n    }\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.symlink_file(\"///dev\", file);\n    ucmd.arg(\"--preserve-root\")\n        .arg(\"-HR\")\n        .arg(\"bin\").arg(format!(\".//{file}/..//..//../../\"))\n        .fails()\n        .stderr_is(\"chgrp: it is dangerous to operate recursively on '/'\\nchgrp: use --no-preserve-root to override this failsafe\\n\");\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.symlink_file(\"/\", \"__root__\");\n    ucmd.arg(\"--preserve-root\")\n        .arg(\"-R\")\n        .arg(\"bin\").arg(\"__root__/.\")\n        .fails()\n        .stderr_is(\"chgrp: it is dangerous to operate recursively on '/'\\nchgrp: use --no-preserve-root to override this failsafe\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::use_after_drop", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "test": "fn use_after_drop() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (global (export \"foo\") (mut i32) (i32.const 100)))\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let g = instance.get_global(&mut store, \"foo\").unwrap();\n    assert_eq!(g.get(&mut store).i32(), Some(100));\n    g.set(&mut store, 101.into())?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Instance::new(&mut store, &module, &[])?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    drop(module);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n\n    // spray some heap values\n    let mut x = Vec::new();\n    for _ in 0..100 {\n        x.push(\"xy\".to_string());\n    }\n    drop(x);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Ok(())\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_6", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_6() {\n    let original = r##\"# H1 \\\n{#myid}\n\n## H2 \\\nnextline {.class}\n\n### H3 [link\n](https://example.com/) {#myid3}\n\"##;\n    let expected = r##\"<h1>H1 \\</h1>\n<p>{#myid}</p>\n<h2>H2 \\</h2>\n<p>nextline {.class}</p>\n<h3>H3 [link</h3>\n<p>](https://example.com/) {#myid3}</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table", "code": "pub fn alter_table_op(stmt: Statement) -> AlterTableOperation {\n    alter_table_op_with_name(stmt, \"tab\")\n}", "test": "fn parse_alter_table() {\n    let add_column = \"ALTER TABLE tab ADD COLUMN foo TEXT;\";\n    match alter_table_op(one_statement_parses_to(\n        add_column,\n        \"ALTER TABLE tab ADD COLUMN foo TEXT\",\n    )) {\n        AlterTableOperation::AddColumn {\n            column_keyword,\n            if_not_exists,\n            column_def,\n        } => {\n            assert!(column_keyword);\n            assert!(!if_not_exists);\n            assert_eq!(\"foo\", column_def.name.to_string());\n            assert_eq!(\"TEXT\", column_def.data_type.to_string());\n        }\n        _ => unreachable!(),\n    };\n\n    let rename_table = \"ALTER TABLE tab RENAME TO new_tab\";\n    match alter_table_op(verified_stmt(rename_table)) {\n        AlterTableOperation::RenameTable { table_name } => {\n            assert_eq!(\"new_tab\", table_name.to_string());\n        }\n        _ => unreachable!(),\n    };\n\n    let rename_column = \"ALTER TABLE tab RENAME COLUMN foo TO new_foo\";\n    match alter_table_op(verified_stmt(rename_column)) {\n        AlterTableOperation::RenameColumn {\n            old_column_name,\n            new_column_name,\n        } => {\n            assert_eq!(old_column_name.to_string(), \"foo\");\n            assert_eq!(new_column_name.to_string(), \"new_foo\");\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_width", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_ls_width() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(at.plus_as_string(\"test-width-1\"));\n    at.touch(at.plus_as_string(\"test-width-2\"));\n    at.touch(at.plus_as_string(\"test-width-3\"));\n    at.touch(at.plus_as_string(\"test-width-4\"));\n\n    for option in [\n        \"-w 100\",\n        \"-w=100\",\n        \"--width=100\",\n        \"--width 100\",\n        \"--wid=100\",\n    ] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1  test-width-2  test-width-3  test-width-4\\n\");\n    }\n\n    for option in [\"-w 50\", \"-w=50\", \"--width=50\", \"--width 50\", \"--wid=50\"] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1  test-width-3\\ntest-width-2  test-width-4\\n\");\n    }\n\n    for option in [\"-w 25\", \"-w=25\", \"--width=25\", \"--width 25\", \"--wid=25\"] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1\\ntest-width-2\\ntest-width-3\\ntest-width-4\\n\");\n    }\n\n    for option in [\"-w 0\", \"-w=0\", \"--width=0\", \"--width 0\", \"--wid=0\"] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1  test-width-2  test-width-3  test-width-4\\n\");\n    }\n\n    for option in [\n        \"-w 062\",\n        \"-w=062\",\n        \"--width=062\",\n        \"--width 062\",\n        \"--wid=062\",\n    ] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1  test-width-3\\ntest-width-2  test-width-4\\n\");\n    }\n\n    for option in [\n        \"-w 100000000000000\",\n        \"-w=100000000000000\",\n        \"--width=100000000000000\",\n        \"--width 100000000000000\",\n        \"-w 07777777777777777777\",\n        \"-w=07777777777777777777\",\n        \"--width=07777777777777777777\",\n        \"--width 07777777777777777777\",\n    ] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .succeeds()\n            .stdout_only(\"test-width-1  test-width-2  test-width-3  test-width-4\\n\");\n    }\n    scene\n        .ucmd()\n        .arg(\"-w=bad\")\n        .arg(\"-C\")\n        .fails()\n        .stderr_contains(\"invalid line width\");\n\n    for option in [\"-w 1a\", \"-w=1a\", \"--width=1a\", \"--width 1a\", \"--wid 1a\"] {\n        scene\n            .ucmd()\n            .args(&option.split(' ').collect::<Vec<_>>())\n            .arg(\"-C\")\n            .fails()\n            .stderr_only(\"ls: invalid line width: '1a'\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_range_start_is_compacted", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_when_warmup_range_start_is_compacted() {\n    let mut cluster = new_node_cluster(0, 3);\n    // GC raft log aggressively.\n    cluster.cfg.raft_store.merge_max_log_gap = 1;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(5);\n    cluster.cfg.raft_store.max_entry_cache_warmup_duration = ReadableDuration::secs(1000);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n    cluster.pd_client.disable_default_operator();\n\n    // Case `test_transfer_leader_msg_index` already proves that\n    // the warmup_range_start is equal to the replicated_index.\n    let warmup_range_start = cluster.raft_local_state(1, 3).last_index;\n    cluster.wait_log_truncated(1, 2, warmup_range_start + 10);\n    let s2_truncated_index = cluster.truncated_state(1, 2).get_index();\n    let s2_last_index = cluster.raft_local_state(1, 2).last_index;\n    assert!(warmup_range_start < s2_truncated_index);\n    assert!(s2_truncated_index + 5 <= s2_last_index);\n\n    // Cache should be warmed up successfully.\n    let (sx, rx) = channel::unbounded();\n    fail::cfg_callback(\"on_entry_cache_warmed_up\", move || sx.send(true).unwrap()).unwrap();\n    cluster.transfer_leader(1, new_peer(2, 2));\n    rx.recv_timeout(Duration::from_millis(500)).unwrap();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::do_while_loop_at_least_once", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn do_while_loop_at_least_once() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            a = 0;\n            do\n            {\n                a += 1;\n            }\n            while (false);\n            a\n        \"#},\n        1,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_size", "code": "fn region_size<T: AsRef<str>>(&self, region_id: u64, cfs: Vec<T>) -> Result<Vec<(T, usize)>> {\n        let region_state_key = keys::region_state_key(region_id);\n        match self\n            .engines\n            .kv\n            .get_msg_cf::<RegionLocalState>(CF_RAFT, &region_state_key)\n        {\n            Ok(Some(region_state)) => {\n                let region = region_state.get_region();\n                let start_key = &keys::data_key(region.get_start_key());\n                let end_key = &keys::data_end_key(region.get_end_key());\n                let mut sizes = vec![];\n                for cf in cfs {\n                    let mut size = 0;\n                    box_try!(self.engines.kv.scan(\n                        cf.as_ref(),\n                        start_key,\n                        end_key,\n                        false,\n                        |k, v| {\n                            size += k.len() + v.len();\n                            Ok(true)\n                        }\n                    ));\n                    sizes.push((cf, size));\n                }\n                Ok(sizes)\n            }\n            Ok(None) => Err(Error::NotFound(format!(\"none region {:?}\", region_id))),\n            Err(e) => Err(box_err!(e)),\n        }\n    }", "test": "fn test_debug_region_size() {\n    let (cluster, debug_client, store_id) = must_new_cluster_and_debug_client();\n    let engine = cluster.get_engine(store_id);\n\n    // Put some data.\n    let region_id = 100;\n    let region_state_key = keys::region_state_key(region_id);\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.set_start_key(b\"a\".to_vec());\n    region.set_end_key(b\"z\".to_vec());\n    let mut state = RegionLocalState::default();\n    state.set_region(region);\n    engine\n        .put_msg_cf(CF_RAFT, &region_state_key, &state)\n        .unwrap();\n\n    let cfs = vec![CF_DEFAULT, CF_LOCK, CF_WRITE];\n    // At lease 8 bytes for the WRITE cf.\n    let (k, v) = (keys::data_key(b\"kkkk_kkkk\"), b\"v\");\n    for cf in &cfs {\n        engine.put_cf(cf, k.as_slice(), v).unwrap();\n    }\n\n    let mut req = debugpb::RegionSizeRequest::default();\n    req.set_region_id(region_id);\n    req.set_cfs(cfs.iter().map(|s| s.to_string()).collect());\n    let entries: Vec<_> = debug_client\n        .region_size(&req)\n        .unwrap()\n        .take_entries()\n        .into();\n    assert_eq!(entries.len(), 3);\n    for e in entries {\n        cfs.iter().find(|&&c| c == e.cf).unwrap();\n        assert!(e.size > 0);\n    }\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_size(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::b_test", "code": "fn b<F: Float>(float: F) -> (u64, i32) {\n    let fp = slow::b(float);\n    (fp.mant, fp.exp)\n}", "test": "fn b_test() {\n    assert_eq!(b(1e-45_f32), (1, -149));\n    assert_eq!(b(5e-324_f64), (1, -1074));\n    assert_eq!(b(1e-323_f64), (2, -1074));\n    assert_eq!(b(2e-323_f64), (4, -1074));\n    assert_eq!(b(3e-323_f64), (6, -1074));\n    assert_eq!(b(4e-323_f64), (8, -1074));\n    assert_eq!(b(5e-323_f64), (10, -1074));\n    assert_eq!(b(6e-323_f64), (12, -1074));\n    assert_eq!(b(7e-323_f64), (14, -1074));\n    assert_eq!(b(8e-323_f64), (16, -1074));\n    assert_eq!(b(9e-323_f64), (18, -1074));\n    assert_eq!(b(1_f32), (8388608, -23));\n    assert_eq!(b(1_f64), (4503599627370496, -52));\n    assert_eq!(b(1e38_f32), (9860761, 103));\n    assert_eq!(b(1e308_f64), (5010420900022432, 971));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_no_match6", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_no_match6() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/-5\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/nope/-5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/-5\", \"-k\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '/nope/-5': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_create_multi", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_create_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(100, 10, 100, 11))));\n    let record2 = record2;\n\n    let mut rrset = RecordSet::from(record.clone());\n    rrset.insert(record2.clone(), 0);\n    let rrset = rrset;\n\n    let result = io_loop\n        .block_on(client.create(rrset.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = io_loop\n        .block_on(client.create(rrset, origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    let mut record = record;\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 12))));\n\n    let result = io_loop\n        .block_on(client.create(record, origin))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_update_region_size.rs::test_server_update_region_size", "code": "fn test_update_region_size<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.split_region_check_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.region_split_check_diff = Some(ReadableSize::kb(1));\n    cluster\n        .cfg\n        .rocksdb\n        .defaultcf\n        .level0_file_num_compaction_trigger = 10;\n    cluster.start().unwrap();\n\n    let batch_put = |cluster: &mut Cluster<T>, mut start, end| {\n        while start < end {\n            let next = std::cmp::min(end, start + 50);\n            let requests = (start..next)\n                .map(|i| {\n                    new_put_cmd(\n                        &format!(\"k{}\", i).into_bytes(),\n                        &format!(\"value{}\", i).into_bytes(),\n                    )\n                })\n                .collect();\n            cluster\n                .batch_put(&format!(\"k{}\", start).into_bytes(), requests)\n                .unwrap();\n            start = next;\n        }\n    };\n\n    for _ in 0..2 {\n        batch_put(cluster, 0, 1000);\n        flush(cluster);\n        batch_put(cluster, 1000, 2000);\n        flush(cluster);\n        batch_put(cluster, 2000, 3000);\n        flush(cluster);\n    }\n\n    // Make sure there are multiple regions, so it will cover all cases of\n    // function `raftstore.on_compaction_finished`.\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let region = pd_client.get_region(b\"\").unwrap();\n    cluster.must_split(&region, b\"k2000\");\n\n    thread::sleep(time::Duration::from_millis(500));\n    let region_id = cluster.get_region_id(b\"\");\n    let old_region_size = cluster\n        .pd_client\n        .get_region_approximate_size(region_id)\n        .unwrap();\n\n    cluster.compact_data();\n\n    thread::sleep(time::Duration::from_millis(500));\n    let new_region_size = cluster\n        .pd_client\n        .get_region_approximate_size(region_id)\n        .unwrap();\n\n    assert_ne!(old_region_size, new_region_size);\n}", "test": "fn test_server_update_region_size() {\n    let count = 1;\n    let mut cluster = new_server_cluster(0, count);\n    test_update_region_size(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_multibyte", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_multibyte() {\n    new_ucmd!()\n        .arg(\"-c\")\n        .arg(\"-w12\")\n        .run_piped_stdin(\"Universit\u00e4t T\u00fcbingen \\u{1B000}\".as_bytes()) // spell-checker:disable-line\n        .success()\n        .no_stderr()\n        .stdout_is(unindent(\n            \"\n            0000000   U   n   i   v   e   r   s   i   t   \u00e4  **   t\n            0000014       T   \u00fc  **   b   i   n   g   e   n       \\u{1B000}\n            0000030  **  **  **\n            0000033\n            \",\n        ));\n}\n\n#["}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_cast_bytes_to_string_format", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_cast_bytes_to_string_format() {\n    let sql = r\"SELECT CAST(B'\\x48\\x65\\x6c\\x6c\\x6f' AS STRING FORMAT 'ASCII') AS bytes_to_string\";\n    bigquery_and_generic().verified_only_select(sql);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_complex_join", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_complex_join() {\n    let sql = \"SELECT c1, c2 FROM t1, t4 JOIN t2 ON t2.c = t1.c LEFT JOIN t3 USING(q, c) WHERE t4.c = t1.c\";\n    verified_only_select(sql);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::len", "code": "pub fn open_multimap_table<'txn, K: RedbKey + 'static, V: RedbKey + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: MultimapTableDefinition<K, V>,\n    ) -> Result<MultimapTable<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening multimap table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Multimap)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(MultimapTable::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn len() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello\", \"world2\").unwrap();\n        table.insert(\"hi\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 3);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::downgrade_severity", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn downgrade_severity() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_LINTER_DOWNGRADE_DIAGNOSTIC.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), NO_DEBUGGER.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    assert_eq!(\n        messages\n            .iter()\n            .filter(|m| m.level == LogLevel::Error)\n            .filter(|m| {\n                let content = format!(\"{:#?}\", m.content);\n                content.contains(\"suspicious/noDebugger\")\n            })\n            .count(),\n        1\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"downgrade_severity\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_lc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_lc() {\n    // Test iterators that skip multiple, leading digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"4__5__.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_numbered_with_t", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_numbered_with_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=t\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_read.rs::test_query_with_write_cmd", "code": "fn is_none(&self) -> bool {\n        false\n    }", "test": "fn test_query_with_write_cmd() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let region_id = 2;\n    let mut req = router.new_request_for(2);\n\n    for write_cmd in [\n        CmdType::Prewrite,\n        CmdType::Delete,\n        CmdType::DeleteRange,\n        CmdType::Put,\n        CmdType::IngestSst,\n    ] {\n        let mut request_inner = Request::default();\n        request_inner.set_cmd_type(write_cmd);\n        req.mut_requests().push(request_inner);\n        let res = router.query(region_id, req.clone()).unwrap();\n        let resp = res.read();\n        assert!(resp.is_none());\n        let error_resp = res.response().unwrap();\n        assert!(error_resp.get_header().has_error());\n        req.clear_requests();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_encode", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_encode() {\n    let input = \"hello, world!\";\n    new_ucmd!()\n        .pipe_in(input)\n        .succeeds()\n        .stdout_only(\"aGVsbG8sIHdvcmxkIQ==\\n\"); // spell-checker:disable-line\n\n    // Using '-' as our file\n    new_ucmd!()\n        .arg(\"-\")\n        .pipe_in(input)\n        .succeeds()\n        .stdout_only(\"aGVsbG8sIHdvcmxkIQ==\\n\"); // spell-checker:disable-line\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/iloop.rs::function_interrupt_from_afar", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn function_interrupt_from_afar() -> anyhow::Result<()> {\n    // Create an instance which calls an imported function on each iteration of\n    // the loop so we can count the number of loop iterations we've executed so\n    // far.\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    static STOP: AtomicBool = AtomicBool::new(false);\n\n    let mut store = interruptable_store();\n    let module = hugely_recursive_module(store.engine())?;\n    let func = Func::wrap(&mut store, || {\n        HITS.fetch_add(1, SeqCst);\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n\n    // Use the instance's interrupt handle to wait for it to enter the loop long\n    // enough and then we signal an interrupt happens.\n    let engine = store.engine().clone();\n    let thread = std::thread::spawn(move || {\n        while HITS.load(SeqCst) <= NUM_HITS && !STOP.load(SeqCst) {\n            // continue ...\n        }\n        engine.increment_epoch();\n    });\n\n    // Enter the infinitely looping function and assert that our interrupt\n    // handle does indeed actually interrupt the function.\n    let iloop = instance.get_typed_func::<(), ()>(&mut store, \"loop\")?;\n    let trap = iloop.call(&mut store, ()).unwrap_err().downcast::<Trap>()?;\n    STOP.store(true, SeqCst);\n    thread.join().unwrap();\n    assert!(HITS.load(SeqCst) > NUM_HITS);\n    assert_eq!(trap, Trap::Interrupt);\n    Ok(())\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::var_decl_hoisting_2_variables_hoisting_2", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn var_decl_hoisting_2_variables_hoisting_2() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var x = y;\n\n            var y = 5;\n            x;\n        \"#},\n        JsValue::undefined(),\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_early_apply.rs::test_follower_commit_early_apply", "code": "fn test_early_apply(mode: DataLost) {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    // So compact log will not be triggered automatically.\n    configure_for_request_snapshot(&mut cluster);\n    cluster.run();\n    if mode == DataLost::LeaderCommit || mode == DataLost::AllLost {\n        cluster.must_transfer_leader(1, new_peer(1, 1));\n    } else {\n        cluster.must_transfer_leader(1, new_peer(3, 3));\n    }\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    test(\n        &mut cluster,\n        |c| {\n            c.async_put(b\"k2\", b\"v2\").unwrap();\n        },\n        |c| must_get_equal(&c.get_engine(1), b\"k2\", b\"v2\"),\n        mode,\n    );\n    let region = cluster.get_region(b\"\");\n    test(\n        &mut cluster,\n        |c| {\n            c.split_region(&region, b\"k2\", Callback::None);\n        },\n        |c| c.wait_region_split(&region),\n        mode,\n    );\n    if mode != DataLost::LeaderCommit && mode != DataLost::AllLost {\n        test(\n            &mut cluster,\n            |c| {\n                c.async_remove_peer(1, new_peer(1, 1)).unwrap();\n            },\n            |c| must_get_none(&c.get_engine(1), b\"k2\"),\n            mode,\n        );\n    }\n}", "test": "fn test_follower_commit_early_apply() {\n    test_early_apply(DataLost::FollowerCommit)\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::invalid_unary_access", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn invalid_unary_access() {\n    run_test_actions([\n        TestAction::assert_native_error(\n            \"++[]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 1\",\n        ),\n        TestAction::assert_native_error(\n            \"[]++\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 3\",\n        ),\n        TestAction::assert_native_error(\n            \"--[]\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 1\",\n        ),\n        TestAction::assert_native_error(\n            \"[]--\",\n            JsNativeErrorKind::Syntax,\n            \"Invalid left-hand side in assignment at line 1, col 3\",\n        ),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_one_file_system", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_one_file_system() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(\"-x\").arg(SUB_DIR).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-x\", SUB_DIR]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_basics_subdir(result.stdout_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_subcommand_return_code", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_subcommand_return_code() {\n    new_ucmd!().arg(\"1\").arg(\"true\").succeeds();\n\n    new_ucmd!().arg(\"1\").arg(\"false\").run().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::om_73k_test_lazy_fullblock() {\n    ", "code": "pub fn wait(self) -> io::Result<CmdResult> {\n        let (bin_path, util_name, tmpd) = (\n            self.bin_path.clone(),\n            self.util_name.clone(),\n            self.tmpd.clone(),\n        );\n\n        #[allow(deprecated)]\n        let output = self.wait_with_output()?;\n\n        Ok(CmdResult {\n            bin_path,\n            util_name,\n            tmpd,\n            exit_status: Some(output.status),\n            stdout: output.stdout,\n            stderr: output.stderr,\n        })\n    }", "test": "andom_73k_test_lazy_fullblock() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkfifo(\"fifo\");\n    let child = ucmd\n        .args(&[\n            \"ibs=521\",\n            \"obs=1031\",\n            \"iflag=fullblock\",\n            \"if=fifo\",\n            \"status=noxfer\",\n        ])\n        .run_no_wait();\n    let data = at.read_bytes(\"random-5828891cb1230748e146f34223bbd3b5.test\");\n    {\n        let mut fifo = OpenOptions::new()\n            .write(true)\n            .open(at.plus(\"fifo\"))\n            .unwrap();\n        for chunk in data.chunks(521 / 2) {\n            fifo.write_all(chunk).unwrap();\n            sleep(Duration::from_millis(10));\n        }\n    }\n    child\n        .wait()\n        .unwrap()\n        .success()\n        .stdout_is_bytes(&data)\n        .stderr_is(\"142+1 records in\\n72+1 records out\\n\");\n}\n\n#[test]"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_split_region.rs::test_follower_slow_split", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_follower_slow_split() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run();\n    let region = cluster.get_region(b\"\");\n\n    // Only need peer 1 and 3. Stop node 2 to avoid extra vote messages.\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    cluster.stop_node(2);\n\n    // Use a channel to retrieve start_key and end_key in pre-vote messages.\n    let (range_tx, range_rx) = mpsc::channel();\n    let prevote_filter = PrevoteRangeFilter {\n        // Only send 1 pre-vote message to peer 3 so if peer 3 drops it,\n        // it needs to start a new election.\n        filter: RegionPacketFilter::new(1000, 1) // new region id is 1000\n            .msg_type(MessageType::MsgRequestPreVote)\n            .direction(Direction::Send)\n            .allow(1),\n        before: Some(Mutex::new(range_tx)),\n        after: None,\n    };\n    cluster\n        .sim\n        .wl()\n        .add_send_filter(1, Box::new(prevote_filter));\n\n    // Ensure pre-vote response is really sended.\n    let (tx, rx) = mpsc::channel();\n    let prevote_resp_notifier = Box::new(MessageTypeNotifier::new(\n        MessageType::MsgRequestPreVoteResponse,\n        tx,\n        Arc::from(AtomicBool::new(true)),\n    ));\n    cluster.sim.wl().add_send_filter(3, prevote_resp_notifier);\n\n    // After split, pre-vote message should be sent to peer 2.\n    fail::cfg(\"apply_before_split_1_3\", \"pause\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let range = range_rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    assert_eq!(range.0, b\"\");\n    assert_eq!(range.1, b\"k2\");\n\n    // After the follower split success, it will response to the pending vote.\n    fail::cfg(\"apply_before_split_1_3\", \"off\").unwrap();\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::is_empty", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "test": "fn is_empty() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert!(table.is_empty().unwrap());\n        table.insert(\"hello\", \"world\").unwrap();\n        assert!(!table.is_empty().unwrap());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert!(!table.is_empty().unwrap());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error64_test", "code": "fn compute_error64(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f64>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_error64(0, 9007199254740992), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 9007199254740993), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9007199254740994), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 9007199254740995), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 9007199254740996), (1065 + INVALID_FP, 9223372036854779904));\n    assert_eq!(compute_error64(0, 18014398509481984), (1066 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 18014398509481986), (1066 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 18014398509481988), (1066 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 18014398509481990), (1066 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 18014398509481992), (1066 + INVALID_FP, 9223372036854779904));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_error64(0, 9007199254740991), (1064 + INVALID_FP, 18446744073709549568));\n    assert_eq!(compute_error64(0, 9223372036854776831), (1075 + INVALID_FP, 9223372036854776830));\n    assert_eq!(compute_error64(0, 9223372036854776832), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9223372036854776833), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-42, 9123456727292927), (925 + INVALID_FP, 13021432563531497894));\n    assert_eq!(compute_error64(-43, 91234567272929275), (925 + INVALID_FP, 13021432563531498606));\n    assert_eq!(compute_error64(-42, 9123456727292928), (925 + INVALID_FP, 13021432563531499320));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error64(-3, 9007199254740992000), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(-3, 9007199254740993000), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-3, 9007199254740994000), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(-3, 9007199254740995000), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(-3, 9007199254740996000), (1065 + INVALID_FP, 9223372036854779904));\n\n    // Test from errors in atof.\n    assert_eq!(compute_error64(-18, 1000000178813934326), (1012 + INVALID_FP, 9223373686122217470));\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error64(-342, 2470328229206232720),\n        (-64 + INVALID_FP, 18446744073709551608)\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_rrset", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_delete_rrset() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .delete_rrset(record.clone(), origin.clone())\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .delete_rrset(record.clone(), origin)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/rayon-1.rs::decoding_in_fetched_global_pool", "code": "pub fn decode(&mut self) -> Result<Vec<u8>> {\n        WorkerScope::with(|worker| self.decode_internal(false, worker))\n    }", "test": "fn decoding_in_fetched_global_pool() {\n    let path = Path::new(\"tests\").join(\"reftest\").join(\"images\").join(\"mozilla\").join(\"jpg-progressive.jpg\");\n\n    rayon::ThreadPoolBuilder::new()\n        .num_threads(1)\n        .build_global()\n        .unwrap();\n\n    rayon::scope(|_| {\n        let mut decoder = Decoder::new(File::open(&path).unwrap());\n        let _ = decoder.decode().unwrap();\n    })\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_read_index_when_transfer_leader_2", "code": "pub fn has_stale_command(&self) -> bool {\n        self.stale_command.is_some()\n    }", "test": "fn test_read_index_when_transfer_leader_2() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    // Increase the election tick to make this test case running reliably.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    // Stop log compaction to transfer leader with filter easier.\n    configure_for_request_snapshot(&mut cluster);\n    let max_lease = Duration::from_secs(2);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n\n    // Add peer 2 and 3 and wait them to apply it.\n    cluster.pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.pd_client.must_add_peer(r1, new_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k0\", b\"v0\");\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n\n    // Put and test again to ensure that peer 3 get the latest writes by message\n    // append instead of snapshot, so that transfer leader to peer 3 can 100%\n    // success.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    let r1 = cluster.get_region(b\"k1\");\n    let old_leader = cluster.leader_of_region(r1.get_id()).unwrap();\n\n    // Use a macro instead of a closure to avoid any capture of local variables.\n    macro_rules! read_on_old_leader {\n        () => {{\n            let (tx, rx) = mpsc::sync_channel(1);\n            let mut read_request = new_request(\n                r1.get_id(),\n                r1.get_region_epoch().clone(),\n                vec![new_get_cmd(b\"k1\")],\n                true, // read quorum\n            );\n            read_request.mut_header().set_peer(new_peer(1, 1));\n            let sim = cluster.sim.wl();\n            sim.async_command_on_node(\n                old_leader.get_id(),\n                read_request,\n                Callback::read(Box::new(move |resp| tx.send(resp.response).unwrap())),\n            )\n            .unwrap();\n            rx\n        }};\n    }\n\n    // Delay all raft messages to peer 1.\n    let dropped_msgs = Arc::new(Mutex::new(Vec::new()));\n    let filter = Box::new(\n        RegionPacketFilter::new(r1.get_id(), old_leader.get_store_id())\n            .direction(Direction::Recv)\n            .skip(MessageType::MsgTransferLeader)\n            .when(Arc::new(AtomicBool::new(true)))\n            .reserve_dropped(Arc::clone(&dropped_msgs)),\n    );\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(old_leader.get_id(), filter);\n\n    let resp1 = read_on_old_leader!();\n\n    cluster.must_transfer_leader(r1.get_id(), new_peer(3, 3));\n\n    let resp2 = read_on_old_leader!();\n\n    // Unpark all pending messages and clear all filters.\n    let router = cluster.sim.wl().get_router(old_leader.get_id()).unwrap();\n    let mut reserved_msgs = Vec::new();\n    'LOOP: loop {\n        for raft_msg in std::mem::take(&mut *dropped_msgs.lock().unwrap()) {\n            let msg_type = raft_msg.get_message().get_msg_type();\n            if msg_type == MessageType::MsgHeartbeatResponse || msg_type == MessageType::MsgAppend {\n                reserved_msgs.push(raft_msg);\n                if msg_type == MessageType::MsgAppend {\n                    break 'LOOP;\n                }\n            }\n        }\n    }\n\n    // Resume reserved messages in one batch to make sure the old leader can get\n    // read and role change in one `Ready`.\n    fail::cfg(\"pause_on_peer_collect_message\", \"pause\").unwrap();\n    for raft_msg in reserved_msgs {\n        router.send_raft_message(raft_msg).unwrap();\n    }\n    fail::cfg(\"pause_on_peer_collect_message\", \"off\").unwrap();\n    cluster.sim.wl().clear_recv_filters(old_leader.get_id());\n\n    let resp1 = resp1.recv().unwrap();\n    assert!(resp1.get_header().get_error().has_stale_command());\n\n    // Response 2 should contains an error.\n    let resp2 = resp2.recv().unwrap();\n    assert!(resp2.get_header().get_error().has_stale_command());\n    drop(cluster);\n    fail::remove(\"pause_on_peer_collect_message\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_whitespace_with_byte", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_whitespace_with_byte() {\n    new_ucmd!()\n        .args(&[\"-w\", \"-b\", COMPLEX_SEQUENCE.sequence])\n        .fails()\n        .code_is(1);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_authority_target_on_extended_connect_request", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "test": "async fn reject_authority_target_on_extended_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"bread:80\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_line_length_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_line_length_chars() {\n    new_ucmd!()\n        .arg(\"-Lm\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"    442      48\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_carriage_return_overwritten_char_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_carriage_return_overwritten_char_should_be_preserved() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"x\\ry\")\n        .succeeds()\n        .stdout_is(\"x\\ry\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_no_deref_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_no_deref_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file1 = \"foo\";\n    let file2 = \"bar\";\n    let link = \"baz\";\n\n    at.touch(file1);\n    at.touch(file2);\n    scene\n        .ucmd()\n        .args(&[\"-s\", file2, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file2);\n\n    // try the normal behavior\n    scene\n        .ucmd()\n        .args(&[\"-sf\", file1, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(\"baz\"));\n    assert_eq!(at.resolve_link(\"baz\"), file1);\n\n    // Doesn't work without the force\n    scene.ucmd().args(&[\"-sn\", file1, link]).fails();\n\n    // Try with the no-deref\n    scene.ucmd().args(&[\"-sfn\", file1, link]).succeeds();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file1);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_basic", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_basic() {\n    let env = create_env();\n    let t = env.get_template(\"hello\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World!\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_version", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_version() {\n    new_ucmd!().arg(\"--version\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_long_no_args_files", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_long_no_args_files() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_simple_backup_file_a\";\n    let file_b = \"test_install_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_server_split_epoch_not_match_right_derive", "code": "fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n        .iter()\n        .map(|&k| pd_client.get_region(k).unwrap())\n        .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec![\n        // All regions should be returned as request uses an oldest epoch.\n        (get_old, regions.clone()),\n        // Only new split regions should be returned.\n        (get_middle, regions[1..].to_vec()),\n        // Epoch is too new that TiKV can't offer any useful hint.\n        (get_new, vec![regions[3].clone()]),\n    ];\n    if right_derive {\n        // TiKV search backward when right derive.\n        cases[0].1.reverse();\n        cases[1].1.reverse();\n    }\n    for (get, exp) in cases {\n        let resp = cluster\n            .call_command_on_leader(get.clone(), Duration::from_secs(5))\n            .unwrap();\n        assert!(resp.get_header().has_error(), \"{:?}\", get);\n        assert!(\n            resp.get_header().get_error().has_epoch_not_match(),\n            \"{:?}\",\n            get\n        );\n        assert_eq!(\n            resp.get_header()\n                .get_error()\n                .get_epoch_not_match()\n                .get_current_regions(),\n            &*exp,\n            \"{:?}\",\n            get\n        );\n    }\n}", "test": "fn test_server_split_epoch_not_match_right_derive() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_split_epoch_not_match(&mut cluster, true);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cli/tests/format.rs::force_exclude_stdin", "code": "fn path(&self) -> Option<&Path> {\n        match self {\n            Self::Ignore(err) => {\n                if let ignore::Error::WithPath { path, .. } = err {\n                    Some(path.as_path())\n                } else {\n                    None\n                }\n            }\n            Self::Panic(path, _)\n            | Self::Read(path, _)\n            | Self::Format(path, _)\n            | Self::Write(path, _)\n            | Self::Diff(path, _) => path.as_deref(),\n        }\n    }", "test": "fn force_exclude_stdin() -> Result<()> {\n    let tempdir = TempDir::new()?;\n    let ruff_toml = tempdir.path().join(\"ruff.toml\");\n    fs::write(\n        &ruff_toml,\n        r#\"\nextend-select = [\"B\", \"Q\"]\nignore = [\"Q000\", \"Q001\", \"Q002\", \"Q003\"]\n\n[format]\nexclude = [\"generated.py\"]\n\"#,\n    )?;\n\n    assert_cmd_snapshot!(Command::new(get_cargo_bin(BIN_NAME))\n        .current_dir(tempdir.path())\n        .args([\"format\", \"--config\", &ruff_toml.file_name().unwrap().to_string_lossy(), \"--stdin-filename\", \"generated.py\", \"--force-exclude\", \"-\"])\n        .pass_stdin(r#\"\nfrom test import say_hy\n\nif __name__ == '__main__':\n    say_hy(\"dear Ruff contributor\")\n\"#), @r###\"\n    success: true\n    exit_code: 0\n    ----- stdout -----\n\n    ----- stderr -----\n    \"###);\n    Ok(())\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::term_test", "code": "pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}", "test": "fn term_test() {\n  assert_eq!(\n    term(\" 3 *  5   \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"(3 * 5)\")))\n  );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/mod.rs::r#async", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn r#async() {\n    test_formatting(\n        r#\"\n            async function async_func(a, b) {\n                console.log(a);\n            }\n            async function async_func_2(a, b) {}\n            pass_async_func(async function(a, b) {\n                console.log(\"in async callback\", a);\n            });\n            pass_async_func(async function(a, b) {});\n            \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_empty_string", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_empty_string() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \"\"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        .stdout_is(\"a       b       c\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_goaway_with_debug_data", "code": "pub(crate) fn reason(&self) -> Reason {\n        self.reason\n    }", "test": "async fn read_goaway_with_debug_data() {\n    let mut codec = raw_codec! {\n        read => [\n            // head\n            0, 0, 22, 7, 0, 0, 0, 0, 0,\n            // last_stream_id\n            0, 0, 0, 1,\n            // error_code\n            0, 0, 0, 11,\n            // debug_data\n            \"too_many_pings\",\n        ];\n    };\n\n    let data = poll_frame!(GoAway, codec);\n    assert_eq!(data.reason(), Reason::ENHANCE_YOUR_CALM);\n    assert_eq!(data.last_stream_id(), 1);\n    assert_eq!(&**data.debug_data(), b\"too_many_pings\");\n\n    assert_closed!(codec);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_use_percentage", "code": "fn ceil(x: BigDecimal) -> BigInt {\n    if x.is_integer() {\n        // Unwrapping the Option because it always returns Some\n        x.to_bigint().unwrap()\n    } else {\n        (x + BigDecimal::one().half()).round(0).to_bigint().unwrap()\n    }\n}", "test": "fn test_use_percentage() {\n    let output = new_ucmd!()\n        .args(&[\"--total\", \"--output=used,avail,pcent\"])\n        .succeeds()\n        .stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    for line in lines {\n        let mut iter = line.split_whitespace();\n        let reported_used = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_avail = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_percentage = iter.next().unwrap();\n        let reported_percentage = reported_percentage[..reported_percentage.len() - 1]\n            .parse::<u8>()\n            .unwrap();\n        let computed_percentage =\n            (100.0 * (reported_used / (reported_used + reported_avail))).ceil() as u8;\n\n        assert_eq!(computed_percentage, reported_percentage);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_overwrite_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_overwrite_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_overwrite_dir_a\";\n    let dir_b = \"test_mv_overwrite_dir_b\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    ucmd.arg(\"-T\").arg(dir_a).arg(dir_b).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_exec_details", "code": "pub fn has_exec_details(&self) -> bool {\n        self.exec_details.is_some()\n    }", "test": "fn test_exec_details() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n\n    let flags = &[0];\n\n    let ctx = Context::default();\n    let req = DagSelect::from(&product).build_with(ctx, flags);\n    let resp = handle_request(&endpoint, req);\n    assert!(resp.has_exec_details());\n    let exec_details = resp.get_exec_details();\n    assert!(exec_details.has_time_detail());\n    assert!(exec_details.has_scan_detail());\n    assert!(resp.has_exec_details_v2());\n    let exec_details = resp.get_exec_details_v2();\n    assert!(exec_details.has_time_detail());\n    assert!(exec_details.has_time_detail_v2());\n    assert!(exec_details.has_scan_detail_v2());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_stdin", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_stdin() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-\", \"10\"])\n        .pipe_in(generate(1, 51))\n        .succeeds()\n        .stdout_only(\"18\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_fifo_error_reference_file_only", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_fifo_error_reference_file_only() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkfifo(\"fifo\");\n    at.make_file(\"reference_file\");\n    ucmd.args(&[\"-r\", \"reference_file\", \"fifo\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"cannot open 'fifo' for writing: No such device or address\");\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_test_caching_works_for_packages_with_versions", "code": "pub(crate) fn stderr(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDERR_FILENO)\n    }", "test": "fn run_test_caching_works_for_packages_with_versions() {\n    let wasmer_dir = TempDir::new().unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"/app/test.py\")\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .assert()\n        .success();\n\n    assert\n        .success()\n        .stderr(contains(\"wapm_source: Querying the GraphQL API\"))\n        .stderr(contains(\"builtin_loader: Downloading a webc file\"))\n        .stderr(contains(\"module_cache::filesystem: Saved to disk\"));\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"/app/test.py\")\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .assert();\n\n    assert\n        .success()\n        .stderr(contains(\"wapm_source: Cache hit!\"))\n        .stderr(contains(\"builtin_loader: Cache hit!\"))\n        .stderr(contains(\"module_cache::filesystem: Cache hit!\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_delete_lock_proposed_after_proposing_locks_2", "code": "fn test_delete_lock_proposed_after_proposing_locks_impl(transfer_msg_count: usize) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 20.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n        .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let mut req = CleanupRequest::default();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_region_epoch(cluster.get_region_epoch(region_id));\n    ctx.set_peer(leader);\n    req.set_context(ctx);\n    req.set_key(b\"key\".to_vec());\n    req.set_start_version(10);\n    req.set_current_ts(u64::MAX);\n\n    // Pause the command after it mark the lock as deleted.\n    fail::cfg(\"raftkv_async_write\", \"pause\").unwrap();\n    let (tx, resp_rx) = mpsc::channel();\n    thread::spawn(move || tx.send(client.kv_cleanup(&req).unwrap()).unwrap());\n\n    thread::sleep(Duration::from_millis(200));\n    resp_rx.try_recv().unwrap_err();\n\n    for _ in 0..transfer_msg_count {\n        cluster.transfer_leader(1, new_peer(2, 2));\n    }\n    thread::sleep(Duration::from_millis(200));\n\n    // Transfer leader will not make the command fail.\n    fail::remove(\"raftkv_async_write\");\n    let resp = resp_rx.recv().unwrap();\n    assert!(!resp.has_region_error());\n\n    for _ in 0..10 {\n        thread::sleep(Duration::from_millis(100));\n        cluster.reset_leader_of_region(region_id);\n        if cluster.leader_of_region(region_id).unwrap().id == 2 {\n            let snapshot = cluster.must_get_snapshot_of_region(1);\n            assert!(\n                snapshot\n                    .get_cf(CF_LOCK, &Key::from_raw(b\"key\"))\n                    .unwrap()\n                    .is_none()\n            );\n            return;\n        }\n    }\n    panic!(\"region should succeed to transfer leader to peer 2\");\n}", "test": "fn test_delete_lock_proposed_after_proposing_locks_2() {\n    // Repeated transfer leader command before proposing the write command\n    test_delete_lock_proposed_after_proposing_locks_impl(2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_bytes_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_bytes_lines() {\n    new_ucmd!()\n        .arg(\"-cl\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25     513\\n\");\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_std_io_write", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "test": "fn TinyVec_std_io_write() {\n  use std::io::Write;\n  let mut tv: TinyVec<[u8; 3]> = TinyVec::new();\n\n  tv.write_all(b\"foo\").ok();\n  assert!(tv.is_inline());\n  assert_eq!(tv, tiny_vec![b'f', b'o', b'o']);\n\n  tv.write_all(b\"bar\").ok();\n  assert!(tv.is_heap());\n  assert_eq!(tv, tiny_vec![b'f', b'o', b'o', b'b', b'a', b'r']);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_multiple_cname_additionals", "code": "pub fn message_type(&self) -> MessageType {\n        self.message_type\n    }", "test": "async fn test_multiple_cname_additionals() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::from_str(\"alias2.example.com.\").unwrap());\n    query.set_query_type(RecordType::A);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let answers: &[Record] = result.answers();\n    assert_eq!(answers.len(), 1);\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::CNAME);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"alias.example.com.\").unwrap()))\n    );\n\n    // we should have the intermediate record\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(\n        additionals.first().unwrap().record_type(),\n        RecordType::CNAME\n    );\n    assert_eq!(\n        additionals.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"www.example.com.\").unwrap()))\n    );\n\n    // final record should be the actual\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(additionals.last().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        additionals.last().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_out_of_range_index", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_out_of_range_index() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[10] }}\")]).unwrap();\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `arr[10]` not found in context while rendering \\'tpl\\': the evaluated version was `arr.10`. Maybe the index is out of bounds?\"\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::empty_statement", "code": "pub fn get_or_intern_static(&mut self, utf8: &'static str, utf16: &'static [u16]) -> Sym {\n        // Uses the utf8 because it's quicker to check inside `COMMON_STRINGS_UTF8`\n        // (which is a perfect hash set) than to check inside `COMMON_STRINGS_UTF16`\n        // (which is a lazy static hash set).\n        self.get(utf8).unwrap_or_else(|| {\n            let index = self.utf8_interner.intern(utf8.as_bytes());\n            let utf16_index = self.utf16_interner.intern(utf16);\n\n            // Just to check everything is okay\n            debug_assert_eq!(index, utf16_index);\n\n            index\n                .checked_add(1 + COMMON_STRINGS_UTF8.len())\n                .and_then(Sym::new)\n                .expect(\"Cannot intern new string: integer overflow\")\n        })\n    }", "test": "fn empty_statement() {\n    let interner = &mut Interner::default();\n    let a = interner.get_or_intern_static(\"a\", utf16!(\"a\"));\n    check_script_parser(\n        r\"\n            ;;var a = 10;\n            if(a) ;\n        \",\n        vec![\n            Statement::Empty.into(),\n            Statement::Empty.into(),\n            Statement::Var(VarDeclaration(\n                vec![Variable::from_identifier(\n                    a.into(),\n                    Some(Literal::from(10).into()),\n                )]\n                .try_into()\n                .unwrap(),\n            ))\n            .into(),\n            Statement::If(If::new(Identifier::new(a).into(), Statement::Empty, None)).into(),\n        ],\n        interner,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nproc.rs::test_nproc_ignore_all_omp", "code": "fn parse(s: &str) -> Result<usize, &'static str> {\n            match s.parse::<usize>() {\n                Ok(0) => Err(\"fields and positions are numbered from 1\"),\n                // GNU fails when we are at the limit. Match their behavior\n                Ok(n) if n == usize::MAX => Err(\"byte/character offset is too large\"),\n                Ok(n) => Ok(n),\n                Err(_) => Err(\"failed to parse range\"),\n            }\n        }", "test": "fn test_nproc_ignore_all_omp() {\n    let result = TestScenario::new(util_name!())\n        .ucmd()\n        .env(\"OMP_NUM_THREADS\", \"42\")\n        .arg(\"--ignore=40\")\n        .succeeds();\n    let nproc: u8 = result.stdout_str().trim().parse().unwrap();\n    assert_eq!(nproc, 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_replace_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_replace_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_replace_file_a\";\n    let file_b = \"test_mv_replace_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a).arg(file_b).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_post_handshake", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn client_respects_buffer_limit_post_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    do_handshake(&mut client, &mut server);\n    client.set_buffer_limit(Some(48));\n\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        6\n    );\n\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_else", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_else() {\n    assert_err_msg(\n        r#\"\n{% if true %}\n{% else %}\n{% else %}\n{% endif %}\n    \"#,\n        &[\"4:1\", \"unexpected tag; expected an endif tag (`{% endif %}`) or some content\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_short_octal", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_short_octal() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\040bar\"])\n        .succeeds()\n        .stdout_only(\"foo bar\\n\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::floor_log5_pow2_minus_log5_3_test", "code": "fn dragonbox_log5_2_sub_log5_3(q: i32) -> i32 {\n    let c = floor_shift(0, 0x6e40d1a4143dcb94, 20);\n    let s = floor_shift(0, 0xaebf47915d443b24, 20);\n    (q * c - s) >> 20\n}", "test": "fn floor_log5_pow2_minus_log5_3_test() {\n    for q in -2427i32..=2427 {\n        let actual = algorithm::floor_log5_pow2_minus_log5_3(q);\n        let expected = dragonbox_log5_2_sub_log5_3(q);\n        assert_eq!(actual, expected);\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake_with_vectored_write", "code": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self\n            .conn\n            .writer()\n            .write_vectored(bufs)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_respects_buffer_limit_pre_handshake_with_vectored_write() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write_vectored(&[\n                IoSlice::new(b\"01234567890123456789\"),\n                IoSlice::new(b\"01234567890123456789\")\n            ])\n            .unwrap(),\n        32\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/tests.rs::test_normalization_tests_unaffected", "code": "fn stream_safe(s: &str) -> String {\n        StreamSafe::new(s.chars()).collect()\n    }", "test": "fn test_normalization_tests_unaffected() {\n    for test in NORMALIZATION_TESTS {\n        for &s in &[test.source, test.nfc, test.nfd, test.nfkc, test.nfkd] {\n            assert_eq!(stream_safe(s), s);\n        }\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_ceil_number", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_ceil_number() {\n    verified_stmt(\"SELECT CEIL(1.5)\");\n    verified_stmt(\"SELECT CEIL(float_column) FROM my_table\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::builder_test", "code": "pub const fn get_max_significant_digits(&self) -> OptionUsize {\n        self.max_significant_digits\n    }", "test": "fn builder_test() {\n    let mut builder = OptionsBuilder::default();\n\n    builder = builder.max_significant_digits(num::NonZeroUsize::new(10));\n    builder = builder.min_significant_digits(num::NonZeroUsize::new(5));\n    builder = builder.positive_exponent_break(num::NonZeroI32::new(9));\n    builder = builder.negative_exponent_break(num::NonZeroI32::new(-9));\n    builder = builder.round_mode(options::RoundMode::Truncate);\n    builder = builder.trim_floats(true);\n    builder = builder.exponent(b'^');\n    builder = builder.decimal_point(b',');\n    builder = builder.nan_string(Some(b\"nan\"));\n    builder = builder.inf_string(Some(b\"Infinity\"));\n\n    assert_eq!(builder.get_max_significant_digits().unwrap().get(), 10);\n    assert_eq!(builder.get_min_significant_digits().unwrap().get(), 5);\n    assert_eq!(builder.get_positive_exponent_break().unwrap().get(), 9);\n    assert_eq!(builder.get_negative_exponent_break().unwrap().get(), -9);\n    assert_eq!(builder.get_round_mode(), options::RoundMode::Truncate);\n    assert_eq!(builder.get_trim_floats(), true);\n    assert_eq!(builder.get_exponent(), b'^');\n    assert_eq!(builder.get_decimal_point(), b',');\n    assert_eq!(builder.get_nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(builder.get_inf_string(), Some(\"Infinity\".as_bytes()));\n\n    assert!(builder.is_valid());\n    assert_eq!(builder.build(), Ok(unsafe { builder.build_unchecked() }));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_joint_replace_peers", "code": "pub fn must_leave_joint(&self, region_id: u64) {\n        self.leave_joint(region_id);\n        self.must_not_in_joint(region_id);\n    }", "test": "fn test_joint_replace_peers() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.allow_remove_leader = false;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Replace peers\n    // Enter joint, now we have C_old(1, 2, 3) and C_new(1, 2, 4)\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(3, 3)),\n            (ConfChangeType::AddNode, new_peer(4, 4)),\n        ],\n    );\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n\n    // Isolated node 3 and node 4\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    cluster.add_send_filter(IsolationFilterFactory::new(4));\n\n    // Request can be handle as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n    must_get_none(&cluster.get_engine(3), b\"k2\");\n    must_get_none(&cluster.get_engine(4), b\"k2\");\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(4), b\"k2\", b\"v2\");\n\n    // Replace leader\n    // Enter joint, now we have C_old(1, 2, 4) and C_new(2, 4, 5)\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(1, 1)),\n            (ConfChangeType::AddNode, new_peer(5, 5)),\n        ],\n    );\n    {\n        // The leader now is DemotingVoter\n        let mut peer = new_peer(1, 1);\n        peer.set_role(PeerRole::DemotingVoter);\n        pd_client.region_leader_must_be(region_id, peer);\n    }\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(5), b\"k3\", b\"v3\");\n\n    cluster.must_transfer_leader(region_id, new_peer(5, 5));\n\n    cluster.must_put(b\"k4\", b\"v4\");\n    for id in 1..=5 {\n        must_get_equal(&cluster.get_engine(id), b\"k4\", b\"v4\");\n    }\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_hex_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--hex-suffixes=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/split_check.rs::test_update_split_check_config", "code": "pub fn stop(&mut self) {\n        if let Some(h) = self.handle.take() {\n            drop(self.timer.take());\n            drop(self.read_stats_sender.take());\n            drop(self.cpu_stats_sender.take());\n            if let Err(e) = h.join() {\n                error!(\"join stats collector failed\"; \"err\" => ?e);\n            }\n        }\n    }", "test": "fn test_update_split_check_config() {\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let engine = tmp_engine(&cfg.storage.data_dir);\n    let (cfg_controller, mut worker) = setup(cfg.clone(), engine);\n    let scheduler = worker.scheduler();\n\n    let cop_config = cfg.coprocessor.clone();\n    // update of other module's config should not effect split check config\n    cfg_controller\n        .update_config(\"raftstore.raft-log-gc-threshold\", \"2000\")\n        .unwrap();\n    validate(&scheduler, move |cfg: &Config| {\n        assert_eq!(cfg, &cop_config);\n    });\n\n    let change = {\n        let mut m = std::collections::HashMap::new();\n        m.insert(\n            \"coprocessor.split_region_on_table\".to_owned(),\n            \"true\".to_owned(),\n        );\n        m.insert(\"coprocessor.batch_split_limit\".to_owned(), \"123\".to_owned());\n        m.insert(\n            \"coprocessor.region_split_keys\".to_owned(),\n            \"12345\".to_owned(),\n        );\n        m\n    };\n    cfg_controller.update(change).unwrap();\n\n    // config should be updated\n    let cop_config = {\n        let mut cop_config = cfg.coprocessor;\n        cop_config.split_region_on_table = true;\n        cop_config.batch_split_limit = 123;\n        cop_config.region_split_keys = Some(12345);\n        cop_config\n    };\n    validate(&scheduler, move |cfg: &Config| {\n        assert_eq!(cfg, &cop_config);\n    });\n\n    worker.stop();\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_single_quote_mixed", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn test_closing_bracket_in_single_quote_mixed() {\n    let mut r = Reader::from_str(r#\"<a attr='\">\"' check='\"2\"'></a>\"#);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(br#\"\">\"\"#),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(br#\"\"2\"\"#),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_flashback", "code": "pub fn get_type(&self) -> JsonType {\n        self.type_code\n    }", "test": "fn test_flashback() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.cfg.resolved_ts.advance_ts_interval = ReadableDuration::millis(50);\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let key = Key::from_raw(b\"a\");\n    let region = suite.cluster.get_region(key.as_encoded());\n    let region_id = region.get_id();\n    let req = suite.new_changedata_request(region_id);\n    let (mut req_tx, _, receive_event) = new_event_feed(suite.get_region_cdc_client(region_id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let event = receive_event(false);\n    event.events.into_iter().for_each(|e| {\n        match e.event.unwrap() {\n            // Even if there is no write,\n            // it should always outputs an Initialized event.\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        }\n    });\n    // Sleep a while to make sure the stream is registered.\n    sleep_ms(1000);\n    let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    for i in 0..2 {\n        let (k, v) = (\n            format!(\"key{}\", i).as_bytes().to_vec(),\n            format!(\"value{}\", i).as_bytes().to_vec(),\n        );\n        // Prewrite\n        let start_ts1 = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.key = k.clone();\n        mutation.value = v;\n        suite.must_kv_prewrite(1, vec![mutation], k.clone(), start_ts1);\n        // Commit\n        let commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n        suite.must_kv_commit(1, vec![k.clone()], start_ts1, commit_ts);\n    }\n    let (start_key, end_key) = (b\"key0\".to_vec(), b\"key2\".to_vec());\n    // Prepare flashback.\n    let flashback_start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.must_kv_prepare_flashback(region_id, &start_key, &end_key, flashback_start_ts);\n    // resolved ts should not be advanced anymore.\n    let mut counter = 0;\n    let mut last_resolved_ts = 0;\n    loop {\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            if resolved_ts.ts == last_resolved_ts {\n                counter += 1;\n            }\n            last_resolved_ts = resolved_ts.ts;\n        }\n        if counter > 20 {\n            break;\n        }\n        sleep_ms(50);\n    }\n    // Flashback.\n    let flashback_commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.must_kv_flashback(\n        region_id,\n        &start_key,\n        &end_key,\n        flashback_start_ts,\n        flashback_commit_ts,\n        start_ts,\n    );\n    // Check the flashback event.\n    let mut resolved_ts = 0;\n    let mut event_counter = 0;\n    loop {\n        let mut cde = receive_event(true);\n        if cde.get_resolved_ts().get_ts() > resolved_ts {\n            resolved_ts = cde.get_resolved_ts().get_ts();\n        }\n        let events = cde.mut_events();\n        if !events.is_empty() {\n            assert_eq!(events.len(), 1);\n            match events.pop().unwrap().event.unwrap() {\n                Event_oneof_event::Entries(entries) => {\n                    assert_eq!(entries.entries.len(), 1);\n                    event_counter += 1;\n                    let e = &entries.entries[0];\n                    assert!(e.commit_ts > resolved_ts);\n                    assert_eq!(e.get_op_type(), EventRowOpType::Delete);\n                    match e.get_type() {\n                        EventLogType::Committed => {\n                            // First entry should be a 1PC flashback.\n                            assert_eq!(e.get_key(), b\"key1\");\n                            assert_eq!(event_counter, 1);\n                        }\n                        EventLogType::Commit => {\n                            // Second entry should be a 2PC commit.\n                            assert_eq!(e.get_key(), b\"key0\");\n                            assert_eq!(event_counter, 2);\n                            break;\n                        }\n                        _ => panic!(\"unknown event type {:?}\", e.get_type()),\n                    }\n                }\n                other => panic!(\"unknown event {:?}\", other),\n            }\n        }\n    }\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/issues.rs::take_till_issue", "code": "fn nothing(i: &[u8]) -> IResult<&[u8], &[u8]> {\n    take_till(|_| true)(i)\n  }", "test": "fn take_till_issue() {\n  use nom::bytes::streaming::take_till;\n\n  fn nothing(i: &[u8]) -> IResult<&[u8], &[u8]> {\n    take_till(|_| true)(i)\n  }\n\n  assert_eq!(nothing(b\"\"), Err(Err::Incomplete(Needed::new(1))));\n  assert_eq!(nothing(b\"abc\"), Ok((&b\"abc\"[..], &b\"\"[..])));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_string_length_of_nothing", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_string_length_of_nothing() {\n    // odd but matches GNU, which must interpret -n as a literal here\n    new_ucmd!().arg(\"-n\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tac.rs::test_invalid_input", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_invalid_input() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    scene\n        .ucmd()\n        .arg(\"b\")\n        .fails()\n        .stderr_contains(\"failed to open 'b' for reading: No such file or directory\");\n\n    at.mkdir(\"a\");\n    scene\n        .ucmd()\n        .arg(\"a\")\n        .fails()\n        .stderr_contains(\"a: read error: Invalid argument\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::bit_length_test", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "test": "fn bit_length_test() {\n    let x = Bigint {\n        data: from_u32(&[0, 0, 0, 1]),\n    };\n    assert_eq!(x.bit_length(), 97);\n\n    let x = Bigint {\n        data: from_u32(&[0, 0, 0, 3]),\n    };\n    assert_eq!(x.bit_length(), 98);\n\n    let x = Bigint {\n        data: from_u32(&[1 << 31]),\n    };\n    assert_eq!(x.bit_length(), 32);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_reference_file_not_found", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_reference_file_not_found() {\n    new_ucmd!()\n        .args(&[\"-r\", \"a\", \"b\"])\n        .fails()\n        .stderr_contains(\"cannot stat 'a': No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_wrap_no_arg", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_wrap_no_arg() {\n    for wrap_param in [\"-w\", \"--wrap\"] {\n        new_ucmd!()\n            .arg(wrap_param)\n            .fails()\n            .stderr_contains(\"a value is required for '--wrap <COLS>' but none was supplied\")\n            .no_stdout();\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_stream_write", "code": "fn test_server_stream_write(stream_kind: StreamKind) {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n        let data = b\"hello\";\n        {\n            let mut pipe = OtherSession::new(&mut client);\n            let mut stream: Box<dyn Write> = match stream_kind {\n                StreamKind::Ref => Box::new(Stream::new(&mut server, &mut pipe)),\n                StreamKind::Owned => Box::new(StreamOwned::new(server, pipe)),\n            };\n            assert_eq!(stream.write(data).unwrap(), 5);\n        }\n        check_read(&mut client.reader(), data);\n    }\n}", "test": "fn server_stream_write() {\n    test_server_stream_write(StreamKind::Ref);\n    test_server_stream_write(StreamKind::Owned);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::nth_bit_test", "code": "pub(crate) fn nth_bit(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n < bits, \"nth_bit() overflow in shl.\");\n\n    1 << n\n}", "test": "fn nth_bit_test() {\n    assert_eq!(nth_bit(0u64), 0b1);\n    assert_eq!(nth_bit(1u64), 0b10);\n    assert_eq!(nth_bit(2u64), 0b100);\n    assert_eq!(nth_bit(10u64), 0b10000000000);\n    assert_eq!(nth_bit(31u64), 0b10000000000000000000000000000000);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::wrong_types", "code": "pub fn open_multimap_table<'txn, K: RedbKey + 'static, V: RedbKey + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: MultimapTableDefinition<K, V>,\n    ) -> Result<MultimapTable<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening multimap table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Multimap)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(MultimapTable::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn wrong_types() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: MultimapTableDefinition<u32, u32> = MultimapTableDefinition::new(\"x\");\n    let wrong_definition: MultimapTableDefinition<u64, u64> = MultimapTableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    txn.open_multimap_table(definition).unwrap();\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    assert!(matches!(\n        txn.open_multimap_table(wrong_definition),\n        Err(TableError::TableTypeMismatch { .. })\n    ));\n    txn.abort().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    txn.open_multimap_table(definition).unwrap();\n    assert!(matches!(\n        txn.open_multimap_table(wrong_definition),\n        Err(TableError::TableTypeMismatch { .. })\n    ));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_14", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_14() {\n    let original = r##\"# H1 { #id1 } foo\n## H2 {#id2} <!-- hello -->\n\"##;\n    let expected = r##\"<h1>H1 { #id1 } foo</h1>\n<h2>H2 {#id2} <!-- hello --></h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_sf_derived_table_in_parenthesis", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn test_sf_derived_table_in_parenthesis() {\n    // Nesting a subquery in an extra set of parentheses is non-standard,\n    // but supported in Snowflake SQL\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM ((SELECT 1) AS t)\",\n        \"SELECT * FROM (SELECT 1) AS t\",\n    );\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (((SELECT 1) AS t))\",\n        \"SELECT * FROM (SELECT 1) AS t\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_relative() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_symlink_relative_a\";\n    let link = \"test_symlink_relative_link\";\n\n    at.touch(file_a);\n\n    // relative symlink\n    ucmd.args(&[\"-r\", \"-s\", file_a, link]).succeeds();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_a);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::var_decl_hoisting_simple", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn var_decl_hoisting_simple() {\n    run_test_actions([TestAction::assert_eq(\"x = 5; var x; x\", 5)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_equalize_widths", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_equalize_widths() {\n    let args = [\"-w\", \"--equal-width\"];\n    for arg in args {\n        new_ucmd!()\n            .args(&[arg, \"5\", \"10\"])\n            .run()\n            .stdout_is(\"05\\n06\\n07\\n08\\n09\\n10\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_check_md5sum_mixed_format", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_check_md5sum_mixed_format() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    #[cfg(not(windows))]\n    {\n        for f in &[\" b\", \"*c\", \"dd\", \" \"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"bf35d7536c785cf06730d5a40301eba2  b\\n\\\n             f5b61709718c1ecf8db1aea8547d4698 *c\\n\\\n             b064a020db8018f18ff5ae367d01b212 dd\\n\\\n             d784fa8b6d98d27699781bd9a7cf19f0  \",\n        );\n    }\n    #[cfg(windows)]\n    {\n        for f in &[\" b\", \"dd\"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"bf35d7536c785cf06730d5a40301eba2  b\\n\\\n             b064a020db8018f18ff5ae367d01b212 dd\",\n        );\n    }\n    scene\n        .ccmd(\"md5sum\")\n        .arg(\"--strict\")\n        .arg(\"-c\")\n        .arg(\"check.md5sum\")\n        .fails()\n        .code_is(1);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::new_server_returns_initial_io_state", "code": "pub fn plaintext_bytes_to_read(&self) -> usize {\n        self.plaintext_bytes_to_read\n    }", "test": "fn new_server_returns_initial_io_state() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    let io_state = server.process_new_packets().unwrap();\n    println!(\"IoState is Debug {:?}\", io_state);\n    assert_eq!(io_state.plaintext_bytes_to_read(), 0);\n    assert!(!io_state.peer_has_closed());\n    assert_eq!(io_state.tls_bytes_to_write(), 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_async_apply_prewrite", "code": "fn test_async_apply_prewrite_impl<E: Engine, F: KvFormat>(\n    storage: &Storage<E, MockLockManager, F>,\n    ctx: Context,\n    key: &[u8],\n    value: &[u8],\n    start_ts: u64,\n    commit_ts: Option<u64>,\n    is_pessimistic: bool,\n    need_lock: bool,\n    use_async_commit: bool,\n    expect_async_apply: bool,\n) {\n    let on_handle_apply = \"on_handle_apply\";\n\n    let start_ts = TimeStamp::from(start_ts);\n\n    // Acquire the pessimistic lock if needed\n    if need_lock {\n        let (tx, rx) = channel();\n        storage\n            .sched_txn_command(\n                commands::AcquirePessimisticLock::new(\n                    vec![(Key::from_raw(key), false)],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    true,\n                    start_ts,\n                    None,\n                    false,\n                    0.into(),\n                    false,\n                    false,\n                    false,\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n        rx.recv_timeout(Duration::from_secs(5))\n            .unwrap()\n            .unwrap()\n            .unwrap();\n    }\n\n    // Prewrite and block it at apply phase.\n    fail::cfg(on_handle_apply, \"pause\").unwrap();\n    let (tx, rx) = channel();\n    let secondaries = if use_async_commit { Some(vec![]) } else { None };\n    if !is_pessimistic {\n        storage\n            .sched_txn_command(\n                commands::Prewrite::new(\n                    vec![Mutation::make_put(Key::from_raw(key), value.to_vec())],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    false,\n                    1,\n                    0.into(),\n                    0.into(),\n                    secondaries,\n                    false,\n                    AssertionLevel::Off,\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n    } else {\n        storage\n            .sched_txn_command(\n                commands::PrewritePessimistic::new(\n                    vec![(\n                        Mutation::make_put(Key::from_raw(key), value.to_vec()),\n                        if need_lock {\n                            DoPessimisticCheck\n                        } else {\n                            SkipPessimisticCheck\n                        },\n                    )],\n                    key.to_vec(),\n                    start_ts,\n                    0,\n                    start_ts,\n                    1,\n                    0.into(),\n                    0.into(),\n                    secondaries,\n                    false,\n                    AssertionLevel::Off,\n                    vec![],\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n    }\n\n    if expect_async_apply {\n        // The result should be able to be returned.\n        let res = rx.recv_timeout(Duration::from_secs(5)).unwrap().unwrap();\n        assert_eq!(res.locks.len(), 0);\n        assert!(use_async_commit);\n        assert!(commit_ts.is_none());\n        let min_commit_ts = res.min_commit_ts;\n        assert!(\n            min_commit_ts > start_ts,\n            \"min_commit_ts({}) not greater than start_ts({})\",\n            min_commit_ts,\n            start_ts\n        );\n\n        // The memory lock is not released so reading will encounter the lock.\n        thread::sleep(Duration::from_millis(300));\n        let err = block_on(storage.get(ctx.clone(), Key::from_raw(key), min_commit_ts.next()))\n            .unwrap_err();\n        expect_locked(err, key, start_ts);\n        // Commit command will be blocked.\n        let (tx, rx) = channel();\n        storage\n            .sched_txn_command(\n                commands::Commit::new(\n                    vec![Key::from_raw(key)],\n                    start_ts,\n                    min_commit_ts,\n                    ctx.clone(),\n                ),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n        assert_eq!(\n            rx.recv_timeout(Duration::from_millis(300)).unwrap_err(),\n            RecvTimeoutError::Timeout\n        );\n\n        // Continue applying and then the commit command can continue.\n        fail::remove(on_handle_apply);\n        rx.recv_timeout(Duration::from_secs(5)).unwrap().unwrap();\n\n        let got_value = block_on(storage.get(ctx, Key::from_raw(key), min_commit_ts.next()))\n            .unwrap()\n            .0;\n        assert_eq!(got_value.unwrap().as_slice(), value);\n    } else {\n        assert_eq!(\n            rx.recv_timeout(Duration::from_millis(300)).unwrap_err(),\n            RecvTimeoutError::Timeout\n        );\n\n        fail::remove(on_handle_apply);\n        let res = rx.recv_timeout(Duration::from_secs(5)).unwrap().unwrap();\n        assert_eq!(res.locks.len(), 0);\n        assert_eq!(res.min_commit_ts, 0.into());\n\n        // Commit it.\n        let commit_ts = commit_ts.unwrap().into();\n        let (tx, rx) = channel();\n        storage\n            .sched_txn_command(\n                commands::Commit::new(vec![Key::from_raw(key)], start_ts, commit_ts, ctx.clone()),\n                Box::new(move |r| tx.send(r).unwrap()),\n            )\n            .unwrap();\n        rx.recv_timeout(Duration::from_secs(5)).unwrap().unwrap();\n\n        let got_value = block_on(storage.get(ctx, Key::from_raw(key), commit_ts.next()))\n            .unwrap()\n            .0;\n        assert_eq!(got_value.unwrap().as_slice(), value);\n    }\n}", "test": "fn test_async_apply_prewrite() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster\n        .sim\n        .read()\n        .unwrap()\n        .storages\n        .get(&1)\n        .unwrap()\n        .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .async_apply_prewrite(true)\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx.clone(),\n        b\"key\",\n        b\"value1\",\n        10,\n        None,\n        false,\n        false,\n        true,\n        true,\n    );\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx.clone(),\n        b\"key\",\n        b\"value2\",\n        20,\n        None,\n        true,\n        false,\n        true,\n        true,\n    );\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx.clone(),\n        b\"key\",\n        b\"value3\",\n        30,\n        None,\n        true,\n        true,\n        true,\n        true,\n    );\n\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx.clone(),\n        b\"key\",\n        b\"value1\",\n        40,\n        Some(45),\n        false,\n        false,\n        false,\n        false,\n    );\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx.clone(),\n        b\"key\",\n        b\"value2\",\n        50,\n        Some(55),\n        true,\n        false,\n        false,\n        false,\n    );\n    test_async_apply_prewrite_impl(\n        &storage,\n        ctx,\n        b\"key\",\n        b\"value3\",\n        60,\n        Some(65),\n        true,\n        true,\n        false,\n        false,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_count_up_floats", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_count_up_floats() {\n    new_ucmd!()\n        .args(&[\"10.0\"])\n        .run()\n        .stdout_is(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_get_tombstone_stores", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_get_tombstone_stores() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let client = new_client(eps, None);\n\n    let mut all_stores = vec![];\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    client.bootstrap_cluster(store.clone(), region).unwrap();\n\n    all_stores.push(store);\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n    let s = client.get_all_stores(false).unwrap();\n    assert_eq!(s, all_stores);\n\n    // Add tombstone store.\n    let mut store99 = metapb::Store::default();\n    store99.set_id(99);\n    store99.set_state(metapb::StoreState::Tombstone);\n    server.default_handler().add_store(store99.clone());\n\n    // do not include tombstone.\n    let s = client.get_all_stores(true).unwrap();\n    assert_eq!(s, all_stores);\n\n    all_stores.push(store99.clone());\n    all_stores.sort_by_key(|a| a.get_id());\n    // include tombstone, there should be 2 stores.\n    let mut s = client.get_all_stores(false).unwrap();\n    s.sort_by_key(|a| a.get_id());\n    assert_eq!(s, all_stores);\n\n    // Add another tombstone store.\n    let mut store199 = store99;\n    store199.set_id(199);\n    server.default_handler().add_store(store199.clone());\n\n    all_stores.push(store199);\n    all_stores.sort_by_key(|a| a.get_id());\n    let mut s = client.get_all_stores(false).unwrap();\n    s.sort_by_key(|a| a.get_id());\n    assert_eq!(s, all_stores);\n\n    client.get_store(store_id).unwrap();\n    client.get_store(99).unwrap_err();\n    client.get_store(199).unwrap_err();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_combined_shorts_tailing_suffix_length", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_obs_lines_within_combined_shorts_tailing_suffix_length() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-combined-shorts-tailing-suffix-length\";\n    RandomFile::new(&at, name).add_lines(1000);\n    ucmd.args(&[\"-d200a4\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x\\d\\d\\d\\d$\");\n    assert_eq!(glob.count(), 5);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_final_newline_when_line_longer_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_final_newline_when_line_longer_than_fold() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"1234\\n\")\n        .succeeds()\n        .stdout_is(\"12\\n34\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_hex_suffix_no_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_short_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"-x\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x0a\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x0b\"), \"99\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/equals.rs::alias_recipe", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn alias_recipe() {\n  Test::new()\n    .justfile(\n      \"\n      alias foo='bar':\n        echo {{foo}}\n    \",\n    )\n    .stdout(\"bar\\n\")\n    .stderr(\"echo bar\\n\")\n    .run();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::as_primitive_test", "code": "fn as_primitive<T: num::AsPrimitive>(t: T) {\n    let _: u8 = t.as_u8();\n    let _: u16 = t.as_u16();\n    let _: u32 = t.as_u32();\n    let _: u64 = t.as_u64();\n    let _: u128 = t.as_u128();\n    let _: usize = t.as_usize();\n    let _: i8 = t.as_i8();\n    let _: i16 = t.as_i16();\n    let _: i32 = t.as_i32();\n    let _: i64 = t.as_i64();\n    let _: i128 = t.as_i128();\n    let _: isize = t.as_isize();\n    let _: f32 = t.as_f32();\n    let _: f64 = t.as_f64();\n}", "test": "fn as_primitive_test() {\n    as_primitive(1u8);\n    as_primitive(1u16);\n    as_primitive(1u32);\n    as_primitive(1u64);\n    as_primitive(1u128);\n    as_primitive(1usize);\n    as_primitive(1i8);\n    as_primitive(1i16);\n    as_primitive(1i32);\n    as_primitive(1i64);\n    as_primitive(1i128);\n    as_primitive(1isize);\n    as_primitive(1f32);\n    as_primitive(1f64);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_exclusive_option", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_exclusive_option() {\n    new_ucmd!()\n        .arg(\"-bp\")\n        .fails()\n        .stderr_contains(\"mutually exclusive\");\n    new_ucmd!()\n        .arg(\"-cp\")\n        .fails()\n        .stderr_contains(\"mutually exclusive\");\n    new_ucmd!()\n        .args(&[\"-b\", \"--print-ls-colors\"])\n        .fails()\n        .stderr_contains(\"mutually exclusive\");\n    new_ucmd!()\n        .args(&[\"-c\", \"--print-ls-colors\"])\n        .fails()\n        .stderr_contains(\"mutually exclusive\");\n    new_ucmd!()\n        .args(&[\"-p\", \"--print-ls-colors\"])\n        .fails()\n        .stderr_contains(\"mutually exclusive\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit126_wasi_snapshot0", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit126_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit126_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 1);\n    assert!(output.stdout.is_empty());\n    assert!(String::from_utf8_lossy(&output.stderr).contains(\"invalid exit status\"));\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_stale_learner_with_read_index", "code": "pub fn get_state(&self) -> Arc<AtomicCell<DownstreamState>> {\n        self.state.clone()\n    }", "test": "fn test_stale_learner_with_read_index() {\n    let mut cluster = new_server_cluster(0, 4);\n    // Do not rely on pd to remove stale peer\n    cluster.cfg.raft_store.max_leader_missing_duration = ReadableDuration::hours(2);\n    cluster.cfg.raft_store.abnormal_leader_missing_duration = ReadableDuration::minutes(20);\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration::minutes(10);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_learner_peer(3, 3));\n    cluster.must_put(b\"k1\", b\"v1\");\n    let engine3 = cluster.get_engine(3);\n    must_get_equal(&engine3, b\"k1\", b\"v1\");\n\n    // And then isolate peer on store 3 from leader\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    // Delete the learner\n    pd_client.must_remove_peer(r1, new_learner_peer(3, 3));\n\n    cluster.clear_send_filters();\n\n    // Stale learner should exist\n    must_get_equal(&engine3, b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_get_cf_cmd(\"default\", b\"k1\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(3, 3));\n    request.mut_header().set_replica_read(true);\n    let (cb, _) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(3, request, cb)\n        .unwrap();\n\n    // Stale learner should be destroyed due to interaction between leader\n    must_get_none(&engine3, b\"k1\");\n    let state_key = keys::region_state_key(r1);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_update_option", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_update_option() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_a = \"test_mv_update_option_file_a\";\n    let file_b = \"test_mv_update_option_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    let ts = time::OffsetDateTime::now_utc();\n    let now = FileTime::from_unix_time(ts.unix_timestamp(), ts.nanosecond());\n    let later = FileTime::from_unix_time(ts.unix_timestamp() + 3600, ts.nanosecond());\n    filetime::set_file_times(at.plus_as_string(file_a), now, now).unwrap();\n    filetime::set_file_times(at.plus_as_string(file_b), now, later).unwrap();\n\n    scene.ucmd().arg(\"--update\").arg(file_a).arg(file_b).run();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"--update\")\n        .arg(file_b)\n        .arg(file_a)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat_iso_negative", "code": "pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    }", "test": "fn test_datetimeformat_iso_negative() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"America/Chicago\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|datetimeformat(format='iso')\")\n        .unwrap();\n    assert_eq!(\n        expr.eval(()).unwrap().to_string(),\n        \"2023-06-24T11:37:22-05:00\"\n    )\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::template_cant_access_macros_context", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn template_cant_access_macros_context() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", r#\"{% import \"macros\" as macros %}{{ macros::empty() }}{{ quote | default(value=\"I'd rather have roses on my table than diamonds on my neck.\") }}\"#),\n        (\"macros\", r#\"{% macro empty() %}{% set_global quote = \"This should not reachable from the calling template!\" %}{% endmacro empty %}\"#)\n    ]).unwrap();\n\n    let result = tera.render(\"parent\", &Context::new());\n    assert_eq!(result.unwrap(), \"I'd rather have roses on my table than diamonds on my neck.\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_older_dest_older", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_older_dest_older() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), new_content);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_nodata_where_name_exists", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "test": "fn test_nodata_where_name_exists() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        let msg = io_loop\n            .block_on(client.query(\n                Name::from_str(\"www.example.com.\").unwrap(),\n                DNSClass::IN,\n                RecordType::SRV,\n            ))\n            .unwrap();\n        assert_eq!(msg.response_code(), ResponseCode::NoError);\n        assert!(msg.answers().is_empty());\n    })\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::immediate_persistence", "code": "fn test_persistence(durability: Durability) {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(durability);\n    let pairs = gen_data(100, 16, 20);\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..ELEMENTS {\n            let (key, value) = &pairs[i % pairs.len()];\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n\n    let mut key_order: Vec<usize> = (0..ELEMENTS).collect();\n    key_order.shuffle(&mut rand::thread_rng());\n\n    {\n        for i in &key_order {\n            let (key, value) = &pairs[*i % pairs.len()];\n            assert_eq!(table.get(key.as_slice()).unwrap().unwrap().value(), value);\n        }\n    }\n}", "test": "fn immediate_persistence() {\n    test_persistence(Durability::Immediate);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_can_get_server_cert_after_resumption", "code": "pub fn peer_certificates(&self) -> Option<&[key::Certificate]> {\n        self.peer_certificates.as_deref()\n    }", "test": "fn client_can_get_server_cert_after_resumption() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = make_server_config(*kt);\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_configs(client_config.clone(), server_config.clone());\n            do_handshake(&mut client, &mut server);\n\n            let original_certs = client.peer_certificates();\n\n            let (mut client, mut server) =\n                make_pair_for_configs(client_config.clone(), server_config.clone());\n            do_handshake(&mut client, &mut server);\n\n            let resumed_certs = client.peer_certificates();\n\n            assert_eq!(original_certs, resumed_certs);\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_long_format_wo_user", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_long_format_wo_user() {\n    // \"no username specified; at least one must be specified when using -l\"\n    new_ucmd!().arg(\"-l\").fails();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::regression_1_nocaptures", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn regression_1_nocaptures() {\n    let source = r#\"\n        void foo() {\n            if (a->x > 10) {\n                a->x = 10;\n            }\n        }\"#;\n\n    let needle = \"{;}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_untagged_a_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_untagged_a_ser() {\n    let v = EnumStructUntagged::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    let e = \"(foo:1,bar:2,different:3)\";\n    test_ser(&v, e);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::connection_notified_on_released_capacity", "code": "fn drop(&mut self) {\n        self.0.state.store(USER_STATE_CLOSED, Ordering::Release);\n        self.0.pong_task.wake();\n    }", "test": "async fn connection_notified_on_released_capacity() {\n    use tokio::sync::{mpsc, oneshot};\n\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    // We're going to run the connection on a thread in order to isolate task\n    // notifications. This test is here, in part, to ensure that the connection\n    // receives the appropriate notifications to send out window updates.\n\n    let (tx, mut rx) = mpsc::unbounded_channel();\n\n    // Because threading is fun\n    let (settings_tx, settings_rx) = oneshot::channel();\n\n    let (th1_tx, th1_rx) = oneshot::channel();\n\n    tokio::spawn(async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        settings_tx.send(()).unwrap();\n        // Get the first request\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/a\")\n                .eos(),\n        )\n        .await;\n        // Get the second request\n        srv.recv_frame(\n            frames::headers(3)\n                .request(\"GET\", \"https://example.com/b\")\n                .eos(),\n        )\n        .await;\n        // Send the first response\n        srv.send_frame(frames::headers(1).response(200)).await;\n        // Send the second response\n        srv.send_frame(frames::headers(3).response(200)).await;\n\n        // Fill the connection window\n        srv.send_frame(frames::data(1, vec![0u8; 16_384]).eos())\n            .await;\n        idle_ms(100).await;\n        srv.send_frame(frames::data(3, vec![0u8; 16_384]).eos())\n            .await;\n\n        // The window update is sent\n        srv.recv_frame(frames::window_update(0, 16_384)).await;\n\n        th1_tx.send(()).unwrap();\n    });\n\n    let (th2_tx, th2_rx) = oneshot::channel();\n\n    let (mut client, mut h2) = client::handshake(io).await.unwrap();\n\n    h2.drive(settings_rx).await.unwrap();\n    let request = Request::get(\"https://example.com/a\").body(()).unwrap();\n    tx.send(client.send_request(request, true).unwrap().0)\n        .unwrap();\n\n    let request = Request::get(\"https://example.com/b\").body(()).unwrap();\n    tx.send(client.send_request(request, true).unwrap().0)\n        .unwrap();\n\n    tokio::spawn(async move {\n        // Run the connection to completion\n        h2.await.unwrap();\n\n        th2_tx.send(()).unwrap();\n        drop(client);\n    });\n\n    // Get the two requests\n    let a = rx.recv().await.unwrap();\n    let b = rx.recv().await.unwrap();\n\n    // Get the first response\n    let response = a.await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n    let (_, mut a) = response.into_parts();\n\n    // Get the next chunk\n    let chunk = a.data().await.unwrap();\n    assert_eq!(16_384, chunk.unwrap().len());\n\n    // Get the second response\n    let response = b.await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n    let (_, mut b) = response.into_parts();\n\n    // Get the next chunk\n    let chunk = b.data().await.unwrap();\n    assert_eq!(16_384, chunk.unwrap().len());\n\n    // Wait a bit\n    idle_ms(100).await;\n\n    // Release the capacity\n    a.flow_control().release_capacity(16_384).unwrap();\n\n    th1_rx.await.unwrap();\n    th2_rx.await.unwrap();\n\n    // Explicitly drop this after the joins so that the capacity doesn't get\n    // implicitly released before.\n    drop(b);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_corner_case2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_corner_case2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/10/-5\", \"/10/\"])\n        .fails()\n        .stderr_is(\"csplit: '/10/': match not found\\n\")\n        .stdout_is(\"8\\n133\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_borrow", "code": "pub fn from_slice(bytes: &'a [u8]) -> Self {\n        Deserializer::new(read::SliceRead::new(bytes))\n    }", "test": "fn test_borrow() {\n    let s: &str = from_str(\"\\\"borrowed\\\"\").unwrap();\n    assert_eq!(\"borrowed\", s);\n\n    let s: &str = from_slice(b\"\\\"borrowed\\\"\").unwrap();\n    assert_eq!(\"borrowed\", s);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_number_option_with_custom_separator_char", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_number_option_with_custom_separator_char() {\n    let test_file_path = \"test_num_page.log\";\n    let expected_test_file_path = \"test_num_page_char.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"-nc\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_kv_service.rs::test_kv_scan_memory_lock", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_kv_scan_memory_lock() {\n    let (_cluster, client, ctx) = must_new_cluster_and_kv_client();\n\n    let mut req = ScanRequest::default();\n    req.set_context(ctx);\n    req.set_start_key(b\"a\".to_vec());\n    req.version = 50;\n\n    fail::cfg(\"raftkv_async_snapshot_err\", \"return\").unwrap();\n    let resp = client.kv_scan(&req).unwrap();\n    // the injected error should be returned at both places for backward\n    // compatibility.\n    assert!(!resp.pairs[0].get_error().get_abort().is_empty());\n    assert!(!resp.get_error().get_abort().is_empty());\n    fail::remove(\"raftkv_async_snapshot_err\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/f16_tests.rs::as_f32_test", "code": "pub fn as_f32(self) -> f32 {\n        f16_to_f32(self)\n    }", "test": "fn as_f32_test() {\n    assert_eq!(f16::from_bits(1).as_f32(), 0.000000059604645);\n    assert_eq!(f16::ZERO.as_f32(), 0.0f32);\n    assert_eq!(f16::ZERO.to_bits(), 0);\n    assert_eq!(f16::ONE.as_f32(), 1.0f32);\n    assert_eq!(f16::ONE.to_bits(), (15 << 10));\n    assert_eq!(f16::TWO.as_f32(), 2.0f32);\n    assert_eq!(f16::TWO.to_bits(), (16 << 10));\n    assert_eq!(f16::from_bits(14 << 10).as_f32(), 0.5f32);\n    assert!(f16::NAN.as_f32().is_nan());\n    assert!(f16::INFINITY.as_f32().is_inf());\n    assert!(f16::NEG_INFINITY.as_f32().is_inf());\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_pre_handshake_with_vectored_write", "code": "fn write_vectored(&mut self, bufs: &[io::IoSlice<'_>]) -> io::Result<usize> {\n        let mut sz = 0;\n        for buf in bufs {\n            sz += self.send_some_plaintext(buf);\n        }\n        Ok(sz)\n    }", "test": "fn client_respects_buffer_limit_pre_handshake_with_vectored_write() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    client.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        client\n            .writer()\n            .write_vectored(&[\n                IoSlice::new(b\"01234567890123456789\"),\n                IoSlice::new(b\"01234567890123456789\")\n            ])\n            .unwrap(),\n        32\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_line_repeat_twice", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_line_repeat_twice() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\", \"{2}\"])\n        .succeeds()\n        .stdout_only(\"18\\n30\\n30\\n63\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 20));\n    assert_eq!(at.read(\"xx02\"), generate(20, 30));\n    assert_eq!(at.read(\"xx03\"), generate(30, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tty.rs::test_close_stdin", "code": "pub fn wait(self) -> io::Result<CmdResult> {\n        let (bin_path, util_name, tmpd) = (\n            self.bin_path.clone(),\n            self.util_name.clone(),\n            self.tmpd.clone(),\n        );\n\n        #[allow(deprecated)]\n        let output = self.wait_with_output()?;\n\n        Ok(CmdResult {\n            bin_path,\n            util_name,\n            tmpd,\n            exit_status: Some(output.status),\n            stdout: output.stdout,\n            stderr: output.stderr,\n        })\n    }", "test": "fn test_close_stdin() {\n    let mut child = new_ucmd!().run_no_wait();\n    child.close_stdin();\n    child.wait().unwrap().code_is(1).stdout_is(\"not a tty\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_ingest_sst_without_crc32", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_sst_without_crc32() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n\n    let temp_dir = Builder::new()\n        .prefix(\"test_ingest_sst_without_crc32\")\n        .tempdir()\n        .unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    // Set crc32 == 0 and length != 0 still ingest success\n    send_upload_sst(&import, &meta, &data).unwrap();\n    meta.set_crc32(0);\n\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n\n    // Check ingested kvs\n    check_ingested_kvs(&tikv, &ctx, sst_range);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_stdin_explicit", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_stdin_explicit() {\n    new_ucmd!()\n        .pipe_in_fixture(FOOBAR_TXT)\n        .arg(\"-\")\n        .run()\n        .stdout_is_fixture(\"foobar_stdin_default.expected\")\n        .no_stderr();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::create_temp_table", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn create_temp_table() {\n    let query = \"CREATE TEMPORARY TABLE db.table (a INT NOT NULL)\";\n    let query2 = \"CREATE TEMP TABLE db.table (a INT NOT NULL)\";\n\n    hive().verified_stmt(query);\n    hive().one_statement_parses_to(query2, query);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_simple_math_expr_plus", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_simple_math_expr_plus() {\n    let sql = \"SELECT a + b, 2 + a, 2.5 + a, a_f + b_f, 2 + a_f, 2.5 + a_f FROM c\";\n    verified_only_select(sql);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::dict_comprehension", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn dict_comprehension() {\n    let source = \"{x: x**2 for x in numbers}\";\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_dynamic_suffix_length", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_numeric_dynamic_suffix_length() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    // Split into chunks of one byte each, use numbers instead of\n    // letters as file suffixes.\n    //\n    // The input file has (10^2) - 10 + 1 = 91 bytes. This is just\n    // enough to force `split` to dynamically increase the length of\n    // the filename for the very last chunk.\n    //\n    //     x00, x01, x02, ..., x87, x88, x89, x9000\n    //\n    ucmd.args(&[\"-d\", \"-b\", \"1\", \"ninetyonebytes.txt\"])\n        .succeeds();\n    for i in 0..90 {\n        let filename = format!(\"x{i:02}\");\n        let contents = file_read(&at, &filename);\n        assert_eq!(contents, \"a\");\n    }\n    assert_eq!(file_read(&at, \"x9000\"), \"a\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::join_argument_count_error", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn join_argument_count_error() {\n  Test::new()\n    .justfile(\"x := join('a')\")\n    .args([\"--evaluate\"])\n    .stderr(\n      \"\n      error: Function `join` called with 1 argument but takes 2 or more\n        |\n      1 | x := join(\\'a\\')\n        |      ^^^^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uptime.rs::test_uptime_since", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_uptime_since() {\n    let re = Regex::new(r\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\").unwrap();\n\n    new_ucmd!().arg(\"--since\").succeeds().stdout_matches(&re);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/browser_field.rs::crypto_js", "code": "pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    }", "test": "fn crypto_js() {\n    let f = super::fixture();\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        fallback: vec![(\n            \"crypto\".into(),\n            vec![AliasValue::Path(f.join(\"lib.js\").to_string_lossy().to_string())],\n        )],\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path = resolver.resolve(f.join(\"crypto-js\"), \"crypto\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Err(ResolveError::Ignored(f.join(\"crypto-js\"))));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_failed_2", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_failed_2() {\n    let (_at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[FILE1]).fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_stdin_stdout_skip_w_multiplier", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_stdin_stdout_skip_w_multiplier() {\n    let input = build_ascii_block(10 * 1024);\n    let output = String::from_utf8(input[5 * 1024..].to_vec()).unwrap();\n    new_ucmd!()\n        .args(&[\"status=none\", \"skip=5K\", \"iflag=skip_bytes\"])\n        .pipe_in(input)\n        .run()\n        .no_stderr()\n        .stdout_is(output)\n        .success();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/windows_shell.rs::windows_shell_setting", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn windows_shell_setting() {\n  Test::new()\n    .justfile(\n      r#\"\n      set windows-shell := [\"pwsh.exe\", \"-NoLogo\", \"-Command\"]\n      set shell := [\"asdfasdfasdfasdf\"]\n\n      foo:\n        Write-Output bar\n    \"#,\n    )\n    .shell(false)\n    .stdout(\"bar\\r\\n\")\n    .stderr(\"Write-Output bar\\n\")\n    .run();\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::attributes_empty_ns", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn attributes_empty_ns() {\n    let src = \"<a att1='a' r:att2='b' xmlns:r='urn:example:r' />\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true);\n\n    let e = match r.read_resolved_event() {\n        Ok((Unbound, Empty(e))) => e,\n        e => panic!(\"Expecting Empty event, got {:?}\", e),\n    };\n\n    let mut attrs = e\n        .attributes()\n        .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n        // we don't care about xmlns attributes for this test\n        .filter(|kv| kv.key.as_namespace_binding().is_none())\n        .map(|Attribute { key: name, value }| {\n            let (opt_ns, local_name) = r.resolve_attribute(name);\n            (opt_ns, local_name.into_inner(), value)\n        });\n    assert_eq!(\n        attrs.next(),\n        Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n    );\n    assert_eq!(\n        attrs.next(),\n        Some((\n            Bound(Namespace(b\"urn:example:r\")),\n            &b\"att2\"[..],\n            Cow::Borrowed(&b\"b\"[..])\n        ))\n    );\n    assert_eq!(attrs.next(), None);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_pseudo_protocol_on_non_connect_request", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "test": "async fn reject_pseudo_protocol_on_non_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/feature_format_tests.rs::ignore_test", "code": "pub const fn flags(&self) -> u128 {\n        FORMAT & flags::FLAG_MASK\n    }", "test": "fn ignore_test() {\n    let fmt = format::NumberFormat::<{ format::IGNORE }> {};\n    assert_eq!(fmt.flags(), format::DIGIT_SEPARATOR_FLAG_MASK);\n    assert_eq!(fmt.digit_separator(), b'_');\n    assert_eq!(fmt.required_integer_digits(), false);\n    assert_eq!(fmt.required_fraction_digits(), false);\n    assert_eq!(fmt.required_exponent_digits(), false);\n    assert_eq!(fmt.required_mantissa_digits(), false);\n    assert_eq!(fmt.required_digits(), false);\n    assert_eq!(fmt.no_positive_mantissa_sign(), false);\n    assert_eq!(fmt.required_mantissa_sign(), false);\n    assert_eq!(fmt.no_exponent_notation(), false);\n    assert_eq!(fmt.no_positive_exponent_sign(), false);\n    assert_eq!(fmt.required_exponent_sign(), false);\n    assert_eq!(fmt.no_exponent_without_fraction(), false);\n    assert_eq!(fmt.no_special(), false);\n    assert_eq!(fmt.case_sensitive_special(), false);\n    assert_eq!(fmt.no_integer_leading_zeros(), false);\n    assert_eq!(fmt.no_float_leading_zeros(), false);\n    assert_eq!(fmt.required_exponent_notation(), false);\n    assert_eq!(fmt.case_sensitive_exponent(), false);\n    #[cfg(feature = \"power-of-two\")]\n    assert_eq!(fmt.case_sensitive_base_prefix(), false);\n    #[cfg(feature = \"power-of-two\")]\n    assert_eq!(fmt.case_sensitive_base_suffix(), false);\n    assert_eq!(fmt.integer_internal_digit_separator(), true);\n    assert_eq!(fmt.fraction_internal_digit_separator(), true);\n    assert_eq!(fmt.exponent_internal_digit_separator(), true);\n    assert_eq!(fmt.internal_digit_separator(), true);\n    assert_eq!(fmt.integer_leading_digit_separator(), true);\n    assert_eq!(fmt.fraction_leading_digit_separator(), true);\n    assert_eq!(fmt.exponent_leading_digit_separator(), true);\n    assert_eq!(fmt.leading_digit_separator(), true);\n    assert_eq!(fmt.integer_trailing_digit_separator(), true);\n    assert_eq!(fmt.fraction_trailing_digit_separator(), true);\n    assert_eq!(fmt.exponent_trailing_digit_separator(), true);\n    assert_eq!(fmt.trailing_digit_separator(), true);\n    assert_eq!(fmt.integer_consecutive_digit_separator(), true);\n    assert_eq!(fmt.fraction_consecutive_digit_separator(), true);\n    assert_eq!(fmt.exponent_consecutive_digit_separator(), true);\n    assert_eq!(fmt.consecutive_digit_separator(), true);\n    assert_eq!(fmt.special_digit_separator(), true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_target_dir", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_target_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_ln_target_dir_dir\";\n    let file_a = \"test_ln_target_dir_file_a\";\n    let file_b = \"test_ln_target_dir_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-t\", dir, file_a, file_b])\n        .succeeds()\n        .no_stderr();\n\n    let file_a_link = &format!(\"{dir}/{file_a}\");\n    assert!(at.is_symlink(file_a_link));\n    assert_eq!(at.resolve_link(file_a_link), file_a);\n\n    let file_b_link = &format!(\"{dir}/{file_b}\");\n    assert!(at.is_symlink(file_b_link));\n    assert_eq!(at.resolve_link(file_b_link), file_b);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::_ascii_implies_unblock() {\n    ", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "onv_ascii_implies_unblock() {\n    // 0x40 = 0o100 =  64, which gets converted to ' '\n    // 0xc1 = 0o301 = 193, which gets converted to 'A'\n    //\n    // `conv=ascii` implies `conv=unblock`, which means trailing paces\n    // are stripped and a newline is appended at the end of each\n    // block.\n    //\n    // `cbs=4` means use a conversion block size of 4 bytes per block.\n    new_ucmd!()\n        .args(&[\"conv=ascii\", \"cbs=4\"])\n        .pipe_in(b\"\\x40\\xc1\\x40\\xc1\\x40\\xc1\\x40\\x40\".to_vec())\n        .succeeds()\n        .stdout_is(\" A A\\n A\\n\");\n}\n\n#[test]"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_invalid_utf8", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_invalid_utf8() {\n    new_ucmd!()\n        .arg(\"not-utf8-sequence.txt\")\n        .run()\n        .failure()\n        .stderr_only(\n        \"uniq: failed to convert line to utf8: invalid utf-8 sequence of 1 bytes from index 0\\n\",\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_read_leader_in_lease", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_read_leader_in_lease() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.run();\n\n    let k1 = b\"k1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(k1), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let mut storage = cluster.sim.rl().storages[&leader.get_id()].clone();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader.clone());\n    let snap_ctx = SnapContext {\n        pb_ctx: &ctx,\n        ..Default::default()\n    };\n\n    // write some data\n    assert_none(snap_ctx.clone(), &mut storage, k2);\n    must_put(&ctx, &storage, k2, v2);\n\n    // isolate leader\n    cluster.add_send_filter(IsolationFilterFactory::new(leader.get_store_id()));\n\n    // leader still in lease, check if can read on leader\n    assert_eq!(can_read(snap_ctx, &mut storage, k2, v2), true);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_errors_for_all_disabled_checks", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_errors_for_all_disabled_checks() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CI_CONFIGURATION.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UNFORMATTED_AND_INCORRECT.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--linter-enabled=false\"),\n                (\"--formatter-enabled=false\"),\n                (\"--organize-imports-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED_AND_INCORRECT);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_errors_for_all_disabled_checks\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_alert", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_alert() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\a\"])\n        .succeeds()\n        .stdout_only(\"\\x07\\n\");\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_parse", "code": "pub(super) fn assert_to_string(value: impl Display, expected: &str) {\n    assert_eq!(value.to_string(), expected);\n}", "test": "pub fn test_parse() {\n    let err = req_err(\"\\0\");\n    assert_to_string(\n        err,\n        \"unexpected character '\\\\0' while parsing major version number\",\n    );\n\n    let err = req_err(\">= >= 0.0.2\");\n    assert_to_string(\n        err,\n        \"unexpected character '>' while parsing major version number\",\n    );\n\n    let err = req_err(\">== 0.0.2\");\n    assert_to_string(\n        err,\n        \"unexpected character '=' while parsing major version number\",\n    );\n\n    let err = req_err(\"a.0.0\");\n    assert_to_string(\n        err,\n        \"unexpected character 'a' while parsing major version number\",\n    );\n\n    let err = req_err(\"1.0.0-\");\n    assert_to_string(err, \"empty identifier segment in pre-release identifier\");\n\n    let err = req_err(\">=\");\n    assert_to_string(\n        err,\n        \"unexpected end of input while parsing major version number\",\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_9", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_9() {\n    let original = r##\"# without space, not recommended{#id1}\n## recommended style with spaces {#id2}\n\"##;\n    let expected = r##\"<h1 id=\"id1\">without space, not recommended</h1>\n<h2 id=\"id2\">recommended style with spaces</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::finally_with_loop_break", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn finally_with_loop_break() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            try {\n              30;\n            }\n            catch {\n            } finally {\n              while(true) {\n                break;\n              }\n            }\n        \"#},\n        30,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_parenthesized_op_compares_literal_parenthesis", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_parenthesized_op_compares_literal_parenthesis() {\n    // ensure we aren\u2019t treating this case as \u201cstring length of literal equal\n    // sign\u201d\n    new_ucmd!().args(&[\"(\", \"=\", \")\"]).run().code_is(1);\n}\n\n#[te"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_wrap_no_arg", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_wrap_no_arg() {\n    for wrap_param in [\"-w\", \"--wrap\"] {\n        let ts = TestScenario::new(util_name!());\n        let expected_stderr = \"a value is required for '--wrap <COLS>' but none was supplied\";\n        ts.ucmd()\n            .arg(wrap_param)\n            .fails()\n            .stderr_contains(expected_stderr)\n            .no_stdout();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_nil() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_too_many_arguments", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_too_many_arguments() {\n    new_ucmd!()\n        .args(&[\"-q\", \"a\", \"b\"])\n        .fails()\n        .code_is(1)\n        .usage_error(\"too many templates\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_macro_passing", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_macro_passing() {\n    let env = Environment::new();\n    let tmpl = env\n        .template_from_str(\"{% macro m(a) %}{{ a }}{% endmacro %}\")\n        .unwrap();\n    let (_, state) = tmpl.render_and_return_state(()).unwrap();\n    let m = state.lookup(\"m\").unwrap();\n    assert_eq!(m.get_attr(\"name\").unwrap().as_str(), Some(\"m\"));\n    let rv = m.call(&state, args!(42)).unwrap();\n    assert_eq!(rv.as_str(), Some(\"42\"));\n\n    // if we call the macro on an empty state it errors\n    let empty_state = env.empty_state();\n    let err = m.call(&empty_state, args!(42)).unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidOperation);\n    assert_eq!(\n        err.detail(),\n        Some(\"cannot call this macro. template state went away.\")\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::two_case_no_break_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn two_case_no_break_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            let b = 10;\n\n            switch (a) {\n                case 10:\n                    a = 150;\n                case 20:\n                    b = 150;\n                    break;\n            }\n\n            a + b;\n        \"#},\n        300,\n    )]);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::smoke", "code": "fn is_none(&self) -> bool {\n        self.index == !0\n    }", "test": "fn smoke() {\n    let mut headers = HeaderMap::new();\n\n    assert!(headers.get(\"hello\").is_none());\n\n    let name: HeaderName = \"hello\".parse().unwrap();\n\n    match headers.entry(&name) {\n        Entry::Vacant(e) => {\n            e.insert(\"world\".parse().unwrap());\n        }\n        _ => panic!(),\n    }\n\n    assert!(headers.get(\"hello\").is_some());\n\n    match headers.entry(&name) {\n        Entry::Occupied(mut e) => {\n            assert_eq!(e.get(), &\"world\");\n\n            // Push another value\n            e.append(\"zomg\".parse().unwrap());\n\n            let mut i = e.iter();\n\n            assert_eq!(*i.next().unwrap(), \"world\");\n            assert_eq!(*i.next().unwrap(), \"zomg\");\n            assert!(i.next().is_none());\n        }\n        _ => panic!(),\n    }\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_basic_works_after_deserialization", "code": "pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    }", "test": "fn check_basic_works_after_deserialization() {\n    let engine = get_blocker_engine();\n    let serialized = engine.serialize_raw().unwrap();\n    let mut deserialized_engine = Engine::default();\n    deserialized_engine.deserialize(&serialized).unwrap();\n\n    {\n        let request = Request::new(\"https://www.youtube.com/youtubei/v1/log_event?alt=json&key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\", \"\", \"\").unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, true);\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_with_no_limit", "code": "pub(crate) fn rpc_server(self, rpc_server: &test_bitcoincore_rpc::Handle) -> Self {\n    Self {\n      rpc_server_url: Some(rpc_server.url()),\n      ..self\n    }\n  }", "test": "fn inscribe_with_no_limit() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  let four_megger = std::iter::repeat(0).take(4_000_000).collect::<Vec<u8>>();\n  CommandBuilder::new(\"wallet inscribe --no-limit degenerate.png --fee-rate 1\")\n    .write(\"degenerate.png\", four_megger)\n    .rpc_server(&rpc_server);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server_encryption.rs::test_server_snapshot_encryption", "code": "fn drop(&mut self) {\n        self.scheduler.stop();\n    }", "test": "fn test_server_snapshot_encryption() {\n    let mut cluster = new_server_cluster(0, 2);\n    test_snapshot_encryption(&mut cluster);\n    // Directory should be cleaned up before background task stopped.\n    let _path = cluster.take_path();\n    drop(cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_snapshot_failed", "code": "pub fn has_store_not_match(&self) -> bool {\n        self.store_not_match.is_some()\n    }", "test": "fn test_snapshot_failed() {\n    let product = ProductTable::new();\n    let (_cluster, raft_engine, ctx) = new_raft_engine(1, \"\");\n\n    let (_, endpoint, _) = init_data_with_engine_and_commit(ctx, raft_engine, &product, &[], true);\n\n    // Use an invalid context to make errors.\n    let req = DagSelect::from(&product).build_with(Context::default(), &[0]);\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_region_error().has_store_not_match());\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::server_builder_set_max_concurrent_streams", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn server_builder_set_max_concurrent_streams() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let mut settings = frame::Settings::default();\n    settings.set_max_concurrent_streams(Some(1));\n\n    let client = async move {\n        let recv_settings = client.assert_server_handshake().await;\n        assert_frame_eq(recv_settings, settings);\n        client\n            .send_frame(frames::headers(1).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::headers(3).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::data(1, &b\"hello\"[..]).eos())\n            .await;\n        client.recv_frame(frames::reset(3).refused()).await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let mut builder = server::Builder::new();\n    builder.max_concurrent_streams(1);\n\n    let h2 = async move {\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, h2).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_missing_destination", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_install_missing_destination() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"source_file1\";\n    let dir_1 = \"source_dir1\";\n\n    at.touch(file_1);\n    at.mkdir(dir_1);\n\n    // will fail and also print some info on correct usage\n    scene\n        .ucmd()\n        .arg(file_1)\n        .fails()\n        .usage_error(format!(\"missing destination file operand after '{file_1}'\"));\n\n    // GNU's install will check for correct num of arguments and then fail\n    // and it does not recognize, that the source is not a file but a directory.\n    scene\n        .ucmd()\n        .arg(dir_1)\n        .fails()\n        .usage_error(format!(\"missing destination file operand after '{dir_1}'\"));\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_untagged_a_roundtrip", "code": "fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n}", "test": "fn test_untagged_a_roundtrip() {\n    let v = EnumStructUntagged::VariantA {\n        foo: 1,\n        bar: 2,\n        different: 3,\n    };\n    test_roundtrip(v);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_8", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_8() {\n    let original = r##\"H1\n{\n  .class1\n  .class2\n}\n==\n\"##;\n    let expected = r##\"<h1>H1\n{\n.class1\n.class2\n}</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_status.rs::test_status", "code": "pub fn get_leader(&self) -> &super::metapb::Peer {\n        self.leader.as_ref().unwrap_or_else(|| super::metapb::Peer::default_instance())\n    }", "test": "fn test_status() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    // When there is only one peer, it should campaign immediately.\n    let mut req = RaftCmdRequest::default();\n    req.mut_header().set_peer(new_peer(1, 3));\n    req.mut_status_request()\n        .set_cmd_type(StatusCmdType::RegionLeader);\n    let res = router.query(2, req.clone()).unwrap();\n    let status_resp = res.response().unwrap().get_status_response();\n    assert_eq!(\n        *status_resp.get_region_leader().get_leader(),\n        new_peer(1, 3)\n    );\n\n    req.mut_status_request()\n        .set_cmd_type(StatusCmdType::RegionDetail);\n    let res = router.query(2, req.clone()).unwrap();\n    let status_resp = res.response().unwrap().get_status_response();\n    let detail = status_resp.get_region_detail();\n    assert_eq!(*detail.get_leader(), new_peer(1, 3));\n    let region = detail.get_region();\n    assert_eq!(region.get_id(), 2);\n    assert!(region.get_start_key().is_empty());\n    assert!(region.get_end_key().is_empty());\n    assert_eq!(*region.get_peers(), vec![new_peer(1, 3)]);\n    assert_eq!(region.get_region_epoch().get_version(), 1);\n    assert_eq!(region.get_region_epoch().get_conf_ver(), 1);\n\n    // Invalid store id should return error.\n    req.mut_header().mut_peer().set_store_id(4);\n    let res = router.query(2, req).unwrap();\n    let resp = res.response().unwrap();\n    assert!(\n        resp.get_header().get_error().has_store_not_match(),\n        \"{:?}\",\n        resp\n    );\n\n    // TODO: add a peer then check for region change and leadership change.\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_aggregate_with_group_by", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_aggregate_with_group_by() {\n    let sql = \"SELECT a, COUNT(1), MIN(b), MAX(b) FROM foo GROUP BY a\";\n    let _ast = verified_only_select(sql);\n    //TODO: assertions\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::geometry", "code": "fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n}", "test": "fn geometry() {\n    require(\n        &[Ca::Geometry],\n        r#\"\n        @fragment\n        fn f(@builtin(primitive_index) x: u32) { }\n    \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_zeros_to_file", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_zeros_to_file() {\n    let tname = \"zero-256k\";\n    let test_fn = format!(\"{tname}.txt\");\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    assert_fixture_exists!(test_fn);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", inf!(test_fn), of!(tmp_fn)])\n        .run()\n        .no_stderr()\n        .no_stdout()\n        .success();\n\n    cmp_file!(\n        File::open(fixture_path!(&test_fn)).unwrap(),\n        fix.open(&tmp_fn)\n    );\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_end_stream", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_end_stream() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 1, 0, 0, 0, 1,\n            \"hello\",\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"hello\"[..]);\n    assert!(data.is_end_stream());\n    assert_closed!(codec);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_with_single_source_and_target_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs_with_single_source_and_target_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source1 = \"source_file_1\";\n    let target_dir = \"missing_target_dir/\";\n\n    at.touch(source1);\n\n    // installing a single file into a missing directory will fail, when -D is used w/o -t parameter\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(at.plus(target_dir))\n        .fails()\n        .stderr_contains(\"missing_target_dir/' is not a directory\");\n\n    assert!(!at.dir_exists(target_dir));\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(\"-t\")\n        .arg(at.plus(target_dir))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{target_dir}/{source1}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_string_length_of_empty", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_string_length_of_empty() {\n    new_ucmd!().args(&[\"-n\", \"\"]).run().code_is(1);\n\n    // STRING equivalent to -n STRING\n    new_ucmd!().arg(\"\").run().code_is(1);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::does_render_owned_for_loop_with_objects_string_keys", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn does_render_owned_for_loop_with_objects_string_keys() {\n    let mut context = Context::new();\n    let data = json!([\n        {\"id\": 1, \"group\": \"a\"},\n        {\"id\": 2, \"group\": \"b\"},\n        {\"id\": 3, \"group\": \"c\"},\n        {\"id\": 4, \"group\": \"a\"},\n        {\"id\": 5, \"group\": \"b\"},\n        {\"id\": 6, \"group\": \"c\"},\n        {\"id\": 7, \"group\": \"a\"},\n        {\"id\": 8},\n        {\"id\": 9, \"year\": null},\n    ]);\n    context.insert(\"something\", &data);\n\n    let tpl = r#\"{% for group, things in something | group_by(attribute=\"group\") %}{{group}},{% endfor %}\"#;\n    let expected = \"a,b,c,\";\n    assert_eq!(render_template(tpl, &context).unwrap(), expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_word_boundary_split_should_preserve_empty_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_word_boundary_split_should_preserve_empty_lines() {\n    new_ucmd!()\n        .arg(\"-s\")\n        .pipe_in(\"\\n\")\n        .succeeds()\n        .stdout_is(\"\\n\");\n\n    new_ucmd!()\n        .args(&[\"-w1\", \"-s\"])\n        .pipe_in(\"0\\n1\\n\\n2\\n\\n\\n\")\n        .succeeds()\n        .stdout_is(\"0\\n1\\n\\n2\\n\\n\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_ymdhms_time", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_ymdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_ymdhms_time\";\n\n    ucmd.args(&[\"-t\", \"1501011234.56\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M.%S\", \"201501010000.00\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_backspace_is_not_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_backspace_is_not_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w10\", \"-s\", \"-b\"])\n        .pipe_in(\"foobar\\x0889abcdef\")\n        .succeeds()\n        .stdout_is(\"foobar\\x0889a\\nbcdef\"); // spell-checker:disable-line\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_early_apply.rs::test_singleton_cannot_early_apply", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_singleton_cannot_early_apply() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    // So compact log will not be triggered automatically.\n    configure_for_request_snapshot(&mut cluster);\n\n    cluster.run();\n    // Put one key first to cache leader.\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let store_1_fp = \"raft_before_save_on_store_1\";\n\n    // Check singleton region can be scheduled correctly.\n    fail::cfg(store_1_fp, \"pause\").unwrap();\n    cluster.async_put(b\"k1\", b\"v1\").unwrap();\n    sleep_ms(100);\n\n    must_get_none(&cluster.get_engine(1), b\"k1\");\n\n    fail::remove(store_1_fp);\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_this", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn test_this() {\n    let needle = r#\"$this->x;\"#;\n\n    let source = r#\"\n    void foo::bar(foo *this){\n        this->x = 10;\n    }\"#;\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/c-api/tests/wasmer-c-api-test-runner/src/lib.rs::print_wasmer_root_to_stdout", "code": "pub fn canonicalize(&self, path: &Path) -> Result<PathBuf> {\n        if !path.exists() {\n            return Err(FsError::InvalidInput);\n        }\n        fs::canonicalize(path).map_err(Into::into)\n    }", "test": "fn print_wasmer_root_to_stdout(config: &Config) {\n    println!(\"print_wasmer_root_to_stdout\");\n\n    use walkdir::WalkDir;\n\n    println!(\n        \"wasmer dir: {}\",\n        std::path::Path::new(&config.wasmer_dir)\n            .canonicalize()\n            .unwrap()\n            .display()\n    );\n\n    for entry in WalkDir::new(&config.wasmer_dir)\n        .into_iter()\n        .filter_map(Result::ok)\n    {\n        let f_name = String::from(entry.path().canonicalize().unwrap().to_string_lossy());\n        println!(\"{f_name}\");\n    }\n\n    println!(\n        \"root dir: {}\",\n        std::path::Path::new(&config.root_dir)\n            .canonicalize()\n            .unwrap()\n            .display()\n    );\n\n    for entry in WalkDir::new(&config.root_dir)\n        .into_iter()\n        .filter_map(Result::ok)\n    {\n        let f_name = String::from(entry.path().canonicalize().unwrap().to_string_lossy());\n        println!(\"{f_name}\");\n    }\n\n    println!(\"printed\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_dereference", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_dereference() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.symlink_dir(SUB_DEEPER_DIR, SUB_DIR_LINKS_DEEPER_SYM_DIR);\n\n    let result = ts.ucmd().arg(\"-L\").arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-L\", SUB_DIR_LINKS]));\n\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n\n    _du_dereference(result.stdout_str());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::ok_many_variable_blocks", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn ok_many_variable_blocks() {\n    let mut context = Context::new();\n    context.insert(\"username\", &\"bob\");\n\n    let mut tpl = String::new();\n    for _ in 0..200 {\n        tpl.push_str(\"{{ username }}\")\n    }\n    let mut expected = String::new();\n    for _ in 0..200 {\n        expected.push_str(\"bob\")\n    }\n    assert_eq!(render_template(&tpl, &context).unwrap(), expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_read_on_replica_check_memory_locks", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_read_on_replica_check_memory_locks() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.cfg.raft_store.hibernate_regions = false;\n    cluster.run();\n\n    let raw_key = b\"key\";\n    let encoded_key = Key::from_raw(raw_key);\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(raw_key), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let leader_cm = cluster.sim.rl().get_concurrency_manager(leader.get_id());\n\n    let lock = Lock::new(\n        LockType::Put,\n        raw_key.to_vec(),\n        10.into(),\n        20000,\n        None,\n        10.into(),\n        1,\n        20.into(),\n    );\n    let guard = block_on(leader_cm.lock_key(&encoded_key));\n    guard.with_lock(|l| *l = Some(lock.clone()));\n\n    // read on follower\n    let mut follower_peer = None;\n    let mut follower_id = 0;\n    let peers = region.get_peers();\n    for p in peers {\n        if p.get_id() != leader.get_id() {\n            follower_id = p.get_id();\n            follower_peer = Some(p.clone());\n            break;\n        }\n    }\n\n    assert!(follower_peer.is_some());\n    let mut follower_ctx = Context::default();\n    follower_ctx.set_region_id(region.get_id());\n    follower_ctx.set_region_epoch(region.get_region_epoch().clone());\n    follower_ctx.set_peer(follower_peer.as_ref().unwrap().clone());\n    follower_ctx.set_replica_read(true);\n    for use_max_ts in [false, true] {\n        let mut range = KeyRange::default();\n        range.set_start_key(encoded_key.as_encoded().to_vec());\n        let ts = if use_max_ts {\n            Some(TimeStamp::max())\n        } else {\n            Some(100.into())\n        };\n        let follower_snap_ctx = SnapContext {\n            pb_ctx: &follower_ctx,\n            start_ts: ts,\n            key_ranges: vec![range],\n            ..Default::default()\n        };\n        let mut follower_storage = cluster.sim.rl().storages[&follower_id].clone();\n        match follower_storage.snapshot(follower_snap_ctx) {\n            Err(Error(box ErrorInner::KeyIsLocked(lock_info))) => {\n                assert_eq!(lock_info, lock.clone().into_lock_info(raw_key.to_vec()))\n            }\n            other => panic!(\"unexpected result: {:?}\", other),\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_random_shuffle_contains_all_lines", "code": "pub fn stdout_move_str(self) -> String {\n        String::from_utf8(self.stdout).unwrap()\n    }", "test": "fn test_random_shuffle_contains_all_lines() {\n    // check whether lines of input are all in output\n    const FILE: &str = \"default_unsorted_ints.expected\";\n    let (at, _ucmd) = at_and_ucmd!();\n    let result = new_ucmd!().arg(\"-R\").arg(FILE).run().stdout_move_str();\n    let expected = at.read(FILE);\n    let result_sorted = new_ucmd!().pipe_in(result.clone()).run().stdout_move_str();\n\n    assert_ne!(result, expected);\n    assert_eq!(result_sorted, expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_multiple_files", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_unlink_multiple_files() {\n    let ts = TestScenario::new(util_name!());\n\n    let (at, mut ucmd) = (ts.fixtures.clone(), ts.ucmd());\n    let file_a = \"test_unlink_multiple_file_a\";\n    let file_b = \"test_unlink_multiple_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a)\n        .arg(file_b)\n        .fails()\n        .stderr_contains(\"Usage\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_key_is_locked_for_index", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_key_is_locked_for_index() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, false);\n\n    let req = DagSelect::from_index(&product, &product[\"name\"]).build();\n    let resp = handle_request(&endpoint, req);\n    assert!(resp.get_data().is_empty(), \"{:?}\", resp);\n    assert!(resp.has_locked(), \"{:?}\", resp);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::mixed_forced", "code": "fn test_many_call_module(mut store: Store<()>) -> Result<()> {\n    const N: i32 = 200;\n\n    let mut wat = String::new();\n    wat.push_str(\"(module\\n\");\n    wat.push_str(\"(func $first (result i32) (i32.const 1))\\n\");\n    for i in 0..N {\n        wat.push_str(&format!(\"(func (export \\\"{}\\\") (result i32 i32)\\n\", i));\n        wat.push_str(\"call $first\\n\");\n        wat.push_str(&format!(\"i32.const {}\\n\", i));\n        wat.push_str(\"i32.add\\n\");\n        wat.push_str(\"call $last\\n\");\n        wat.push_str(&format!(\"i32.const {}\\n\", i));\n        wat.push_str(\"i32.add)\\n\");\n    }\n    wat.push_str(\"(func $last (result i32) (i32.const 2))\\n\");\n    wat.push_str(\")\\n\");\n\n    let module = Module::new(store.engine(), &wat)?;\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    for i in 0..N {\n        let name = i.to_string();\n        let func = instance.get_typed_func::<(), (i32, i32)>(&mut store, &name)?;\n        let (a, b) = func.call(&mut store, ())?;\n        assert_eq!(a, i + 1);\n        assert_eq!(b, i + 2);\n    }\n    Ok(())\n}", "test": "fn mixed_forced() -> Result<()> {\n    let mut config = Config::new();\n    unsafe {\n        config.cranelift_flag_set(\"wasmtime_linkopt_force_jump_veneer\", \"true\");\n    }\n    let engine = Engine::new(&config)?;\n    test_many_call_module(Store::new(&engine, ()))\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_incorrect_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_sync_incorrect_arg() {\n    new_ucmd!().arg(\"--foo\").fails();\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_lit.rs::strings", "code": "pub fn value(&self) -> String {\n        let repr = self.repr.token.to_string();\n        let (value, _suffix) = value::parse_lit_str(&repr);\n        String::from(value)\n    }", "test": "fn strings() {\n    fn test_string(s: &str, value: &str) {\n        match lit(s) {\n            Lit::Str(lit) => {\n                assert_eq!(lit.value(), value);\n                let again = lit.into_token_stream().to_string();\n                if again != s {\n                    test_string(&again, value);\n                }\n            }\n            wrong => panic!(\"{:?}\", wrong),\n        }\n    }\n\n    test_string(\"\\\"a\\\"\", \"a\");\n    test_string(\"\\\"\\\\n\\\"\", \"\\n\");\n    test_string(\"\\\"\\\\r\\\"\", \"\\r\");\n    test_string(\"\\\"\\\\t\\\"\", \"\\t\");\n    test_string(\"\\\"\ud83d\udc15\\\"\", \"\ud83d\udc15\"); // NOTE: This is an emoji\n    test_string(\"\\\"\\\\\\\"\\\"\", \"\\\"\");\n    test_string(\"\\\"'\\\"\", \"'\");\n    test_string(\"\\\"\\\"\", \"\");\n    test_string(\"\\\"\\\\u{1F415}\\\"\", \"\\u{1F415}\");\n    test_string(\"\\\"\\\\u{1_2__3_}\\\"\", \"\\u{123}\");\n    test_string(\n        \"\\\"contains\\nnewlines\\\\\\nescaped newlines\\\"\",\n        \"contains\\nnewlinesescaped newlines\",\n    );\n    test_string(\n        \"\\\"escaped newline\\\\\\n \\x0C unsupported whitespace\\\"\",\n        \"escaped newline\\x0C unsupported whitespace\",\n    );\n    test_string(\"r\\\"raw\\nstring\\\\\\nhere\\\"\", \"raw\\nstring\\\\\\nhere\");\n    test_string(\"\\\"...\\\"q\", \"...\");\n    test_string(\"r\\\"...\\\"q\", \"...\");\n    test_string(\"r##\\\"...\\\"##q\", \"...\");\n}\n\n#[te"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_block_fragments", "code": "pub fn eval_to_state<S: Serialize>(&self, ctx: S) -> Result<State<'_, 'env>, Error> {\n        let root = Value::from_serializable(&ctx);\n        let mut out = Output::null();\n        let vm = Vm::new(self.env);\n        let state = ok!(vm.eval(\n            &self.compiled.instructions,\n            root,\n            &self.compiled.blocks,\n            &mut out,\n            self.initial_auto_escape,\n        ))\n        .1;\n        Ok(state)\n    }", "test": "fn test_block_fragments() {\n    let mut env = Environment::new();\n    env.add_template(\n        \"demo\",\n        \"I am outside the fragment{% block foo %}foo{% endblock %}So am I!\",\n    )\n    .unwrap();\n    let tmpl = env.get_template(\"demo\").unwrap();\n\n    let rv_a = tmpl.render(()).unwrap();\n    let rv_b = tmpl.eval_to_state(()).unwrap().render_block(\"foo\").unwrap();\n\n    assert_eq!(rv_a, \"I am outside the fragmentfooSo am I!\");\n    assert_eq!(rv_b, \"foo\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/create.rs::wallet_creates_correct_test_network_taproot_descriptor", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn wallet_creates_correct_test_network_taproot_descriptor() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n    .network(Network::Signet)\n    .build();\n\n  CommandBuilder::new(\"--chain signet wallet create\")\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Output>();\n\n  assert_eq!(rpc_server.descriptors().len(), 2);\n  assert_regex_match!(\n    &rpc_server.descriptors()[0],\n    r\"tr\\(\\[[[:xdigit:]]{8}/86'/1'/0'\\]tprv[[:alnum:]]*/0/\\*\\)#[[:alnum:]]{8}\"\n  );\n  assert_regex_match!(\n    &rpc_server.descriptors()[1],\n    r\"tr\\(\\[[[:xdigit:]]{8}/86'/1'/0'\\]tprv[[:alnum:]]*/1/\\*\\)#[[:alnum:]]{8}\"\n  );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_command_with_no_adjustment", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_command_with_no_adjustment() {\n    new_ucmd!().args(&[\"echo\", \"a\"]).run().stdout_is(\"a\\n\");\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::cover_offset", "code": "pub fn cover_offset(self, offset: TextSize) -> TextRange {\n        self.cover(TextRange::empty(offset))\n    }", "test": "fn cover_offset() {\n    assert_eq!(range(1..3).cover_offset(size(0)), range(0..3));\n    assert_eq!(range(1..3).cover_offset(size(1)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(2)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(3)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(4)), range(1..4));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_7", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_7() {\n    let original = r##\"H1\ncont\n{#myid}\n==\n\"##;\n    let expected = r##\"<h1 id=\"myid\">H1\ncont\n</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/tests/spec_tests.rs::quick_test", "code": "pub fn has_errors(&self) -> bool {\n        self.diagnostics\n            .iter()\n            .any(|diagnostic| diagnostic.is_error())\n    }", "test": "fn quick_test() {\n    let source = r#\"{\n        \"javascript\": {\n            \"formatter\": {\n                \"overrides\": [\n                {}]\n            }\n        }\n    }\"#;\n    let result = deserialize_from_json_str::<Configuration>(source, JsonParserOptions::default());\n\n    dbg!(result.diagnostics());\n    assert!(!result.has_errors());\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::insert", "code": "pub fn insert<'k, 'v>(\n        &mut self,\n        key: impl Borrow<K::SelfType<'k>>,\n        value: impl Borrow<V::SelfType<'v>>,\n    ) -> Result<bool> {\n        let value_bytes = V::as_bytes(value.borrow());\n        let value_bytes_ref = value_bytes.as_ref();\n        if value_bytes_ref.len() > MAX_VALUE_LENGTH {\n            return Err(StorageError::ValueTooLarge(value_bytes_ref.len()));\n        }\n        let key_bytes = K::as_bytes(key.borrow());\n        if key_bytes.as_ref().len() > MAX_VALUE_LENGTH {\n            return Err(StorageError::ValueTooLarge(key_bytes.as_ref().len()));\n        }\n        let get_result = self.tree.get(key.borrow())?;\n        let existed = if get_result.is_some() {\n            #[allow(clippy::unnecessary_unwrap)]\n            let guard = get_result.unwrap();\n            let collection_type = guard.value().collection_type();\n            match collection_type {\n                Inline => {\n                    let leaf_data = guard.value().as_inline();\n                    let accessor = LeafAccessor::new(\n                        leaf_data,\n                        V::fixed_width(),\n                        <() as RedbValue>::fixed_width(),\n                    );\n                    let (position, found) = accessor.position::<V>(value_bytes_ref);\n                    if found {\n                        return Ok(true);\n                    }\n\n                    let new_pairs = accessor.num_pairs() + 1;\n                    let new_pair_bytes =\n                        accessor.length_of_pairs(0, accessor.num_pairs()) + value_bytes_ref.len();\n                    let new_key_bytes =\n                        accessor.length_of_keys(0, accessor.num_pairs()) + value_bytes_ref.len();\n                    let required_inline_bytes =\n                        RawLeafBuilder::required_bytes(new_pairs, new_pair_bytes);\n\n                    if required_inline_bytes < self.mem.get_page_size() / 2 {\n                        let mut data = vec![0; required_inline_bytes];\n                        let mut builder = RawLeafBuilder::new(\n                            &mut data,\n                            new_pairs,\n                            V::fixed_width(),\n                            <() as RedbValue>::fixed_width(),\n                            new_key_bytes,\n                        );\n                        for i in 0..accessor.num_pairs() {\n                            if i == position {\n                                builder.append(\n                                    value_bytes_ref,\n                                    <() as RedbValue>::as_bytes(&()).as_ref(),\n                                );\n                            }\n                            let entry = accessor.entry(i).unwrap();\n                            builder.append(entry.key(), entry.value());\n                        }\n                        if position == accessor.num_pairs() {\n                            builder\n                                .append(value_bytes_ref, <() as RedbValue>::as_bytes(&()).as_ref());\n                        }\n                        drop(builder);\n                        drop(guard);\n                        let inline_data = DynamicCollection::<V>::make_inline_data(&data);\n                        self.tree\n                            .insert(key.borrow(), &DynamicCollection::new(&inline_data))?;\n                    } else {\n                        // convert into a subtree\n                        let mut page = self.mem.allocate(leaf_data.len(), CachePriority::Low)?;\n                        page.memory_mut()[..leaf_data.len()].copy_from_slice(leaf_data);\n                        let page_number = page.get_page_number();\n                        drop(page);\n                        drop(guard);\n\n                        // Don't bother computing the checksum, since we're about to modify the tree\n                        let mut subtree: BtreeMut<'_, V, ()> = BtreeMut::new(\n                            Some((page_number, 0)),\n                            self.mem,\n                            self.freed_pages.clone(),\n                        );\n                        let existed = subtree.insert(value.borrow(), &())?.is_some();\n                        assert_eq!(existed, found);\n                        let (new_root, new_checksum) = subtree.get_root().unwrap();\n                        let subtree_data =\n                            DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                        self.tree\n                            .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n                    }\n\n                    found\n                }\n                Subtree => {\n                    let mut subtree: BtreeMut<'_, V, ()> = BtreeMut::new(\n                        Some(guard.value().as_subtree()),\n                        self.mem,\n                        self.freed_pages.clone(),\n                    );\n                    drop(guard);\n                    let existed = subtree.insert(value.borrow(), &())?.is_some();\n                    let (new_root, new_checksum) = subtree.get_root().unwrap();\n                    let subtree_data =\n                        DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                    self.tree\n                        .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n\n                    existed\n                }\n            }\n        } else {\n            drop(get_result);\n            let required_inline_bytes = RawLeafBuilder::required_bytes(1, value_bytes_ref.len());\n            if required_inline_bytes < self.mem.get_page_size() / 2 {\n                let mut data = vec![0; required_inline_bytes];\n                let mut builder = RawLeafBuilder::new(\n                    &mut data,\n                    1,\n                    V::fixed_width(),\n                    <() as RedbValue>::fixed_width(),\n                    value_bytes_ref.len(),\n                );\n                builder.append(value_bytes_ref, <() as RedbValue>::as_bytes(&()).as_ref());\n                drop(builder);\n                let inline_data = DynamicCollection::<V>::make_inline_data(&data);\n                self.tree\n                    .insert(key.borrow(), &DynamicCollection::new(&inline_data))?;\n            } else {\n                let mut subtree: BtreeMut<'_, V, ()> =\n                    BtreeMut::new(None, self.mem, self.freed_pages.clone());\n                subtree.insert(value.borrow(), &())?;\n                let (new_root, new_checksum) = subtree.get_root().unwrap();\n                let subtree_data =\n                    DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                self.tree\n                    .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n            }\n            false\n        };\n\n        Ok(existed)\n    }", "test": "fn insert() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        assert!(!table.insert(\"hello\", \"world\").unwrap());\n        assert!(!table.insert(\"hello\", \"world2\").unwrap());\n        assert!(table.insert(\"hello\", \"world2\").unwrap());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\"world\".to_string(), \"world2\".to_string()],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 2);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_server_continues_on_bad_data_tcp", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_server_continues_on_bad_data_tcp() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n\n        // Send a bad packet, this should get rejected by the server\n        let mut raw_socket = TcpStream::connect(addr).expect(\"couldn't bind raw\");\n\n        raw_socket\n            .write_all(b\"0xDEADBEEF\")\n            .expect(\"raw send failed\");\n\n        // just tests that multiple queries work\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n    })\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_download_sst", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_download_sst() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n    let temp_dir = Builder::new()\n        .prefix(\"test_download_sst\")\n        .tempdir()\n        .unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, _) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    // Checks that downloading a non-existing storage returns error.\n    let mut download = DownloadRequest::default();\n    download.set_sst(meta.clone());\n    download.set_storage_backend(external_storage_export::make_local_backend(temp_dir.path()));\n    download.set_name(\"missing.sst\".to_owned());\n\n    let result = import.download(&download).unwrap();\n    assert!(\n        result.has_error(),\n        \"unexpected download reply: {:?}\",\n        result\n    );\n\n    // Checks that downloading an empty SST returns OK (but cannot be ingested)\n    download.set_name(\"test.sst\".to_owned());\n    download.mut_sst().mut_range().set_start(vec![sst_range.1]);\n    download\n        .mut_sst()\n        .mut_range()\n        .set_end(vec![sst_range.1 + 1]);\n    let result = import.download(&download).unwrap();\n    assert!(result.get_is_empty());\n\n    // Now perform a proper download.\n    download.mut_sst().mut_range().set_start(Vec::new());\n    download.mut_sst().mut_range().set_end(Vec::new());\n    let result = import.download(&download).unwrap();\n    assert!(!result.get_is_empty());\n    assert_eq!(result.get_range().get_start(), &[sst_range.0]);\n    assert_eq!(result.get_range().get_end(), &[sst_range.1 - 1]);\n\n    // Do an ingest and verify the result is correct.\n\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error());\n\n    check_ingested_kvs(&tikv, &ctx, sst_range);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_read", "code": "pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    }", "test": "fn server_complete_io_for_read() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        client\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        {\n            let mut pipe = OtherSession::new(&mut client);\n            let (rdlen, wrlen) = server.complete_io(&mut pipe).unwrap();\n            assert!(rdlen > 0 && wrlen == 0);\n            assert_eq!(pipe.reads, 1);\n        }\n        check_read(&mut server.reader(), b\"01234567890123456789\");\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::memory_init", "code": "pub fn data<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> &'a [u8] {\n        unsafe {\n            let store = store.into();\n            let definition = &*store[self.0].definition;\n            debug_assert!(!self.ty(store).is_shared());\n            slice::from_raw_parts(definition.base, definition.current_length())\n        }\n    }", "test": "fn memory_init() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(2).table_elements(0);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"m\") 2)\n                (data (i32.const 65530) \"this data spans multiple pages\")\n                (data (i32.const 10) \"hello world\")\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    assert_eq!(\n        &memory.data(&store)[65530..65560],\n        b\"this data spans multiple pages\"\n    );\n    assert_eq!(&memory.data(&store)[10..21], b\"hello world\");\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_write_to_self_empty", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_write_to_self_empty() {\n    // it's ok if the input file is also the output file if it's empty\n    let s = TestScenario::new(util_name!());\n    let file_path = s.fixtures.plus(\"file.txt\");\n\n    let file = OpenOptions::new()\n        .create_new(true)\n        .write(true)\n        .append(true)\n        .open(&file_path)\n        .unwrap();\n\n    s.ucmd().set_stdout(file).arg(&file_path).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_invalid_time_interval", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_invalid_time_interval() {\n    new_ucmd!()\n        .args(&[\"xyz\", \"sleep\", \"0\"])\n        .fails()\n        .code_is(125)\n        .usage_error(\"invalid time interval 'xyz'\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::upgrade_severity", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn upgrade_severity() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_LINTER_UPGRADE_DIAGNOSTIC.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UPGRADE_SEVERITY_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    let error_count = messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Error)\n        .filter(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"style/noNegationElse\")\n        })\n        .count();\n\n    assert_eq!(\n        error_count, 1,\n        \"expected 1 error-level message in console buffer, found {error_count:?}:\\n{:?}\",\n        console.out_buffer\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"upgrade_severity\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_nul", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_nul() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\0 bar\"])\n        .succeeds()\n        .stdout_only(\"foo\\0 bar\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_prewrite_before_max_ts_is_synced", "code": "pub fn has_max_timestamp_not_synced(&self) -> bool {\n        self.max_timestamp_not_synced.is_some()\n    }", "test": "fn test_prewrite_before_max_ts_is_synced() {\n    let mut cluster = new_server_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.run();\n\n    // Transfer leader to node 1 first to ensure all operations happen on node 1\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let do_prewrite = |cluster: &mut Cluster<ServerCluster>| {\n        let region_id = right.get_id();\n        let leader = cluster.leader_of_region(region_id).unwrap();\n        let epoch = cluster.get_region_epoch(region_id);\n        let mut ctx = Context::default();\n        ctx.set_region_id(region_id);\n        ctx.set_peer(leader);\n        ctx.set_region_epoch(epoch);\n\n        let mut req = PrewriteRequest::default();\n        req.set_context(ctx);\n        req.set_primary_lock(b\"key\".to_vec());\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.set_key(b\"key\".to_vec());\n        mutation.set_value(b\"value\".to_vec());\n        req.mut_mutations().push(mutation);\n        req.set_start_version(100);\n        req.set_lock_ttl(20000);\n        req.set_use_async_commit(true);\n        client.kv_prewrite(&req).unwrap()\n    };\n\n    fail::cfg(\"test_raftstore_get_tso\", \"return(50)\").unwrap();\n    cluster.pd_client.must_merge(left.get_id(), right.get_id());\n    let resp = do_prewrite(&mut cluster);\n    assert!(resp.get_region_error().has_max_timestamp_not_synced());\n    fail::remove(\"test_raftstore_get_tso\");\n    thread::sleep(Duration::from_millis(200));\n    let resp = do_prewrite(&mut cluster);\n    assert!(!resp.get_region_error().has_max_timestamp_not_synced());\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/dnssec_client_handle_tests.rs::test_secure_query_example_nonet", "code": "fn with_nonet<F>(test: F)\nwhere\n    F: Fn(DnssecDnsHandle<MemoizeClientHandle<AsyncClient>>, Runtime),\n{\n    let succeeded = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));\n    let succeeded_clone = succeeded.clone();\n    let join = std::thread::Builder::new()\n        .name(\"thread_killer\".to_string())\n        .spawn(move || {\n            let succeeded = succeeded_clone;\n            for _ in 0..15 {\n                std::thread::sleep(std::time::Duration::from_secs(1));\n                if succeeded.load(std::sync::atomic::Ordering::Relaxed) {\n                    return;\n                }\n            }\n\n            println!(\"Thread Killer has been awoken, killing process\");\n            std::process::exit(-1);\n        })\n        .unwrap();\n\n    let authority = create_secure_example();\n\n    let trust_anchor = {\n        let signers = block_on(authority.secure_keys());\n        let public_key = signers\n            .first()\n            .expect(\"expected a key in the authority\")\n            .key()\n            .to_public_key()\n            .expect(\"could not convert keypair to public_key\");\n\n        let mut trust_anchor = TrustAnchor::new();\n        trust_anchor.insert_trust_anchor(&public_key);\n\n        trust_anchor\n    };\n\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let client = AsyncClient::new(stream, sender, None);\n\n    let (client, bg) = io_loop\n        .block_on(client)\n        .expect(\"failed to create new client\");\n\n    hickory_proto::spawn_bg(&io_loop, bg);\n    let client = MemoizeClientHandle::new(client);\n    let secure_client = DnssecDnsHandle::with_trust_anchor(client, trust_anchor);\n\n    test(secure_client, io_loop);\n    succeeded.store(true, std::sync::atomic::Ordering::Relaxed);\n    join.join().unwrap();\n}", "test": "fn test_secure_query_example_nonet() {\n    with_nonet(test_secure_query_example);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_psbt", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_psbt() {\n    let tx = Transaction {\n        version: 1,\n        lock_time: absolute::LockTime::ZERO,\n        input: vec![TxIn {\n            previous_output: OutPoint {\n                txid: \"e567952fb6cc33857f392efa3a46c995a28f69cca4bb1b37e0204dab1ec7a389\"\n                    .parse::<Txid>()\n                    .unwrap(),\n                vout: 1,\n            },\n            script_sig: ScriptBuf::from_hex(\"160014be18d152a9b012039daf3da7de4f53349eecb985\")\n                .unwrap(),\n            sequence: Sequence::from_consensus(4294967295),\n            witness: Witness::from_slice(&[Vec::from_hex(\n                \"03d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f2105\",\n            )\n            .unwrap()]),\n        }],\n        output: vec![TxOut {\n            value: Amount::from_sat(190_303_501_938),\n            script_pubkey: ScriptBuf::from_hex(\"a914339725ba21efd62ac753a9bcd067d6c7a6a39d0587\")\n                .unwrap(),\n        }],\n    };\n    let unknown: BTreeMap<raw::Key, Vec<u8>> =\n        vec![(raw::Key { type_value: 1, key: vec![0, 1] }, vec![3, 4, 5])].into_iter().collect();\n    let key_source = (\"deadbeef\".parse().unwrap(), \"m/0'/1\".parse().unwrap());\n    let keypaths: BTreeMap<secp256k1::PublicKey, KeySource> = vec![(\n        \"0339880dc92394b7355e3d0439fa283c31de7590812ea011c4245c0674a685e883\".parse().unwrap(),\n        key_source.clone(),\n    )]\n    .into_iter()\n    .collect();\n\n    let proprietary: BTreeMap<raw::ProprietaryKey, Vec<u8>> = vec![(\n        raw::ProprietaryKey {\n            prefix: \"prefx\".as_bytes().to_vec(),\n            subtype: 42,\n            key: \"test_key\".as_bytes().to_vec(),\n        },\n        vec![5, 6, 7],\n    )]\n    .into_iter()\n    .collect();\n\n    let psbt = Psbt {\n        version: 0,\n        xpub: {\n            let s = include_str!(\"data/serde/extended_pub_key\");\n            let xpub = Xpub::from_str(s.trim()).unwrap();\n            vec![(xpub, key_source)].into_iter().collect()\n        },\n        unsigned_tx: {\n            let mut unsigned = tx.clone();\n            unsigned.input[0].script_sig = ScriptBuf::new();\n            unsigned.input[0].witness = Witness::default();\n            unsigned\n        },\n        proprietary: proprietary.clone(),\n        unknown: unknown.clone(),\n\n        inputs: vec![Input {\n            non_witness_utxo: Some(tx),\n            witness_utxo: Some(TxOut {\n                value: Amount::from_sat(190_303_501_938),\n                script_pubkey: ScriptBuf::from_hex(\"a914339725ba21efd62ac753a9bcd067d6c7a6a39d0587\").unwrap(),\n            }),\n            sighash_type: Some(PsbtSighashType::from(EcdsaSighashType::from_str(\"SIGHASH_SINGLE|SIGHASH_ANYONECANPAY\").unwrap())),\n            redeem_script: Some(vec![0x51].into()),\n            witness_script: None,\n            partial_sigs: vec![(\n                \"0339880dc92394b7355e3d0439fa283c31de7590812ea011c4245c0674a685e883\".parse().unwrap(),\n                \"304402204f67e2afb76142d44fae58a2495d33a3419daa26cd0db8d04f3452b63289ac0f022010762a9fb67e94cc5cad9026f6dc99ff7f070f4278d30fbc7d0c869dd38c7fe701\".parse().unwrap(),\n            )].into_iter().collect(),\n            bip32_derivation: keypaths.clone().into_iter().collect(),\n            final_script_witness: Some(Witness::from_slice(&[vec![1, 3], vec![5]])),\n            ripemd160_preimages: vec![(ripemd160::Hash::hash(&[]), vec![1, 2])].into_iter().collect(),\n            sha256_preimages: vec![(sha256::Hash::hash(&[]), vec![1, 2])].into_iter().collect(),\n            hash160_preimages: vec![(hash160::Hash::hash(&[]), vec![1, 2])].into_iter().collect(),\n            hash256_preimages: vec![(sha256d::Hash::hash(&[]), vec![1, 2])].into_iter().collect(),\n            proprietary: proprietary.clone(),\n            unknown: unknown.clone(),\n            ..Default::default()\n        }],\n        outputs: vec![Output {\n            bip32_derivation: keypaths.into_iter().collect(),\n            proprietary,\n            unknown,\n            ..Default::default()\n        }],\n    };\n\n    let got = serialize(&psbt).unwrap();\n    let want = include_bytes!(\"data/serde/psbt_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_invalid_block_size_from_env", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "test": "fn test_invalid_block_size_from_env() {\n    let default_block_size_header = \"1K-blocks\";\n\n    let output = new_ucmd!()\n        .arg(\"--output=size\")\n        .env(\"DF_BLOCK_SIZE\", \"invalid\")\n        .succeeds()\n        .stdout_move_str();\n    let header = output.lines().next().unwrap().trim().to_string();\n\n    assert_eq!(header, default_block_size_header);\n\n    let output = new_ucmd!()\n        .arg(\"--output=size\")\n        .env(\"DF_BLOCK_SIZE\", \"invalid\")\n        .env(\"BLOCK_SIZE\", \"222\")\n        .succeeds()\n        .stdout_move_str();\n    let header = output.lines().next().unwrap().trim().to_string();\n\n    assert_eq!(header, default_block_size_header);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_three_arguments", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_link_three_arguments() {\n    let (_, mut ucmd) = at_and_ucmd!();\n    let arguments = [\n        \"test_link_argument1\",\n        \"test_link_argument2\",\n        \"test_link_argument3\",\n    ];\n    ucmd.args(&arguments[..])\n        .fails()\n        .stderr_contains(\"2 values required\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_empty", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_empty() {\n    test_formatting(\n        r#\"\n        class A {}\n        \"#,\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::uuid", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn uuid() {\n  Test::new()\n    .justfile(\"x := uuid()\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout_regex(\"........-....-....-....-............\")\n    .run();\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::cmp_test", "code": "fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        Some(bigint::compare(self, other))\n    }", "test": "fn cmp_test() {\n    // Simple\n    let x = VecType::from_u64(1);\n    let y = VecType::from_u64(2);\n    assert_eq!(x.partial_cmp(&x), Some(cmp::Ordering::Equal));\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Less);\n\n    // Check asymmetric\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    let y = VecType::from_u64(2);\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Check when we use reverse ordering properly.\n    let x = VecType::try_from(&[5, 1, 9]).unwrap();\n    let y = VecType::try_from(&[6, 2, 8]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = VecType::try_from(&[0, 1, 9]).unwrap();\n    let y = VecType::try_from(&[4294967295, 0, 9]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::alpn_success", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn alpn_success() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"bar\".into(), \"quux\".into(), \"corge\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n\n    let hd = pair\n        .client_conn_mut(client_ch)\n        .crypto_session()\n        .handshake_data()\n        .unwrap()\n        .downcast::<crate::crypto::rustls::HandshakeData>()\n        .unwrap();\n    assert_eq!(hd.protocol.unwrap(), &b\"bar\"[..]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::multiple_tables", "code": "pub fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: TableDefinition<K, V>,\n    ) -> Result<Table<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Normal)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(Table::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn multiple_tables() {\n    let definition1: TableDefinition<&str, &str> = TableDefinition::new(\"1\");\n    let definition2: TableDefinition<&str, &str> = TableDefinition::new(\"2\");\n\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition1).unwrap();\n        let mut table2 = write_txn.open_table(definition2).unwrap();\n\n        table.insert(\"hello\", \"world\").unwrap();\n        table2.insert(\"hello\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition1).unwrap();\n    let table2 = read_txn.open_table(definition2).unwrap();\n    assert_eq!(table.len().unwrap(), 1);\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 1);\n    assert_eq!(\"world2\", table2.get(\"hello\").unwrap().unwrap().value());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_line_length_lines_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_line_length_lines_chars() {\n    new_ucmd!()\n        .arg(\"-Llm\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25     442      48\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_with_trailing_tab_i", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_with_trailing_tab_i() {\n    new_ucmd!()\n        .arg(\"with-trailing-tab.txt\")\n        .arg(\"-i\")\n        .succeeds()\n        .stdout_contains(\"        // with tabs=>\\t\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_only_delimited", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_only_delimited() {\n    for param in [\"-s\", \"--only-delimited\", \"--only-del\"] {\n        new_ucmd!()\n            .args(&[\"-d_\", param, \"-f\", \"1\"])\n            .pipe_in(\"91\\n82\\n7_3\")\n            .succeeds()\n            .stdout_only(\"7\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_get_tombstone_store", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_get_tombstone_store() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let client = new_client(eps, None);\n\n    let mut all_stores = vec![];\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    client.bootstrap_cluster(store.clone(), region).unwrap();\n\n    all_stores.push(store);\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n    let s = client.get_all_stores(false).unwrap();\n    assert_eq!(s, all_stores);\n\n    // Add tombstone store.\n    let mut store99 = metapb::Store::default();\n    store99.set_id(99);\n    store99.set_state(metapb::StoreState::Tombstone);\n    server.default_handler().add_store(store99.clone());\n\n    let r = block_on(client.get_store_async(99));\n    assert_eq!(r.unwrap_err().error_code(), error_code::pd::STORE_TOMBSTONE);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_https_tests.rs::test_example_https_toml_startup", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_example_https_toml_startup() {\n    // env_logger::try_init().ok();\n\n    const ALPN_H2: &[u8] = b\"h2\";\n\n    named_test_harness(\"dns_over_https.toml\", move |_, _, _, https_port, _| {\n        let mut cert_der = vec![];\n        let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"..\".to_owned());\n        println!(\"using server src path: {server_path}\");\n\n        File::open(format!(\n            \"{server_path}/tests/test-data/test_configs/sec/example.cert\"\n        ))\n        .expect(\"failed to open cert\")\n        .read_to_end(&mut cert_der)\n        .expect(\"failed to read cert\");\n\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = (\"127.0.0.1\", https_port.expect(\"no https_port\"))\n            .to_socket_addrs()\n            .unwrap()\n            .next()\n            .unwrap();\n\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        // using the mozilla default root store\n        let mut root_store = RootCertStore::empty();\n        root_store.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {\n            OwnedTrustAnchor::from_subject_spki_name_constraints(\n                ta.subject,\n                ta.spki,\n                ta.name_constraints,\n            )\n        }));\n\n        let cert = to_trust_anchor(&cert_der);\n        root_store.add(&cert).unwrap();\n\n        let mut client_config = ClientConfig::builder()\n            .with_safe_default_cipher_suites()\n            .with_safe_default_kx_groups()\n            .with_safe_default_protocol_versions()\n            .unwrap()\n            .with_root_certificates(root_store)\n            .with_no_client_auth();\n        client_config.alpn_protocols.push(ALPN_H2.to_vec());\n\n        let client_config = Arc::new(client_config);\n\n        let https_builder = HttpsClientStreamBuilder::with_client_config(client_config);\n\n        let mp = https_builder\n            .build::<AsyncIoTokioAsStd<TokioTcpStream>>(addr, \"ns.example.com\".to_string());\n        let client = AsyncClient::connect(mp);\n\n        // ipv4 should succeed\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        query_a(&mut io_loop, &mut client);\n\n        // a second request should work...\n        query_a(&mut io_loop, &mut client);\n    })\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_hex16", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hex16() {\n    let input: [u8; 9] = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xff];\n    // spell-checker:disable\n    let expected_output = unindent(\n        \"\n            0000000 2301 6745 ab89 efcd 00ff\n            0000011\n            \",\n    );\n    // spell-checker:enable\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-x\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::non_page_size_multiple", "code": "pub fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &mut self,\n        transaction: &'txn WriteTransaction<'db>,\n        definition: TableDefinition<K, V>,\n    ) -> Result<Table<'db, 'txn, K, V>, TableError> {\n        #[cfg(feature = \"logging\")]\n        info!(\"Opening table: {}\", definition);\n        let root = self.inner_open::<K, V>(definition.name(), TableType::Normal)?;\n        transaction.dirty.store(true, Ordering::Release);\n\n        Ok(Table::new(\n            definition.name(),\n            root,\n            transaction.freed_pages.clone(),\n            transaction.mem,\n            transaction,\n        ))\n    }", "test": "fn non_page_size_multiple() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n    let key = vec![0u8; 1024];\n    let value = vec![0u8; 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        table.insert(key.as_slice(), value.as_slice()).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(SLICE_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_from_si", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_from_si() {\n    new_ucmd!()\n        .args(&[\"--from=si\"])\n        .pipe_in(\"1000\\n1.1M\\n0.1G\")\n        .run()\n        .stdout_is(\"1000\\n1100000\\n100000000\\n\");\n}"}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::zlib_encoder_empty_read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "test": "fn zlib_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::ZlibEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_trailing_comma", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_create_table_trailing_comma() {\n    let sql = \"CREATE TABLE foo (bar int,)\";\n    all_dialects().one_statement_parses_to(sql, \"CREATE TABLE foo (bar INT)\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_no_parent", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mkdir_no_parent() {\n    let _guard = TEST_MUTEX.lock();\n    new_ucmd!().arg(\"parent_dir/child_dir\").fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_column", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_column() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    let req = new_analyze_column_req(&product, 3, 3, 3, 3, 4, 32);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeColumnsResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let hist = analyze_resp.get_pk_hist();\n    assert_eq!(hist.get_buckets().len(), 2);\n    assert_eq!(hist.get_ndv(), 4);\n    let collectors = analyze_resp.get_collectors().to_vec();\n    assert_eq!(collectors.len(), product.columns_info().len() - 1);\n    assert_eq!(collectors[0].get_null_count(), 1);\n    assert_eq!(collectors[0].get_count(), 3);\n    let rows = collectors[0].get_cm_sketch().get_rows();\n    assert_eq!(rows.len(), 4);\n    let sum: u32 = rows.first().unwrap().get_counters().iter().sum();\n    assert_eq!(sum, 3);\n    assert_eq!(collectors[0].get_total_size(), 21);\n    assert_eq!(collectors[1].get_total_size(), 4);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_tasklist.rs::gfm_tasklist_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_tasklist_test_2() {\n    let original = r##\"- [x] foo\n  - [ ] bar\n  - [x] baz\n- [ ] bim\n\"##;\n    let expected = r##\"<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> foo\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> bar</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> baz</li>\n</ul>\n</li>\n<li><input disabled=\"\" type=\"checkbox\"> bim</li>\n</ul>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_corner_case4", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_corner_case4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/-10\", \"/30/-4\"])\n        .succeeds()\n        .stdout_only(\"18\\n48\\n75\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 26));\n    assert_eq!(at.read(\"xx02\"), generate(26, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_separator_and_terminator", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_separator_and_terminator() {\n    new_ucmd!()\n        .args(&[\"-s\", \",\", \"-t\", \"!\", \"2\", \"6\"])\n        .run()\n        .stdout_is(\"2,3,4,5,6!\");\n    new_ucmd!()\n        .args(&[\"-s\", \",\", \"2\", \"6\"])\n        .run()\n        .stdout_is(\"2,3,4,5,6\\n\");\n    new_ucmd!()\n        .args(&[\"-s\", \"\\n\", \"2\", \"6\"])\n        .run()\n        .stdout_is(\"2\\n3\\n4\\n5\\n6\\n\");\n    new_ucmd!()\n        .args(&[\"-s\", \"\\\\n\", \"2\", \"6\"])\n        .run()\n        .stdout_is(\"2\\\\n3\\\\n4\\\\n5\\\\n6\\n\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ignore_vcs_ignored_file_via_cli", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ignore_vcs_ignored_file_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let git_ignore = r#\"\nfile2.js\n\"#;\n\n    let code2 = r#\"foo.call();\n\n\n    bar.call();\"#;\n    let code1 = r#\"array.map(sentence => sentence.split(' ')).flat();\"#;\n\n    // ignored files\n    let file_path1 = Path::new(\"file1.js\");\n    fs.insert(file_path1.into(), code1.as_bytes());\n    let file_path2 = Path::new(\"file2.js\");\n    fs.insert(file_path2.into(), code2.as_bytes());\n\n    // git folder\n    let git_folder = Path::new(\"./.git\");\n    fs.insert(git_folder.into(), \"\".as_bytes());\n\n    // git ignore file\n    let ignore_file = Path::new(\"./.gitignore\");\n    fs.insert(ignore_file.into(), git_ignore.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--vcs-enabled=true\"),\n                (\"--vcs-client-kind=git\"),\n                (\"--vcs-use-ignore-file=true\"),\n                (\"--vcs-root=.\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignore_vcs_ignored_file_via_cli\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_ignore_initial_plus", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_ignore_initial_plus() {\n    new_ucmd!()\n        .args(&[\"--tabs=+3\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"   a  b  c\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/fuel_metering.rs::metered_i32_add", "code": "pub fn fuel_consumed(&self) -> u64 {\n        self.total.wrapping_sub(self.remaining)\n    }", "test": "fn metered_i32_add() {\n    let wasm = wat2wasm(\n        r#\"\n        (module\n            (func (export \"test\") (param $a i32) (param $b i32) (result i32)\n                (i32.add\n                    (local.get $a)\n                    (local.get $b)\n                )\n            )\n        )\n    \"#,\n    );\n    let (mut store, func) = default_test_setup(&wasm);\n    let func = func.typed::<(i32, i32), i32>(&store).unwrap();\n    // No fuel -> no success.\n    assert_out_of_fuel(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(0));\n    // Now add too little fuel for a start, so still no success.\n    store.add_fuel(1).unwrap();\n    assert_out_of_fuel(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(0));\n    // Now add enough fuel, so execution should succeed.\n    store.add_fuel(10).unwrap();\n    assert_success(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(5));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_as_other_option_value", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_obs_lines_as_other_option_value() {\n    // This test will ensure that:\n    // if obsolete lines option is used incorrectly and treated as a hyphen prefixed value of other option - it fails\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n        .ucmd()\n        .args(&[\"--lines\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of lines: '-200'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-l\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of lines: '-200'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-a\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid suffix length: '-200'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--suffix-length\", \"-d200e\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid suffix length: '-d200e'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-C\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of bytes: '-200'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--line-bytes\", \"-x200a4\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of bytes: '-x200a4'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-b\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of bytes: '-200'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--bytes\", \"-200xd\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of bytes: '-200xd'\\n\");\n    scene\n        .ucmd()\n        .args(&[\"-n\", \"-200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of chunks: -200\\n\");\n    scene\n        .ucmd()\n        .args(&[\"--number\", \"-e200\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"split: invalid number of chunks: -e200\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dirname.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit2_wasi_snapshot0", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit2_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit2_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 2);\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_cdc_rawkv_basic", "code": "pub fn pop(&self) -> Option<(TimeStamp, bool /* is_used_up */)> {\n        // alloc_offset might be far bigger than logical_end if the concurrency is\n        // *very* high, but it won't overflow in practice, so no need to do an\n        // extra load check here.\n        let ts = self.alloc_offset.fetch_add(1, Ordering::Relaxed);\n        if ts < self.logical_end {\n            return Some((\n                TimeStamp::compose(self.physical, ts),\n                ts + 1 == self.logical_end,\n            ));\n        }\n        None\n    }", "test": "fn test_cdc_rawkv_basic() {\n    let mut suite = TestSuite::new(1, ApiVersion::V2);\n\n    // rawkv\n    let mut req = suite.new_changedata_request(1);\n    req.set_kv_api(ChangeDataRequestKvApi::RawKv);\n    let (mut req_tx, _event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(1));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n\n    let event = receive_event(false);\n    event.events.into_iter().for_each(|e| {\n        match e.event.unwrap() {\n            // Even if there is no write,\n            // it should always outputs an Initialized event.\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        }\n    });\n    // Sleep a while to make sure the stream is registered.\n    sleep_ms(1000);\n    // There must be a delegate.\n    let scheduler = suite.endpoints.values().next().unwrap().scheduler();\n    scheduler\n        .schedule(Task::Validate(Validate::Region(\n            1,\n            Box::new(|delegate| {\n                let d = delegate.unwrap();\n                assert_eq!(d.downstreams().len(), 1);\n            }),\n        )))\n        .unwrap();\n\n    // If tikv enable ApiV2, raw key needs to start with 'r';\n    let (k, v) = (b\"rkey1\".to_vec(), b\"value\".to_vec());\n    suite.must_kv_put(1, k, v);\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1, \"{:?}\", events);\n\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Entries(entries) => {\n            assert_eq!(entries.entries.len(), 1);\n            assert_eq!(entries.entries[0].get_type(), EventLogType::Committed);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    // boundary case\n    let (k, v) = (b\"r\\0\".to_vec(), b\"value\".to_vec());\n    suite.must_kv_put(1, k, v);\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1, \"{:?}\", events);\n\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Entries(entries) => {\n            assert_eq!(entries.entries.len(), 1);\n            assert_eq!(entries.entries[0].get_type(), EventLogType::Committed);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_replication_mode_allowlist", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_replication_mode_allowlist() {\n    let mut cluster = prepare_cluster();\n    run_cluster(&mut cluster);\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::Async, vec![1]);\n    thread::sleep(Duration::from_millis(100));\n\n    // 2,3 are paused, so it should not be able to write.\n    let region = cluster.get_region(b\"k1\");\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k2\", b\"v2\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n\n    // clear allowlist.\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::Async, vec![]);\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_read.rs::test_snap_with_invalid_parameter", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_snap_with_invalid_parameter() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let region_id = 2;\n    let mut req = router.new_request_for(region_id);\n    let mut request_inner = Request::default();\n    request_inner.set_cmd_type(CmdType::Snap);\n    req.mut_requests().push(request_inner);\n\n    // store_id is incorrect;\n    let mut invalid_req = req.clone();\n    invalid_req.mut_header().set_peer(new_peer(2, 3));\n    let res = router.query(region_id, invalid_req).unwrap();\n    let error_resp = res.response().unwrap();\n    assert!(error_resp.get_header().has_error());\n\n    // run again, with incorrect peer_id\n    let mut invalid_req = req.clone();\n    invalid_req.mut_header().set_peer(new_peer(1, 4));\n    let res = router.query(region_id, invalid_req).unwrap();\n    let error_resp = res.response().unwrap();\n    assert!(error_resp.get_header().has_error());\n\n    // run with stale term\n    let mut invalid_req = req.clone();\n    invalid_req.mut_header().set_term(1);\n    let res = router.query(region_id, invalid_req).unwrap();\n    let error_resp = res.response().unwrap();\n    assert!(error_resp.get_header().has_error());\n\n    // run with stale read\n    let mut invalid_req = req.clone();\n    invalid_req\n        .mut_header()\n        .set_flags(WriteBatchFlags::STALE_READ.bits());\n    let res = router.query(region_id, invalid_req).unwrap();\n    let error_resp = res.response().unwrap();\n    assert!(error_resp.get_header().has_error());\n\n    // run again with invalid region_epoch\n    let mut invalid_req = req.clone();\n    let invalid_ver = req.get_header().get_region_epoch().get_version() + 1;\n    invalid_req\n        .mut_header()\n        .mut_region_epoch()\n        .set_version(invalid_ver);\n    let res = router.query(region_id, invalid_req).unwrap();\n    let error_resp = res.response().unwrap();\n    assert!(error_resp.get_header().has_error());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_multiple", "code": "pub fn has_weak_maps() -> bool {\n    BOA_GC.with(|current| {\n        let gc = current.borrow();\n\n        gc.weak_map_start.get().is_some()\n    })\n}", "test": "fn weak_map_multiple() {\n    run_test(|| {\n        let key1 = Gc::new(String::from(\"key1\"));\n        let key2 = Gc::new(String::from(\"key2\"));\n        let key3 = Gc::new(String::from(\"key3\"));\n\n        assert!(!has_weak_maps());\n\n        let mut map_1 = WeakMap::new();\n        let mut map_2 = WeakMap::new();\n\n        assert!(has_weak_maps());\n\n        map_1.insert(&key1, ());\n        map_1.insert(&key2, ());\n        map_2.insert(&key3, ());\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(map_1.contains_key(&key1));\n        assert!(map_1.contains_key(&key2));\n        assert!(!map_1.contains_key(&key3));\n        assert!(!map_2.contains_key(&key1));\n        assert!(!map_2.contains_key(&key2));\n        assert!(map_2.contains_key(&key3));\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(key1);\n        drop(key2);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(!map_1.contains_key(&key3));\n        assert!(map_2.contains_key(&key3));\n\n        drop(key3);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(map_1);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(map_2);\n\n        force_collect();\n        assert!(!has_weak_maps());\n    });\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_remove_existing_same_src_and_dest", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_remove_existing_same_src_and_dest() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"a\");\n    at.write(\"a\", \"sample\");\n    ucmd.args(&[\"-sf\", \"a\", \"a\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"'a' and 'a' are the same file\");\n    assert!(at.file_exists(\"a\") && !at.symlink_exists(\"a\"));\n    assert_eq!(at.read(\"a\"), \"sample\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_many_results_works", "code": "fn ascending_tuple() -> I32x16 {\n    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n}", "test": "fn static_many_results_works() {\n    let (mut store, func) = setup_many_results();\n    let typed_func = func.typed::<(), I32x16>(&mut store).unwrap();\n    let result = typed_func.call(&mut store, ()).unwrap();\n    let expected = ascending_tuple();\n    assert_eq_tuple!(result, expected; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_default_allows_final_non_existent", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_realpath_default_allows_final_non_existent() {\n    let p = Path::new(\"\").join(GIBBERISH);\n    let (at, mut ucmd) = at_and_ucmd!();\n    let expect = path_concat!(at.root_dir_resolved(), p.to_str().unwrap()) + \"\\n\";\n    ucmd.arg(p.as_os_str()).succeeds().stdout_only(expect);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_split_merge", "code": "pub fn call_command_on_leader(\n        &mut self,\n        mut request: RaftCmdRequest,\n        timeout: Duration,\n    ) -> Result<RaftCmdResponse> {\n        let timer = Instant::now();\n        let region_id = request.get_header().get_region_id();\n        loop {\n            let leader = match self.leader_of_region(region_id) {\n                None => return Err(Error::NotLeader(region_id, None)),\n                Some(l) => l,\n            };\n            request.mut_header().set_peer(leader);\n            let resp = match self.call_command(request.clone(), timeout) {\n                e @ Err(_) => return e,\n                Ok(resp) => resp,\n            };\n            if self.refresh_leader_if_needed(&resp, region_id)\n                && timer.saturating_elapsed() < timeout\n            {\n                warn!(\n                    \"{:?} is no longer leader, let's retry\",\n                    request.get_header().get_peer()\n                );\n                continue;\n            }\n            return Ok(resp);\n        }\n    }", "test": "fn test_witness_split_merge() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    // nonwitness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n    let before = cluster\n        .apply_state(region.get_id(), nodes[2])\n        .get_applied_index();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.must_split(&region, b\"k2\");\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    must_get_none(&cluster.get_engine(3), b\"k2\");\n    // applied index of witness is updated\n    let after = cluster\n        .apply_state(region.get_id(), nodes[2])\n        .get_applied_index();\n    assert!(after - before >= 3);\n\n    // the newly split peer should be witness as well\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k2\");\n    assert_ne!(left.get_id(), right.get_id());\n    assert!(find_peer(&left, nodes[2]).unwrap().is_witness);\n    assert!(find_peer(&right, nodes[2]).unwrap().is_witness);\n\n    // merge\n    pd_client.must_merge(left.get_id(), right.get_id());\n    let after_merge = cluster.get_region(b\"k1\");\n    assert!(find_peer(&after_merge, nodes[2]).unwrap().is_witness);\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    must_get_none(&cluster.get_engine(3), b\"k2\");\n    // epoch of witness is updated\n    assert_eq!(\n        cluster\n            .region_local_state(after_merge.get_id(), nodes[2])\n            .get_region()\n            .get_region_epoch(),\n        after_merge.get_region_epoch()\n    );\n\n    // split again\n    cluster.must_split(&after_merge, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k2\");\n    assert!(find_peer(&left, nodes[2]).unwrap().is_witness);\n    assert!(find_peer(&right, nodes[2]).unwrap().is_witness);\n\n    // can't merge with different witness location\n    let peer_on_store3 = find_peer(&left, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        left.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![false],\n    );\n    let left = cluster.get_region(b\"k1\");\n    let req = new_admin_request(\n        left.get_id(),\n        left.get_region_epoch(),\n        new_prepare_merge(right),\n    );\n    let resp = cluster\n        .call_command_on_leader(req, Duration::from_millis(100))\n        .unwrap();\n    assert!(\n        resp.get_header()\n            .get_error()\n            .get_message()\n            .contains(\"peers doesn't match\")\n    );\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_numbers", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn test_numbers() {\n    let needle = \"{$x = 10;}\";\n    let source = r\"\n    void func(){\n        a = 10; // match\n        b = 0xa; // match\n        c = 10u; // match\n        d = 012; // match\n        f = 0x100; // no match\n        g = 0x10; // no match\n        h = 010; // no match\n        i = 3.14 // no match \n    }}\";\n\n    let matches = parse_and_match_cpp(needle, source);\n\n    assert_eq!(matches, 4);\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/matching.rs::check_engine_matching", "code": "pub fn is_redirect(&self) -> bool {\n        self.mask.contains(NetworkFilterMask::IS_REDIRECT)\n    }", "test": "fn check_engine_matching() {\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    for req in requests {\n        if req.url == \"http://\" || req.url == \"https://\" {\n            continue;\n        }\n        for filter in req.filters {\n            let opts = ParseOptions::default();\n            let mut engine = Engine::from_rules_debug(&[filter.clone()], opts);\n            let resources = build_resources_from_filters(&[filter.clone()]);\n            engine.use_resources(resources);\n\n            let network_filter_res = NetworkFilter::parse(&filter, true, opts);\n            assert!(\n                network_filter_res.is_ok(),\n                \"Could not parse filter {}\",\n                filter\n            );\n            let network_filter = network_filter_res.unwrap();\n\n            let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n            let result = engine.check_network_request(&request);\n\n            if network_filter.is_exception() {\n                assert!(\n                    !result.matched,\n                    \"Expected {} to NOT match {} at {}, typed {}\",\n                    filter, req.url, req.sourceUrl, req.r#type\n                );\n                // assert!(result.exception.is_some(), \"Expected exception {} to match {} at {}, typed {}\", filter, req.url, req.sourceUrl, req.r#type);\n            } else {\n                assert!(\n                    result.matched,\n                    \"Expected {} to match {} at {}, typed {}\",\n                    filter, req.url, req.sourceUrl, req.r#type\n                );\n            }\n\n            if network_filter.is_redirect() {\n                assert!(\n                    result.redirect.is_some(),\n                    \"Expected {} to trigger redirect rule {}\",\n                    req.url,\n                    filter\n                );\n                let resource = result.redirect.unwrap();\n                // each redirect resource is base64 encoded\n                assert!(resource.contains(\"base64\"));\n            }\n        }\n    }\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_public_key", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_public_key() {\n    let s = include_str!(\"data/serde/public_key_hex\");\n    let pk = PublicKey::from_str(s.trim()).unwrap();\n    let got = serialize(&pk).unwrap();\n    let want = include_bytes!(\"data/serde/public_key_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/push_promise.rs::recv_push_promise_over_max_header_list_size", "code": "pub fn reason(&self) -> Option<Reason> {\n        match self.kind {\n            Kind::Reset(_, reason, _) | Kind::GoAway(_, reason, _) | Kind::Reason(reason) => {\n                Some(reason)\n            }\n            _ => None,\n        }\n    }", "test": "async fn recv_push_promise_over_max_header_list_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_frame_eq(settings, frames::settings().max_header_list_size(10));\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(\n            frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n        )\n        .await;\n        srv.recv_frame(frames::reset(2).refused()).await;\n        srv.send_frame(frames::headers(1).response(200).eos()).await;\n        idle_ms(10).await;\n    };\n\n    let client = async move {\n        let (mut client, mut conn) = client::Builder::new()\n            .max_header_list_size(10)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req = async move {\n            let err = client\n                .send_request(request, true)\n                .expect(\"send_request\")\n                .0\n                .await\n                .expect_err(\"response\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        conn.drive(req).await;\n        conn.await.expect(\"client\");\n    };\n    join(srv, client).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8() {\n    new_ucmd!()\n        .args(&[\"-lwmcL\"])\n        .pipe_in_fixture(\"UTF_8_test.txt\")\n        .run()\n        .stdout_is(\"    303    2119   22457   23025      79\\n\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_recv_headers_only", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn send_recv_headers_only() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 5, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[0, 0, 1, 1, 5, 0, 0, 0, 1, 0x89])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::NO_CONTENT);\n\n    h2.await.unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_stdin_skip_invalid_fields_obsolete", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_stdin_skip_invalid_fields_obsolete() {\n    new_ucmd!()\n        .args(&[\"-5deadbeef\"])\n        .run()\n        .failure()\n        .stderr_only(\"uniq: Invalid argument for skip-fields: 5deadbeef\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_window_functions", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_window_functions() {\n    let sql = \"SELECT row_number() OVER (ORDER BY dt DESC), \\\n               sum(foo) OVER (PARTITION BY a, b ORDER BY c, d \\\n               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), \\\n               avg(bar) OVER (ORDER BY a \\\n               RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING), \\\n               sum(bar) OVER (ORDER BY a \\\n               RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND INTERVAL '1 MONTH' FOLLOWING), \\\n               COUNT(*) OVER (ORDER BY a \\\n               RANGE BETWEEN INTERVAL '1 DAY' PRECEDING AND INTERVAL '1 DAY' FOLLOWING), \\\n               max(baz) OVER (ORDER BY a \\\n               ROWS UNBOUNDED PRECEDING), \\\n               sum(qux) OVER (ORDER BY a \\\n               GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING) \\\n               FROM foo\";\n    let select = verified_only_select(sql);\n    assert_eq!(7, select.projection.len());\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"row_number\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: Some(WindowType::WindowSpec(WindowSpec {\n                partition_by: vec![],\n                order_by: vec![OrderByExpr {\n                    expr: Expr::Identifier(Ident::new(\"dt\")),\n                    asc: Some(false),\n                    nulls_first: None,\n                }],\n                window_frame: None,\n            })),\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[0])\n    );\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_in_separate_outputs_with_parent", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn batch_in_separate_outputs_with_parent() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let parent_output = CommandBuilder::new(\"wallet inscribe --fee-rate 5.0 --file parent.png\")\n    .write(\"parent.png\", [1; 520])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let parent_id = parent_output.inscriptions[0].id;\n\n  let output = CommandBuilder::new(\"wallet inscribe --fee-rate 1 --batch batch.yaml\")\n    .write(\"inscription.txt\", \"Hello World\")\n    .write(\"tulip.png\", [0; 555])\n    .write(\"meow.wav\", [0; 2048])\n    .write(\n      \"batch.yaml\",\n      format!(\"parent: {parent_id}\\nmode: separate-outputs\\ninscriptions:\\n- file: inscription.txt\\n- file: tulip.png\\n- file: meow.wav\\n\")\n    )\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  for inscription in &output.inscriptions {\n    assert_eq!(inscription.location.offset, 0);\n  }\n  let mut outpoints = output\n    .inscriptions\n    .iter()\n    .map(|inscription| inscription.location.outpoint)\n    .collect::<Vec<OutPoint>>();\n  outpoints.sort();\n  outpoints.dedup();\n  assert_eq!(outpoints.len(), output.inscriptions.len());\n\n  rpc_server.mine_blocks(1);\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[]);\n\n  let output_1 = output.inscriptions[0].location.outpoint;\n  let output_2 = output.inscriptions[1].location.outpoint;\n  let output_3 = output.inscriptions[2].location.outpoint;\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[0].id),\n    format!(\n      r\".*<dt>parent</dt>\\s*<dd>.*{parent_id}.*</dd>.*<dt>output value</dt>.*<dd>10000</dd>.*.*<dt>location</dt>.*<dd class=monospace>{}:0</dd>.*\",\n      output_1\n    ),\n  );\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[1].id),\n    format!(\n      r\".*<dt>parent</dt>\\s*<dd>.*{parent_id}.*</dd>.*<dt>output value</dt>.*<dd>10000</dd>.*.*<dt>location</dt>.*<dd class=monospace>{}:0</dd>.*\",\n      output_2\n    ),\n  );\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[2].id),\n    format!(\n      r\".*<dt>parent</dt>\\s*<dd>.*{parent_id}.*</dd>.*<dt>output value</dt>.*<dd>10000</dd>.*.*<dt>location</dt>.*<dd class=monospace>{}:0</dd>.*\",\n      output_3\n    ),\n  );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printf.rs::escaped_unicode_four_digit", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn escaped_unicode_four_digit() {\n    new_ucmd!().args(&[\"\\\\u0125\"]).succeeds().stdout_only(\"\u0125\");\n}\n"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::manually_destroy", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn manually_destroy() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n\n                (core module $m\n                  (global $drops (mut i32) i32.const 0)\n                  (global $last-drop (mut i32) i32.const 0)\n\n                  (func (export \"dtor\") (param i32)\n                    (global.set $drops (i32.add (global.get $drops) (i32.const 1)))\n                    (global.set $last-drop (local.get 0))\n                  )\n                  (func (export \"drops\") (result i32) global.get $drops)\n                  (func (export \"last-drop\") (result i32) global.get $last-drop)\n                  (func (export \"pass\") (param i32) (result i32) local.get 0)\n                )\n                (core instance $i (instantiate $m))\n                (type $t2' (resource (rep i32) (dtor (func $i \"dtor\"))))\n                (export $t2 \"t2\" (type $t2'))\n                (core func $ctor (canon resource.new $t2))\n                (func (export \"[constructor]t2\") (param \"rep\" u32) (result (own $t2))\n                  (canon lift (core func $ctor)))\n                (func (export \"[static]t2.drops\") (result u32)\n                  (canon lift (core func $i \"drops\")))\n                (func (export \"[static]t2.last-drop\") (result u32)\n                  (canon lift (core func $i \"last-drop\")))\n\n                (func (export \"t1-pass\") (param \"t\" (own $t1)) (result (own $t1))\n                  (canon lift (core func $i \"pass\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    #[derive(Default)]\n    struct Data {\n        drops: u32,\n        last_drop: Option<u32>,\n    }\n\n    let mut store = Store::new(&engine, Data::default());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |mut cx, rep| {\n        let data: &mut Data = cx.data_mut();\n        data.drops += 1;\n        data.last_drop = Some(rep);\n        Ok(())\n    })?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let t2_ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"[constructor]t2\")?;\n    let t2_drops = i.get_typed_func::<(), (u32,)>(&mut store, \"[static]t2.drops\")?;\n    let t2_last_drop = i.get_typed_func::<(), (u32,)>(&mut store, \"[static]t2.last-drop\")?;\n    let t1_pass = i.get_typed_func::<(Resource<MyType>,), (ResourceAny,)>(&mut store, \"t1-pass\")?;\n\n    // Host resources can be destroyed through `resource_drop`\n    let t1 = Resource::new_own(100);\n    let (t1,) = t1_pass.call(&mut store, (t1,))?;\n    t1_pass.post_return(&mut store)?;\n    assert_eq!(store.data().drops, 0);\n    assert_eq!(store.data().last_drop, None);\n    t1.resource_drop(&mut store)?;\n    assert_eq!(store.data().drops, 1);\n    assert_eq!(store.data().last_drop, Some(100));\n\n    // Guest resources can be destroyed through `resource_drop`\n    let (t2,) = t2_ctor.call(&mut store, (200,))?;\n    t2_ctor.post_return(&mut store)?;\n    assert_eq!(t2_drops.call(&mut store, ())?, (0,));\n    t2_drops.post_return(&mut store)?;\n    assert_eq!(t2_last_drop.call(&mut store, ())?, (0,));\n    t2_last_drop.post_return(&mut store)?;\n    t2.resource_drop(&mut store)?;\n    assert_eq!(t2_drops.call(&mut store, ())?, (1,));\n    t2_drops.post_return(&mut store)?;\n    assert_eq!(t2_last_drop.call(&mut store, ())?, (200,));\n    t2_last_drop.post_return(&mut store)?;\n\n    // Wires weren't crossed to drop more resources\n    assert_eq!(store.data().drops, 1);\n    assert_eq!(store.data().last_drop, Some(100));\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_pseudofloat_equal", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_pseudofloat_equal() {\n    // string comparison; test(1) doesn't support comparison of actual floats\n    new_ucmd!().args(&[\"123.45\", \"=\", \"123.45\"]).succeeds();\n}"}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/connection_reset.rs::test_server_close", "code": "pub fn is_close(&self) -> bool {\n        matches!(*self, Message::Close(_))\n    }", "test": "fn test_server_close() {\n    do_test(\n        3012,\n        |mut cli_sock| {\n            cli_sock.send(Message::Text(\"Hello WebSocket\".into())).unwrap();\n\n            let message = cli_sock.read().unwrap(); // receive close from server\n            assert!(message.is_close());\n\n            let err = cli_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n        |mut srv_sock| {\n            let message = srv_sock.read().unwrap();\n            assert_eq!(message.into_data(), b\"Hello WebSocket\");\n\n            srv_sock.close(None).unwrap(); // send close to client\n\n            let message = srv_sock.read().unwrap(); // receive acknowledgement\n            assert!(message.is_close());\n\n            let err = srv_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_size_v2", "code": "fn region_size<T: AsRef<str>>(&self, region_id: u64, cfs: Vec<T>) -> Result<Vec<(T, usize)>> {\n        let region_state_key = keys::region_state_key(region_id);\n        match self\n            .engines\n            .kv\n            .get_msg_cf::<RegionLocalState>(CF_RAFT, &region_state_key)\n        {\n            Ok(Some(region_state)) => {\n                let region = region_state.get_region();\n                let start_key = &keys::data_key(region.get_start_key());\n                let end_key = &keys::data_end_key(region.get_end_key());\n                let mut sizes = vec![];\n                for cf in cfs {\n                    let mut size = 0;\n                    box_try!(self.engines.kv.scan(\n                        cf.as_ref(),\n                        start_key,\n                        end_key,\n                        false,\n                        |k, v| {\n                            size += k.len() + v.len();\n                            Ok(true)\n                        }\n                    ));\n                    sizes.push((cf, size));\n                }\n                Ok(sizes)\n            }\n            Ok(None) => Err(Error::NotFound(format!(\"none region {:?}\", region_id))),\n            Err(e) => Err(box_err!(e)),\n        }\n    }", "test": "fn test_debug_region_size_v2() {\n    let (cluster, debug_client, store_id) = test_raftstore_v2::must_new_cluster_and_debug_client();\n    let raft_engine = cluster.get_raft_engine(store_id);\n    let engine = cluster.get_engine(store_id);\n\n    let mut lb = raft_engine.log_batch(10);\n    // Put some data.\n    let region_id = 1;\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.set_start_key(b\"a\".to_vec());\n    region.set_end_key(b\"z\".to_vec());\n    let mut state = RegionLocalState::default();\n    state.set_region(region);\n    state.set_tablet_index(5);\n    lb.put_region_state(region_id, 5, &state).unwrap();\n    raft_engine.consume(&mut lb, false).unwrap();\n\n    let cfs = vec![CF_DEFAULT, CF_LOCK, CF_WRITE];\n    // At lease 8 bytes for the WRITE cf.\n    let (k, v) = (keys::data_key(b\"kkkk_kkkk\"), b\"v\");\n    for cf in &cfs {\n        engine.put_cf(cf, k.as_slice(), v).unwrap();\n    }\n\n    let mut req = debugpb::RegionSizeRequest::default();\n    req.set_region_id(region_id);\n    req.set_cfs(cfs.iter().map(|s| s.to_string()).collect());\n    let entries: Vec<_> = debug_client\n        .region_size(&req)\n        .unwrap()\n        .take_entries()\n        .into();\n    assert_eq!(entries.len(), 3);\n    for e in entries {\n        cfs.iter().find(|&&c| c == e.cf).unwrap();\n        assert!(e.size > 0);\n    }\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_size(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/slash_operator.rs::no_rhs_once", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn no_rhs_once() {\n  Test::new()\n    .justfile(\"x := 'a' /\")\n    .stderr(\n      \"\n      error: Expected backtick, identifier, '(', '/', or string, but found end of file\n        |\n      1 | x := 'a' /\n        |           ^\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::wildcard", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn wildcard() {\n    let needle = \"{for (_; _; $i++){$x[$i]=_;}}\";\n    let source = \"void bar() {for(int i=0; i<10; i++) {buf[i]=10;}}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_cleanup_sst", "code": "pub fn send_upload_sst(\n    client: &ImportSstClient,\n    meta: &SstMeta,\n    data: &[u8],\n) -> Result<UploadResponse> {\n    let mut r1 = UploadRequest::default();\n    r1.set_meta(meta.clone());\n    let mut r2 = UploadRequest::default();\n    r2.set_data(data.to_vec());\n    let reqs: Vec<_> = vec![r1, r2]\n        .into_iter()\n        .map(|r| Result::Ok((r, WriteFlags::default())))\n        .collect();\n    let (mut tx, rx) = client.upload().unwrap();\n    let mut stream = stream::iter(reqs);\n    block_on(async move {\n        tx.send_all(&mut stream).await?;\n        tx.close().await?;\n        rx.await\n    })\n}", "test": "fn test_cleanup_sst() {\n    let (mut cluster, ctx, _, import) = new_cluster_and_tikv_import_client();\n\n    let temp_dir = Builder::new().prefix(\"test_cleanup_sst\").tempdir().unwrap();\n\n    let sst_path = temp_dir.path().join(\"test_split.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    // Can not upload the same file when it exists.\n    assert_to_string_contains!(\n        send_upload_sst(&import, &meta, &data).unwrap_err(),\n        \"FileExists\"\n    );\n\n    // The uploaded SST should be deleted if the region split.\n    let region = cluster.get_region(&[]);\n    cluster.must_split(&region, &[100]);\n\n    check_sst_deleted(&import, &meta, &data);\n\n    let left = cluster.get_region(&[]);\n    let right = cluster.get_region(&[100]);\n\n    let sst_path = temp_dir.path().join(\"test_merge.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(left.get_id());\n    meta.set_region_epoch(left.get_region_epoch().clone());\n\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    // The uploaded SST should be deleted if the region merged.\n    cluster.pd_client.must_merge(left.get_id(), right.get_id());\n    let res = block_on(cluster.pd_client.get_region_by_id(left.get_id()));\n    assert_eq!(res.unwrap(), None);\n\n    check_sst_deleted(&import, &meta, &data);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::empty_function_returns_undefined", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn empty_function_returns_undefined() {\n    run_test_actions([TestAction::assert_eq(\n        \"(function () {}) ()\",\n        JsValue::undefined(),\n    )]);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/errors.rs::test_fuzzer_input_4", "code": "fn parse_all_options(md: &str) {\n    let parser = Parser::new_ext(md, Options::all());\n\n    for _ in parser {}\n}", "test": "fn test_fuzzer_input_4() {\n    parse_all_options(\"\\u{0}{\\t\u03d0}\\n-\");\n}\n"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_request_in_joint_state", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_request_in_joint_state() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_learner_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Enter joint, now we have C_old(1, 2) and C_new(1, 3)\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n        ],\n    );\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    // Both new and old configuation have the newest log\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n\n    let region = cluster.get_region(b\"k1\");\n\n    // Isolated peer 2, so the old configuation can't reach quorum\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n    let mut rx = cluster\n        .async_request(put_request(&region, 1, b\"k3\", b\"v3\"))\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    cluster.clear_send_filters();\n\n    // Isolated peer 3, so the new configuation can't reach quorum\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    let mut rx = cluster\n        .async_request(put_request(&region, 1, b\"k4\", b\"v4\"))\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    cluster.clear_send_filters();\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n\n    // Isolated peer 2, but it is not in quorum any more\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n    cluster.must_put(b\"k5\", b\"v5\");\n    must_get_equal(&cluster.get_engine(3), b\"k5\", b\"v5\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_all", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_all() {\n    new_ucmd!()\n        .arg(\"-lwmcL\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25      87     442     513      48\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_number_kth_of_n_round_robin", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_number_kth_of_n_round_robin() {\n    new_ucmd!()\n        .args(&[\"--number\", \"r/2/3\", \"fivelines.txt\"])\n        .succeeds()\n        .stdout_only(\"2\\n5\\n\");\n    new_ucmd!()\n        .args(&[\"--number\", \"r/1/4\", \"fivelines.txt\"])\n        .succeeds()\n        .stdout_only(\"1\\n5\\n\");\n    new_ucmd!()\n        .args(&[\"-e\", \"--number\", \"r/7/7\", \"fivelines.txt\"])\n        .succeeds()\n        .stdout_only(\"\");\n    #[cfg(target_pointer_width = \"64\")]\n    new_ucmd!()\n        .args(&[\n            \"--number\",\n            \"r/9223372036854775807/18446744073709551615\",\n            \"fivelines.txt\",\n        ])\n        .succeeds()\n        .stdout_only(\"\");\n    #[cfg(target_pointer_width = \"64\")]\n    new_ucmd!()\n        .args(&[\n            \"--number\",\n            \"r/9223372036854775807/18446744073709551616\",\n            \"fivelines.txt\",\n        ])\n        .fails()\n        .stderr_contains(\"split: invalid number of chunks: 18446744073709551616\");\n    new_ucmd!()\n        .args(&[\"--number\", \"r/0/3\", \"fivelines.txt\"])\n        .fails()\n        .stderr_contains(\"split: invalid chunk number: 0\");\n    new_ucmd!()\n        .args(&[\"--number\", \"r/10/3\", \"fivelines.txt\"])\n        .fails()\n        .stderr_contains(\"split: invalid chunk number: 10\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_creates_inscriptions", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn inscribe_creates_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let (inscription, _) = inscribe(&rpc_server);\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let request =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/content/{inscription}\"));\n\n  assert_eq!(request.status(), 200);\n  assert_eq!(\n    request.headers().get(\"content-type\").unwrap(),\n    \"text/plain;charset=utf-8\"\n  );\n  assert_eq!(request.text().unwrap(), \"FOO\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_if_existing_backup_existing", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_numbered_if_existing_backup_existing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n    let file_b_backup = \"test_install_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    scene\n        .ucmd()\n        .arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_mpr_and_column_options", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_with_mpr_and_column_options() {\n    let test_file_path = \"column.log\";\n    new_ucmd!()\n        .args(&[\"--column=2\", \"-m\", \"-n\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: cannot specify number of columns when printing in parallel\\n\")\n        .stdout_is(\"\");\n\n    new_ucmd!()\n        .args(&[\"-a\", \"-m\", \"-n\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: cannot specify both printing across and printing in parallel\\n\")\n        .stdout_is(\"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_mpr", "code": "pub fn stdout_is_templated_fixture_any<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[Vec<(String, String)>],\n    ) {\n        let contents = String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        let possible_values = template_vars.iter().map(|vars| {\n            let mut contents = contents.clone();\n            for kv in vars {\n                contents = contents.replace(&kv.0, &kv.1);\n            }\n            contents\n        });\n        self.stdout_is_any(&possible_values.collect::<Vec<_>>());\n    }", "test": "fn test_with_mpr() {\n    let test_file_path = \"column.log\";\n    let test_file_path1 = \"hosts.log\";\n    let expected_test_file_path = \"mpr.log.expected\";\n    let expected_test_file_path1 = \"mpr1.log.expected\";\n    let expected_test_file_path2 = \"mpr2.log.expected\";\n    let start = OffsetDateTime::now_utc();\n    new_ucmd!()\n        .args(&[\"--pages=1:2\", \"-m\", \"-n\", test_file_path, test_file_path1])\n        .succeeds()\n        .stdout_is_templated_fixture_any(\n            expected_test_file_path,\n            &valid_last_modified_template_vars(start),\n        );\n\n    let start = OffsetDateTime::now_utc();\n    new_ucmd!()\n        .args(&[\"--pages=2:4\", \"-m\", \"-n\", test_file_path, test_file_path1])\n        .succeeds()\n        .stdout_is_templated_fixture_any(\n            expected_test_file_path1,\n            &valid_last_modified_template_vars(start),\n        );\n\n    let start = OffsetDateTime::now_utc();\n    new_ucmd!()\n        .args(&[\n            \"--pages=1:2\",\n            \"-l\",\n            \"100\",\n            \"-n\",\n            \"-m\",\n            test_file_path,\n            test_file_path1,\n            test_file_path,\n        ])\n        .succeeds()\n        .stdout_is_templated_fixture_any(\n            expected_test_file_path2,\n            &valid_last_modified_template_vars(start),\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_count_down", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_count_down() {\n    new_ucmd!()\n        .args(&[\"--\", \"5\", \"-1\", \"1\"])\n        .run()\n        .stdout_is(\"5\\n4\\n3\\n2\\n1\\n\");\n    new_ucmd!()\n        .args(&[\"5\", \"-1\", \"1\"])\n        .run()\n        .stdout_is(\"5\\n4\\n3\\n2\\n1\\n\");\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::coalesce", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn coalesce() {\n    test(\"a ?? b\", \"a??b;\");\n    test(\"a ?? b ?? c ?? d\", \"a??b??c??d;\");\n    test(\"a ?? (b ?? (c ?? d))\", \"a??b??c??d;\");\n    test(\"(a ?? (b ?? (c ?? d)))\", \"a??b??c??d;\");\n    test(\"a, b ?? c\", \"a,b??c;\");\n    test(\"(a, b) ?? c\", \"(a,b)??c;\");\n    test(\"a, b ?? c, d\", \"a,b??c,d;\");\n    test(\"a, b ?? (c, d)\", \"a,b??(c,d);\");\n    test(\"a = b ?? c\", \"a=b??c;\");\n    test(\"a ?? (b = c)\", \"a??(b=c);\");\n    test(\"(a | b) ?? (c | d)\", \"a|b??c|d;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date3", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date3() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"@1623786360\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(1_623_786_360, 0);\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::multi_page_kv", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn multi_page_kv() {\n    let tmpfile = create_tempfile();\n    let elements = 4;\n    let page_size = 4096;\n\n    let db = Builder::new().create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; page_size + 1];\n    let mut value = vec![0; page_size + 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            value[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n    for i in 0..elements {\n        key[0] = i;\n        value[0] = i;\n        assert_eq!(&value, table.get(key.as_slice()).unwrap().unwrap().value());\n    }\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::semver_matches", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn semver_matches() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo {{ semver_matches('0.1.0', '>=0.1.0') }}\n        echo {{ semver_matches('0.1.0', '=0.0.1') }}\n    \",\n    )\n    .stdout(\"true\\nfalse\\n\")\n    .stderr(\"echo true\\necho false\\n\")\n    .run();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_chained_cname_lookup", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_chained_cname_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n\n    // The first response should be a cname, the second will be the actual record\n    let message1 = message(resp_query.clone(), vec![cname_record], vec![], vec![]);\n    let message2 = message(resp_query, vec![v4_record], vec![], vec![]);\n\n    // the mock pops messages...\n    let client: MockClientHandle<_, ResolveError> = MockClientHandle::mock(vec![\n        Ok(DnsResponse::from_message(message2).unwrap()),\n        Ok(DnsResponse::from_message(message1).unwrap()),\n    ]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_order_by_nulls_order", "code": "pub fn verified_query(&self, sql: &str) -> Query {\n        match self.verified_stmt(sql) {\n            Statement::Query(query) => *query,\n            _ => panic!(\"Expected Query\"),\n        }\n    }", "test": "fn parse_select_order_by_nulls_order() {\n    let sql = \"SELECT id, fname, lname FROM customer WHERE id < 5 \\\n               ORDER BY lname ASC NULLS FIRST, fname DESC NULLS LAST LIMIT 2\";\n    let select = verified_query(sql);\n    assert_eq!(\n        vec![\n            OrderByExpr {\n                expr: Expr::Identifier(Ident::new(\"lname\")),\n                asc: Some(true),\n                nulls_first: Some(true),\n            },\n            OrderByExpr {\n                expr: Expr::Identifier(Ident::new(\"fname\")),\n                asc: Some(false),\n                nulls_first: Some(false),\n            },\n        ],\n        select.order_by\n    );\n    assert_eq!(Some(Expr::Value(number(\"2\"))), select.limit);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stty.rs::all_and_setting", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn all_and_setting() {\n    new_ucmd!()\n        .args(&[\"--all\", \"nl0\"])\n        .fails()\n        .stderr_contains(\"when specifying an output style, modes may not be set\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_missing_short_tmpdir_flag", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_missing_short_tmpdir_flag() {\n    let scene = TestScenario::new(util_name!());\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"a value is required for '-p <DIR>' but none was supplied\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_flag_a_2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_flag_a_2() {\n    new_ucmd!()\n        .args(&[\"-t8\"])\n        .pipe_in(\"e     E\\nf      F\\ng       G\\nh        H\\n\")\n        .run()\n        .stdout_is(\"e     E\\nf      F\\ng\\tG\\nh\\t H\\n\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/subsidy.rs::first_block_without_subsidy", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn first_block_without_subsidy() {\n  CommandBuilder::new(\"subsidy 6930000\")\n    .expected_stderr(\"error: block 6930000 has no subsidy\\n\")\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_kth_r", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_split_separator_semicolon_number_kth_r() {\n    new_ucmd!()\n        .args(&[\n            \"--number=r/1/3\",\n            \"--separator\",\n            \";\",\n            \"separator_semicolon.txt\",\n        ])\n        .succeeds()\n        .stdout_only(\"1;4;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_first_line_number_long_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_first_line_number_long_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_first_line.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"--first-line-number=5\", \"-n\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_variable_block", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_variable_block() {\n    assert_err_msg(\n        \"{{ hey\",\n        &[\n            \"1:7\",\n            \"expected `or`, `and`, `not`, `<=`, `>=`, `<`, `>`, `==`, `!=`, `+`, `-`, `*`, `/`, `%`, a filter, or a variable end (`}}`)\"\n        ],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_not_retry_async", "code": "fn test_not_retry<F: Fn(&RpcClient)>(func: F) {\n    let eps_count = 1;\n    // NotRetry mocker returns Ok() with error header first, and next returns Ok()\n    // without any error header.\n    let not_retry = Arc::new(NotRetry::new());\n    let server = MockServer::with_case(eps_count, not_retry);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps, None);\n\n    func(&client);\n}", "test": "fn test_not_retry_async() {\n    let r#async = |client: &RpcClient| {\n        block_on(client.get_region_by_id(1)).unwrap_err();\n    };\n    test_not_retry(r#async);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_early_apply.rs::test_leader_early_apply", "code": "fn test_early_apply(mode: DataLost) {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    // So compact log will not be triggered automatically.\n    configure_for_request_snapshot(&mut cluster);\n    cluster.run();\n    if mode == DataLost::LeaderCommit || mode == DataLost::AllLost {\n        cluster.must_transfer_leader(1, new_peer(1, 1));\n    } else {\n        cluster.must_transfer_leader(1, new_peer(3, 3));\n    }\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    test(\n        &mut cluster,\n        |c| {\n            c.async_put(b\"k2\", b\"v2\").unwrap();\n        },\n        |c| must_get_equal(&c.get_engine(1), b\"k2\", b\"v2\"),\n        mode,\n    );\n    let region = cluster.get_region(b\"\");\n    test(\n        &mut cluster,\n        |c| {\n            c.split_region(&region, b\"k2\", Callback::None);\n        },\n        |c| c.wait_region_split(&region),\n        mode,\n    );\n    if mode != DataLost::LeaderCommit && mode != DataLost::AllLost {\n        test(\n            &mut cluster,\n            |c| {\n                c.async_remove_peer(1, new_peer(1, 1)).unwrap();\n            },\n            |c| must_get_none(&c.get_engine(1), b\"k2\"),\n            mode,\n        );\n    }\n}", "test": "fn test_leader_early_apply() {\n    test_early_apply(DataLost::LeaderCommit)\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_undefined_comparison2", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_undefined_comparison2() {\n    test(\"'123' !== void 0\", \"!0;\");\n    test(\"'123' === void 0\", \"!1;\");\n\n    test(\"void 0 !== '123'\", \"!0;\");\n    test(\"void 0 === '123'\", \"!1;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_file_is_not_sticky", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_file_is_not_sticky() {\n    new_ucmd!().args(&[\"-k\", \"regular_file\"]).run().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_invalid_option", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_invalid_option() {\n    new_ucmd!().arg(\"-w\").arg(\"-q\").arg(\"/\").fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_to_key_then_forward_engine", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_to_key_then_forward_engine() {\n    let db = default_engine();\n    seek_to_key_then_forward(&db.engine, |e| e.iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_get_tombstone_stores", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_get_tombstone_stores() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let mut client = new_client_v2(eps, None);\n\n    let mut all_stores = vec![];\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    client.bootstrap_cluster(store.clone(), region).unwrap();\n\n    all_stores.push(store);\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n    let s = client.get_all_stores(false).unwrap();\n    assert_eq!(s, all_stores);\n\n    // Add tombstone store.\n    let mut store99 = metapb::Store::default();\n    store99.set_id(99);\n    store99.set_state(metapb::StoreState::Tombstone);\n    server.default_handler().add_store(store99.clone());\n\n    // do not include tombstone.\n    let s = client.get_all_stores(true).unwrap();\n    assert_eq!(s, all_stores);\n\n    all_stores.push(store99.clone());\n    all_stores.sort_by_key(|a| a.get_id());\n    // include tombstone, there should be 2 stores.\n    let mut s = client.get_all_stores(false).unwrap();\n    s.sort_by_key(|a| a.get_id());\n    assert_eq!(s, all_stores);\n\n    // Add another tombstone store.\n    let mut store199 = store99;\n    store199.set_id(199);\n    server.default_handler().add_store(store199.clone());\n\n    all_stores.push(store199);\n    all_stores.sort_by_key(|a| a.get_id());\n    let mut s = client.get_all_stores(false).unwrap();\n    s.sort_by_key(|a| a.get_id());\n    assert_eq!(s, all_stores);\n\n    client.get_store(store_id).unwrap();\n    client.get_store(99).unwrap_err();\n    client.get_store(199).unwrap_err();\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_formatter/tests/fixtures.rs::black_compatibility", "code": "pub fn to_string(&self) -> Option<String> {\n        let mut s = String::with_capacity(self.0.layout().len?);\n        self.write(&mut s).unwrap();\n        Some(s)\n    }", "test": "fn black_compatibility() {\n    let test_file = |input_path: &Path| {\n        let content = fs::read_to_string(input_path).unwrap();\n\n        let options_path = input_path.with_extension(\"options.json\");\n\n        let options: PyFormatOptions = if let Ok(options_file) = fs::File::open(options_path) {\n            let reader = BufReader::new(options_file);\n            serde_json::from_reader(reader).expect(\"Options to be a valid Json file\")\n        } else {\n            PyFormatOptions::from_extension(input_path)\n        };\n\n        let printed = format_module_source(&content, options.clone()).unwrap_or_else(|err| {\n            panic!(\n                \"Formatting of {} to succeed but encountered error {err}\",\n                input_path.display()\n            )\n        });\n\n        let expected_path = input_path.with_extension(\"py.expect\");\n        let expected_output = fs::read_to_string(&expected_path)\n            .unwrap_or_else(|_| panic!(\"Expected Black output file '{expected_path:?}' to exist\"));\n\n        let formatted_code = printed.as_code();\n\n        ensure_stability_when_formatting_twice(formatted_code, options, input_path);\n\n        if formatted_code == expected_output {\n            // Black and Ruff formatting matches. Delete any existing snapshot files because the Black output\n            // already perfectly captures the expected output.\n            // The following code mimics insta's logic generating the snapshot name for a test.\n            let workspace_path = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n\n            let mut components = input_path.components().rev();\n            let file_name = components.next().unwrap();\n            let test_suite = components.next().unwrap();\n\n            let snapshot_name = format!(\n                \"black_compatibility@{}__{}.snap\",\n                test_suite.as_os_str().to_string_lossy(),\n                file_name.as_os_str().to_string_lossy()\n            );\n\n            let snapshot_path = Path::new(&workspace_path)\n                .join(\"tests/snapshots\")\n                .join(snapshot_name);\n            if snapshot_path.exists() && snapshot_path.is_file() {\n                // SAFETY: This is a convenience feature. That's why we don't want to abort\n                // when deleting a no longer needed snapshot fails.\n                fs::remove_file(&snapshot_path).ok();\n            }\n\n            let new_snapshot_path = snapshot_path.with_extension(\"snap.new\");\n            if new_snapshot_path.exists() && new_snapshot_path.is_file() {\n                // SAFETY: This is a convenience feature. That's why we don't want to abort\n                // when deleting a no longer needed snapshot fails.\n                fs::remove_file(&new_snapshot_path).ok();\n            }\n        } else {\n            // Black and Ruff have different formatting. Write out a snapshot that covers the differences\n            // today.\n            let mut snapshot = String::new();\n            write!(snapshot, \"{}\", Header::new(\"Input\")).unwrap();\n            write!(snapshot, \"{}\", CodeFrame::new(\"py\", &content)).unwrap();\n\n            write!(snapshot, \"{}\", Header::new(\"Black Differences\")).unwrap();\n\n            let diff = TextDiff::from_lines(expected_output.as_str(), formatted_code)\n                .unified_diff()\n                .header(\"Black\", \"Ruff\")\n                .to_string();\n\n            write!(snapshot, \"{}\", CodeFrame::new(\"diff\", &diff)).unwrap();\n\n            write!(snapshot, \"{}\", Header::new(\"Ruff Output\")).unwrap();\n            write!(snapshot, \"{}\", CodeFrame::new(\"py\", &formatted_code)).unwrap();\n\n            write!(snapshot, \"{}\", Header::new(\"Black Output\")).unwrap();\n            write!(snapshot, \"{}\", CodeFrame::new(\"py\", &expected_output)).unwrap();\n\n            insta::with_settings!({\n                omit_expression => true,\n                input_file => input_path,\n                prepend_module_to_snapshot => false,\n            }, {\n                insta::assert_snapshot!(snapshot);\n            });\n        }\n    };\n\n    insta::glob!(\"../resources\", \"test/fixtures/black/**/*.py\", test_file);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/attributes.rs::duplicate_attributes_are_disallowed", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn duplicate_attributes_are_disallowed() {\n  Test::new()\n    .justfile(\n      \"\n      [no-exit-message]\n      [no-exit-message]\n      foo:\n        echo bar\n    \",\n    )\n    .stderr(\n      \"\n      error: Recipe attribute `no-exit-message` first used on line 1 is duplicated on line 2\n        |\n      2 | [no-exit-message]\n        |  ^^^^^^^^^^^^^^^\n      \",\n    )\n    .status(1)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_lease_read_callback_destroy", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_lease_read_callback_destroy() {\n    // Only server cluster can fake sending message successfully in raftstore layer.\n    let mut cluster = new_server_cluster(0, 3);\n    // Increase the Raft tick interval to make this test case running reliably.\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(50), None);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    // Isolate the target peer to make transfer leader fail.\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    cluster.transfer_leader(1, new_peer(3, 3));\n    thread::sleep(election_timeout * 2);\n    // Trigger ReadIndex on the leader.\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n    cluster.must_put(b\"k2\", b\"v2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pathchk.rs::test_posix_all", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_posix_all() {\n    // test the posix special mode\n\n    // accept some reasonable default\n    new_ucmd!()\n        .args(&[\"-p\", \"-P\", \"dir/file\"])\n        .succeeds()\n        .no_stdout();\n\n    // accept non-leading hyphen\n    new_ucmd!()\n        .args(&[\"-p\", \"-P\", \"dir/file-name\"])\n        .succeeds()\n        .no_stdout();\n\n    // fail on long path\n    new_ucmd!()\n        .args(&[\n            \"-p\",\n            \"-P\",\n            \"dir\".repeat(libc::PATH_MAX as usize + 1).as_str(),\n        ])\n        .fails()\n        .no_stdout();\n\n    // fail on long filename\n    new_ucmd!()\n        .args(&[\n            \"-p\",\n            \"-P\",\n            format!(\"dir/{}\", \"file\".repeat(libc::FILENAME_MAX as usize + 1)).as_str(),\n        ])\n        .fails()\n        .no_stdout();\n\n    // fail on non-portable chars\n    new_ucmd!()\n        .args(&[\"-p\", \"-P\", \"dir#/$file\"])\n        .fails()\n        .no_stdout();\n\n    // fail on leading hyphen char\n    new_ucmd!()\n        .args(&[\"-p\", \"-P\", \"dir/-file\"])\n        .fails()\n        .no_stdout();\n\n    // fail on empty path\n    new_ucmd!().args(&[\"-p\", \"-P\", \"\"]).fails().no_stdout();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::export_default", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn export_default() {\n    test(\"export default function() {}\", \"export default function(){}\");\n    test(\"export default function foo() {}\", \"export default function foo(){}\");\n    test(\"export default async function() {}\", \"export default async function(){}\");\n    test(\"export default async function foo() {}\", \"export default async function foo(){}\");\n    test(\"export default class {}\", \"export default class{}\");\n    test(\"export default class foo {}\", \"export default class foo{}\");\n\n    test(\"export default (function() {})\", \"export default (function(){});\");\n    test(\"export default (function foo() {})\", \"export default (function foo(){});\");\n    test(\"export default (async function() {})\", \"export default (async function(){});\");\n    test(\"export default (async function foo() {})\", \"export default (async function foo(){});\");\n    test(\"export default (class {})\", \"export default (class{});\");\n    test(\"export default (class foo {})\", \"export default (class foo{});\");\n\n    // test(\n    // \"export default (function() {}.toString())\",\n    // \"export default (function() {}).toString()\",\n    // );\n    // test(\n    // \"export default (function foo() {}.toString())\",\n    // \"export default (function foo() {}).toString()\",\n    // );\n    // test(\n    // \"export default (async function() {}.toString())\",\n    // \"export default (async function() {}).toString()\",\n    // );\n    // test(\n    // \"export default (async function foo() {}.toString())\",\n    // \"export default (async function foo() {}).toString()\",\n    // );\n    // test(\"export default (class {}.toString())\", \"export default (class {}).toString();\");\n    // test(\"export default (class foo {}.toString())\", \"export default (class foo {}).toString();\");\n\n    test(\"export default function() {}\", \"export default function(){}\");\n    test(\"export default function foo() {}\", \"export default function foo(){}\");\n    test(\"export default async function() {}\", \"export default async function(){}\");\n    test(\"export default async function foo() {}\", \"export default async function foo(){}\");\n    test(\"export default class {}\", \"export default class{}\");\n    test(\"export default class foo {}\", \"export default class foo{}\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_meta_item_list_name_value", "code": "fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n}", "test": "fn test_meta_item_list_name_value() {\n    let meta = test(\"#[foo(bar = 5)]\");\n\n    snapshot!(meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`bar = 5`),\n    }\n    \"###);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_tc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_tc() {\n    // Test iterators that skip multiple, trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4__5.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_directory_not_recursive", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_cp_directory_not_recursive() {\n    new_ucmd!()\n        .arg(TEST_COPY_TO_FOLDER)\n        .arg(TEST_HELLO_WORLD_DEST)\n        .fails()\n        .stderr_contains(\"omitting directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_target_directory_is_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_cp_target_directory_is_file() {\n    new_ucmd!()\n        .arg(\"-t\")\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .fails()\n        .stderr_contains(format!(\"'{TEST_HOW_ARE_YOU_SOURCE}' is not a directory\"));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_project_references.rs::manual", "code": "pub fn full_path(&self) -> PathBuf {\n        let mut path = self.path.clone().into_os_string();\n        if let Some(query) = &self.query {\n            path.push(query);\n        }\n        if let Some(fragment) = &self.fragment {\n            path.push(fragment);\n        }\n        PathBuf::from(path)\n    }", "test": "fn manual() {\n    let f = super::fixture_root().join(\"tsconfig_project_references\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        tsconfig: Some(TsconfigOptions {\n            config_file: f.join(\"app\"),\n            references: TsconfigReferences::Paths(vec![\"../project_a/conf.json\".into()]),\n        }),\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        // Test normal paths alias\n        (f.join(\"app\"), \"@/index.ts\", Ok(f.join(\"app/aliased/index.ts\"))),\n        (f.join(\"app\"), \"@/../index.ts\", Ok(f.join(\"app/index.ts\"))),\n        // Test project reference\n        (f.join(\"project_a\"), \"@/index.ts\", Ok(f.join(\"project_a/aliased/index.ts\"))),\n        (f.join(\"project_b/src\"), \"@/index.ts\", Err(ResolveError::NotFound(f.join(\"project_b/src\")))),\n        // Does not have paths alias\n        (f.join(\"project_a\"), \"./index.ts\", Ok(f.join(\"project_a/index.ts\"))),\n        (f.join(\"project_c\"), \"./index.ts\", Ok(f.join(\"project_c/index.ts\"))),\n    ];\n\n    for (path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolved_path, expected, \"{request} {path:?}\");\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_splitting_not_necessary_after_higher_mtu_discovered", "code": "pub(super) fn drive_client(&mut self) {\n        let span = info_span!(\"client\");\n        let _guard = span.enter();\n        self.client.drive(self.time, self.server.addr);\n        for x in self.client.outbound.drain(..) {\n            if packet_size(&x) > self.mtu {\n                info!(\n                    packet_size = packet_size(&x),\n                    \"dropping packet (max size exceeded)\"\n                );\n                continue;\n            }\n            if x.contents[0] & packet::LONG_HEADER_FORM == 0 {\n                let spin = x.contents[0] & packet::SPIN_BIT != 0;\n                self.spins += (spin == self.last_spin) as u64;\n                self.last_spin = spin;\n            }\n            if let Some(ref socket) = self.client.socket {\n                socket.send_to(&x.contents, x.destination).unwrap();\n            }\n            if self.server.addr == x.destination {\n                self.server.inbound.push_back((\n                    self.time + self.latency,\n                    x.ecn,\n                    x.contents.as_ref().into(),\n                ));\n            }\n        }\n    }", "test": "fn packet_splitting_not_necessary_after_higher_mtu_discovered() {\n    let _guard = subscribe();\n    let payload = vec![42; 1300];\n\n    let mut pair = Pair::default();\n    pair.mtu = 1500;\n\n    let (client_ch, _) = pair.connect();\n    pair.drive();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert_eq!(pair.client.outbound.len(), 1);\n\n    pair.drive_client();\n    assert_eq!(pair.server.inbound.len(), 1);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cli/tests/format.rs::exclude_stdin", "code": "fn path(&self) -> Option<&Path> {\n        match self {\n            Self::Ignore(err) => {\n                if let ignore::Error::WithPath { path, .. } = err {\n                    Some(path.as_path())\n                } else {\n                    None\n                }\n            }\n            Self::Panic(path, _)\n            | Self::Read(path, _)\n            | Self::Format(path, _)\n            | Self::Write(path, _)\n            | Self::Diff(path, _) => path.as_deref(),\n        }\n    }", "test": "fn exclude_stdin() -> Result<()> {\n    let tempdir = TempDir::new()?;\n    let ruff_toml = tempdir.path().join(\"ruff.toml\");\n    fs::write(\n        &ruff_toml,\n        r#\"\nextend-select = [\"B\", \"Q\"]\nignore = [\"Q000\", \"Q001\", \"Q002\", \"Q003\"]\n\n[format]\nexclude = [\"generated.py\"]\n\"#,\n    )?;\n\n    assert_cmd_snapshot!(Command::new(get_cargo_bin(BIN_NAME))\n        .current_dir(tempdir.path())\n        .args([\"format\", \"--config\", &ruff_toml.file_name().unwrap().to_string_lossy(), \"--stdin-filename\", \"generated.py\", \"-\"])\n        .pass_stdin(r#\"\nfrom test import say_hy\n\nif __name__ == '__main__':\n    say_hy(\"dear Ruff contributor\")\n\"#), @r###\"\n    success: true\n    exit_code: 0\n    ----- stdout -----\n    from test import say_hy\n\n    if __name__ == \"__main__\":\n        say_hy(\"dear Ruff contributor\")\n\n    ----- stderr -----\n    \"###);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_too_few_xs_suffix", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_too_few_xs_suffix() {\n    new_ucmd!()\n        .args(&[\"--suffix=X\", \"aXX\"])\n        .fails()\n        .stderr_only(\"mktemp: too few X's in template 'aXXX'\\n\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/spec.rs::) {\n    let o", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "95() {\n    let original = r##\"[link](foo(and(bar)))\n\"##;\n    let expected = r##\"<p><a href=\"foo(and(bar))\">link</a></p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_default_missing_value", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_default_missing_value() {\n    new_ucmd!().arg(\"-d\").arg(\"--tmpdir\").succeeds();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::path_not_found", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn path_not_found() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo $NAME\n    \",\n    )\n    .args([\"--dotenv-path\", \".env.prod\"])\n    .stderr(if cfg!(windows) {\n      \"error: Failed to load environment file: The system cannot find the file specified. (os \\\n       error 2)\\n\"\n    } else {\n      \"error: Failed to load environment file: No such file or directory (os error 2)\\n\"\n    })\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_dec", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_dec() {\n    // spell-checker:ignore (words) 0xffu8 xffu\n    let input = [\n        0u8, 0u8, 1u8, 0u8, 2u8, 0u8, 3u8, 0u8, 0xffu8, 0x7fu8, 0x00u8, 0x80u8, 0x01u8, 0x80u8,\n    ];\n    let expected_output = unindent(\n        \"\n            0000000      0      1      2      3  32767 -32768 -32767\n            0000016\n            \",\n    );\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-s\")\n        .run_piped_stdin(&input[..])\n        .success()\n        .no_stderr()\n        .stdout_is(expected_output);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_ident", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_variable_block_ident() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"a\", &2);\n    context.insert(\"b\", &3);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert(\"tuple_list\", &vec![(1, 2, 3), (1, 2, 3)]);\n    context.insert(\"review\", &Review::new());\n    context.insert(\"with_newline\", &\"Animal Alphabets\\nB is for Bee-Eater\");\n\n    let inputs = vec![\n        (\"{{ name }}\", \"john\"),\n        (\"{{ malicious }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\"<html>\\\" }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\" html \\\" | upper | trim }}\", \"HTML\"),\n        (\"{{ 'html' }}\", \"html\"),\n        (\"{{ `html` }}\", \"html\"),\n        // https://github.com/Keats/tera/issues/273\n        (\n            r#\"{{ 'hangar new \"Will Smoth <will_s@example.com>\"' | safe }}\"#,\n            r#\"hangar new \"Will Smoth <will_s@example.com>\"\"#,\n        ),\n        (\"{{ malicious | safe }}\", \"<html>\"),\n        (\"{{ malicious | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ malicious | upper | safe }}\", \"<HTML>\"),\n        (\"{{ malicious | safe | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ review | length }}\", \"2\"),\n        (\"{{ review.paragraphs.1 }}\", \"B\"),\n        (\"{{ numbers }}\", \"[1, 2, 3]\"),\n        (\"{{ numbers.0 }}\", \"1\"),\n        (\"{{ tuple_list.1.1 }}\", \"2\"),\n        (\"{{ name and true }}\", \"true\"),\n        (\"{{ name | length }}\", \"4\"),\n        (\"{{ name is defined }}\", \"true\"),\n        (\"{{ not name is defined }}\", \"false\"),\n        (\"{{ name is not defined }}\", \"false\"),\n        (\"{{ not name is not defined }}\", \"true\"),\n        (\"{{ a is odd }}\", \"false\"),\n        (\"{{ a is odd or b is odd  }}\", \"true\"),\n        (\"{{ range(start=1, end=4) }}\", \"[1, 2, 3]\"),\n        (\"{{ a + b }}\", \"5\"),\n        (\"{{ a + 1.5 }}\", \"3.5\"),\n        (\"{{ 1 + 1 + 1 }}\", \"3\"),\n        (\"{{ 2 - 2 - 1 }}\", \"-1\"),\n        (\"{{ 1 - 1 + 1 }}\", \"1\"),\n        (\"{{ 1 + get_number() }}\", \"11\"),\n        (\"{{ get_number() + 1 }}\", \"11\"),\n        (\"{{ (1.9 + a) | round }}\", \"4\"),\n        (\"{{ 1.9 + a | round }}\", \"4\"),\n        (\"{{ numbers | length - 1 }}\", \"2\"),\n        (\"{{ 1.9 + a | round - 1 }}\", \"3\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round }}\", \"0\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round - 1 }}\", \"-1\"),\n        (\"{{ 4 + 40 / (2 + 8) / 4 }}\", \"5\"),\n        (\"{{ ( ( 2 ) + ( 2 ) ) }}\", \"4\"),\n        (\"{{ ( ( 4 / 1 ) + ( 2 / 1 ) ) }}\", \"6\"),\n        (\"{{ ( ( 4 + 2 ) / ( 2 + 1 ) ) }}\", \"2\"),\n        // https://github.com/Keats/tera/issues/435\n        (\n            \"{{ with_newline | replace(from='\\n', to='<br>') | safe }}\",\n            \"Animal Alphabets<br>B is for Bee-Eater\",\n        ),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::test_path_exists_filepath_doesnt_exist", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn test_path_exists_filepath_doesnt_exist() {\n  Test::new()\n    .justfile(\"x := path_exists('testfile')\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout(\"false\")\n    .run();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_does_not_pick_locked_utxos", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_does_not_pick_locked_utxos() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let coinbase_tx = &rpc_server.mine_blocks(1)[0].txdata[0];\n  let outpoint = OutPoint::new(coinbase_tx.txid(), 0);\n\n  rpc_server.lock(outpoint);\n\n  CommandBuilder::new(\"wallet inscribe --file hello.txt --fee-rate 1\")\n    .rpc_server(&rpc_server)\n    .write(\"hello.txt\", \"HELLOWORLD\")\n    .expected_exit_code(1)\n    .stderr_regex(\"error: wallet contains no cardinal utxos\\n\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/snapshot.rs::test_snapshot_minimodem_tx", "code": "pub fn convert_stdout_to_hash(&mut self) {\n        self.result = match &self.result {\n            TestResult::Success(a) => TestResult::Success(TestOutput {\n                stdout: format!(\"hash: {:x}\", md5::compute(a.stdout.as_bytes())),\n                stderr: a.stderr.clone(),\n                exit_code: a.exit_code,\n            }),\n            res => res.clone(),\n        };\n    }", "test": "fn test_snapshot_minimodem_tx() {\n    let mut snapshot = TestBuilder::new()\n        .with_name(function!())\n        .stdin_str(\"This message wont get through\")\n        .arg(\"--tx\")\n        .arg(\"--tx-carrier\")\n        .arg(\"--stdio\")\n        .arg(\"--float-samples\")\n        .arg(\"same\")\n        .run_wasm(include_bytes!(\"./wasm/minimodem.wasm\"));\n    snapshot.convert_stdout_to_hash();\n\n    assert_json_snapshot!(snapshot);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_vdir.rs::test_vdir", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_vdir() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_files0_errors_quoting", "code": "pub fn failure(&self) -> &Self {\n        assert!(\n            !self.succeeded(),\n            \"Command was expected to fail.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_files0_errors_quoting() {\n    new_ucmd!()\n        .args(&[\"--files0-from=files0 with nonexistent.txt\"])\n        .run()\n        .failure()\n        .stderr_is(concat!(\n            \"wc: this_file_does_not_exist.txt: No such file or directory\\n\",\n            \"wc: 'files0 with nonexistent.txt':2: invalid zero-length file name\\n\",\n            \"wc: 'this file does not exist.txt': No such file or directory\\n\",\n            \"wc: \\\"this files doesn't exist either.txt\\\": No such file or directory\\n\",\n        ))\n        .stdout_is(\"0 0 0 total\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_zero_duration", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_sleep_zero_duration() {\n    new_ucmd!().args(&[\"0\"]).succeeds().stdout_only(\"\");\n    new_ucmd!().args(&[\"0s\"]).succeeds().stdout_only(\"\");\n    new_ucmd!().args(&[\"0m\"]).succeeds().stdout_only(\"\");\n    new_ucmd!().args(&[\"0h\"]).succeeds().stdout_only(\"\");\n    new_ucmd!().args(&[\"0d\"]).succeeds().stdout_only(\"\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_does_not_use_inscribed_sats_as_cardinal_utxos", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_does_not_use_inscribed_sats_as_cardinal_utxos() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks_with_subsidy(1, 100);\n\n  CommandBuilder::new(\n    \"wallet inscribe --file degenerate.png --fee-rate 1\"\n  )\n  .rpc_server(&rpc_server)\n  .write(\"degenerate.png\", [1; 100])\n  .expected_exit_code(1)\n  .expected_stderr(\"error: wallet does not contain enough cardinal UTXOs, please add additional funds to wallet.\\n\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_value_into_deserializer", "code": "fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }", "test": "fn test_value_into_deserializer() {\n    #[derive(Deserialize)]\n    struct Outer {\n        inner: Inner,\n    }\n\n    #[derive(Deserialize)]\n    struct Inner {\n        string: String,\n    }\n\n    let mut map = BTreeMap::new();\n    map.insert(\"inner\", json!({ \"string\": \"Hello World\" }));\n\n    let outer = Outer::deserialize(serde::de::value::MapDeserializer::new(\n        map.iter().map(|(k, v)| (*k, v)),\n    ))\n    .unwrap();\n    assert_eq!(outer.inner.string, \"Hello World\");\n\n    let outer = Outer::deserialize(map.into_deserializer()).unwrap();\n    assert_eq!(outer.inner.string, \"Hello World\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_server_stale_peer_without_data_right_derive_when_split", "code": "fn test_stale_peer_without_data<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let region = cluster.get_region(b\"\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.must_split(&region, b\"k2\");\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine3 = cluster.get_engine(3);\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    let new_region = if right_derive {\n        cluster.get_region(b\"k1\")\n    } else {\n        cluster.get_region(b\"k3\")\n    };\n    let new_region_id = new_region.get_id();\n    // Block peer (3, 4) at receiving snapshot, but not the heartbeat\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(new_region_id, 3).msg_type(MessageType::MsgSnapshot),\n    ));\n\n    pd_client.must_add_peer(new_region_id, new_peer(3, 4));\n\n    // Wait for the heartbeat broadcasted from peer (1, 1000) to peer (3, 4).\n    cluster.must_region_exist(new_region_id, 3);\n\n    // And then isolate peer (3, 4) from peer (1, 1000).\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_remove_peer(new_region_id, new_peer(3, 4));\n\n    cluster.must_remove_region(3, new_region_id);\n\n    // There must be no data on store 3 belongs to new region\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n    } else {\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    // Check whether peer(3, 4) is destroyed.\n    // Before peer 4 is destroyed, a tombstone mark will be written into the engine.\n    // So we could check the tombstone mark to make sure peer 4 is destroyed.\n    let state_key = keys::region_state_key(new_region_id);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // other region should not be affected.\n    if right_derive {\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n    }\n}", "test": "fn test_server_stale_peer_without_data_right_derive_when_split() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    test_stale_peer_without_data(&mut cluster, true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_no_clobber() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--no-clobber\")\n        .fails()\n        .stderr_contains(\"not replacing\");\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_empty_line_and_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_empty_line_and_final_newline() {\n    new_ucmd!()\n        .arg(\"-w2\")\n        .pipe_in(\"12\\n\\n34\\n\")\n        .succeeds()\n        .stdout_is(\"12\\n\\n34\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/undefined_variables.rs::unknown_first_variable_in_binary_call", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn unknown_first_variable_in_binary_call() {\n  Test::new()\n    .justfile(\n      \"\n    foo x=env_var_or_default(a, b):\n  \",\n    )\n    .stderr(\n      \"\n      error: Variable `a` not defined\n        |\n      1 | foo x=env_var_or_default(a, b):\n        |                          ^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "test": "fn valid_context_directory() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let b_context = get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap(),\n        b_context\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_reflink_always", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_cp_sparse_always_reflink_always() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.make_file(\"src_file1\");\n\n    ucmd.args(&[\n        \"--sparse=always\",\n        \"--reflink=always\",\n        \"src_file1\",\n        \"dst_file\",\n    ])\n    .fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_keep_setgid", "code": "pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    }", "test": "fn test_chmod_keep_setgid() {\n    for (from, arg, to) in [\n        (0o7777, \"777\", 0o46777),\n        (0o7777, \"=777\", 0o40777),\n        (0o7777, \"0777\", 0o46777),\n        (0o7777, \"=0777\", 0o40777),\n        (0o7777, \"00777\", 0o40777),\n        (0o2444, \"a+wx\", 0o42777),\n        (0o2444, \"a=wx\", 0o42333),\n        (0o1444, \"g+s\", 0o43444),\n        (0o4444, \"u-s\", 0o40444),\n        (0o7444, \"a-s\", 0o41444),\n    ] {\n        let (at, mut ucmd) = at_and_ucmd!();\n        at.mkdir(\"dir\");\n        set_permissions(at.plus(\"dir\"), Permissions::from_mode(from)).unwrap();\n        let r = ucmd.arg(arg).arg(\"dir\").succeeds();\n        println!(\"{}\", r.stderr_str());\n        assert_eq!(at.metadata(\"dir\").permissions().mode(), to);\n    }\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query_tcp_ipv4", "code": "fn block_on<F: Future>(&mut self, future: F) -> F::Output {\n        async_std::task::block_on(future)\n    }", "test": "fn test_query_tcp_ipv4() {\n    let io_loop = Runtime::new().unwrap();\n    let addr: SocketAddr = (\"8.8.8.8\", 53).to_socket_addrs().unwrap().next().unwrap();\n    let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n    let client = AsyncClient::new(stream, sender, None);\n    let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // TODO: timeouts on these requests so that the test doesn't hang\n    io_loop.block_on(test_query(&mut client));\n    io_loop.block_on(test_query(&mut client));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_directories", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_mode_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let component = \"component\";\n    let directories_arg = \"-d\";\n    let mode_arg = \"--mode=333\";\n\n    ucmd.arg(directories_arg)\n        .arg(component)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(component));\n    let permissions = at.metadata(component).permissions();\n    assert_eq!(0o040_333_u32, PermissionsExt::mode(&permissions));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_dir_with_target_arg", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_file_into_dir_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_move_file_into_dir_with_target_arg_dir\";\n    let file = \"test_mv_move_file_into_dir_with_target_arg_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(\"--target\")\n        .arg(dir)\n        .arg(file)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_txin", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_txin() {\n    let ser = include_bytes!(\"data/serde/txin_ser\");\n    let txin: TxIn = deserialize(ser).unwrap();\n\n    let got = serialize(&txin).unwrap();\n    let want = include_bytes!(\"data/serde/txin_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_commit", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_commit() {\n    match verified_stmt(\"COMMIT\") {\n        Statement::Commit { chain: false } => (),\n        _ => unreachable!(),\n    }\n\n    match verified_stmt(\"COMMIT AND CHAIN\") {\n        Statement::Commit { chain: true } => (),\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\"COMMIT AND NO CHAIN\", \"COMMIT\");\n    one_statement_parses_to(\"COMMIT WORK AND NO CHAIN\", \"COMMIT\");\n    one_statement_parses_to(\"COMMIT TRANSACTION AND NO CHAIN\", \"COMMIT\");\n    one_statement_parses_to(\"COMMIT WORK AND CHAIN\", \"COMMIT AND CHAIN\");\n    one_statement_parses_to(\"COMMIT TRANSACTION AND CHAIN\", \"COMMIT AND CHAIN\");\n    one_statement_parses_to(\"COMMIT WORK\", \"COMMIT\");\n    one_statement_parses_to(\"COMMIT TRANSACTION\", \"COMMIT\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_multiple_param", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_multiple_param() {\n    for multiple_param in [\"-a\", \"--multiple\", \"--mul\"] {\n        let path = \"/foo/bar/baz\";\n        new_ucmd!()\n            .args(&[multiple_param, path, path])\n            .succeeds()\n            .stdout_only(\"baz\\nbaz\\n\"); // spell-checker:disable-line\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::hi64_test", "code": "fn hi64(&self) -> (u64, bool) {\n        match self.as_ref().len() {\n            0 => (0, false),\n            1 => self.hi64_1(),\n            2 => self.hi64_2(),\n            _ => self.hi64_3(),\n        }\n    }", "test": "fn hi64_test() {\n    assert_eq!(Bigint::from_u64(0xA).hi64(), (0xA000000000000000, false));\n    assert_eq!(Bigint::from_u64(0xAB).hi64(), (0xAB00000000000000, false));\n    assert_eq!(\n        Bigint::from_u64(0xAB00000000).hi64(),\n        (0xAB00000000000000, false)\n    );\n    assert_eq!(\n        Bigint::from_u64(0xA23456789A).hi64(),\n        (0xA23456789A000000, false)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_server_catching_api_error", "code": "pub fn has_region_error(&self) -> bool {\n        self.region_error.is_some()\n    }", "test": "fn test_server_catching_api_error() {\n    let raftkv_fp = \"raftkv_early_error_report\";\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    let region = cluster.get_region(b\"\");\n    let leader = region.get_peers()[0].clone();\n\n    fail::cfg(raftkv_fp, \"return\").unwrap();\n\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n\n    let mut prewrite_req = PrewriteRequest::default();\n    prewrite_req.set_context(ctx.clone());\n    let mutation = kvrpcpb::Mutation {\n        op: Op::Put,\n        key: b\"k3\".to_vec(),\n        value: b\"v3\".to_vec(),\n        ..Default::default()\n    };\n    prewrite_req.set_mutations(vec![mutation].into_iter().collect());\n    prewrite_req.primary_lock = b\"k3\".to_vec();\n    prewrite_req.start_version = 1;\n    prewrite_req.lock_ttl = prewrite_req.start_version + 1;\n    let prewrite_resp = client.kv_prewrite(&prewrite_req).unwrap();\n    assert!(prewrite_resp.has_region_error(), \"{:?}\", prewrite_resp);\n    assert!(\n        prewrite_resp.get_region_error().has_region_not_found(),\n        \"{:?}\",\n        prewrite_resp\n    );\n    must_get_none(&cluster.get_engine(1), b\"k3\");\n\n    let mut put_req = RawPutRequest::default();\n    put_req.set_context(ctx);\n    put_req.key = b\"k3\".to_vec();\n    put_req.value = b\"v3\".to_vec();\n    let put_resp = client.raw_put(&put_req).unwrap();\n    assert!(put_resp.has_region_error(), \"{:?}\", put_resp);\n    assert!(\n        put_resp.get_region_error().has_region_not_found(),\n        \"{:?}\",\n        put_resp\n    );\n    must_get_none(&cluster.get_engine(1), b\"k3\");\n\n    fail::remove(raftkv_fp);\n    let put_resp = client.raw_put(&put_req).unwrap();\n    assert!(!put_resp.has_region_error(), \"{:?}\", put_resp);\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_missing_destination", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_symlink_missing_destination() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_missing_destination\";\n\n    at.touch(file);\n\n    ucmd.args(&[\"-s\", \"-T\", file]).fails().stderr_is(format!(\n        \"ln: missing destination file operand after '{file}'\\n\"\n    ));\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_btc_does_not_send_locked_utxos", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn send_btc_does_not_send_locked_utxos() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  let coinbase_tx = &rpc_server.mine_blocks(1)[0].txdata[0];\n  let outpoint = OutPoint::new(coinbase_tx.txid(), 0);\n\n  rpc_server.lock(outpoint);\n\n  CommandBuilder::new(\"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 1btc\")\n    .rpc_server(&rpc_server)\n    .expected_exit_code(1)\n    .stderr_regex(\"error:.*\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_corner_case1", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_corner_case1() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/10/\", \"11\"])\n        .succeeds()\n        .stdout_only(\"18\\n3\\n120\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), \"10\\n\");\n    assert_eq!(at.read(\"xx02\"), generate(11, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_name", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_uname_name() {\n    new_ucmd!().arg(\"-n\").succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pwd.rs::test_failed", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_failed() {\n    let (_at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(\"will-fail\").fails();\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic.rs::factor_test", "code": "fn factor(i: &str) -> IResult<&str, Expr> {\n  alt((\n    map(\n      map_res(delimited(multispace, digit, multispace), FromStr::from_str),\n      Expr::Value,\n    ),\n    parens,\n  ))(i)\n}", "test": "fn factor_test() {\n  assert_eq!(factor(\"3\"), Ok((\"\", 3)));\n  assert_eq!(factor(\" 12\"), Ok((\"\", 12)));\n  assert_eq!(factor(\"537  \"), Ok((\"\", 537)));\n  assert_eq!(factor(\"  24   \"), Ok((\"\", 24)));\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_move_to_heap_and_shrink", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "test": "fn TinyVec_try_move_to_heap_and_shrink() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert!(tv.is_inline());\n  assert!(tv.try_move_to_the_heap().is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 0);\n\n  assert!(tv.try_reserve_exact(1).is_ok());\n  assert_eq!(tv.capacity(), 1);\n  tv.push(1);\n  tv.shrink_to_fit();\n  assert!(tv.is_inline());\n  assert_eq!(tv.capacity(), 4);\n\n  assert!(tv.try_move_to_the_heap_and_reserve(3).is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 4);\n  tv.extend(2..=4);\n  assert_eq!(tv.capacity(), 4);\n  assert_eq!(tv.as_slice(), [1, 2, 3, 4]);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::files_max_size_parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn files_max_size_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--files-max-size=-1\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"files_max_size_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_binding_pattern_object", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch_binding_pattern_object() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw {\n                    n: 30,\n                };\n            } catch ({ n }) {\n                a = n;\n            }\n\n            a;\n        \"#},\n        30,\n    )]);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_null", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_null() {\n    test_parse_err::<()>(&[\n        (\"n\", \"EOF while parsing a value at line 1 column 1\"),\n        (\"nul\", \"EOF while parsing a value at line 1 column 3\"),\n        (\"nulla\", \"trailing characters at line 1 column 5\"),\n    ]);\n\n    test_parse_ok(vec![(\"null\", ())]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_pessimistic_lock_check_valid", "code": "pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    }", "test": "fn test_pessimistic_lock_check_valid() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let txn_ext = cluster\n        .must_get_snapshot_of_region(1)\n        .ext()\n        .get_txn_ext()\n        .unwrap()\n        .clone();\n\n    let region = cluster.get_region(b\"\");\n    let leader = region.get_peers()[0].clone();\n    fail::cfg(\"acquire_pessimistic_lock\", \"pause\").unwrap();\n\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n\n    let mut mutation = pb::Mutation::default();\n    mutation.set_op(Op::PessimisticLock);\n    mutation.key = b\"key\".to_vec();\n    let mut req = PessimisticLockRequest::default();\n    req.set_context(ctx.clone());\n    req.set_mutations(vec![mutation].into());\n    req.set_start_version(10);\n    req.set_for_update_ts(10);\n    req.set_primary_lock(b\"key\".to_vec());\n\n    let lock_resp = thread::spawn(move || client.kv_pessimistic_lock(&req).unwrap());\n    thread::sleep(Duration::from_millis(300));\n    // Set `status` to `TransferringLeader` to make the locks table not writable,\n    // but the region remains available to serve.\n    txn_ext.pessimistic_locks.write().status = LocksStatus::TransferringLeader;\n    fail::remove(\"acquire_pessimistic_lock\");\n\n    let resp = lock_resp.join().unwrap();\n    // There should be no region error.\n    assert!(!resp.has_region_error());\n    // The lock should not be written to the in-memory pessimistic lock table.\n    assert!(txn_ext.pessimistic_locks.read().is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_rename_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_rename_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_rename_file\";\n    let file2 = \"test_mv_rename_file2\";\n\n    at.touch(file1);\n\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n    assert!(at.file_exists(file2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_line_num_out_of_range1", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_line_num_out_of_range1() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"100\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '100': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"100\", \"-k\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '100': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_batch_size_limit", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_batch_size_limit() {\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), true);\n    let (mock_server, port) = create_mock_server(service, 60200, 60300).unwrap();\n\n    let mut raft_client = get_raft_client_by_port(port);\n\n    // `send` should success.\n    for _ in 0..10 {\n        // 5M per RaftMessage.\n        let mut raft_m = RaftMessage::default();\n        for _ in 0..(5 * 1024) {\n            let mut e = Entry::default();\n            e.set_data(vec![b'a'; 1024].into());\n            raft_m.mut_message().mut_entries().push(e);\n        }\n        raft_client.send(raft_m).unwrap();\n    }\n    raft_client.flush();\n\n    check_msg_count(500, &msg_count, 10);\n    // The final received message count should be 10 exactly.\n    drop(raft_client);\n    drop(mock_server);\n    assert_eq!(msg_count.load(Ordering::SeqCst), 10);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_floats_and_ints", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_floats_and_ints() {\n    test_helper(\n        \"numeric_floats_and_ints\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stty.rs::save_and_setting", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn save_and_setting() {\n    new_ucmd!()\n        .args(&[\"--save\", \"nl0\"])\n        .fails()\n        .stderr_contains(\"when specifying an output style, modes may not be set\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/byte_order_mark.rs::non_leading_byte_order_mark_produces_error", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn non_leading_byte_order_mark_produces_error() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo bar\n      \\u{feff}\n    \",\n    )\n    .stderr(\n      \"\n      error: Expected \\'@\\', \\'[\\', comment, end of file, end of line, or identifier, but found byte order mark\n        |\n      3 | \\u{feff}\n        | ^\n      \")\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_invalid_size", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_du_invalid_size() {\n    let args = &[\"block-size\", \"threshold\"];\n    let ts = TestScenario::new(util_name!());\n    for s in args {\n        ts.ucmd()\n            .arg(format!(\"--{s}=1fb4t\"))\n            .arg(\"/tmp\")\n            .fails()\n            .code_is(1)\n            .stderr_only(format!(\"du: invalid suffix in --{s} argument '1fb4t'\\n\"));\n        ts.ucmd()\n            .arg(format!(\"--{s}=x\"))\n            .arg(\"/tmp\")\n            .fails()\n            .code_is(1)\n            .stderr_only(format!(\"du: invalid --{s} argument 'x'\\n\"));\n        #[cfg(not(target_pointer_width = \"128\"))]\n        ts.ucmd()\n            .arg(format!(\"--{s}=1Y\"))\n            .arg(\"/tmp\")\n            .fails()\n            .code_is(1)\n            .stderr_only(format!(\"du: --{s} argument '1Y' too large\\n\"));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_invalid_time_interval", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_invalid_time_interval() {\n    new_ucmd!()\n        .arg(\"xyz\")\n        .fails()\n        .usage_error(\"invalid time interval 'xyz': Invalid input: xyz\");\n    new_ucmd!()\n        .args(&[\"--\", \"-1\"])\n        .fails()\n        .usage_error(\"invalid time interval '-1': Number was negative\");\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_whitespace_delimited_comparator_sets", "code": "pub(super) fn assert_to_string(value: impl Display, expected: &str) {\n    assert_eq!(value.to_string(), expected);\n}", "test": "pub fn test_whitespace_delimited_comparator_sets() {\n    // https://github.com/steveklabnik/semver/issues/55\n    let err = req_err(\"> 0.0.9 <= 2.5.3\");\n    assert_to_string(err, \"expected comma after patch version number, found '<'\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_byte_buf_de", "code": "pub fn from_str(s: &'a str) -> Self {\n        Deserializer::new(read::StrRead::new(s))\n    }", "test": "fn test_byte_buf_de() {\n    let bytes = ByteBuf::new();\n    let v: ByteBuf = from_str(\"[]\").unwrap();\n    assert_eq!(v, bytes);\n\n    let bytes = ByteBuf::from(vec![1, 2, 3]);\n    let v: ByteBuf = from_str(\"[1, 2, 3]\").unwrap();\n    assert_eq!(v, bytes);\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/host_calls_wasm.rs::host_calls_wasm", "code": "pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    }", "test": "fn host_calls_wasm() {\n    let (mut store, mut linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, |mut caller: Caller<()>, input: i32| -> i32 {\n        let wasm_fn = caller\n            .get_export(\"square\")\n            .and_then(Extern::into_func)\n            .unwrap()\n            .typed::<i32, i32>(&caller)\n            .unwrap();\n        wasm_fn.call(&mut caller, input + input).unwrap()\n    });\n    linker.define(\"env\", \"host_fn\", host_fn).unwrap();\n    let wasm = wat::parse_str(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (param i32) (result i32)))\n            (func (export \"wasm_fn\") (param i32) (result i32)\n                (call $host_fn (local.get 0))\n            )\n            (func (export \"square\") (param i32) (result i32)\n                (i32.mul\n                    (local.get 0)\n                    (local.get 0)\n                )\n            )\n        )\n        \"#,\n    )\n    .unwrap();\n    let module = Module::new(store.engine(), &mut &wasm[..]).unwrap();\n    let instance = linker\n        .instantiate(&mut store, &module)\n        .unwrap()\n        .start(&mut store)\n        .unwrap();\n    let wasm_fn = instance\n        .get_export(&store, \"wasm_fn\")\n        .and_then(Extern::into_func)\n        .unwrap()\n        .typed::<i32, i32>(&store)\n        .unwrap();\n    let input = 5;\n    let expected = (input + input) * (input + input);\n    let result = wasm_fn.call(&mut store, input).unwrap();\n    assert_eq!(result, expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_life.rs::test_gc_peer_response", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_gc_peer_response() {\n    let cluster = Cluster::with_node_count(2, None);\n    let region_id = 2;\n    let mut req = cluster.routers[0].new_request_for(region_id);\n    let admin_req = req.mut_admin_request();\n    admin_req.set_cmd_type(AdminCmdType::ChangePeer);\n    admin_req\n        .mut_change_peer()\n        .set_change_type(ConfChangeType::AddLearnerNode);\n    let store_id = cluster.node(1).id();\n    let new_peer = new_learner_peer(store_id, 10);\n    admin_req.mut_change_peer().set_peer(new_peer.clone());\n    let resp = cluster.routers[0].admin_command(2, req.clone()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    let raft_engine = &cluster.node(0).running_state().unwrap().raft_engine;\n    let region_state = raft_engine\n        .get_region_state(region_id, u64::MAX)\n        .unwrap()\n        .unwrap();\n    assert!(region_state.get_removed_records().is_empty());\n\n    let new_conf_ver = req.get_header().get_region_epoch().get_conf_ver() + 1;\n    req.mut_header()\n        .mut_region_epoch()\n        .set_conf_ver(new_conf_ver);\n    req.mut_admin_request()\n        .mut_change_peer()\n        .set_change_type(ConfChangeType::RemoveNode);\n    let resp = cluster.routers[0]\n        .admin_command(region_id, req.clone())\n        .unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    cluster.routers[0].wait_flush(region_id, Duration::from_millis(300));\n    // Drain all existing messages.\n    while cluster.receiver(0).try_recv().is_ok() {}\n\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(region_id);\n    msg.set_to_peer(req.get_header().get_peer().clone());\n    msg.set_from_peer(new_peer);\n    let receiver = &cluster.receiver(0);\n    for ty in &[MessageType::MsgRequestVote, MessageType::MsgRequestPreVote] {\n        msg.mut_message().set_msg_type(*ty);\n        cluster.routers[0].send_raft_message(msg.clone()).unwrap();\n        let tombstone_msg = match receiver.recv_timeout(Duration::from_millis(300)) {\n            Ok(msg) => msg,\n            Err(e) => panic!(\"failed to receive tombstone message {:?}: {:?}\", ty, e),\n        };\n        assert_tombstone_msg(&tombstone_msg, region_id, 10);\n    }\n    // Non-vote message should not trigger tombstone.\n    msg.mut_message().set_msg_type(MessageType::MsgHeartbeat);\n    cluster.routers[0].send_raft_message(msg).unwrap();\n    cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap_err();\n\n    // GcTick should also trigger tombstone.\n    cluster.routers[0]\n        .send(region_id, PeerMsg::Tick(PeerTick::GcPeer))\n        .unwrap();\n    let tombstone_msg = cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    assert_tombstone_msg(&tombstone_msg, region_id, 10);\n\n    // First message to create the peer and destroy.\n    cluster.routers[1]\n        .send_raft_message(Box::new(tombstone_msg.clone()))\n        .unwrap();\n    cluster.routers[1].wait_flush(region_id, Duration::from_millis(300));\n    cluster\n        .receiver(1)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap_err();\n    // Send message should trigger tombstone report.\n    cluster.routers[1]\n        .send_raft_message(Box::new(tombstone_msg))\n        .unwrap();\n    let report = cluster\n        .receiver(1)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    assert_valid_report(&report, region_id, 10);\n    cluster.routers[0]\n        .send_raft_message(Box::new(report))\n        .unwrap();\n    let raft_engine = &cluster.node(0).running_state().unwrap().raft_engine;\n    let region_state = raft_engine\n        .get_region_state(region_id, u64::MAX)\n        .unwrap()\n        .unwrap();\n    assert_eq!(region_state.get_removed_records().len(), 1);\n    // Tick should flush records gc.\n    cluster.routers[0]\n        .send(region_id, PeerMsg::Tick(PeerTick::GcPeer))\n        .unwrap();\n    // Trigger a write to make sure records gc is finished.\n    let header = Box::new(cluster.routers[0].new_request_for(region_id).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n    let (msg, sub) = PeerMsg::simple_write(header, put.encode());\n    cluster.routers[0].send(region_id, msg).unwrap();\n    block_on(sub.result()).unwrap();\n    cluster.routers[0].wait_flush(region_id, Duration::from_millis(300));\n    let region_state = raft_engine\n        .get_region_state(region_id, u64::MAX)\n        .unwrap()\n        .unwrap();\n    assert!(region_state.get_removed_records().is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::help", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn help() {\n    new_ucmd!().args(&[\"--help\"]).succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raft_storage.rs::test_raft_storage", "code": "fn clone(&self) -> Self {\n        let refs = self.refs.fetch_add(1, atomic::Ordering::SeqCst);\n\n        trace!(\n            \"Storage referenced\"; \"original_ref\" => refs\n        );\n\n        Self {\n            engine: self.engine.clone(),\n            sched: self.sched.clone(),\n            read_pool: self.read_pool.clone(),\n            refs: self.refs.clone(),\n            max_key_size: self.max_key_size,\n            concurrency_manager: self.concurrency_manager.clone(),\n            api_version: self.api_version,\n            causal_ts_provider: self.causal_ts_provider.clone(),\n            resource_tag_factory: self.resource_tag_factory.clone(),\n            quota_limiter: self.quota_limiter.clone(),\n            _phantom: PhantomData,\n        }\n    }", "test": "fn test_raft_storage() {\n    let (_cluster, storage, mut ctx) = new_raft_storage();\n    let key = Key::from_raw(b\"key\");\n    assert_eq!(storage.get(ctx.clone(), &key, 5).unwrap().0, None);\n    storage\n        .prewrite(\n            ctx.clone(),\n            vec![Mutation::make_put(key.clone(), b\"value\".to_vec())],\n            b\"key\".to_vec(),\n            10,\n        )\n        .unwrap();\n    storage\n        .commit(ctx.clone(), vec![key.clone()], 10, 15)\n        .unwrap();\n    assert_eq!(\n        storage.get(ctx.clone(), &key, 20).unwrap().0.unwrap(),\n        b\"value\".to_vec()\n    );\n\n    // Test wrong region id.\n    let region_id = ctx.get_region_id();\n    ctx.set_region_id(region_id + 1);\n    storage.get(ctx.clone(), &key, 20).unwrap_err();\n    storage\n        .batch_get(ctx.clone(), &[key.clone()], 20)\n        .unwrap_err();\n    storage\n        .scan(ctx.clone(), key, None, 1, false, 20)\n        .unwrap_err();\n    storage.scan_locks(ctx, 20, None, None, 100).unwrap_err();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_read.rs::test_read_index", "code": "pub fn read(&self) -> Option<&ReadResponse> {\n        match self {\n            QueryResult::Read(r) => Some(r),\n            _ => None,\n        }\n    }", "test": "fn test_read_index() {\n    let mut config = v2_default_config();\n    config.raft_store_max_leader_lease = ReadableDuration::millis(150);\n    let cluster = Cluster::with_config(config);\n    let router = &cluster.routers[0];\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let region_id = 2;\n    let mut req = router.new_request_for(region_id);\n    let mut request_inner = Request::default();\n    request_inner.set_cmd_type(CmdType::Snap);\n    request_inner.mut_read_index();\n    req.mut_requests().push(request_inner);\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    assert_eq!(resp.read_index, 6); // single node commited index should be 6.\n\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    // Since it's still with the lease, read index will be skipped.\n    assert_eq!(resp.read_index, 0);\n\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    // the read lease should be expired\n    let res = router.query(region_id, req.clone()).unwrap();\n    let resp = res.read().unwrap();\n    assert_eq!(resp.read_index, 6);\n\n    std::thread::sleep(std::time::Duration::from_millis(200));\n    let read_req = req.clone();\n    // the read lease should be expired and renewed by write\n    let header = Box::new(router.new_request_for(region_id).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n\n    let (msg, sub) = PeerMsg::simple_write(header, put.encode());\n    router.send(region_id, msg).unwrap();\n    block_on(sub.result()).unwrap();\n\n    let res = router.query(region_id, read_req).unwrap();\n    let resp = res.read().unwrap();\n    assert_eq!(resp.read_index, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_equal_as_delimiter2", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_equal_as_delimiter2() {\n    new_ucmd!()\n        .args(&[\"-f2\", \"--delimiter=\"])\n        .pipe_in(\"a=b\\n\")\n        .succeeds()\n        .stdout_only(\"a=b\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_help_flag", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_help_flag() {\n    let help_short = new_ucmd!().arg(\"-h\").succeeds();\n    let help_long = new_ucmd!().arg(\"--help\").succeeds();\n\n    assert_eq!(help_short.stdout_str(), help_long.stdout_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_dry_run", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mktemp_dry_run() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE6)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE7)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-u\")\n        .arg(TEST_TEMPLATE8)\n        .fails();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_list", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_list() {\n    test_parse_err::<Vec<f64>>(&[\n        (\"[\", \"EOF while parsing a list at line 1 column 1\"),\n        (\"[ \", \"EOF while parsing a list at line 1 column 2\"),\n        (\"[1\", \"EOF while parsing a list at line 1 column 2\"),\n        (\"[1,\", \"EOF while parsing a value at line 1 column 3\"),\n        (\"[1,]\", \"trailing comma at line 1 column 4\"),\n        (\"[1 2]\", \"expected `,` or `]` at line 1 column 4\"),\n        (\"[]a\", \"trailing characters at line 1 column 3\"),\n    ]);\n\n    test_parse_ok(vec![\n        (\"[]\", vec![]),\n        (\"[ ]\", vec![]),\n        (\"[null]\", vec![()]),\n        (\" [ null ] \", vec![()]),\n    ]);\n\n    test_parse_ok(vec![(\"[true]\", vec![true])]);\n\n    test_parse_ok(vec![(\"[3,1]\", vec![3u64, 1]), (\" [ 3 , 1 ] \", vec![3, 1])]);\n\n    test_parse_ok(vec![(\"[[3], [1, 2]]\", vec![vec![3u64], vec![1, 2]])]);\n\n    test_parse_ok(vec![(\"[1]\", (1u64,))]);\n\n    test_parse_ok(vec![(\"[1, 2]\", (1u64, 2u64))]);\n\n    test_parse_ok(vec![(\"[1, 2, 3]\", (1u64, 2u64, 3u64))]);\n\n    test_parse_ok(vec![(\"[1, [2, 3]]\", (1u64, (2u64, 3u64)))]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_file_exists_and_is_regular", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_file_exists_and_is_regular() {\n    new_ucmd!().args(&[\"-f\", \"regular_file\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_all_then_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_all_then_none() {\n    // take last if multiple update args are supplied,\n    // update=none wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_all_then_none_file1\";\n    let new = \"test_cp_arg_update_all_then_none_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=all\")\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/byte_order_mark.rs::dont_mention_byte_order_mark_in_errors", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dont_mention_byte_order_mark_in_errors() {\n  Test::new()\n    .justfile(\"{\")\n    .stderr(\n      \"\n      error: Expected '@', '[', comment, end of file, end of line, or identifier, but found '{'\n        |\n      1 | {\n        | ^\n      \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_nonexisting_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_nonexisting_file() {\n    let file_name = \"asdf\";\n\n    new_ucmd!()\n        .arg(file_name)\n        .fails()\n        .no_stdout()\n        .stderr_contains(format!(\"cksum: {file_name}: No such file or directory\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_empty_test_equivalent_to_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_empty_test_equivalent_to_false() {\n    new_ucmd!().run().code_is(1);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::as_cast_test", "code": "fn as_cast<T: num::AsCast>(t: T) {\n    let _: i8 = num::as_cast(t);\n    let _: i16 = num::as_cast(t);\n    let _: i32 = num::as_cast(t);\n    let _: i64 = num::as_cast(t);\n    let _: i128 = num::as_cast(t);\n    let _: isize = num::as_cast(t);\n    let _: u8 = num::as_cast(t);\n    let _: u16 = num::as_cast(t);\n    let _: u32 = num::as_cast(t);\n    let _: u64 = num::as_cast(t);\n    let _: u128 = num::as_cast(t);\n    let _: usize = num::as_cast(t);\n    let _: f32 = num::as_cast(t);\n    let _: f64 = num::as_cast(t);\n}", "test": "fn as_cast_test() {\n    as_cast(1u8);\n    as_cast(1u16);\n    as_cast(1u32);\n    as_cast(1u64);\n    as_cast(1u128);\n    as_cast(1usize);\n    as_cast(1i8);\n    as_cast(1i16);\n    as_cast(1i32);\n    as_cast(1i64);\n    as_cast(1i128);\n    as_cast(1isize);\n    as_cast(1f32);\n    as_cast(1f64);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/quote.rs::quotes_are_escaped", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn quotes_are_escaped() {\n  Test::new()\n    .justfile(\n      r#\"\n      x := quote(\"'\")\n    \"#,\n    )\n    .args([\"--evaluate\", \"x\"])\n    .stdout(r\"''\\'''\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_no_match5", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_no_match5() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/nope/\", \"{*}\"])\n        .succeeds()\n        .stdout_only(\"141\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_config_ok_formatter_no_linter", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn extends_config_ok_formatter_no_linter() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"format.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), test_file.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_config_ok_formatter_no_linter\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_reflink_always_override", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_cp_reflink_always_override() {\n    let scene = TestScenario::new(util_name!());\n\n    const DISK: &str = \"disk.img\";\n    const ROOTDIR: &str = \"disk_root/\";\n    const USERDIR: &str = \"dir/\";\n    const MOUNTPOINT: &str = \"mountpoint/\";\n\n    let src1_path: &str = &[MOUNTPOINT, USERDIR, \"src1\"].concat();\n    let src2_path: &str = &[MOUNTPOINT, USERDIR, \"src2\"].concat();\n    let dst_path: &str = &[MOUNTPOINT, USERDIR, \"dst\"].concat();\n\n    scene.fixtures.mkdir(ROOTDIR);\n    scene.fixtures.mkdir([ROOTDIR, USERDIR].concat());\n\n    // Setup:\n    // Because neither `mkfs.btrfs` not btrfs `mount` options allow us to have a mountpoint owned\n    // by a non-root user, we want the following directory structure:\n    //\n    // uid  | path\n    // ---------------------------\n    // user | .\n    // root | \u2514\u2500\u2500 mountpoint\n    // user |     \u2514\u2500\u2500 dir\n    // user |         \u251c\u2500\u2500 src1\n    // user |         \u2514\u2500\u2500 src2\n\n    scene\n        .ccmd(\"truncate\")\n        .args(&[\"-s\", \"128M\", DISK])\n        .succeeds();\n\n    if !scene\n        .cmd(\"env\")\n        .env(\"PATH\", PATH)\n        .args(&[\"mkfs.btrfs\", \"--rootdir\", ROOTDIR, DISK])\n        .run()\n        .succeeded()\n    {\n        print!(\"Test skipped; couldn't make btrfs disk image\");\n        return;\n    }\n\n    scene.fixtures.mkdir(MOUNTPOINT);\n\n    let mount = scene\n        .cmd(\"sudo\")\n        .env(\"PATH\", PATH)\n        .args(&[\"-E\", \"--non-interactive\", \"mount\", DISK, MOUNTPOINT])\n        .run();\n\n    if !mount.succeeded() {\n        print!(\"Test skipped; requires root user\");\n        return;\n    }\n\n    scene.fixtures.make_file(src1_path);\n    scene.fixtures.write_bytes(src1_path, &[0x64; 8192]);\n\n    scene.fixtures.make_file(src2_path);\n    scene.fixtures.write(src2_path, \"other data\");\n\n    scene\n        .ucmd()\n        .args(&[\"--reflink=always\", src1_path, dst_path])\n        .succeeds();\n\n    scene\n        .ucmd()\n        .args(&[\"--reflink=always\", src2_path, dst_path])\n        .succeeds();\n\n    scene\n        .cmd(\"sudo\")\n        .env(\"PATH\", PATH)\n        .args(&[\"-E\", \"--non-interactive\", \"umount\", MOUNTPOINT])\n        .succeeds();\n}\n\n#[test]\nfn test_copy_d"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::issue_9", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn issue_9() {\n    setup();\n\n    let path = format!(\"{}/tests/issue9.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"Feuil1\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [String(\"test1\".to_string())],\n            [String(\"test2 other\".to_string())],\n            [String(\"test3 aaa\".to_string())],\n            [String(\"test4\".to_string())]\n        ]\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_fast_destroy", "code": "fn test_fast_destroy<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n    // remove peer (3, 3)\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n\n    must_get_none(&engine_3, b\"k1\");\n\n    cluster.stop_node(3);\n\n    let key = keys::region_state_key(1);\n    let state: RegionLocalState = engine_3.get_msg_cf(CF_RAFT, &key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // Force add some dirty data.\n    engine_3.put(&keys::data_key(b\"k0\"), b\"v0\").unwrap();\n\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    // start node again.\n    cluster.run_node(3).unwrap();\n\n    // add new peer in node 3\n    pd_client.must_add_peer(1, new_peer(3, 4));\n\n    must_get_equal(&engine_3, b\"k2\", b\"v2\");\n    // the dirty data must be cleared up.\n    must_get_none(&engine_3, b\"k0\");\n}", "test": "fn test_server_fast_destroy() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    test_fast_destroy(&mut cluster);\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_macro", "code": "pub fn push(&mut self, val: T) {\n    if self.len < self.capacity() {\n      self.data[self.len] = val;\n      self.len += 1;\n    } else {\n      panic!(\"SliceVec::push> capacity overflow\")\n    }\n  }", "test": "fn TinyVec_macro() {\n  let mut expected: TinyVec<[i32; 4]> = Default::default();\n  expected.push(1);\n  expected.push(2);\n  expected.push(3);\n\n  let actual = tiny_vec!(1, 2, 3);\n\n  assert_eq!(expected, actual);\n\n  assert_eq!(tiny_vec![0u8; 4], tiny_vec!(0u8, 0u8, 0u8, 0u8));\n  assert_eq!(tiny_vec![0u8; 4], tiny_vec!([u8; 4] => 0, 0, 0, 0));\n  assert_eq!(tiny_vec![0; 4], tiny_vec!(0, 0, 0, 0));\n  assert_eq!(tiny_vec![0; 4], tiny_vec!([u8; 4] => 0, 0, 0, 0));\n\n  let expected2 = tiny_vec![1.1; 3];\n  let actual2 = tiny_vec!([f32; 3] => 1.1, 1.1, 1.1);\n  assert_eq!(expected2, actual2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_random_ignore_case", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_random_ignore_case() {\n    let input = \"ABC\\nABc\\nAbC\\nAbc\\naBC\\naBc\\nabC\\nabc\\n\";\n    new_ucmd!()\n        .args(&[\"-fR\"])\n        .pipe_in(input)\n        .succeeds()\n        .stdout_is(input);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple4_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn tuple4_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8, u16, u32), (u16, u32)> =\n        TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5, 6, 7), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(\n        table.get(&(\"hello\", 5, 6, 7)).unwrap().unwrap().value(),\n        (0, 123)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_rawkv.rs::test_region_merge", "code": "pub fn get_end_key(&self) -> &[u8] {\n        self.region.get_end_key()\n    }", "test": "fn test_region_merge() {\n    let mut suite = TestSuite::new(3, ApiVersion::V2);\n    let keys = vec![b\"rk0\", b\"rk1\", b\"rk2\", b\"rk3\", b\"rk4\", b\"rk5\"];\n\n    suite.must_raw_put(keys[1], b\"v1\");\n    suite.must_raw_put(keys[3], b\"v3\");\n    suite.must_raw_put(keys[5], b\"v5\");\n\n    // Split to: region1: (-, 2), region3: [2, 4), region5: [4, +)\n    let region1 = suite.cluster.get_region(keys[1]);\n    suite.cluster.must_split(&region1, keys[2]);\n    let region1 = suite.cluster.get_region(keys[1]);\n    let region3 = suite.cluster.get_region(keys[3]);\n    suite.cluster.must_split(&region3, keys[4]);\n    let region3 = suite.cluster.get_region(keys[3]);\n    let region5 = suite.cluster.get_region(keys[5]);\n    assert_eq!(region1.get_end_key(), region3.get_start_key());\n    assert_eq!(region3.get_end_key(), region5.get_start_key());\n\n    // Transfer leaders: region 1 -> store 1, region 3 -> store 2, region 5 -> store\n    // 3.\n    suite.must_transfer_leader(&region1, 1);\n    suite.must_transfer_leader(&region3, 2);\n    suite.must_transfer_leader(&region5, 3);\n\n    // Write to region 1.\n    {\n        let leader1 = suite.must_leader_on_store(keys[1], 1);\n\n        suite.must_raw_put(keys[1], b\"v2\");\n        suite.must_raw_put(keys[1], b\"v3\");\n        suite.flush_timestamp(leader1.get_store_id()); // Flush to make ts of store 1 larger than others.\n        suite.must_raw_put(keys[1], b\"v4\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n    }\n\n    // Make causal_ts_provider.async_flush() & handle_update_max_timestamp fail.\n    fail::cfg(FP_GET_TSO, \"return(50)\").unwrap();\n\n    // Merge region 1 to 3.\n    {\n        suite.must_merge_region_by_key(keys[1], keys[3]);\n        suite.must_leader_on_store(keys[1], 2);\n\n        // Write to store 2. Store 2 has a TSO batch smaller than store 1.\n        suite.raw_put_err_by_timestamp_not_synced(keys[1], b\"v5\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n        suite.raw_put_err_by_timestamp_not_synced(keys[1], b\"v6\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n    }\n\n    // Make handle_update_max_timestamp succeed.\n    fail::cfg(FP_GET_TSO, \"off\").unwrap();\n\n    // Merge region 3 to 5.\n    {\n        suite.must_merge_region_by_key(keys[3], keys[5]);\n        suite.must_leader_on_store(keys[1], 3);\n\n        // Write to store 3.\n        suite.must_raw_put(keys[1], b\"v7\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v7\".to_vec()));\n        suite.must_raw_put(keys[1], b\"v8\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v8\".to_vec()));\n    }\n\n    fail::remove(FP_GET_TSO);\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_check_md5sum_reverse_bsd", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_check_md5sum_reverse_bsd() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    #[cfg(not(windows))]\n    {\n        for f in &[\"a\", \" b\", \"*c\", \"dd\", \" \"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"60b725f10c9c85c70d97880dfe8191b3 a\\n\\\n             bf35d7536c785cf06730d5a40301eba2  b\\n\\\n             f5b61709718c1ecf8db1aea8547d4698 *c\\n\\\n             b064a020db8018f18ff5ae367d01b212 dd\\n\\\n             d784fa8b6d98d27699781bd9a7cf19f0  \",\n        );\n        scene\n            .ccmd(\"md5sum\")\n            .arg(\"--strict\")\n            .arg(\"-c\")\n            .arg(\"check.md5sum\")\n            .succeeds()\n            .stdout_is(\"a: OK\\n b: OK\\n*c: OK\\ndd: OK\\n : OK\\n\")\n            .stderr_is(\"\");\n    }\n    #[cfg(windows)]\n    {\n        for f in &[\"a\", \" b\", \"dd\"] {\n            at.write(f, &format!(\"{f}\\n\"));\n        }\n        at.write(\n            \"check.md5sum\",\n            \"60b725f10c9c85c70d97880dfe8191b3 a\\n\\\n             bf35d7536c785cf06730d5a40301eba2  b\\n\\\n             b064a020db8018f18ff5ae367d01b212 dd\",\n        );\n        scene\n            .ccmd(\"md5sum\")\n            .arg(\"--strict\")\n            .arg(\"-c\")\n            .arg(\"check.md5sum\")\n            .succeeds()\n            .stdout_is(\"a: OK\\n b: OK\\ndd: OK\\n\")\n            .stderr_is(\"\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_fold_at_word_boundary_only_whitespace_preserve_final_newline", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_fold_at_word_boundary_only_whitespace_preserve_final_newline() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-s\", \"-b\"])\n        .pipe_in(\"    \\n\")\n        .succeeds()\n        .stdout_is(\"  \\n  \\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_octal_invalid_digit", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_octal_invalid_digit() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\08 bar\"])\n        .succeeds()\n        .stdout_only(\"foo\\u{0}8 bar\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_snap.rs::test_server_huge_snapshot_multi_files", "code": "fn test_huge_snapshot<T: Simulator>(cluster: &mut Cluster<T>, max_snapshot_file_size: u64) {\n    cluster.cfg.rocksdb.titan.enabled = true;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(1000);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.snap_apply_batch_size = ReadableSize(500);\n    cluster.cfg.raft_store.max_snapshot_file_raw_size = ReadableSize(max_snapshot_file_size);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    let first_value = vec![0; 10240];\n    // at least 4m data\n    for i in 0..400 {\n        let key = format!(\"{:03}\", i);\n        cluster.must_put(key.as_bytes(), &first_value);\n    }\n    let first_key: &[u8] = b\"000\";\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, first_key);\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k2\", b\"v2\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    must_get_equal(&engine_2, key, value);\n\n    // now snapshot must be applied on peer 2;\n    must_get_equal(&engine_2, first_key, &first_value);\n    let stale = Arc::new(AtomicBool::new(false));\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(LeadingDuplicatedSnapshotFilter::new(\n            Arc::clone(&stale),\n            false,\n        )),\n    );\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n    let mut i = 400;\n    loop {\n        i += 1;\n        let key = format!(\"{:03}\", i);\n        cluster.must_put(key.as_bytes(), &first_value);\n        if stale.load(Ordering::Relaxed) {\n            break;\n        }\n        if i > 1000 {\n            panic!(\"snapshot should be sent twice after {} kvs\", i);\n        }\n    }\n    cluster.must_put(b\"k3\", b\"v3\");\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k3\", b\"v3\");\n\n    // TODO: add more tests.\n}", "test": "fn test_server_huge_snapshot_multi_files() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_huge_snapshot(&mut cluster, 1024 * 1024);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram_fails_to_stream", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_datagram_fails_to_stream() {\n    // Lookup to UDP should fail, and then the query should be retried on TCP because\n    // `try_tcp_on_error` is set to true.\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n    let udp_message: Result<DnsResponse, _> = Err(ResolveError::from(\"Forced Testing Error\"));\n\n    let tcp_message = message(query.clone(), vec![tcp_record.clone()], vec![], vec![]);\n\n    let udp_nameserver = mock_nameserver(vec![udp_message], Default::default());\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let mut options = ResolverOpts::default();\n    options.try_tcp_on_error = true;\n    let pool = mock_nameserver_pool(vec![udp_nameserver], vec![tcp_nameserver], None, options);\n\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], tcp_record);\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_duplicate_works", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "test": "fn static_duplicate_works() {\n    let (mut store, duplicate, duplicate_dyn) = setup_duplicate();\n    let duplicate = duplicate.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    let duplicate_dyn = duplicate_dyn.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    for input in 0..10 {\n        assert_eq!(duplicate.call(&mut store, input).unwrap(), (input, input));\n        assert_eq!(\n            duplicate_dyn.call(&mut store, input).unwrap(),\n            (input, input)\n        );\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_1() {\n    let original = r##\"| foo | bar |\n| --- | --- |\n| baz | bim |\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>foo</th>\n<th>bar</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>baz</td>\n<td>bim</td>\n</tr>\n</tbody>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_preserve_final_newline_when_line_equal_to_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_preserve_final_newline_when_line_equal_to_fold() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-b\"])\n        .pipe_in(\"1\\n\")\n        .succeeds()\n        .stdout_is(\"1\\n\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_externally_b_de", "code": "fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n}", "test": "fn test_externally_b_de() {\n    let s = \"VariantB(foo:1,bar:2)\";\n    let e = EnumStructExternally::VariantB { foo: 1, bar: 2 };\n    test_de(s, e);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_not_add_newline_when_line_equal_to_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_not_add_newline_when_line_equal_to_fold() {\n    new_ucmd!()\n        .arg(\"-w1\")\n        .pipe_in(\" \")\n        .succeeds()\n        .stdout_is(\" \");\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::regression_2_funcdefptr", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn regression_2_funcdefptr() {\n    let source = r#\"\n    void *malloc() {\n        return NULL;\n    }\"#;\n\n    let needle = \"_ $func() {return NULL;}\";\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_remove_symlink_dir", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_rmdir_remove_symlink_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"dir\");\n    at.symlink_dir(\"dir\", \"dl\");\n\n    ucmd.arg(\"dl/\")\n        .fails()\n        .stderr_is(\"rmdir: failed to remove 'dl/': Symbolic link not followed\\n\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_rustls_tests.rs::test_example_tls_toml_startup", "code": "pub fn query_a<C: ClientHandle>(io_loop: &mut Runtime, client: &mut C) {\n    let name = Name::from_str(\"www.example.com\").unwrap();\n    let response = query_message(io_loop, client, name, RecordType::A);\n    let record = &response.answers()[0];\n\n    if let Some(RData::A(ref address)) = record.data() {\n        assert_eq!(address, &A::new(127, 0, 0, 1))\n    } else {\n        panic!(\"wrong RDATA\")\n    }\n}", "test": "fn test_example_tls_toml_startup() {\n    named_test_harness(\n        \"dns_over_tls_rustls_and_openssl.toml\",\n        move |_, _, tls_port, _, _| {\n            let mut cert_der = vec![];\n            let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"..\".to_owned());\n            println!(\"using server src path: {server_path}\");\n\n            File::open(format!(\n                \"{server_path}/tests/test-data/test_configs/sec/example.cert\"\n            ))\n            .expect(\"failed to open cert\")\n            .read_to_end(&mut cert_der)\n            .expect(\"failed to read cert\");\n\n            let mut io_loop = Runtime::new().unwrap();\n            let addr: SocketAddr = (\"127.0.0.1\", tls_port.expect(\"no tls_port\"))\n                .to_socket_addrs()\n                .unwrap()\n                .next()\n                .unwrap();\n\n            let cert = to_trust_anchor(&cert_der);\n            let mut root_store = RootCertStore::empty();\n            root_store.add(&cert).expect(\"bad certificate\");\n\n            let config = ClientConfig::builder()\n                .with_safe_defaults()\n                .with_root_certificates(root_store)\n                .with_no_client_auth();\n\n            let config = Arc::new(config);\n\n            let (stream, sender) = tls_client_connect::<AsyncIoTokioAsStd<TokioTcpStream>>(\n                addr,\n                \"ns.example.com\".to_string(),\n                config.clone(),\n            );\n            let client = AsyncClient::new(stream, sender, None);\n\n            let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n            hickory_proto::spawn_bg(&io_loop, bg);\n\n            // ipv4 should succeed\n            query_a(&mut io_loop, &mut client);\n\n            let addr: SocketAddr = (\"127.0.0.1\", tls_port.expect(\"no tls_port\"))\n                .to_socket_addrs()\n                .unwrap()\n                .next()\n                .unwrap();\n            let (stream, sender) = tls_client_connect::<AsyncIoTokioAsStd<TokioTcpStream>>(\n                addr,\n                \"ns.example.com\".to_string(),\n                config,\n            );\n            let client = AsyncClient::new(stream, sender, None);\n\n            let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n            hickory_proto::spawn_bg(&io_loop, bg);\n\n            // ipv6 should succeed\n            query_a(&mut io_loop, &mut client);\n        },\n    )\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_points_and_counts", "code": "pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }", "test": "fn save_points_and_counts() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::wasm_flags_without_subcommand", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn wasm_flags_without_subcommand() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .current_dir(\"tests/all/cli_tests/\")\n        .arg(\"print-arguments.wat\")\n        .arg(\"-foo\")\n        .arg(\"bar\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"\\\n            print-arguments.wat\\n\\\n            -foo\\n\\\n            bar\\n\\\n        \"\n    );\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_io.rs::test_async_io_cannot_destroy_when_persist_snapshot", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_async_io_cannot_destroy_when_persist_snapshot() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    configure_for_snapshot(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_1 = find_peer(&region, 1).cloned().unwrap();\n    let peer_3 = find_peer(&region, 3).cloned().unwrap();\n\n    cluster.must_transfer_leader(region.get_id(), peer_1);\n\n    cluster.must_put(b\"k\", b\"v\");\n    // Make sure peer 3 exists\n    must_get_equal(&cluster.get_engine(3), b\"k\", b\"v\");\n\n    let dropped_msgs = Arc::new(Mutex::new(Vec::new()));\n    let send_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 3)\n            .direction(Direction::Send)\n            .msg_type(MessageType::MsgAppendResponse)\n            .reserve_dropped(Arc::clone(&dropped_msgs)),\n    );\n    cluster.sim.wl().add_send_filter(3, send_filter);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.sim.wl().clear_send_filters(3);\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    for i in 2..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n\n    let raft_before_save_kv_on_store_3_fp = \"raft_before_save_kv_on_store_3\";\n    fail::cfg(raft_before_save_kv_on_store_3_fp, \"pause\").unwrap();\n\n    let (notify_tx, notify_rx) = mpsc::channel();\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(MessageTypeNotifier::new(\n            MessageType::MsgSnapshot,\n            notify_tx,\n            Arc::new(AtomicBool::new(true)),\n        )),\n    );\n\n    cluster.clear_send_filters();\n\n    // Wait for leader sending snapshot to peer 3\n    notify_rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    // Wait for peer 3 handling snapshot\n    sleep_ms(100);\n\n    pd_client.must_remove_peer(region.get_id(), peer_3);\n\n    // Trigger leader sending tombstone msg to peer 3\n    let router = cluster.sim.wl().get_router(1).unwrap();\n    for raft_msg in dropped_msgs.lock().unwrap().drain(..).rev() {\n        if raft_msg.get_to_peer().get_store_id() == 1 {\n            router.send_raft_message(raft_msg).unwrap();\n            break;\n        }\n    }\n    // Wait for peer 3 handling tombstone msg\n    sleep_ms(100);\n\n    // Peer 3 should not be destroyed because its snapshot is persisting\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    fail::remove(raft_before_save_kv_on_store_3_fp);\n\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_disabled", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_disabled() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().disable_push())\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // attempt to push - expect failure\n        let req = http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://http2.akamai.com/style.css\")\n            .body(())\n            .unwrap();\n        stream\n            .push_request(req)\n            .expect_err(\"push_request should error\");\n\n        // send normal response\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_life.rs::test_gc_peer_request", "code": "pub fn assert_valid_report(report: &RaftMessage, region_id: u64, peer_id: u64) {\n        assert_eq!(\n            report.get_extra_msg().get_type(),\n            ExtraMessageType::MsgGcPeerResponse\n        );\n        assert_eq!(report.get_region_id(), region_id);\n        assert_eq!(report.get_from_peer().get_id(), peer_id);\n    }", "test": "fn test_gc_peer_request() {\n    let cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    let test_region_id = 4;\n    let test_peer_id = 5;\n    let test_leader_id = 6;\n\n    let mut msg = Box::<RaftMessage>::default();\n    msg.set_region_id(test_region_id);\n    msg.set_to_peer(new_peer(1, test_peer_id));\n    msg.mut_region_epoch().set_conf_ver(1);\n    msg.set_from_peer(new_peer(2, test_leader_id));\n    let raft_message = msg.mut_message();\n    raft_message.set_msg_type(raft::prelude::MessageType::MsgHeartbeat);\n    raft_message.set_from(6);\n    raft_message.set_term(5);\n\n    // Tombstone message should create the peer and then destroy it.\n    let mut tombstone_msg = msg.clone();\n    tombstone_msg.set_is_tombstone(true);\n    router.send_raft_message(tombstone_msg.clone()).unwrap();\n    cluster.routers[0].wait_flush(test_region_id, Duration::from_millis(300));\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    // Resend a normal message will not create the peer.\n    router.send_raft_message(msg).unwrap();\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap_err();\n    // Resend tombstone message should trigger report.\n    router.send_raft_message(tombstone_msg).unwrap();\n    assert_peer_not_exist(test_region_id, test_peer_id, router);\n    let report = cluster\n        .receiver(0)\n        .recv_timeout(Duration::from_millis(300))\n        .unwrap();\n    assert_valid_report(&report, test_region_id, test_peer_id);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_user_id_nonexistent_user", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_chown_only_user_id_nonexistent_user() {\n    let ts = TestScenario::new(util_name!());\n    let at = ts.fixtures.clone();\n    at.touch(\"f\");\n    if let Ok(result) = run_ucmd_as_root(&ts, &[\"12345\", \"f\"]) {\n        result.success().no_stdout().no_stderr();\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::trim_end_match", "code": "fn assert_eval_eq(expression: &str, result: &str) {\n  Test::new()\n    .justfile(format!(\"x := {expression}\"))\n    .args([\"--evaluate\", \"x\"])\n    .stdout(result)\n    .unindent_stdout(false)\n    .run();\n}", "test": "fn trim_end_match() {\n  assert_eval_eq(\"trim_end_match('foo', 'o')\", \"fo\");\n  assert_eval_eq(\"trim_end_match('fabab', 'ab')\", \"fab\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_unnest_in_from_clause", "code": "fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }", "test": "fn parse_unnest_in_from_clause() {\n    fn chk(\n        array_exprs: &str,\n        alias: bool,\n        with_offset: bool,\n        with_offset_alias: bool,\n        dialects: &TestedDialects,\n        want: Vec<TableWithJoins>,\n    ) {\n        let sql = &format!(\n            \"SELECT * FROM UNNEST({}){}{}{}\",\n            array_exprs,\n            if alias { \" AS numbers\" } else { \"\" },\n            if with_offset { \" WITH OFFSET\" } else { \"\" },\n            if with_offset_alias {\n                \" AS with_offset_alias\"\n            } else {\n                \"\"\n            },\n        );\n        let select = dialects.verified_only_select(sql);\n        assert_eq!(select.from, want);\n    }\n    let dialects = TestedDialects {\n        dialects: vec![Box::new(BigQueryDialect {}), Box::new(GenericDialect {})],\n        options: None,\n    };\n    // 1. both Alias and WITH OFFSET clauses.\n    chk(\n        \"expr\",\n        true,\n        true,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: Some(TableAlias {\n                    name: Ident::new(\"numbers\"),\n                    columns: vec![],\n                }),\n                array_exprs: vec![Expr::Identifier(Ident::new(\"expr\"))],\n                with_offset: true,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    );\n    // 2. neither Alias nor WITH OFFSET clause.\n    chk(\n        \"expr\",\n        false,\n        false,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: None,\n                array_exprs: vec![Expr::Identifier(Ident::new(\"expr\"))],\n                with_offset: false,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    );\n    // 3. Alias but no WITH OFFSET clause.\n    chk(\n        \"expr\",\n        false,\n        true,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: None,\n                array_exprs: vec![Expr::Identifier(Ident::new(\"expr\"))],\n                with_offset: true,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    );\n    // 4. WITH OFFSET but no Alias.\n    chk(\n        \"expr\",\n        true,\n        false,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: Some(TableAlias {\n                    name: Ident::new(\"numbers\"),\n                    columns: vec![],\n                }),\n                array_exprs: vec![Expr::Identifier(Ident::new(\"expr\"))],\n                with_offset: false,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    );\n    // 5. Simple array\n    chk(\n        \"make_array(1, 2, 3)\",\n        false,\n        false,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: None,\n                array_exprs: vec![Expr::Function(Function {\n                    name: ObjectName(vec![Ident::new(\"make_array\")]),\n                    args: vec![\n                        FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"1\")))),\n                        FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"2\")))),\n                        FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"3\")))),\n                    ],\n                    null_treatment: None,\n                    filter: None,\n                    over: None,\n                    distinct: false,\n                    special: false,\n                    order_by: vec![],\n                })],\n                with_offset: false,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    );\n    // 6. Multiple arrays\n    chk(\n        \"make_array(1, 2, 3), make_array(5, 6)\",\n        false,\n        false,\n        false,\n        &dialects,\n        vec![TableWithJoins {\n            relation: TableFactor::UNNEST {\n                alias: None,\n                array_exprs: vec![\n                    Expr::Function(Function {\n                        name: ObjectName(vec![Ident::new(\"make_array\")]),\n                        args: vec![\n                            FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"1\")))),\n                            FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"2\")))),\n                            FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"3\")))),\n                        ],\n                        null_treatment: None,\n                        filter: None,\n                        over: None,\n                        distinct: false,\n                        special: false,\n                        order_by: vec![],\n                    }),\n                    Expr::Function(Function {\n                        name: ObjectName(vec![Ident::new(\"make_array\")]),\n                        args: vec![\n                            FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"5\")))),\n                            FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(number(\"6\")))),\n                        ],\n                        null_treatment: None,\n                        filter: None,\n                        over: None,\n                        distinct: false,\n                        special: false,\n                        order_by: vec![],\n                    }),\n                ],\n                with_offset: false,\n                with_offset_alias: None,\n            },\n            joins: vec![],\n        }],\n    )\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_obsolete_extras", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_obsolete_extras() {\n    new_ucmd!()\n        .args(&[\"-5zv\"])\n        .pipe_in(\"1\\x002\\x003\\x004\\x005\\x006\")\n        .succeeds()\n        .stdout_is(\"==> standard input <==\\n1\\x002\\x003\\x004\\x005\\0\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::no_warning", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn no_warning() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        echo ${DOTENV_KEY:-unset}\n    \",\n    )\n    .stdout(\"unset\\n\")\n    .stderr(\"echo ${DOTENV_KEY:-unset}\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_backup", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"-b\")\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_break_outside_loop", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_break_outside_loop() {\n    assert_err_msg(r#\"{% break %}\"#, &[\"1:1\", \"{% break %}\", \"expected a template\"]);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_explain_analyze_with_simple_select", "code": "fn run_explain_analyze(\n    query: &str,\n    expected_verbose: bool,\n    expected_analyze: bool,\n    expected_format: Option<AnalyzeFormat>,\n) {\n    match verified_stmt(query) {\n        Statement::Explain {\n            describe_alias: _,\n            analyze,\n            verbose,\n            statement,\n            format,\n        } => {\n            assert_eq!(verbose, expected_verbose);\n            assert_eq!(analyze, expected_analyze);\n            assert_eq!(format, expected_format);\n            assert_eq!(\"SELECT sqrt(id) FROM foo\", statement.to_string());\n        }\n        _ => panic!(\"Unexpected Statement, must be Explain\"),\n    }\n}", "test": "fn parse_explain_analyze_with_simple_select() {\n    // Describe is an alias for EXPLAIN\n    run_explain_analyze(\"DESCRIBE SELECT sqrt(id) FROM foo\", false, false, None);\n\n    run_explain_analyze(\"EXPLAIN SELECT sqrt(id) FROM foo\", false, false, None);\n    run_explain_analyze(\n        \"EXPLAIN VERBOSE SELECT sqrt(id) FROM foo\",\n        true,\n        false,\n        None,\n    );\n    run_explain_analyze(\n        \"EXPLAIN ANALYZE SELECT sqrt(id) FROM foo\",\n        false,\n        true,\n        None,\n    );\n    run_explain_analyze(\n        \"EXPLAIN ANALYZE VERBOSE SELECT sqrt(id) FROM foo\",\n        true,\n        true,\n        None,\n    );\n\n    run_explain_analyze(\n        \"EXPLAIN ANALYZE FORMAT GRAPHVIZ SELECT sqrt(id) FROM foo\",\n        false,\n        true,\n        Some(AnalyzeFormat::GRAPHVIZ),\n    );\n\n    run_explain_analyze(\n        \"EXPLAIN ANALYZE VERBOSE FORMAT JSON SELECT sqrt(id) FROM foo\",\n        true,\n        true,\n        Some(AnalyzeFormat::JSON),\n    );\n\n    run_explain_analyze(\n        \"EXPLAIN VERBOSE FORMAT TEXT SELECT sqrt(id) FROM foo\",\n        true,\n        false,\n        Some(AnalyzeFormat::TEXT),\n    );\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::zero_rtt_happypath", "code": "pub fn has_0rtt(&self) -> bool {\n        self.zero_rtt_enabled\n    }", "test": "fn zero_rtt_happypath() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig {\n            use_retry: true,\n            ..server_config()\n        },\n    );\n    let config = client_config();\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(config.clone());\n    pair.drive();\n    pair.server.assert_accept();\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(0), [][..].into());\n    pair.drive();\n\n    pair.client.addr = SocketAddr::new(\n        Ipv6Addr::LOCALHOST.into(),\n        CLIENT_PORTS.lock().unwrap().next().unwrap(),\n    );\n    info!(\"resuming session\");\n    let client_ch = pair.begin_connect(config);\n    assert!(pair.client_conn_mut(client_ch).has_0rtt());\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"Hello, 0-RTT!\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected)\n    );\n\n    assert!(pair.client_conn_mut(client_ch).accepted_0rtt());\n    let server_ch = pair.server.assert_accept();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    // We don't currently preserve stream event order wrt. connection events\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    let _ = chunks.finalize();\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_directory", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_directory() {\n    new_ucmd!()\n        .args(&[\"/root/alpha/beta/gamma/delta/epsilon/omega/\"])\n        .succeeds()\n        .stdout_only(\"omega\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_division_by_zero_reference_and_size", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_division_by_zero_reference_and_size() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.make_file(FILE1);\n    ucmd.args(&[\"-r\", FILE1, \"-s\", \"/0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"division by zero\");\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.make_file(FILE1);\n    ucmd.args(&[\"-r\", FILE1, \"-s\", \"%0\", \"file\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"division by zero\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tty.rs::test_help", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_help() {\n    new_ucmd!().args(&[\"--help\"]).succeeds();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::do_loop_early_break", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn do_loop_early_break() {\n    // Ordering with statements after the break.\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 1;\n            do {\n                if (a == 3) {\n                    break;\n                }\n                a++;\n            } while (a < 5);\n            a;\n        \"#},\n        3,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"Thu Jan 01 12:34:00 2015\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, start_of_year);\n    assert_eq!(mtime, start_of_year);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_base_template", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_location_base_template() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"Hello {{ greeting + 1}} {% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}Hey{% endblock bob %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\' (error happened in 'parent').\"\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_set_variable", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_set_variable() {\n    match verified_stmt(\"SET SOMETHING = '1'\") {\n        Statement::SetVariable {\n            local,\n            hivevar,\n            variable,\n            value,\n        } => {\n            assert!(!local);\n            assert!(!hivevar);\n            assert_eq!(variable, ObjectName(vec![\"SOMETHING\".into()]));\n            assert_eq!(\n                value,\n                vec![Expr::Value(Value::SingleQuotedString(\"1\".into()))]\n            );\n        }\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\"SET SOMETHING TO '1'\", \"SET SOMETHING = '1'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_carriage_return_is_not_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_carriage_return_is_not_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w6\", \"-s\", \"-b\"])\n        .pipe_in(\"fizz\\rbuzz\\rfizzbuzz\") // spell-checker:disable-line\n        .succeeds()\n        .stdout_is(\"fizz\\rb\\nuzz\\rfi\\nzzbuzz\"); // spell-checker:disable-line\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_retry_pending_prepare_merge_fail", "code": "pub fn is_writable(&self) -> bool {\n        self.status == LocksStatus::Normal\n    }", "test": "fn test_retry_pending_prepare_merge_fail() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    cluster.must_transfer_leader(right.id, new_peer(2, 2));\n\n    // Insert lock l1 into the left region\n    let snapshot = cluster.must_get_snapshot_of_region(left.id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    let l1 = PessimisticLock {\n        primary: b\"k1\".to_vec().into_boxed_slice(),\n        start_ts: 10.into(),\n        ttl: 3000,\n        for_update_ts: 20.into(),\n        min_commit_ts: 30.into(),\n        last_change_ts: 15.into(),\n        versions_to_last_change: 3,\n    };\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(Key::from_raw(b\"k1\"), l1)])\n        .unwrap();\n\n    // Pause apply and write some data to the left region\n    fail::cfg(\"on_handle_apply\", \"pause\").unwrap();\n    let (propose_tx, propose_rx) = mpsc::sync_channel(10);\n    fail::cfg_callback(\"after_propose\", move || propose_tx.send(()).unwrap()).unwrap();\n\n    let mut rx = cluster.async_put(b\"k1\", b\"v11\").unwrap();\n    propose_rx.recv_timeout(Duration::from_secs(2)).unwrap();\n    rx.recv_timeout(Duration::from_millis(200)).unwrap_err();\n\n    // Then, start merging. PrepareMerge should become pending because applied_index\n    // is smaller than proposed_index.\n    cluster.merge_region(left.id, right.id, Callback::None);\n    propose_rx.recv_timeout(Duration::from_secs(2)).unwrap();\n    thread::sleep(Duration::from_millis(200));\n    assert!(txn_ext.pessimistic_locks.read().is_writable());\n\n    // Set disk full error to let PrepareMerge fail. (Set both peer to full to avoid\n    // transferring leader)\n    fail::cfg(\"disk_already_full_peer_1\", \"return\").unwrap();\n    fail::cfg(\"disk_already_full_peer_2\", \"return\").unwrap();\n    fail::remove(\"on_handle_apply\");\n    let res = rx.recv_timeout(Duration::from_secs(1)).unwrap();\n    assert!(!res.get_header().has_error(), \"{:?}\", res);\n\n    propose_rx.recv_timeout(Duration::from_secs(2)).unwrap();\n    fail::remove(\"disk_already_full_peer_1\");\n    fail::remove(\"disk_already_full_peer_2\");\n\n    // Merge should not succeed because the disk is full.\n    thread::sleep(Duration::from_millis(300));\n    cluster.reset_leader_of_region(left.id);\n    assert_eq!(cluster.get_region(b\"k1\"), left);\n\n    cluster.must_put(b\"k1\", b\"v12\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/failpoints/test_basic_write.rs::test_write_batch_rollback", "code": "pub async fn wait_proposed(&mut self) -> bool {\n        WaitEvent {\n            event: CmdResChannel::PROPOSED_EVENT,\n            core: &self.core,\n        }\n        .await\n    }", "test": "fn test_write_batch_rollback() {\n    let mut cluster = Cluster::default();\n    let router = &mut cluster.routers[0];\n    let header = Box::new(router.new_request_for(2).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n    // Make several entries to batch in apply thread.\n    fail::cfg(\"APPLY_COMMITTED_ENTRIES\", \"pause\").unwrap();\n\n    // Good proposal should be committed.\n    let (msg, mut sub0) = PeerMsg::simple_write(header.clone(), put.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub0.wait_proposed()));\n    assert!(block_on(sub0.wait_committed()));\n\n    // If the write batch is correctly initialized, next write should not contain\n    // last result.\n    put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key1\", b\"value\");\n    let (msg, mut sub1) = PeerMsg::simple_write(header.clone(), put.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub1.wait_proposed()));\n    assert!(block_on(sub1.wait_committed()));\n\n    fail::cfg(\"APPLY_PUT\", \"1*return()\").unwrap();\n    // Wake up and sleep in next committed entry.\n    fail::remove(\"APPLY_COMMITTED_ENTRIES\");\n    // First apply will fail due to aborted. If write batch is initialized\n    // correctly, correct response can be returned.\n    let resp = block_on(sub0.result()).unwrap();\n    assert!(\n        resp.get_header()\n            .get_error()\n            .get_message()\n            .contains(\"aborted\"),\n        \"{:?}\",\n        resp\n    );\n    let resp = block_on(sub1.result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    let snap = router.stale_snapshot(2);\n    assert_matches!(snap.get_value(b\"key\"), Ok(None));\n    assert_eq!(snap.get_value(b\"key1\").unwrap().unwrap(), b\"value\");\n\n    fail::cfg(\"APPLY_COMMITTED_ENTRIES\", \"pause\").unwrap();\n\n    // Trigger error again, so an initialized write batch should be rolled back.\n    put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key2\", b\"value\");\n    let (msg, mut sub0) = PeerMsg::simple_write(header.clone(), put.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub0.wait_proposed()));\n    assert!(block_on(sub0.wait_committed()));\n\n    // If the write batch is correctly rollbacked, next write should not contain\n    // last result.\n    put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key3\", b\"value\");\n    let (msg, mut sub1) = PeerMsg::simple_write(header, put.encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub1.wait_proposed()));\n    assert!(block_on(sub1.wait_committed()));\n\n    fail::cfg(\"APPLY_PUT\", \"1*return()\").unwrap();\n    fail::remove(\"APPLY_COMMITTED_ENTRIES\");\n    let resp = block_on(sub0.result()).unwrap();\n    assert!(\n        resp.get_header()\n            .get_error()\n            .get_message()\n            .contains(\"aborted\"),\n        \"{:?}\",\n        resp\n    );\n    let resp = block_on(sub1.result()).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    let snap = router.stale_snapshot(2);\n    assert_matches!(snap.get_value(b\"key2\"), Ok(None));\n    assert_eq!(snap.get_value(b\"key3\").unwrap().unwrap(), b\"value\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/spec.rs::spec_test_1", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn spec_test_1() {\n    let original = r##\"    foo    baz        bim\n\"##;\n    let expected = r##\"<pre><code>foo    baz        bim\n</code></pre>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_check_conf_change", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_check_conf_change() {\n    let mut cluster = prepare_cluster();\n    run_cluster(&mut cluster);\n    let pd_client = cluster.pd_client.clone();\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    must_get_none(&cluster.get_engine(2), b\"k1\");\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n    pd_client.must_add_peer(1, new_learner_peer(2, 4));\n    let region = cluster.get_region(b\"k1\");\n    // Peer 4 can be promoted as there will be enough quorum alive.\n    let cc = new_change_peer_request(ConfChangeType::AddNode, new_peer(2, 4));\n    let req = new_admin_request(region.get_id(), region.get_region_epoch(), cc);\n    let res = cluster\n        .call_command_on_leader(req, Duration::from_secs(3))\n        .unwrap();\n    assert!(!res.get_header().has_error(), \"{:?}\", res);\n    must_get_none(&cluster.get_engine(2), b\"k1\");\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v0\");\n\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    pd_client.must_add_peer(1, new_learner_peer(3, 5));\n    let region = cluster.get_region(b\"k1\");\n    // Peer 5 can not be promoted as there is no enough quorum alive.\n    let cc = new_change_peer_request(ConfChangeType::AddNode, new_peer(3, 5));\n    let req = new_admin_request(region.get_id(), region.get_region_epoch(), cc);\n    let res = cluster\n        .call_command_on_leader(req, Duration::from_secs(3))\n        .unwrap();\n    assert!(\n        res.get_header()\n            .get_error()\n            .get_message()\n            .contains(\"promoted commit index\"),\n        \"{:?}\",\n        res\n    );\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::subquery", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn subquery() {\n    let needle = \"{int $something = _($i+1);}\";\n    let source = \"void x(){int foo = 100*17-f(bar+1);}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_server_stale_peer_out_of_region", "code": "fn test_stale_peer_out_of_region<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_learner_peer(2, 2));\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_learner_peer(3, 3));\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, key, value);\n\n    // Isolate peer 2 from rest of the cluster.\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // In case 2 is leader, it will fail to pass the healthy nodes check,\n    // so remove isolated node first. Because 2 is isolated, so it can't remove\n    // itself.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // Add peer [(4, 4), (5, 5), (6, 6)].\n    pd_client.must_add_peer(r1, new_learner_peer(4, 4));\n    pd_client.must_add_peer(r1, new_peer(4, 4));\n    pd_client.must_add_peer(r1, new_learner_peer(5, 5));\n    pd_client.must_add_peer(r1, new_peer(5, 5));\n    pd_client.must_add_peer(r1, new_learner_peer(6, 6));\n    pd_client.must_add_peer(r1, new_peer(6, 6));\n\n    // Remove peer [(1, 1), (3, 3)].\n    pd_client.must_remove_peer(r1, new_peer(1, 1));\n    pd_client.must_remove_peer(r1, new_peer(3, 3));\n\n    // Keep peer 2 isolated. Otherwise whether peer 3 is destroyed or not,\n    // it will handle the stale raft message from peer 2 and cause peer 2 to\n    // destroy itself earlier than this test case expects.\n\n    // Wait for max_leader_missing_duration to time out.\n    cluster.must_remove_region(2, r1);\n\n    // Check whether this region is still functional properly.\n    let (key2, value2) = (b\"k2\", b\"v2\");\n    cluster.must_put(key2, value2);\n    assert_eq!(cluster.get(key2), Some(value2.to_vec()));\n\n    // Check whether peer(2, 2) and its data are destroyed.\n    must_get_none(&engine_2, key);\n    must_get_none(&engine_2, key2);\n    let state_key = keys::region_state_key(1);\n    let state: RegionLocalState = engine_2.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n}", "test": "fn test_server_stale_peer_out_of_region() {\n    let count = 6;\n    let mut cluster = new_server_cluster(0, count);\n    test_stale_peer_out_of_region(&mut cluster);\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/reference_images.rs::render_images", "code": "pub fn save<Q>(&self, path: Q) -> ImageResult<()>\n    where\n        Q: AsRef<Path>,\n    {\n        dynamic_map!(*self, |ref p| p.save(path))\n    }", "test": "fn render_images() {\n    process_images(IMAGE_DIR, None, |base, path, decoder| {\n        println!(\"render_images {}\", path.display());\n        let img = match image::open(&path) {\n            Ok(img) => img,\n            // Do not fail on unsupported error\n            // This might happen because the testsuite contains unsupported images\n            // or because a specific decoder included via a feature.\n            Err(image::ImageError::Unsupported(e)) => {\n                println!(\"UNSUPPORTED {}: {}\", path.display(), e);\n                return;\n            }\n            Err(err) => panic!(\"decoding of {:?} failed with: {}\", path, err),\n        };\n        let mut crc = Crc32::new();\n        crc.update(img.as_bytes());\n\n        let (filename, testsuite) = {\n            let mut path: Vec<_> = path.components().collect();\n            (path.pop().unwrap(), path.pop().unwrap())\n        };\n        let mut out_path = base.clone();\n\n        out_path.push(OUTPUT_DIR);\n        out_path.push(decoder);\n        out_path.push(testsuite.as_os_str());\n        fs::create_dir_all(&out_path).unwrap();\n        out_path.push(format!(\n            \"{}.{}.{}\",\n            filename.as_os_str().to_str().unwrap(),\n            format!(\"{:x}\", crc.finalize()),\n            \"png\"\n        ));\n        img.save(out_path).unwrap();\n    })\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_read_index_on_replica", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_read_index_on_replica() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.run();\n\n    let k1 = b\"k1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(k1), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let mut storage = cluster.sim.rl().storages[&leader.get_id()].clone();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader.clone());\n    let snap_ctx = SnapContext {\n        pb_ctx: &ctx,\n        ..Default::default()\n    };\n\n    // write some data\n    let peers = region.get_peers();\n    assert_none(snap_ctx, &mut storage, k2);\n    must_put(&ctx, &storage, k2, v2);\n\n    // read on follower\n    let mut follower_peer = None;\n    for p in peers {\n        if p.get_id() != leader.get_id() {\n            follower_peer = Some(p.clone());\n            break;\n        }\n    }\n\n    assert!(follower_peer.is_some());\n    ctx.set_peer(follower_peer.as_ref().unwrap().clone());\n    let resp = read_index_on_peer(\n        &mut cluster,\n        follower_peer.unwrap(),\n        region.clone(),\n        false,\n        std::time::Duration::from_secs(5),\n    );\n    assert!(!resp.as_ref().unwrap().get_header().has_error());\n    assert_ne!(\n        resp.unwrap().get_responses()[0]\n            .get_read_index()\n            .get_read_index(),\n        0\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/snapshot_basic.rs::snapshot_get_value_cf", "code": "fn get_value_cf(&self, cf: &str, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_cf_opt(&ReadOptions::default(), cf, key)\n    }", "test": "fn snapshot_get_value_cf() {\n    let db = engine_cfs(ALL_CFS);\n\n    db.engine.put_cf(CF_WRITE, b\"a\", b\"aa\").unwrap();\n\n    let snap = db.engine.snapshot();\n\n    let value = snap.get_value_cf(CF_WRITE, b\"a\").unwrap();\n    let value = value.unwrap();\n    assert_eq!(value, b\"aa\");\n\n    let value = snap.get_value_cf(CF_WRITE, b\"b\").unwrap();\n    assert!(value.is_none());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_negated_or", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_negated_or() {\n    new_ucmd!()\n        .args(&[\"!\", \"foo\", \"-o\", \"bar\"])\n        .run()\n        .code_is(1);\n    new_ucmd!().args(&[\"foo\", \"-o\", \"!\", \"bar\"]).succeeds();\n    new_ucmd!()\n        .args(&[\"!\", \"foo\", \"-o\", \"!\", \"bar\"])\n        .run()\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_context_underflow", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_context_underflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%5%-10\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '%5%-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%5%-10\", \"-k\"])\n        .fails()\n        .stdout_is(\"141\\n\")\n        .stderr_is(\"csplit: '%5%-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(1, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_sleep_interval", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_sleep_interval() {\n    new_ucmd!().arg(\"-s\").arg(\"10\").arg(FOOBAR_TXT).succeeds();\n    new_ucmd!().arg(\"-s\").arg(\".1\").arg(FOOBAR_TXT).succeeds();\n    new_ucmd!().arg(\"-s.1\").arg(FOOBAR_TXT).succeeds();\n    new_ucmd!().arg(\"-s\").arg(\"-1\").arg(FOOBAR_TXT).fails();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"1..1\")\n        .arg(FOOBAR_TXT)\n        .fails()\n        .stderr_contains(\"invalid number of seconds: '1..1'\")\n        .code_is(1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::get_set_externref_globals_via_api", "code": "pub fn get(&self, mut store: impl AsContextMut) -> Val {\n        unsafe {\n            let store = store.as_context_mut();\n            let definition = &*store[self.0].definition;\n            match self.ty(&store).content() {\n                ValType::I32 => Val::from(*definition.as_i32()),\n                ValType::I64 => Val::from(*definition.as_i64()),\n                ValType::F32 => Val::F32(*definition.as_u32()),\n                ValType::F64 => Val::F64(*definition.as_u64()),\n                ValType::ExternRef => Val::ExternRef(\n                    definition\n                        .as_externref()\n                        .clone()\n                        .map(|inner| ExternRef { inner }),\n                ),\n                ValType::FuncRef => {\n                    Val::FuncRef(Func::from_raw(store, definition.as_func_ref().cast()))\n                }\n                ValType::V128 => Val::V128((*definition.as_u128()).into()),\n            }\n        }\n    }", "test": "fn get_set_externref_globals_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    // Initialize with a null externref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Var),\n        Val::ExternRef(None),\n    )?;\n    assert!(global.get(&mut store).unwrap_externref().is_none());\n\n    global.set(\n        &mut store,\n        Val::ExternRef(Some(ExternRef::new(\"hello\".to_string()))),\n    )?;\n    let r = global.get(&mut store).unwrap_externref().unwrap();\n    assert!(r.data().is::<String>());\n    assert_eq!(r.data().downcast_ref::<String>().unwrap(), \"hello\");\n\n    // Initialize with a non-null externref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Const),\n        Val::ExternRef(Some(ExternRef::new(42_i32))),\n    )?;\n    let r = global.get(&mut store).unwrap_externref().unwrap();\n    assert!(r.data().is::<i32>());\n    assert_eq!(r.data().downcast_ref::<i32>().copied().unwrap(), 42);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_no_existing_files", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_sync_no_existing_files() {\n    new_ucmd!()\n        .arg(\"--data\")\n        .arg(\"do-no-exist\")\n        .fails()\n        .stderr_contains(\"error opening\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_tuple", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_tuple() {\n    test_encode_ok(&[((5,), \"[5]\")]);\n\n    test_pretty_encode_ok(&[((5,), pretty_str!([5]))]);\n\n    test_encode_ok(&[((5, (6, \"abc\")), \"[5,[6,\\\"abc\\\"]]\")]);\n\n    test_pretty_encode_ok(&[((5, (6, \"abc\")), pretty_str!([5, [6, \"abc\"]]))]);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::nullish", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn nullish() {\n    // \"??\" can't directly contain \"||\" or \"&&\"\n    test(\"(a && b) ?? c\", \"(a&&b)??c;\");\n    test(\"(a || b) ?? c\", \"(a||b)??c;\");\n    test(\"a ?? (b && c)\", \"a??(b&&c);\");\n    test(\"a ?? (b || c)\", \"a??(b||c);\");\n\n    // \"||\" and \"&&\" can't directly contain \"??\"\n    test(\"a && (b ?? c)\", \"a&&(b??c);\");\n    test(\"a || (b ?? c)\", \"a||(b??c);\");\n    test(\"(a ?? b) && c\", \"(a??b)&&c;\");\n    test(\"(a ?? b) || c\", \"(a??b)||c;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_zero_bytes", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_positive_zero_bytes() {\n    let ts = TestScenario::new(util_name!());\n    ts.ucmd()\n        .args(&[\"-c\", \"+0\"])\n        .pipe_in(\"abcde\")\n        .succeeds()\n        .stdout_is(\"abcde\");\n    ts.ucmd()\n        .args(&[\"-c\", \"0\"])\n        .pipe_in(\"abcde\")\n        .ignore_stdin_write_error()\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_directory_without_flag", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_rm_directory_without_flag() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_directory_without_flag_dir\";\n\n    at.mkdir(dir);\n\n    ucmd.arg(dir)\n        .fails()\n        .stderr_contains(&format!(\"cannot remove '{dir}': Is a directory\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_encryption.rs::test_file_dict_file_record_corrupted", "code": "fn get(&self, _: &[u8]) -> Option<&[u8]> {\n        None\n    }", "test": "fn test_file_dict_file_record_corrupted() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let mut file_dict_file = FileDictionaryFile::new(\n        tempdir.path(),\n        \"test_file_dict_file_record_corrupted_1\",\n        true,\n        10, // file_rewrite_threshold\n    )\n    .unwrap();\n    let info1 = create_file_info(1, EncryptionMethod::Aes256Ctr);\n    let info2 = create_file_info(2, EncryptionMethod::Unknown);\n    // 9 represents that the first 9 bytes will be discarded.\n    // Crc32 (4 bytes) + File name length (2 bytes) + FileInfo length (2 bytes) +\n    // Log type (1 bytes)\n    fail::cfg(\"file_dict_log_append_incomplete\", \"return(9)\").unwrap();\n    file_dict_file.insert(\"info1\", &info1, true).unwrap();\n    fail::remove(\"file_dict_log_append_incomplete\");\n    file_dict_file.insert(\"info2\", &info2, true).unwrap();\n    // Intermediate record damage is not allowed.\n    file_dict_file.recovery().unwrap_err();\n\n    let mut file_dict_file = FileDictionaryFile::new(\n        tempdir.path(),\n        \"test_file_dict_file_record_corrupted_2\",\n        true,\n        10, // file_rewrite_threshold\n    )\n    .unwrap();\n    let info1 = create_file_info(1, EncryptionMethod::Aes256Ctr);\n    let info2 = create_file_info(2, EncryptionMethod::Unknown);\n    file_dict_file.insert(\"info1\", &info1, true).unwrap();\n    fail::cfg(\"file_dict_log_append_incomplete\", \"return(9)\").unwrap();\n    file_dict_file.insert(\"info2\", &info2, true).unwrap();\n    fail::remove(\"file_dict_log_append_incomplete\");\n    // The ending record can be discarded.\n    let file_dict = file_dict_file.recovery().unwrap();\n    assert_eq!(*file_dict.files.get(\"info1\").unwrap(), info1);\n    assert_eq!(file_dict.files.len(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_numbered_if_existing_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_auto_promote_learner", "code": "pub fn sleep_ms(ms: u64) {\n    std::thread::sleep(Duration::from_millis(ms));\n}", "test": "fn test_unsafe_recovery_auto_promote_learner() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n    let peer_on_store0 = find_peer(&region, nodes[0]).unwrap();\n    let peer_on_store2 = find_peer(&region, nodes[2]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store2.clone());\n    // replace one peer with learner\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store0.clone());\n    cluster.pd_client.must_add_peer(\n        region.get_id(),\n        new_learner_peer(nodes[0], peer_on_store0.get_id()),\n    );\n    // Sleep 100 ms to wait for the new learner to be initialized.\n    sleep_ms(100);\n    cluster.stop_node(nodes[1]);\n    cluster.stop_node(nodes[2]);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n    cluster.must_enter_force_leader(region.get_id(), nodes[0], vec![nodes[1], nodes[2]]);\n\n    let to_be_removed: Vec<metapb::Peer> = region\n        .get_peers()\n        .iter()\n        .filter(|&peer| peer.get_store_id() != nodes[0])\n        .cloned()\n        .collect();\n    let mut plan = pdpb::RecoveryPlan::default();\n    let mut demote = pdpb::DemoteFailedVoters::default();\n    demote.set_region_id(region.get_id());\n    demote.set_failed_voters(to_be_removed.into());\n    plan.mut_demotes().push(demote);\n    pd_client.must_set_unsafe_recovery_plan(nodes[0], plan);\n    cluster.must_send_store_heartbeat(nodes[0]);\n\n    let mut demoted = true;\n    let mut promoted = false;\n    for _ in 0..10 {\n        let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n        promoted = region\n            .get_peers()\n            .iter()\n            .find(|peer| peer.get_store_id() == nodes[0])\n            .unwrap()\n            .get_role()\n            == metapb::PeerRole::Voter;\n\n        demoted = region\n            .get_peers()\n            .iter()\n            .filter(|peer| peer.get_store_id() != nodes[0])\n            .all(|peer| peer.get_role() == metapb::PeerRole::Learner);\n        if demoted && promoted {\n            break;\n        }\n        sleep_ms(100);\n    }\n    assert!(demoted);\n    assert!(promoted);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_machine", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_uname_machine() {\n    new_ucmd!().arg(\"-m\").succeeds();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::instantiate_async", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "async fn instantiate_async() -> Result<(), Error> {\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n\n    let m = Module::new(store.engine(), \"(module)\")?;\n    Instance::new_async(&mut store, &m, &[]).await?;\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    let m = Module::new(store.engine(), \"(module (func) (start 0))\")?;\n    Instance::new_async(&mut store, &m, &[]).await?;\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    Ok(())\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u8_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u8_pow10_test() {\n    let values: &[u8] = &[0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_float_f64_rounding", "code": "pub fn compute_float64(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f64>(&num);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f64_rounding() {\n    // Also need to check halfway cases **inside** that exponent range.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1076, 2));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1077, 2));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_float64(0, 9007199254740991), (1075, 4503599627370495));\n    assert_eq!(compute_float64(0, 9223372036854776831), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776832), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776833), (1086, 1));\n    assert_eq!(compute_float64(-42, 9123456727292927), (936, 1854521741541368));\n    assert_eq!(compute_float64(-43, 91234567272929275), (936, 1854521741541369));\n    assert_eq!(compute_float64(-42, 9123456727292928), (936, 1854521741541369));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1076, 2));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_many_params_works", "code": "pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    }", "test": "fn dynamic_many_params_works() {\n    let (mut store, func) = setup_many_params();\n    func.call(\n        &mut store,\n        &[\n            Value::I32(0),\n            Value::I32(1),\n            Value::I32(2),\n            Value::I32(3),\n            Value::I32(4),\n            Value::I32(5),\n            Value::I32(6),\n            Value::I32(7),\n            Value::I32(8),\n            Value::I32(9),\n            Value::I32(10),\n            Value::I32(11),\n            Value::I32(12),\n            Value::I32(13),\n            Value::I32(14),\n            Value::I32(15),\n        ],\n        &mut [],\n    )\n    .unwrap();\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::attributes_empty_ns_expanded", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn attributes_empty_ns_expanded() {\n    let src = \"<a att1='a' r:att2='b' xmlns:r='urn:example:r' />\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true).expand_empty_elements(true);\n    {\n        let e = match r.read_resolved_event() {\n            Ok((Unbound, Start(e))) => e,\n            e => panic!(\"Expecting Empty event, got {:?}\", e),\n        };\n\n        let mut attrs = e\n            .attributes()\n            .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n            // we don't care about xmlns attributes for this test\n            .filter(|kv| kv.key.as_namespace_binding().is_none())\n            .map(|Attribute { key: name, value }| {\n                let (opt_ns, local_name) = r.resolve_attribute(name);\n                (opt_ns, local_name.into_inner(), value)\n            });\n        assert_eq!(\n            attrs.next(),\n            Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n        );\n        assert_eq!(\n            attrs.next(),\n            Some((\n                Bound(Namespace(b\"urn:example:r\")),\n                &b\"att2\"[..],\n                Cow::Borrowed(&b\"b\"[..])\n            ))\n        );\n        assert_eq!(attrs.next(), None);\n    }\n\n    match r.read_resolved_event() {\n        Ok((Unbound, End(e))) => assert_eq!(e.name(), QName(b\"a\")),\n        e => panic!(\"Expecting End event, got {:?}\", e),\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::test_capitalized_justfile_search", "code": "fn join() {\n  assert_eval_eq(\"join('a', 'b', 'c', 'd')\", \"a/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', 'c', 'd')\", \"/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', 'd')\", \"/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', '/d')\", \"/d\");\n}", "test": "fn test_capitalized_justfile_search() {\n  let tmp = temptree! {\n    Justfile: \"default:\\n\\techo ok\",\n    a: {\n      b: {\n        c: {\n          d: {},\n        },\n      },\n    },\n  };\n\n  search_test(tmp.path().join(\"a/b/c/d\"), &[]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_no_match2", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_no_match2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%nope%\", \"{50}\"])\n        .fails()\n        .stderr_only(\"csplit: '%nope%': match not found\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::create_open", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn create_open() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &1).unwrap();\n    }\n    write_txn.commit().unwrap();\n    drop(db);\n\n    let db2 = Database::open(tmpfile.path()).unwrap();\n\n    let read_txn = db2.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    assert_eq!(1, table.get(&0).unwrap().unwrap().value());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_leader_down_in_joint_state", "code": "fn must_has_peer(region: &Region, peer_id: u64, role: PeerRole) {\n    assert!(\n        region\n            .get_peers()\n            .iter()\n            .any(|p| p.get_id() == peer_id && p.get_role() == role)\n    );\n}", "test": "fn test_leader_down_in_joint_state() {\n    let mut cluster = new_node_cluster(0, 5);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    pd_client.must_add_peer(region_id, new_learner_peer(4, 4));\n    pd_client.must_add_peer(region_id, new_learner_peer(5, 5));\n    for i in 2..=5 {\n        must_get_equal(&cluster.get_engine(i), b\"k1\", b\"v1\");\n    }\n\n    // Enter joint, now we have C_old(1, 2, 3) and C_new(1, 4, 5)\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            (ConfChangeType::AddLearnerNode, new_learner_peer(3, 3)),\n            (ConfChangeType::AddNode, new_peer(4, 4)),\n            (ConfChangeType::AddNode, new_peer(5, 5)),\n        ],\n    );\n    cluster.must_put(b\"k2\", b\"v2\");\n    for i in 2..=5 {\n        must_get_equal(&cluster.get_engine(i), b\"k2\", b\"v2\");\n    }\n\n    // Isolated leader\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n    sleep_ms(500);\n\n    // Peer from both configuration can become leader\n    for leader_id in &[3, 4] {\n        let (k, v) = (format!(\"k{}\", leader_id), format!(\"v{}\", leader_id));\n        cluster.must_transfer_leader(region_id, new_peer(*leader_id, *leader_id));\n        cluster.must_put(k.as_bytes(), v.as_bytes());\n\n        for i in 2..=5 {\n            must_get_equal(&cluster.get_engine(i), k.as_bytes(), v.as_bytes());\n        }\n    }\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n\n    // Joint confchange finished\n    let region = cluster.get_region(b\"k1\");\n    must_has_peer(&region, 1, PeerRole::Voter);\n    must_has_peer(&region, 2, PeerRole::Learner);\n    must_has_peer(&region, 3, PeerRole::Learner);\n    must_has_peer(&region, 4, PeerRole::Voter);\n    must_has_peer(&region, 5, PeerRole::Voter);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::program_argument_has_priority_for_dotenv_path", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn program_argument_has_priority_for_dotenv_path() {\n  Test::new()\n    .justfile(\n      r#\"\n        set dotenv-path:= \"subdir/.env\"\n\n        foo:\n          @echo $NAME\n      \"#,\n    )\n    .tree(tree! {\n      subdir: {\n        \".env\": \"NAME=bar\",\n        \".env.special\": \"NAME=baz\"\n      }\n    })\n    .args([\"--dotenv-path\", \"subdir/.env.special\"])\n    .stdout(\"baz\\n\")\n    .status(EXIT_SUCCESS)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tr.rs::test_small_set2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_small_set2() {\n    new_ucmd!()\n        .args(&[\"0-9\", \"X\"])\n        .pipe_in(\"@0123456789\")\n        .run()\n        .stdout_is(\"@XXXXXXXXXX\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nonexistent_file_size_test_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_nonexistent_file_size_test_is_false() {\n    new_ucmd!()\n        .args(&[\"-s\", \"nonexistent_file\"])\n        .run()\n        .code_is(1);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_not", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_not() {\n    let sql = \"SELECT id FROM customer WHERE NOT salary = ''\";\n    let _ast = verified_only_select(sql);\n    //TODO: add assertions\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_invalid_group", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_invalid_group() {\n    new_ucmd!()\n        .arg(\"__nosuchgroup__\")\n        .arg(\"/\")\n        .fails()\n        .stderr_is(\"chgrp: invalid group: '__nosuchgroup__'\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_join_lines_option", "code": "pub fn stdout_is_templated_fixture_any<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[Vec<(String, String)>],\n    ) {\n        let contents = String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        let possible_values = template_vars.iter().map(|vars| {\n            let mut contents = contents.clone();\n            for kv in vars {\n                contents = contents.replace(&kv.0, &kv.1);\n            }\n            contents\n        });\n        self.stdout_is_any(&possible_values.collect::<Vec<_>>());\n    }", "test": "fn test_with_join_lines_option() {\n    let test_file_1 = \"hosts.log\";\n    let test_file_2 = \"test.log\";\n    let expected_file_path = \"joined.log.expected\";\n    let mut scenario = new_ucmd!();\n    let start = OffsetDateTime::now_utc();\n    scenario\n        .args(&[\"+1:2\", \"-J\", \"-m\", test_file_1, test_file_2])\n        .run()\n        .stdout_is_templated_fixture_any(\n            expected_file_path,\n            &valid_last_modified_template_vars(start),\n        );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_bool", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_bool() {\n    test_parse_err::<bool>(&[\n        (\"t\", \"EOF while parsing a value at line 1 column 1\"),\n        (\"truz\", \"expected ident at line 1 column 4\"),\n        (\"f\", \"EOF while parsing a value at line 1 column 1\"),\n        (\"faz\", \"expected ident at line 1 column 3\"),\n        (\"truea\", \"trailing characters at line 1 column 5\"),\n        (\"falsea\", \"trailing characters at line 1 column 6\"),\n    ]);\n\n    test_parse_ok(vec![\n        (\"true\", true),\n        (\" true \", true),\n        (\"false\", false),\n        (\" false \", false),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_leading_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_leading_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w3\", \"-s\"])\n        .pipe_in(\" aaa\")\n        .succeeds()\n        .stdout_is(\" \\naaa\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_offset_space_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_offset_space_option() {\n    let test_file_path = \"column.log\";\n    let expected_test_file_path = \"column_spaces_across.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\n            \"-o\",\n            \"5\",\n            \"--pages=3:5\",\n            \"--column=3\",\n            \"-a\",\n            \"-n\",\n            test_file_path,\n        ])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_flag_a_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_flag_a_1() {\n    new_ucmd!()\n        .args(&[\"-a\"])\n        .pipe_in(\"e     E\\nf      F\\ng       G\\nh        H\\n\")\n        .run()\n        .stdout_is(\"e     E\\nf      F\\ng\\tG\\nh\\t H\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/slash_operator.rs::once", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn once() {\n  Test::new()\n    .justfile(\"x := 'a' / 'b'\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout(\"a/b\")\n    .run();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::apply_suggested_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn apply_suggested_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), APPLY_SUGGESTED_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply-unsafe\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_suggested_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_parent_directories", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_parent_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_dir = \"ancestor1/ancestor2/target_dir\";\n    let directories_arg = \"-d\";\n\n    // Here one of the ancestors already exist and only the target_dir and\n    // its parent must be created.\n    at.mkdir(ancestor1);\n\n    ucmd.args(&[directories_arg, target_dir])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.dir_exists(target_dir));\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::image_queries", "code": "fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n}", "test": "fn image_queries() {\n    require(\n        &[Ca::ImageQuery],\n        r#\"\n        fn f(i: texture_2d<f32>) -> vec2<u32> {\n            return textureDimensions(i);\n        }\n    \"#,\n    );\n    require(\n        &[Ca::ImageQuery],\n        r#\"\n        fn f(i: texture_2d_array<f32>) -> u32 {\n            return textureNumLayers(i);\n        }\n    \"#,\n    );\n    require(\n        &[Ca::ImageQuery],\n        r#\"\n        fn f(i: texture_2d<f32>) -> u32 {\n            return textureNumLevels(i);\n        }\n    \"#,\n    );\n    require(\n        &[Ca::ImageQuery],\n        r#\"\n        fn f(i: texture_multisampled_2d<f32>) -> u32 {\n            return textureNumSamples(i);\n        }\n    \"#,\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::assign_operator_precedence", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn assign_operator_precedence() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 1;\n            a = a + 1;\n            a\n        \"#},\n        2,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_resize_async_ios_failed_1", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_resize_async_ios_failed_1() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    // Save current async-io tids before shrinking\n    let org_writers_tids = get_async_writers_tids();\n    assert_eq!(2, org_writers_tids.len());\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    // Update config, expand from async-mode(async-ios == 2) to\n    // sync-mode(async-ios == 0).\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-io-pool-size\".to_owned(), \"0\".to_owned());\n            change\n        };\n\n        assert!(cfg_controller.update(change).is_err());\n        assert_eq!(\n            cfg_controller.get_current().raft_store.store_io_pool_size,\n            2\n        );\n    }\n    // Save current async-io tids after scaling up, and compared with the\n    // orginial one before scaling up, the thread num should be added up to TWO.\n    let cur_writers_tids = get_async_writers_tids();\n    assert_eq!(cur_writers_tids.len(), org_writers_tids.len());\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_wrap", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_wrap() {\n    for wrap_param in [\"-w\", \"--wrap\", \"--wr\"] {\n        let input = \"The quick brown fox jumps over the lazy dog.\";\n        new_ucmd!()\n            .arg(wrap_param)\n            .arg(\"20\")\n            .pipe_in(input)\n            .succeeds()\n            .stdout_only(\n                \"KRUGKIDROVUWG2ZAMJZG\\n653OEBTG66BANJ2W24DT\\nEBXXMZLSEB2GQZJANRQX\\nU6JAMRXWOLQ=\\n\", // spell-checker:disable-line\n            );\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_current_directory", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_realpath_current_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let expect = at.root_dir_resolved() + \"\\n\";\n    ucmd.arg(\".\").succeeds().stdout_is(expect);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/attributes.rs::all", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn all() {\n  Test::new()\n    .justfile(\n      \"\n      [macos]\n      [windows]\n      [linux]\n      [unix]\n      [no-exit-message]\n      foo:\n        exit 1\n    \",\n    )\n    .stderr(\"exit 1\\n\")\n    .status(1)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_with_tab_size", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_with_tab_size() {\n    new_ucmd!()\n        .arg(\"with-tab.txt\")\n        .arg(\"--tabs=10\")\n        .succeeds()\n        .stdout_contains(\"          \");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_send_recv", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn datagram_send_recv() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), Some(x) if x > 0);\n\n    const DATA: &[u8] = b\"whee\";\n    pair.client_datagrams(client_ch).send(DATA.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_basic", "code": "pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -46 || m10 == 0 {\n        // Number is less than 1e-46, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n    if m10digits + e10 >= 40 {\n        // Number is larger than 1e+39, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u32;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits; better to\n        // have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the FLOAT_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(f2s::FLOAT_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        m2 = mul_pow5_div_pow2(m10, e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(f2s::FLOAT_POW5_INV_BITCOUNT);\n        m2 = mul_pow5_inv_div_pow2(m10, -e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))\n        //\n        // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10))\n        // divides m10, which is the case iff pow5(m10) >= -e10 AND pow2(m10) >=\n        // e2-e10.\n        //\n        // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) /\n        // 5^(-e10)] above, and we need to check whether 5^(-e10) divides (m10 *\n        // 2^(e10-e2)), which is the case iff pow5(m10 * 2^(e10-e2)) = pow5(m10)\n        // >= -e10.\n        trailing_zeros = (e2 < e10\n            || (e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32)))\n            && multiple_of_power_of_5_32(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + FLOAT_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0xfe {\n        // Final IEEE exponent is larger than the maximum representable; return\n        // +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(FLOAT_EXPONENT_BIAS as i32)\n        .wrapping_sub(f2s::FLOAT_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u32 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u32);\n    debug_assert!(ieee_m2 <= 1_u32 << (f2s::FLOAT_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u32 << f2s::FLOAT_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Rounding up may overflow the mantissa.\n        // In this case we move a trailing zero of the mantissa into the\n        // exponent.\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u32) << f2s::FLOAT_EXPONENT_BITS) | ieee_e2)\n        << f2s::FLOAT_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f32::from_bits(ieee))\n}", "test": "fn test_basic() {\n    assert_eq!(0.0, s2f(b\"0\").unwrap());\n    assert_eq!(-0.0, s2f(b\"-0\").unwrap());\n    assert_eq!(1.0, s2f(b\"1\").unwrap());\n    assert_eq!(-1.0, s2f(b\"-1\").unwrap());\n    assert_eq!(123456792.0, s2f(b\"123456789\").unwrap());\n    assert_eq!(299792448.0, s2f(b\"299792458\").unwrap());\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::reset_stream", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn reset_stream() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"resetting stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.client_send(client_ch, s).reset(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Err(ReadError::Reset(ERROR)));\n    let _ = chunks.finalize();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_inodes_basic", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_inodes_basic() {\n    let ts = TestScenario::new(util_name!());\n    let result = ts.ucmd().arg(\"--inodes\").succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"--inodes\"]));\n        assert_eq!(result.stdout_str(), result_reference.stdout_str());\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    _du_inodes_basic(result.stdout_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_ref_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_ref_help() {\n    new_ucmd!()\n        .arg(\"--reference=ref_file\")\n        .arg(\"--help\")\n        .succeeds()\n        .stdout_contains(\"Arguments:\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_from_stdin", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_from_stdin() {\n    let input = \"abcdefghijklmnopqrstuvwxyz\\n\"; // spell-checker:disable-line\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .run_piped_stdin(input.as_bytes())\n        .success()\n        .no_stderr()\n        .stdout_is(unindent(ALPHA_OUT));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601_minute", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_8601_minute() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!()\n            .arg(format!(\"{param}=minute\"))\n            .succeeds()\n            .stdout_matches(&re);\n        new_ucmd!()\n            .arg(format!(\"{param}=minutes\"))\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::escaping_happens_at_the_end", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn escaping_happens_at_the_end() {\n    let inputs = vec![\n        #[cfg(feature = \"builtins\")]\n        (\"{{ url | urlencode | safe }}\", \"https%3A//www.example.org/apples-%26-oranges/\"),\n        (\"{{ '<html>' }}\", \"&lt;html&gt;\"),\n        (\"{{ '<html>' | safe }}\", \"<html>\"),\n        (\"{{ 'hello' | safe | replace(from='h', to='&') }}\", \"&amp;ello\"),\n        (\"{{ 'hello' | replace(from='h', to='&') | safe }}\", \"&ello\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut context = Context::new();\n        context.insert(\"url\", \"https://www.example.org/apples-&-oranges/\");\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_globals", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_globals() {\n    let mut env = Environment::new();\n    env.add_global(\"a\", Value::from(42));\n    env.add_template(\"test\", \"{{ a }}\").unwrap();\n    let tmpl = env.get_template(\"test\").unwrap();\n    assert_eq!(tmpl.render(()).unwrap(), \"42\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_loading_macro_from_unloaded_namespace", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_loading_macro_from_unloaded_namespace() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{ macro::hello() }}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n    println!(\"{:#?}\", result);\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Macro namespace `macro` was not found in template `tpl`. Have you maybe forgotten to import it, or misspelled it?\"\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::drop_func", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn drop_func() -> Result<()> {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n    linker.allow_shadowing(true);\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    // Define the function again to ensure redefined functions are dropped\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 1);\n\n    drop(linker);\n\n    assert_eq!(HITS.load(SeqCst), 2);\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_update_from_toml_file", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_update_from_toml_file() {\n    use std::{error::Error, result::Result};\n\n    use online_config::ConfigManager;\n\n    #[derive(Clone)]\n    struct CfgManager(Arc<Mutex<RaftstoreConfig>>);\n\n    impl ConfigManager for CfgManager {\n        fn dispatch(&mut self, c: ConfigChange) -> Result<(), Box<dyn Error>> {\n            self.0.lock().unwrap().update(c)\n        }\n    }\n\n    let (cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let cfg = cfg_controller.get_current();\n    let mgr = CfgManager(Arc::new(Mutex::new(cfg.raft_store.clone())));\n    cfg_controller.register(Module::Raftstore, Box::new(mgr));\n\n    // update config file\n    let c = r#\"\n[raftstore]\nraft-log-gc-threshold = 2000\n\"#;\n    let mut f = File::create(&cfg.cfg_path).unwrap();\n    f.write_all(c.as_bytes()).unwrap();\n    // before update this configuration item should be the default value\n    assert_eq!(\n        cfg_controller\n            .get_current()\n            .raft_store\n            .raft_log_gc_threshold,\n        50\n    );\n    // config update from config file\n    cfg_controller.update_from_toml_file().unwrap();\n    // after update this configration item should be constant with the modified\n    // configuration file\n    assert_eq!(\n        cfg_controller\n            .get_current()\n            .raft_store\n            .raft_log_gc_threshold,\n        2000\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::thread_through_borrow", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "test": "fn thread_through_borrow() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"x\" (borrow $t))))\n\n                (core func $f (canon lower (func $f)))\n                (core func $drop (canon resource.drop $t))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32)))\n                    (import \"\" \"drop\" (func $drop (param i32)))\n                    (func (export \"f2\") (param i32)\n                        (call $f (local.get 0))\n                        (call $f (local.get 0))\n                        (call $drop (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                        (export \"drop\" (func $drop))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n        .root()\n        .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| {\n            assert!(!r.owned());\n            assert_eq!(r.rep(), 100);\n            Ok(())\n        })?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    f.call(&mut store, (&resource,))?;\n    f.post_return(&mut store)?;\n    Ok(())\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::equality", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn equality() {\n    test(\"a == b != c === d !== e\", \"a==b!=c===d!==e;\");\n    test(\"a == (b != (c === (d !== e)))\", \"a==b!=c===d!==e;\");\n    test(\"(((a == b) != c) === d) !== e\", \"a==b!=c===d!==e;\");\n    test(\"a > b == c < d\", \"a>b==c<d;\");\n    test(\"(a > b) == (c < d)\", \"a>b==c<d;\");\n    test(\"a | b == c & d\", \"a|b==c&d;\");\n    test(\"(a | b) == (c & d)\", \"(a|b)==(c&d);\");\n    test(\"a, b == c , d\", \"a,b==c,d;\");\n    test(\"(a, b) == (c , d)\", \"(a,b)==(c,d);\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_23", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_23() {\n    let original = r##\"# H1 {<i>foo</i>}\n\"##;\n    let expected = r##\"<h1>H1 {<i>foo</i>}</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible_si", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_compatible_si() {\n    new_ucmd!().arg(\"-aH\").succeeds();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_when_missing_macro_templates", "code": "pub fn add_raw_templates<I, N, C>(&mut self, templates: I) -> Result<()>\n    where\n        I: IntoIterator<Item = (N, C)>,\n        N: AsRef<str>,\n        C: AsRef<str>,\n    {\n        for (name, content) in templates {\n            let name = name.as_ref();\n            let tpl = Template::new(name, None, content.as_ref())\n                .map_err(|e| Error::chain(format!(\"Failed to parse '{}'\", name), e))?;\n            self.templates.insert(name.to_string(), tpl);\n        }\n        self.build_inheritance_chains()?;\n        self.check_macro_files()?;\n        Ok(())\n    }", "test": "fn error_when_missing_macro_templates() {\n    let mut tera = Tera::default();\n    let result = tera.add_raw_templates(vec![(\n        \"parent\",\n        \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}\",\n    )]);\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Template `parent` loads macros from `macros` which isn\\'t present in Tera\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_retry_rpc_client", "code": "pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    }", "test": "fn test_retry_rpc_client() {\n    let eps_count = 1;\n    let mut server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let m_eps = eps.clone();\n    let mgr = Arc::new(SecurityManager::new(&SecurityConfig::default()).unwrap());\n    let m_mgr = mgr.clone();\n    server.stop();\n    let child = thread::spawn(move || {\n        let cfg = new_config(m_eps);\n        RpcClientV2::new(&cfg, None, m_mgr).unwrap();\n    });\n    thread::sleep(Duration::from_millis(500));\n    server.start(&mgr, eps);\n    child.join().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date7", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date7() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2004-01-16 12:00 +0000\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(1_074_254_400, 0);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_verbose_single", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_verbose_single() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n\n    ucmd.arg(\"-v\")\n        .arg(DIR)\n        .succeeds()\n        .no_stderr()\n        .stdout_is(\"rmdir: removing directory, 'dir'\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::test_path_exists_filepath_exist", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn test_path_exists_filepath_exist() {\n  Test::new()\n    .tree(tree! {\n      testfile: \"\"\n    })\n    .justfile(\"x := path_exists('testfile')\")\n    .args([\"--evaluate\", \"x\"])\n    .stdout(\"true\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::k_sync() {\n    ", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "lock_sync() {\n    new_ucmd!()\n        .args(&[\"ibs=5\", \"cbs=5\", \"conv=block,sync\", \"status=noxfer\"])\n        .pipe_in(\"012\\nabcde\\n\")\n        .succeeds()\n        // blocks:    1    2\n        .stdout_is(\"012  abcde\")\n        .stderr_is(\"2+0 records in\\n0+1 records out\\n\");\n\n    // It seems that a partial record in is represented as an\n    // all-spaces block at the end of the output. The \"1 truncated\n    // record\" line is present in the status report due to the line\n    // \"abcdefg\\n\" being truncated to \"abcde\".\n    new_ucmd!()\n        .args(&[\"ibs=5\", \"cbs=5\", \"conv=block,sync\", \"status=noxfer\"])\n        .pipe_in(\"012\\nabcdefg\\n\")\n        .succeeds()\n        // blocks:    1    2    3\n        .stdout_is(\"012  abcde     \")\n        .stderr_is(\"2+1 records in\\n0+1 records out\\n1 truncated record\\n\");\n}\n\n#[test]"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_fold_logical_op2", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn test_fold_logical_op2() {\n    test(\"x = function(){} && x\", \"x=x;\");\n    test(\"x = true && function(){}\", \"x=function(){};\");\n    test(\"x = [(function(){alert(x)})()] && x\", \"x=([function(){alert(x)}()],x);\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_multiple_decimals_general", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_multiple_decimals_general() {\n    test_helper(\n        \"multiple_decimals_general\",\n        &[\"-g\", \"--general-numeric-sort\", \"--sort=general-numeric\"],\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_resolves_when_using_config_path", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn extends_resolves_when_using_config_path() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"config/biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"format.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"config/format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"config/linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": true } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                \"--config-path=config/\",\n                test_file.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_resolves_when_using_config_path\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_pessimistic_lock_check_epoch", "code": "pub fn has_stale_command(&self) -> bool {\n        self.stale_command.is_some()\n    }", "test": "fn test_pessimistic_lock_check_epoch() {\n    let mut cluster = new_server_cluster(0, 2);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    let region = cluster.get_region(b\"\");\n    let leader = region.get_peers()[0].clone();\n\n    let epoch = cluster.get_region_epoch(region.id);\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.id);\n    ctx.set_peer(leader.clone());\n    ctx.set_region_epoch(epoch);\n\n    let (fp_tx, fp_rx) = sync_channel(0);\n    fail::cfg_callback(\"acquire_pessimistic_lock\", move || {\n        fp_tx.send(()).unwrap();\n    })\n    .unwrap();\n\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n\n    let mut mutation = pb::Mutation::default();\n    mutation.set_op(Op::PessimisticLock);\n    mutation.key = b\"key\".to_vec();\n    let mut req = PessimisticLockRequest::default();\n    req.set_context(ctx.clone());\n    req.set_mutations(vec![mutation].into());\n    req.set_start_version(10);\n    req.set_for_update_ts(10);\n    req.set_primary_lock(b\"key\".to_vec());\n\n    let lock_resp = thread::spawn(move || client.kv_pessimistic_lock(&req).unwrap());\n    thread::sleep(Duration::from_millis(300));\n\n    // Transfer leader out and back, so the term should have changed.\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    fp_rx.recv().unwrap();\n\n    let resp = lock_resp.join().unwrap();\n    // Region leader changes, so we should get a StaleCommand error.\n    assert!(resp.get_region_error().has_stale_command());\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::test_config_builders_debug", "code": "pub fn with_protocol_versions(\n        self,\n        versions: &[&'static versions::SupportedProtocolVersion],\n    ) -> Result<ConfigBuilder<S, WantsVerifier>, Error> {\n        let mut any_usable_suite = false;\n        for suite in &self.state.cipher_suites {\n            if versions.contains(&suite.version()) {\n                any_usable_suite = true;\n                break;\n            }\n        }\n\n        if !any_usable_suite {\n            return Err(Error::General(\"no usable cipher suites configured\".into()));\n        }\n\n        if self.state.kx_groups.is_empty() {\n            return Err(Error::General(\"no kx groups configured\".into()));\n        }\n\n        Ok(ConfigBuilder {\n            state: WantsVerifier {\n                cipher_suites: self.state.cipher_suites,\n                kx_groups: self.state.kx_groups,\n                versions: versions::EnabledVersions::new(versions),\n            },\n            side: self.side,\n        })\n    }", "test": "fn test_config_builders_debug() {\n    let b = ServerConfig::builder();\n    assert_eq!(\n        \"ConfigBuilder<ServerConfig, _> { state: WantsCipherSuites(()) }\",\n        format!(\"{:?}\", b)\n    );\n    let b = b.with_cipher_suites(&[rustls::cipher_suite::TLS13_CHACHA20_POLY1305_SHA256]);\n    assert_eq!(\"ConfigBuilder<ServerConfig, _> { state: WantsKxGroups { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256] } }\", format!(\"{:?}\", b));\n    let b = b.with_kx_groups(&[&rustls::kx_group::X25519]);\n    assert_eq!(\"ConfigBuilder<ServerConfig, _> { state: WantsVersions { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256], kx_groups: [X25519] } }\", format!(\"{:?}\", b));\n    let b = b\n        .with_protocol_versions(&[&rustls::version::TLS13])\n        .unwrap();\n    let b = b.with_no_client_auth();\n    assert_eq!(\"ConfigBuilder<ServerConfig, _> { state: WantsServerCert { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256], kx_groups: [X25519], versions: [TLSv1_3], verifier: dyn ClientCertVerifier } }\", format!(\"{:?}\", b));\n\n    let b = ClientConfig::builder();\n    assert_eq!(\n        \"ConfigBuilder<ClientConfig, _> { state: WantsCipherSuites(()) }\",\n        format!(\"{:?}\", b)\n    );\n    let b = b.with_cipher_suites(&[rustls::cipher_suite::TLS13_CHACHA20_POLY1305_SHA256]);\n    assert_eq!(\"ConfigBuilder<ClientConfig, _> { state: WantsKxGroups { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256] } }\", format!(\"{:?}\", b));\n    let b = b.with_kx_groups(&[&rustls::kx_group::X25519]);\n    assert_eq!(\"ConfigBuilder<ClientConfig, _> { state: WantsVersions { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256], kx_groups: [X25519] } }\", format!(\"{:?}\", b));\n    let b = b\n        .with_protocol_versions(&[&rustls::version::TLS13])\n        .unwrap();\n    assert_eq!(\"ConfigBuilder<ClientConfig, _> { state: WantsVerifier { cipher_suites: [TLS13_CHACHA20_POLY1305_SHA256], kx_groups: [X25519], versions: [TLSv1_3] } }\", format!(\"{:?}\", b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_line", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_line() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"10\"])\n        .succeeds()\n        .stdout_only(\"18\\n123\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 10));\n    assert_eq!(at.read(\"xx01\"), generate(10, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_with_multiple_files", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_with_multiple_files() {\n    new_ucmd!()\n        .arg(\"with-spaces.txt\")\n        .arg(\"with-tab.txt\")\n        .succeeds()\n        .stdout_contains(\"    return\")\n        .stdout_contains(\"        \");\n}"}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/test_streamsafe_regression.rs::test_streamsafe_regression", "code": "pub fn is_nfc(s: &str) -> bool {\n    match is_nfc_quick(s.chars()) {\n        IsNormalized::Yes => true,\n        IsNormalized::No => false,\n        IsNormalized::Maybe => s.chars().eq(s.chars().nfc()),\n    }\n}", "test": "fn test_streamsafe_regression(){\n    let input = \"\\u{342}\".repeat(55) + &\"\\u{344}\".repeat(3);\n    let nfc_ss = input.chars().nfc().stream_safe().collect::<String>();\n\n    // The result should be NFC:\n    assert!(is_nfc(&nfc_ss));\n    // and should be stream-safe:\n    assert!(is_nfc_stream_safe(&nfc_ss))\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_parse_zone_keys", "code": "pub fn key_path(&self) -> &Path {\n        Path::new(&self.key_path)\n    }", "test": "fn test_parse_zone_keys() {\n    use hickory_proto::rr::dnssec::Algorithm;\n    use hickory_proto::rr::Name;\n\n    let config = Config::from_toml(\n        \"\n[[zones]]\nzone = \\\"example.com\\\"\nzone_type = \\\"Primary\\\"\nfile = \\\"example.com.zone\\\"\n\n\\\n         [[zones.keys]]\nkey_path = \\\"/path/to/my_ed25519.pem\\\"\nalgorithm = \\\"ED25519\\\"\n\\\n         signer_name = \\\"ns.example.com.\\\"\nis_zone_signing_key = false\nis_zone_update_auth = true\n\n[[zones.keys]]\nkey_path = \\\"/path/to/my_rsa.pem\\\"\nalgorithm = \\\n         \\\"RSASHA256\\\"\nsigner_name = \\\"ns.example.com.\\\"\n\",\n    )\n    .unwrap();\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0].key_path(),\n        Path::new(\"/path/to/my_ed25519.pem\")\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0].algorithm().unwrap(),\n        Algorithm::ED25519\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0]\n            .signer_name()\n            .unwrap()\n            .unwrap(),\n        Name::parse(\"ns.example.com.\", None).unwrap()\n    );\n    assert!(!config.get_zones()[0].get_keys()[0].is_zone_signing_key(),);\n    assert!(config.get_zones()[0].get_keys()[0].is_zone_update_auth(),);\n\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1].key_path(),\n        Path::new(\"/path/to/my_rsa.pem\")\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1].algorithm().unwrap(),\n        Algorithm::RSASHA256\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1]\n            .signer_name()\n            .unwrap()\n            .unwrap(),\n        Name::parse(\"ns.example.com.\", None).unwrap()\n    );\n    assert!(!config.get_zones()[0].get_keys()[1].is_zone_signing_key(),);\n    assert!(!config.get_zones()[0].get_keys()[1].is_zone_update_auth(),);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ltc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_ltc() {\n    // Test iterators that skip multiple, leading or trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"4__5.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_sequence1", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_sequence1() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%0$%\", \"%^4%\"])\n        .succeeds()\n        .stdout_only(\"33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(40, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_prompt_write_protected_no", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_prompt_write_protected_no() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_2 = \"test_rm_prompt_write_protected_2\";\n\n    at.touch(file_2);\n\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_2).succeeds();\n\n    scene.ucmd().arg(file_2).pipe_in(\"n\").succeeds();\n    assert!(at.file_exists(file_2));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_if_elif_else", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_if_elif_else() {\n    let mut context = Context::new();\n    context.insert(\"is_true\", &true);\n    context.insert(\"is_false\", &false);\n    context.insert(\"age\", &18);\n    context.insert(\"name\", &\"john\");\n    context.insert(\"empty_string\", &\"\");\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (\"{% if is_true %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if is_true or age + 1 > 18 %}Adult{% endif %}\", \"Adult\"),\n        (\"{% if is_true and age == 18 %}Adult{% endif %}\", \"Adult\"),\n        // https://github.com/Keats/tera/issues/187\n        (\"{% if 1 <= 2 %}a{% endif %}\", \"a\"),\n        (\"{% if 2 >= 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 < 2 %}a{% endif %}\", \"a\"),\n        (\"{% if 2 > 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 == 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 != 2 %}a{% endif %}\", \"a\"),\n        // testing string conditions\n        (\"{% if 'true' %}a{% endif %}\", \"a\"),\n        (\"{% if name %}a{% endif %}\", \"a\"),\n        (\"{% if '' %}a{% endif %}\", \"\"),\n        (\"{% if empty_string %}a{% endif %}\", \"\"),\n        (\"{% if '' ~ name %}a{% endif %}\", \"a\"),\n        (\"{% if '' ~ empty_string %}a{% endif %}\", \"\"),\n        // some not conditions\n        (\"{% if not is_false %}a{% endif %}\", \"a\"),\n        (\"{% if not is_true %}a{% endif %}\", \"\"),\n        (\"{% if undefined %}a{% endif %}\", \"\"),\n        (\"{% if not undefined %}a{% endif %}\", \"a\"),\n        (\"{% if not is_false and is_true %}a{% endif %}\", \"a\"),\n        (\"{% if not is_false or numbers | length > 0 %}a{% endif %}\", \"a\"),\n        // doesn't panic with NaN results\n        (\"{% if 0 / 0 %}a{% endif %}\", \"\"),\n        // if and else\n        (\"{% if is_true %}Admin{% else %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_false %}Admin{% else %}User{% endif %}\", \"User\"),\n        // if and elifs\n        (\"{% if is_true %}Admin{% elif is_false %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_true %}Admin{% elif is_true %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_true %}Admin{% elif numbers | length > 0 %}User{% endif %}\", \"Admin\"),\n        // if, elifs and else\n        (\"{% if is_true %}Admin{% elif is_false %}User{% else %}Hmm{% endif %}\", \"Admin\"),\n        (\"{% if false %}Admin{% elif is_false %}User{% else %}Hmm{% endif %}\", \"Hmm\"),\n        // doesn't fallthrough elifs\n        // https://github.com/Keats/tera/issues/188\n        (\"{% if 1 < 4 %}a{% elif 2 < 4 %}b{% elif 3 < 4 %}c{% else %}d{% endif %}\", \"a\"),\n        // with in operator\n        (\n            \"{% if 1 in numbers %}Admin{% elif 100 in numbers %}User{% else %}Hmm{% endif %}\",\n            \"Admin\",\n        ),\n        (\"{% if 100 in numbers %}Admin{% elif 1 in numbers %}User{% else %}Hmm{% endif %}\", \"User\"),\n        (\"{% if 'n' in name %}Admin{% else %}Hmm{% endif %}\", \"Admin\"),\n        // function in if\n        (\"{% if get_true() %}Truth{% endif %}\", \"Truth\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_symlinks", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_symlinks() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let mut tested: bool = false;\n    // arbitrarily chosen symlinks with hope that the CI environment provides at least one of them\n    for file in [\n        \"/bin/sh\",\n        \"/data/data/com.termux/files/usr/bin/sh\", // spell-checker:disable-line\n        \"/bin/sudoedit\",\n        \"/usr/bin/ex\",\n        \"/etc/localtime\",\n        \"/etc/aliases\",\n    ] {\n        if at.file_exists(file) && at.is_symlink(file) {\n            tested = true;\n            let args = [\"-c\", NORMAL_FORMAT_STR, file];\n            let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n            ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n            // -L, --dereference    follow links\n            let args = [\"-L\", \"-c\", NORMAL_FORMAT_STR, file];\n            let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n            ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n        }\n    }\n    if !tested {\n        panic!(\"No symlink found to test in this environment\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_wrap_bad_arg", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_wrap_bad_arg() {\n    for wrap_param in [\"-w\", \"--wrap\"] {\n        new_ucmd!()\n            .arg(wrap_param)\n            .arg(\"b\")\n            .fails()\n            .stderr_only(\"base32: invalid wrap size: 'b'\\n\");\n    }\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_png", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_png() {\n    truncate_images(\"png\")\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_catch_up_logs_restart", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_node_merge_catch_up_logs_restart() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_on_store1 = find_peer(&region, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    // make sure the peer of left region on engine 3 has caught up logs.\n    cluster.must_put(b\"k0\", b\"v0\");\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k11\", b\"v11\");\n    must_get_none(&cluster.get_engine(3), b\"k11\");\n\n    // after source peer is applied but before set it to tombstone\n    fail::cfg(\"after_handle_catch_up_logs_for_merge_1003\", \"return()\").unwrap();\n    pd_client.must_merge(left.get_id(), right.get_id());\n    thread::sleep(Duration::from_millis(100));\n    cluster.shutdown();\n\n    fail::remove(\"after_handle_catch_up_logs_for_merge_1003\");\n    cluster.start().unwrap();\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v11\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_when_multiple_input_some_with_error_then_shows_all_errors", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_sleep_when_multiple_input_some_with_error_then_shows_all_errors() {\n    let expected = \"invalid time interval 'abc': Invalid input: abc\\n\\\n        sleep: invalid time interval '1years': Invalid time unit: 'years' at position 2\\n\\\n        sleep: invalid time interval ' ': Found only whitespace in input\";\n\n    // Even if one of the arguments is valid, but the rest isn't, we should still fail and exit early.\n    // So, the timeout of 10 seconds ensures we haven't executed `thread::sleep` with the only valid\n    // interval of `100000.0` seconds.\n    new_ucmd!()\n        .args(&[\"abc\", \"100000.0\", \"1years\", \" \"])\n        .timeout(Duration::from_secs(10))\n        .fails()\n        .usage_error(expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_default_block_size_in_posix_portability_mode", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_default_block_size_in_posix_portability_mode() {\n    fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }\n\n    let output = new_ucmd!().arg(\"-P\").succeeds().stdout_move_str();\n    assert_eq!(get_header(&output), \"1024-blocks\");\n\n    let output = new_ucmd!()\n        .arg(\"-P\")\n        .env(\"POSIXLY_CORRECT\", \"1\")\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(get_header(&output), \"512-blocks\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_partition_leader_in_minority_detect_in_minority", "code": "fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };\n\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        // Once we see a response on the wire we know a prevote round is happening.\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with failure prevote notifier, got {:?}\", received);\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during failure.\",\n        );\n    }\n\n    // Let the cluster recover.\n    match failure_type {\n        FailureType::Partition(..) => {\n            cluster.clear_send_filters();\n        }\n        FailureType::Reboot(peers) => {\n            cluster.clear_send_filters();\n            peers.iter().for_each(|&peer| {\n                cluster.run_node(peer).unwrap();\n            });\n        }\n    };\n\n    // Prepare to listen.\n    let rx = if let Some((id, _)) = detect_during_recovery {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached recovery prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    if let Some(leader_id) = leader_after_failure_id.into() {\n        cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    };\n\n    // Once we see a response on the wire we know a prevote round is happening.\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with recovery prevote notifier, got {:?}\", received);\n\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during recovery.\",\n        );\n    };\n\n    cluster.must_put(b\"k3\", b\"v3\");\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n}", "test": "fn test_prevote_partition_leader_in_minority_detect_in_minority() {\n    let mut cluster = new_node_cluster(0, 5);\n    // The follower is in the minority and is part of a prevote process. On rejoin\n    // it adopts the old leader.\n    test_prevote(\n        &mut cluster,\n        FailureType::Partition(&[1, 2, 3], &[3, 4, 5]),\n        None,\n        (4, true),\n        None,\n    );\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_wildcard_stmt", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn test_wildcard_stmt() {\n    let needle = r#\"_;\"#;\n\n    let source = r#\"\n    void f (){\n        foo(x);\n        x = 10;\n    }\n    \"#;\n\n    let matches = parse_and_match(needle, source);\n    assert_eq!(matches, 2);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::function_decl_hoisting", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn function_decl_hoisting() {\n    run_test_actions([\n        TestAction::assert_eq(\n            indoc! {r#\"\n                {\n                    let a = hello();\n                    function hello() { return 5 }\n\n                    a;\n                }\n            \"#},\n            5,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                {\n                    x = hello();\n\n                    function hello() { return 5 }\n                    var x;\n                    x;\n                }\n            \"#},\n            5,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                {\n                    hello = function() { return 5 }\n                    x = hello();\n\n                    x;\n                }\n            \"#},\n            5,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                {\n                    let x = b();\n\n                    function a() {return 5}\n                    function b() {return a()}\n\n                    x;\n                }\n            \"#},\n            5,\n        ),\n        TestAction::assert_eq(\n            indoc! {r#\"\n                {\n                    let x = b();\n\n                    function b() {return a()}\n                    function a() {return 5}\n\n                    x;\n                }\n            \"#},\n            5,\n        ),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_number_format_rz_with_negative_line_number", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_number_format_rz_with_negative_line_number() {\n    for arg in [\"-nrz\", \"--number-format=rz\"] {\n        new_ucmd!()\n            .arg(arg)\n            .arg(\"-v-12\")\n            .pipe_in(\"test\")\n            .succeeds()\n            .stdout_is(\"-00012\\ttest\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_worker.rs::test_error_in_compaction_filter", "code": "fn count(&self) -> usize {\n        panic!()\n    }", "test": "fn test_error_in_compaction_filter() {\n    let mut engine = TestEngineBuilder::new().build().unwrap();\n    let raw_engine = engine.get_rocksdb();\n\n    let large_value = vec![b'x'; 300];\n    must_prewrite_put(&mut engine, b\"zkey\", &large_value, b\"zkey\", 101);\n    must_commit(&mut engine, b\"zkey\", 101, 102);\n    must_prewrite_put(&mut engine, b\"zkey\", &large_value, b\"zkey\", 103);\n    must_commit(&mut engine, b\"zkey\", 103, 104);\n    must_prewrite_delete(&mut engine, b\"zkey\", b\"zkey\", 105);\n    must_commit(&mut engine, b\"zkey\", 105, 106);\n\n    let fp = \"write_compaction_filter_flush_write_batch\";\n    fail::cfg(fp, \"return\").unwrap();\n\n    let mut gc_runner = TestGcRunner::new(200);\n    gc_runner.gc(&raw_engine);\n\n    match gc_runner.gc_receiver.recv().unwrap() {\n        GcTask::OrphanVersions { wb, .. } => assert_eq!(wb.count(), 2),\n        GcTask::GcKeys { .. } => {}\n        _ => unreachable!(),\n    }\n\n    // Although versions on default CF is not cleaned, write CF is GCed correctly.\n    must_get_none(&mut engine, b\"zkey\", 102);\n    must_get_none(&mut engine, b\"zkey\", 104);\n\n    fail::remove(fp);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_rollback", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_rollback() {\n    match verified_stmt(\"ROLLBACK\") {\n        Statement::Rollback { chain: false } => (),\n        _ => unreachable!(),\n    }\n\n    match verified_stmt(\"ROLLBACK AND CHAIN\") {\n        Statement::Rollback { chain: true } => (),\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\"ROLLBACK AND NO CHAIN\", \"ROLLBACK\");\n    one_statement_parses_to(\"ROLLBACK WORK AND NO CHAIN\", \"ROLLBACK\");\n    one_statement_parses_to(\"ROLLBACK TRANSACTION AND NO CHAIN\", \"ROLLBACK\");\n    one_statement_parses_to(\"ROLLBACK WORK AND CHAIN\", \"ROLLBACK AND CHAIN\");\n    one_statement_parses_to(\"ROLLBACK TRANSACTION AND CHAIN\", \"ROLLBACK AND CHAIN\");\n    one_statement_parses_to(\"ROLLBACK WORK\", \"ROLLBACK\");\n    one_statement_parses_to(\"ROLLBACK TRANSACTION\", \"ROLLBACK\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_wasmtime_simple_wat", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "test": "fn run_wasmtime_simple_wat() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/simple.wat\")?;\n    run_wasmtime(&[\n        \"run\",\n        \"--invoke\",\n        \"simple\",\n        \"-Ccache=n\",\n        wasm.path().to_str().unwrap(),\n        \"4\",\n    ])?;\n    assert_eq!(\n        run_wasmtime(&[\n            \"run\",\n            \"--invoke\",\n            \"get_f32\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ])?,\n        \"100\\n\"\n    );\n    assert_eq!(\n        run_wasmtime(&[\n            \"run\",\n            \"--invoke\",\n            \"get_f64\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ])?,\n        \"100\\n\"\n    );\n    Ok(())\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/f16_tests.rs::from_f32_test", "code": "pub const fn to_bits(self) -> u16 {\n        self.bits\n    }", "test": "fn from_f32_test() {\n    assert_eq!(f16::from_f32(2.980232e-08).to_bits(), 0);\n    assert_eq!(f16::from_f32(2.9802322e-08).to_bits(), 0);\n    assert_eq!(f16::from_f32(2.9802326e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.960464e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.9604645e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.960465e-08).to_bits(), 1);\n    assert!(f16::from_f32(f32::NAN).is_nan());\n    assert!(f16::from_f32(f32::INFINITY).is_inf());\n    assert!(f16::from_f32(f32::NEG_INFINITY).is_inf());\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::columns_after_partition", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn columns_after_partition() {\n    let query = \"INSERT INTO db.table_name PARTITION (a, b) (c, d) SELECT a, b, c, d FROM db.table\";\n    hive().verified_stmt(query);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::dynamic_val", "code": "pub fn ty(&self) -> Type {\n        match self {\n            DataValue::I8(_) => types::I8,\n            DataValue::I16(_) => types::I16,\n            DataValue::I32(_) => types::I32,\n            DataValue::I64(_) => types::I64,\n            DataValue::I128(_) => types::I128,\n            DataValue::F32(_) => types::F32,\n            DataValue::F64(_) => types::F64,\n            DataValue::V128(_) => types::I8X16, // A default type.\n            DataValue::V64(_) => types::I8X8,   // A default type.\n        }\n    }", "test": "fn dynamic_val() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n                (type $t2' (resource (rep i32)))\n                (export $t2 \"t2\" (type $t2'))\n                (core func $f (canon resource.new $t2))\n\n                (core module $m\n                    (func (export \"pass\") (param i32) (result i32)\n                        (local.get 0)))\n                (core instance $i (instantiate $m))\n\n                (func (export \"a\") (param \"x\" (own $t1)) (result (own $t1))\n                    (canon lift (core func $i \"pass\")))\n                (func (export \"b\") (param \"x\" u32) (result (own $t2))\n                    (canon lift (core func $f)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let a = i.get_func(&mut store, \"a\").unwrap();\n    let a_typed = i.get_typed_func::<(Resource<MyType>,), (ResourceAny,)>(&mut store, \"a\")?;\n    let b = i.get_func(&mut store, \"b\").unwrap();\n    let t2 = i.get_resource(&mut store, \"t2\").unwrap();\n\n    let t1 = Resource::new_own(100);\n    let (t1,) = a_typed.call(&mut store, (t1,))?;\n    a_typed.post_return(&mut store)?;\n    assert_eq!(t1.ty(), ResourceType::host::<MyType>());\n\n    let mut results = [Val::Bool(false)];\n    a.call(&mut store, &[Val::Resource(t1)], &mut results)?;\n    a.post_return(&mut store)?;\n    match &results[0] {\n        Val::Resource(resource) => {\n            assert_eq!(resource.ty(), ResourceType::host::<MyType>());\n        }\n        _ => unreachable!(),\n    }\n\n    b.call(&mut store, &[Val::U32(200)], &mut results)?;\n    match &results[0] {\n        Val::Resource(resource) => {\n            assert_eq!(resource.ty(), t2);\n        }\n        _ => unreachable!(),\n    }\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_excl_causes_failure_when_present", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_excl_causes_failure_when_present() {\n    let fname = \"this-file-exists-excl.txt\";\n    assert_fixture_exists!(&fname);\n\n    let (_fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"of=this-file-exists-excl.txt\", \"conv=excl\"])\n        .fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_missing", "code": "pub fn stdout_move_str(self) -> String {\n        String::from_utf8(self.stdout).unwrap()\n    }", "test": "fn test_canonicalize_missing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let actual = ucmd.arg(\"-m\").arg(GIBBERISH).run().stdout_move_str();\n    let expect = path_concat!(at.root_dir_resolved(), GIBBERISH) + \"\\n\";\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    assert_eq!(actual, expect);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::doesnt_work_with_justfile_and_working_directory", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn doesnt_work_with_justfile_and_working_directory() {\n  Test::new()\n    .tree(tree! {\n      bar: {\n        justfile: \"\n          baz:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\n      \"\n      foo:\n        echo root\n    \",\n    )\n    .args([\"--justfile\", \"justfile\", \"--working-directory\", \".\", \"foo\"])\n    .current_dir(\"bar\")\n    .status(EXIT_FAILURE)\n    .stderr(\"error: Justfile does not contain recipe `foo`.\\n\")\n    .run();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::backwards_call_works", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn backwards_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (result i32)\n                    i32.const 4)\n                (func (export \"foo\") (result i32)\n                    call 0)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_loading_label_after_rolling_start", "code": "fn region_replication_status<T>(\n        &mut self,\n        ctx: &PollContext<EK, ER, T>,\n    ) -> Option<RegionReplicationStatus> {\n        if self.replication_mode_version == 0 {\n            return None;\n        }\n        let mut status = RegionReplicationStatus {\n            state_id: self.replication_mode_version,\n            ..Default::default()\n        };\n        let state = if !self.replication_sync {\n            if self.dr_auto_sync_state != DrAutoSyncState::Async {\n                // use raft_log_gc_threshold, it's indicate the log is almost synced.\n                let res = self.check_group_commit_consistent(ctx.cfg.raft_log_gc_threshold);\n                if Some(true) != res {\n                    let mut buffer: SmallVec<[(u64, u64, u64); 5]> = SmallVec::new();\n                    if self.get_store().applied_term() >= self.term() {\n                        let progress = self.raft_group.raft.prs();\n                        for (id, p) in progress.iter() {\n                            if !progress.conf().voters().contains(*id) {\n                                continue;\n                            }\n                            buffer.push((*id, p.commit_group_id, p.matched));\n                        }\n                    };\n                    info!(\n                        \"still not reach integrity over label\";\n                        \"status\" => ?res,\n                        \"region_id\" => self.region_id,\n                        \"peer_id\" => self.peer.id,\n                        \"progress\" => ?buffer,\n                        \"dr_auto_sync_state\" => ?self.dr_auto_sync_state,\n                    );\n                } else {\n                    // Once the DR replicas catch up the log during the `SyncRecover` phase, we\n                    // should enable group commit to promise `IntegrityOverLabel`. then safe\n                    // to switch to the `Sync` phase.\n                    if self.dr_auto_sync_state == DrAutoSyncState::SyncRecover {\n                        self.switch_group_commit(true, &ctx.global_replication_state)\n                    }\n                    self.replication_sync = true;\n                }\n                match res {\n                    Some(true) => RegionReplicationState::IntegrityOverLabel,\n                    Some(false) => RegionReplicationState::SimpleMajority,\n                    None => RegionReplicationState::Unknown,\n                }\n            } else {\n                RegionReplicationState::SimpleMajority\n            }\n        } else {\n            RegionReplicationState::IntegrityOverLabel\n        };\n        status.set_state(state);\n        Some(status)\n    }", "test": "fn test_loading_label_after_rolling_start() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.pd_store_heartbeat_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 10;\n    cluster.create_engines();\n    let r = cluster.bootstrap_conf_change();\n    cluster.add_label(1, \"zone\", \"ES\");\n    cluster.run_node(1).unwrap();\n    cluster.add_label(2, \"zone\", \"ES\");\n    cluster.run_node(2).unwrap();\n    cluster.add_label(3, \"zone\", \"WS\");\n    cluster.run_node(3).unwrap();\n\n    let pd_client = cluster.pd_client.clone();\n    pd_client.must_add_peer(r, new_peer(2, 2));\n    pd_client.must_add_peer(r, new_peer(3, 3));\n    cluster.must_transfer_leader(r, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n    cluster.must_put(b\"k2\", b\"v2\");\n    // Non exists label key can't tolerate any node unavailable.\n    cluster.pd_client.configure_dr_auto_sync(\"zone\");\n    thread::sleep(Duration::from_millis(100));\n    cluster.must_put(b\"k3\", b\"v3\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(r);\n    assert_eq!(state.state_id, 1);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_sections_and_styles", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_sections_and_styles() {\n    // spell-checker:disable\n    for (fixture, output) in [\n        (\n            \"section.txt\",\n            \"\\n    HEADER1\\n    HEADER2\\n\\n1  |BODY1\\n2  \\\n             |BODY2\\n\\n    FOOTER1\\n    FOOTER2\\n\\n    NEXTHEADER1\\n    NEXTHEADER2\\n\\n1  \\\n             |NEXTBODY1\\n2  |NEXTBODY2\\n\\n    NEXTFOOTER1\\n    NEXTFOOTER2\\n\",\n        ),\n        (\n            \"joinblanklines.txt\",\n            \"1  |Nonempty\\n2  |Nonempty\\n3  |Followed by 10x empty\\n    \\n    \\n    \\n    \\n4  \\\n             |\\n    \\n    \\n    \\n    \\n5  |\\n6  |Followed by 5x empty\\n    \\n    \\n    \\n    \\n7  |\\n8  \\\n             |Followed by 4x empty\\n    \\n    \\n    \\n    \\n9  |Nonempty\\n10 |Nonempty\\n11 \\\n             |Nonempty.\\n\",\n        ),\n    ] {\n        new_ucmd!()\n            .args(&[\n                \"-s\", \"|\", \"-n\", \"ln\", \"-w\", \"3\", \"-b\", \"a\", \"-l\", \"5\", fixture,\n            ])\n            .run()\n            .stdout_is(output);\n    }\n    // spell-checker:enable\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::update_max_frame_len_at_rest", "code": "pub fn payload(&self) -> &T {\n        &self.data\n    }", "test": "async fn update_max_frame_len_at_rest() {\n    use futures::StreamExt;\n    use tokio::io::AsyncReadExt;\n\n    h2_support::trace_init!();\n    // TODO: add test for updating max frame length in flight as well?\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 0, 0, 0, 0, 1,\n            \"hello\",\n            0, 64, 1, 0, 0, 0, 0, 0, 1,\n            vec![0; 16_385],\n        ];\n    };\n\n    assert_eq!(poll_frame!(Data, codec).payload(), &b\"hello\"[..]);\n\n    codec.set_max_recv_frame_size(16_384);\n\n    assert_eq!(codec.max_recv_frame_size(), 16_384);\n    assert_eq!(\n        codec.next().await.unwrap().unwrap_err().to_string(),\n        \"frame with invalid size\"\n    );\n\n    // drain codec buffer\n    let mut buf = Vec::new();\n    codec.get_mut().read_to_end(&mut buf).await.unwrap();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::deny_unicode_escape_in_false_expression", "code": "pub(super) fn check_invalid_script(js: &str) {\n    assert!(Parser::new(Source::from_bytes(js))\n        .parse_script(&mut Interner::default())\n        .is_err());\n}", "test": "fn deny_unicode_escape_in_false_expression() {\n    check_invalid_script(r\"let x = f\\u{61}lse;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_line_bytes", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nul_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dir.rs::test_dir", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_dir() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_with_multiple_sources_and_target_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs_with_multiple_sources_and_target_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source1 = \"source_file_1\";\n    let source2 = \"source_file_2\";\n    let target_dir = \"missing_target_dir\";\n\n    at.touch(source1);\n    at.touch(source2);\n\n    // installing multiple files into a missing directory will fail, when -D is used w/o -t parameter\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(at.plus(target_dir))\n        .fails()\n        .stderr_contains(\"missing_target_dir' is not a directory\");\n\n    assert!(!at.dir_exists(target_dir));\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(\"-t\")\n        .arg(at.plus(target_dir))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(target_dir));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_first_line_number_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_first_line_number_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_first_line.log.expected\";\n    let mut scenario = new_ucmd!();\n    let value = file_last_modified_time(&scenario, test_file_path);\n    scenario\n        .args(&[\"-N\", \"5\", \"-n\", test_file_path])\n        .succeeds()\n        .stdout_is_templated_fixture(expected_test_file_path, &[(\"{last_modified_time}\", &value)]);\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/f2s_test.rs::test_basic", "code": "fn pretty(f: f64) -> String {\n    ryu::Buffer::new().format(f).to_owned()\n}", "test": "fn test_basic() {\n    check!(0.0);\n    check!(-0.0);\n    check!(1.0);\n    check!(-1.0);\n    assert_eq!(pretty(f32::NAN), \"NaN\");\n    assert_eq!(pretty(f32::INFINITY), \"inf\");\n    assert_eq!(pretty(f32::NEG_INFINITY), \"-inf\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/attributes.rs::multiple_attributes_one_line_duplicate_check", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn multiple_attributes_one_line_duplicate_check() {\n  Test::new()\n    .justfile(\n      \"\n      [macos, windows, linux]\n      [linux]\n      foo:\n        exit 1\n    \",\n    )\n    .stderr(\n      \"\n      error: Recipe attribute `linux` first used on line 1 is duplicated on line 2\n        |\n      2 | [linux]\n        |  ^^^^^\n        \",\n    )\n    .status(1)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_key_prev_miss_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_key_prev_miss_snapshot() {\n    let db = default_engine();\n    seek_key_prev_miss(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_create_table_empty", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_create_table_empty() {\n    // Zero-column tables are weird, but supported by at least PostgreSQL.\n    // <https://github.com/sqlparser-rs/sqlparser-rs/pull/94>\n    let _ = pg_and_generic().verified_stmt(\"CREATE TABLE t ()\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_ingest_file_twice_and_conflict", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_file_twice_and_conflict() {\n    // test with tde\n    let (_tmp_key_dir, _cluster, ctx, _tikv, import) = new_cluster_and_tikv_import_client_tde();\n\n    let temp_dir = Builder::new()\n        .prefix(\"test_ingest_file_twice_and_conflict\")\n        .tempdir()\n        .unwrap();\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    upload_sst(&import, &meta, &data).unwrap();\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx);\n    ingest.set_sst(meta);\n\n    let latch_fp = \"import::sst_service::ingest\";\n    let (tx1, rx1) = channel();\n    let (tx2, rx2) = channel();\n    let tx1 = Arc::new(Mutex::new(tx1));\n    let rx2 = Arc::new(Mutex::new(rx2));\n    fail::cfg_callback(latch_fp, move || {\n        tx1.lock().unwrap().send(()).unwrap();\n        rx2.lock().unwrap().recv().unwrap();\n    })\n    .unwrap();\n    let resp_recv = import.ingest_async(&ingest).unwrap();\n\n    // Make sure the before request has acquired lock.\n    rx1.recv().unwrap();\n\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(resp.has_error());\n    assert_eq!(\"ingest file conflict\", resp.get_error().get_message());\n    tx2.send(()).unwrap();\n    let resp = block_on(resp_recv).unwrap();\n    assert!(!resp.has_error());\n\n    fail::remove(latch_fp);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(resp.has_error());\n    assert_eq!(\n        \"The file which would be ingested doest not exist.\",\n        resp.get_error().get_message()\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::drops_empty_tbody", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn drops_empty_tbody() {\n    assert_eq!(\n        \"<table><thead><tr><td>hi</td></tr></thead></table>\",\n        normalize_html(\"<table><thead><tr><td>hi</td></tr></thead><tbody>  </tbody></table>\")\n    )\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_no_backup", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn inscribe_no_backup() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  create_wallet(&rpc_server);\n  assert_eq!(rpc_server.descriptors().len(), 2);\n\n  CommandBuilder::new(\"wallet inscribe --file hello.txt --no-backup --fee-rate 1\")\n    .write(\"hello.txt\", \"HELLOWORLD\")\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  assert_eq!(rpc_server.descriptors().len(), 2);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_preserve_empty_lines", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_preserve_empty_lines() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"\\n\")\n        .succeeds()\n        .stdout_is(\"\\n\");\n\n    new_ucmd!()\n        .args(&[\"-w1\", \"-b\"])\n        .pipe_in(\"0\\n1\\n\\n2\\n\\n\\n\")\n        .succeeds()\n        .stdout_is(\"0\\n1\\n\\n2\\n\\n\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_data", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_sync_data() {\n    // Todo add a second arg\n    let temporary_directory = tempdir().unwrap();\n    let temporary_path = fs::canonicalize(temporary_directory.path()).unwrap();\n    new_ucmd!().arg(\"--data\").arg(&temporary_path).succeeds();\n}"}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes192_encrypted_file", "code": "pub fn name(&self) -> &str {\n        &self.data.file_name\n    }", "test": "fn aes192_encrypted_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n        .by_name_decrypt(\"secret_data_192\", PASSWORD)\n        .expect(\"couldn't find file in archive\")\n        .expect(\"invalid password\");\n    assert_eq!(\"secret_data_192\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"couldn't read encrypted file\");\n    assert_eq!(SECRET_CONTENT, content);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_string_predicate", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_select_string_predicate() {\n    let sql = \"SELECT id, fname, lname FROM customer \\\n               WHERE salary <> 'Not Provided' AND salary <> ''\";\n    let _ast = verified_only_select(sql);\n    //TODO: add assertions\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::bitwise_or", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn bitwise_or() {\n    test(\"a | b | c\", \"a|b|c;\");\n    test(\"(a | b) | c\", \"a|b|c;\");\n    test(\"a | (b | c)\", \"a|b|c;\");\n    test(\"a | b ^ c\", \"a|b^c;\");\n    test(\"a | (b ^ c)\", \"a|b^c;\");\n    test(\"a | (b && c)\", \"a|(b&&c);\");\n    test(\"a | b && c\", \"a|b&&c;\");\n    test(\"(a ^ b) | (c ^ d)\", \"a^b|c^d;\");\n    test(\"(a, b) | (c, d)\", \"(a,b)|(c,d);\");\n    test(\"a, b | c, d\", \"a,b|c,d;\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_when_merge_region", "code": "pub fn must_transfer_leader(\n    cluster: &Cluster,\n    region_id: u64,\n    from_off: usize,\n    to_off: usize,\n    to_peer: metapb::Peer,\n) {\n    let router = &cluster.routers[from_off];\n    let router2 = &cluster.routers[to_off];\n    let mut req = router.new_request_for(region_id);\n    let mut transfer_req = TransferLeaderRequest::default();\n    transfer_req.set_peer(to_peer.clone());\n    let admin_req = req.mut_admin_request();\n    admin_req.set_cmd_type(AdminCmdType::TransferLeader);\n    admin_req.set_transfer_leader(transfer_req);\n    let resp = router.admin_command(region_id, req).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    cluster.dispatch(region_id, vec![]);\n\n    let meta = router\n        .must_query_debug_info(region_id, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(meta.raft_status.soft_state.leader_id, to_peer.id);\n    let meta = router2\n        .must_query_debug_info(region_id, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(meta.raft_status.soft_state.leader_id, to_peer.id);\n}", "test": "fn test_detect_deadlock_when_merge_region() {\n    let mut cluster = new_cluster_for_deadlock_test(3);\n\n    // Source region will be destroyed.\n    for as_target in &[false, true] {\n        must_split_region(&mut cluster, b\"\", b\"k1\");\n        if *as_target {\n            must_merge_region(&mut cluster, b\"k1\", b\"\");\n        } else {\n            must_merge_region(&mut cluster, b\"\", b\"k1\");\n        }\n        deadlock_detector_leader_must_be(&mut cluster, 1);\n        must_detect_deadlock(&mut cluster, b\"k\", 10);\n    }\n\n    // Leaders of two regions are on different store.\n    for as_target in &[false, true] {\n        must_split_region(&mut cluster, b\"\", b\"k1\");\n        must_transfer_leader(&mut cluster, b\"k1\", 2);\n        if *as_target {\n            must_merge_region(&mut cluster, b\"k1\", b\"\");\n            deadlock_detector_leader_must_be(&mut cluster, 1);\n        } else {\n            must_merge_region(&mut cluster, b\"\", b\"k1\");\n            deadlock_detector_leader_must_be(&mut cluster, 2);\n        }\n        must_detect_deadlock(&mut cluster, b\"k\", 10);\n        must_transfer_leader(&mut cluster, b\"\", 1);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_logical_mode", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_realpath_logical_mode() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.mkdir(\"dir1\");\n    at.mkdir(\"dir2\");\n    at.symlink_dir(\"dir2\", \"dir1/foo\");\n\n    scene\n        .ucmd()\n        .arg(\"-L\")\n        .arg(\"dir1/foo/..\")\n        .succeeds()\n        .stdout_contains(\"dir1\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_no_args_file_to_dir", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_no_args_file_to_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_install_simple_backup_file_a\";\n    let dest_dir = \"test_install_dest/\";\n    let expect = format!(\"{dest_dir}{file}\");\n\n    at.touch(file);\n    at.mkdir(dest_dir);\n    at.touch(&expect);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(file)\n        .arg(dest_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(&expect));\n    assert!(at.file_exists(format!(\"{expect}~\")));\n}"}
