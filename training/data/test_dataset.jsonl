{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::ref_get_signatures", "code": "fn drop(&mut self) {\n            let data = mem::take(&mut self.data);\n            assert!(self\n                .buffer\n                .lock()\n                .unwrap()\n                .insert(self.page, Arc::new(data))\n                .is_none());\n        }", "test": "fn ref_get_signatures() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..10u8 {\n            table.insert([i].as_slice(), [i + 1].as_slice()).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(SLICE_TABLE).unwrap();\n\n    let zero = vec![0u8];\n    assert_eq!(&[1], table.get([0].as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(b\"\\0\".as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(zero.as_slice()).unwrap().unwrap().value());\n\n    let start = vec![0u8];\n    let end = vec![10u8];\n    let mut iter = table.range::<&[u8]>(..).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range(start.as_slice()..&end).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n    drop(iter);\n\n    let mut iter = table.range(start.as_slice()..end.as_slice()).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range([0u8].as_slice()..[10u8].as_slice()).unwrap();\n    for i in 0..10u8 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), [i + 1].as_slice());\n    }\n    assert!(iter.next().is_none());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_t", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_t() {\n    // Test iterators that skip single, trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4__5_.56\");\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::class_type_parameters", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn class_type_parameters() {\n    let source = r#\"class X[T: str, U, *Ts, **P]: ...\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_lifetime", "code": "fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n                            fixed_key_size,\n                            fixed_value_size,\n                        );\n                        let entry = if reverse {\n                            child_accessor.num_pairs() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Leaf {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            entry,\n                            parent,\n                        }))\n                    }\n                    BRANCH => {\n                        let child_accessor = BranchAccessor::new(&child_page, fixed_key_size);\n                        let child = if reverse {\n                            child_accessor.count_children() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Internal {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            child,\n                            parent,\n                        }))\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", "test": "fn range_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.range::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(\n        iter.next()\n            .unwrap()\n            .unwrap()\n            .1\n            .next()\n            .unwrap()\n            .unwrap()\n            .value(),\n        \"world\"\n    );\n    assert!(iter.next().is_none());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_batch", "code": "fn lock(primary: &[u8]) -> PessimisticLock {\n        PessimisticLock {\n            primary: primary.to_vec().into_boxed_slice(),\n            start_ts: 100.into(),\n            ttl: 3000,\n            for_update_ts: 110.into(),\n            min_commit_ts: 110.into(),\n            last_change_ts: 105.into(),\n            versions_to_last_change: 2,\n        }\n    }", "test": "fn test_batch() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    let metrics = builder.metrics.clone();\n    system.spawn(\"test\".to_owned(), builder);\n    let mut expected_metrics = HandleMetrics::default();\n    assert_eq!(*metrics.lock().unwrap(), expected_metrics);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                let mailbox = BasicMailbox::new(tx, runner, Arc::default());\n                r.register(1, mailbox);\n                tx_.send(1).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n    // sleep to wait Batch-System to finish calling end().\n    sleep(Duration::from_millis(20));\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(2).unwrap();\n            })),\n        )\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(2));\n    system.shutdown();\n    expected_metrics.control = 1;\n    expected_metrics.normal = 1;\n    expected_metrics.begin = 2;\n    assert_eq!(*metrics.lock().unwrap(), expected_metrics);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/failpoints/test_life.rs::test_destroy_by_larger_id_while_applying", "code": "pub async fn wait_committed(&mut self) -> bool {\n        WaitEvent {\n            event: CmdResChannel::COMMITTED_EVENT,\n            core: &self.core,\n        }\n        .await\n    }", "test": "fn test_destroy_by_larger_id_while_applying() {\n    let fp = \"APPLY_COMMITTED_ENTRIES\";\n    let mut cluster = Cluster::default();\n    let router = &cluster.routers[0];\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    fail::cfg(fp, \"pause\").unwrap();\n\n    let header = Box::new(router.new_request_for(2).take_header());\n    let mut put = SimpleWriteEncoder::with_capacity(64);\n    put.put(CF_DEFAULT, b\"key\", b\"value\");\n    let (msg, mut sub) = PeerMsg::simple_write(header.clone(), put.clone().encode());\n    router.send(2, msg).unwrap();\n    assert!(block_on(sub.wait_committed()));\n\n    let mut larger_id_msg = Box::<RaftMessage>::default();\n    larger_id_msg.set_region_id(2);\n    let mut target_peer = header.get_peer().clone();\n    target_peer.set_id(target_peer.get_id() + 1);\n    larger_id_msg.set_to_peer(target_peer.clone());\n    larger_id_msg.set_region_epoch(header.get_region_epoch().clone());\n    larger_id_msg\n        .mut_region_epoch()\n        .set_conf_ver(header.get_region_epoch().get_conf_ver() + 1);\n    larger_id_msg.set_from_peer(new_peer(2, 8));\n    let raft_message = larger_id_msg.mut_message();\n    raft_message.set_msg_type(MessageType::MsgHeartbeat);\n    raft_message.set_from(8);\n    raft_message.set_to(target_peer.get_id());\n    raft_message.set_term(10);\n\n    // Larger ID should trigger destroy.\n    router.send_raft_message(larger_id_msg).unwrap();\n    fail::remove(fp);\n    assert_peer_not_exist(2, header.get_peer().get_id(), router);\n    let meta = router\n        .must_query_debug_info(2, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(meta.raft_status.id, target_peer.get_id());\n    assert_eq!(meta.raft_status.hard_state.term, 10);\n\n    std::thread::sleep(Duration::from_millis(10));\n\n    // New peer should survive restart.\n    cluster.restart(0);\n    let router = &cluster.routers[0];\n    let meta = router\n        .must_query_debug_info(2, Duration::from_secs(3))\n        .unwrap();\n    assert_eq!(meta.raft_status.id, target_peer.get_id());\n    assert_eq!(meta.raft_status.hard_state.term, 10);\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::large_add_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn large_add_test() {\n    // Overflow, both single values\n    let mut x = VecType::from_u64(4294967295);\n    let y = VecType::from_u64(5);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    // No overflow, single value\n    let mut x = VecType::from_u64(5);\n    let y = VecType::from_u64(7);\n    bigint::large_add(&mut x, &y);\n    let expected = VecType::from_u64(12);\n    assert_eq!(&*x, &*expected);\n\n    // Single carry, internal overflow\n    let mut x = VecType::from_u64(0x80000000FFFFFFFF);\n    let y = VecType::from_u64(7);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[6, 0x80000001]);\n    assert_eq!(&*x, &*expected);\n\n    // 1st overflows, 2nd doesn't.\n    let mut x = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    let y = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFE, 0xFFFFFFFF]);\n    assert_eq!(&*x, &*expected);\n\n    // Both overflow.\n    let mut x = VecType::from_u64(0x8FFFFFFFFFFFFFFF);\n    let y = VecType::from_u64(0x7FFFFFFFFFFFFFFF);\n    bigint::large_add(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFE, 0x0FFFFFFF, 1]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typed_struct_with_field_name", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_typed_struct_with_field_name() {\n    let sql = r#\"SELECT STRUCT<x INT64>(5), STRUCT<y STRING>(\"foo\")\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"x\")),\n                field_type: DataType::Int64\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\"foo\".to_string())),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"y\")),\n                field_type: DataType::String(None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<x INT64, y INT64>(5, 5)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(1, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")), Expr::Value(number(\"5\")),],\n            fields: vec![\n                StructField {\n                    field_name: Some(Ident::from(\"x\")),\n                    field_type: DataType::Int64\n                },\n                StructField {\n                    field_name: Some(Ident::from(\"y\")),\n                    field_type: DataType::Int64\n                }\n            ]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::small_add_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn small_add_test() {\n    let mut x = VecType::from_u32(4294967295);\n    bigint::small_add(&mut x, 5);\n    let expected: VecType = vec_from_u32(&[4, 1]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(5);\n    bigint::small_add(&mut x, 7);\n    let expected = VecType::from_u32(12);\n    assert_eq!(&*x, &*expected);\n\n    // Single carry, internal overflow\n    let mut x = VecType::from_u64(0x80000000FFFFFFFF);\n    bigint::small_add(&mut x, 7);\n    let expected: VecType = vec_from_u32(&[6, 0x80000001]);\n    assert_eq!(&*x, &*expected);\n\n    // Double carry, overflow\n    let mut x = VecType::from_u64(0xFFFFFFFFFFFFFFFF);\n    bigint::small_add(&mut x, 7);\n    let expected: VecType = vec_from_u32(&[6, 0, 1]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::help", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn help() {\n    new_ucmd!().arg(\"--help\").succeeds();\n    new_ucmd!().arg(\"-h\").succeeds();\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/snapshots.rs::convert_glsl_folder", "code": "fn write_output_wgsl(\n    input: &Input,\n    module: &naga::Module,\n    info: &naga::valid::ModuleInfo,\n    params: &WgslOutParameters,\n) {\n    use naga::back::wgsl;\n\n    println!(\"generating WGSL\");\n\n    let mut flags = wgsl::WriterFlags::empty();\n    flags.set(wgsl::WriterFlags::EXPLICIT_TYPES, params.explicit_types);\n\n    let string = wgsl::write_string(module, info, flags).expect(\"WGSL write failed\");\n\n    input.write_output_file(\"wgsl\", \"wgsl\", string);\n}", "test": "fn convert_glsl_folder() {\n    let _ = env_logger::try_init();\n\n    for input in Input::files_in_dir(\"glsl\") {\n        let input = Input {\n            keep_input_extension: true,\n            ..input\n        };\n        let file_name = &input.file_name;\n        if file_name.ends_with(\".ron\") {\n            // No needed to validate ron files\n            continue;\n        }\n\n        let mut parser = naga::front::glsl::Frontend::default();\n        let module = parser\n            .parse(\n                &naga::front::glsl::Options {\n                    stage: match file_name.extension().and_then(|s| s.to_str()).unwrap() {\n                        \"vert\" => naga::ShaderStage::Vertex,\n                        \"frag\" => naga::ShaderStage::Fragment,\n                        \"comp\" => naga::ShaderStage::Compute,\n                        ext => panic!(\"Unknown extension for glsl file {ext}\"),\n                    },\n                    defines: Default::default(),\n                },\n                &input.read_source(),\n            )\n            .unwrap();\n\n        let info = naga::valid::Validator::new(\n            naga::valid::ValidationFlags::all(),\n            naga::valid::Capabilities::all(),\n        )\n        .validate(&module)\n        .unwrap();\n\n        #[cfg(feature = \"wgsl-out\")]\n        {\n            write_output_wgsl(&input, &module, &info, &WgslOutParameters::default());\n        }\n    }\n}"}
{"test_id": "pyfisch-cbor/pyfisch-cbor-347a3f0/tests/ser.rs::test_str", "code": "fn serialize_and_compare<T: Serialize>(value: T, expected: &[u8]) {\n    let mut slice = [0u8; 64];\n    let writer = SliceWrite::new(&mut slice);\n    let mut serializer = Serializer::new(writer);\n    value.serialize(&mut serializer).unwrap();\n    let writer = serializer.into_inner();\n    let end = writer.bytes_written();\n    let slice = writer.into_inner();\n    assert_eq!(&slice[..end], expected);\n}", "test": "fn test_str() {\n    serialize_and_compare(\"foobar\", b\"ffoobar\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_slash_long_columns", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_trailing_slash_long_columns() {\n    new_ucmd!()\n        .arg(\"--tabs=1,/3\")\n        .pipe_in(\"\\taaaa\\tbbbb\\tcccc\")\n        .succeeds()\n        //          0         1\n        //          01234567890123456\n        .stdout_is(\" aaaa bbbb  cccc\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_control_block", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_control_block() {\n    let s = include_str!(\"data/serde/control_block_hex\");\n    let block = ControlBlock::decode(&Vec::<u8>::from_hex(s.trim()).unwrap()).unwrap();\n    let got = serialize(&block).unwrap();\n\n    let want = include_bytes!(\"data/serde/control_block_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::old_octal_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn old_octal_syntax() {\n    new_ucmd!()\n        .arg(\"-e\")\n        .arg(\"\\\\1foo\")\n        .succeeds()\n        .stdout_is(\"\\x01foo\\n\");\n\n    new_ucmd!()\n        .arg(\"-e\")\n        .arg(\"\\\\43foo\")\n        .succeeds()\n        .stdout_is(\"#foo\\n\");\n\n    new_ucmd!()\n        .arg(\"-e\")\n        .arg(\"\\\\101 foo\")\n        .succeeds()\n        .stdout_is(\"A foo\\n\");\n\n    new_ucmd!()\n        .arg(\"-e\")\n        .arg(\"\\\\1011\")\n        .succeeds()\n        .stdout_is(\"A1\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_hex_rejects_sign_after_identifier", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_hex_rejects_sign_after_identifier() {\n    new_ucmd!()\n        .args(&[\"0x-123ABC\"])\n        .fails()\n        .no_stdout()\n        .usage_error(\"invalid floating point argument: '0x-123ABC'\");\n    new_ucmd!()\n        .args(&[\"0x+123ABC\"])\n        .fails()\n        .no_stdout()\n        .usage_error(\"invalid floating point argument: '0x+123ABC'\");\n\n    new_ucmd!()\n        .args(&[\"--\", \"-0x-123ABC\"])\n        .fails()\n        .no_stdout()\n        .usage_error(\"invalid floating point argument: '-0x-123ABC'\");\n    new_ucmd!()\n        .args(&[\"--\", \"-0x+123ABC\"])\n        .fails()\n        .no_stdout()\n        .usage_error(\"invalid floating point argument: '-0x+123ABC'\");\n\n    // test without \"--\" => argument parsed as (invalid) flag\n    new_ucmd!()\n        .args(&[\"-0x-123ABC\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"unexpected argument '-0' found\");\n    new_ucmd!()\n        .args(&[\"-0x+123ABC\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"unexpected argument '-0' found\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_seq_object_borrow", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "test": "fn test_seq_object_borrow() {\n    fn connect(values: &dyn SeqObject) -> String {\n        let mut rv = String::new();\n        for item in values.iter() {\n            rv.push_str(&item.to_string())\n        }\n        rv\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"connect\", connect);\n    let state = env.empty_state();\n    assert_eq!(\n        state\n            .apply_filter(\n                \"connect\",\n                args!(vec![Value::from(\"HELLO\"), Value::from(42)])\n            )\n            .unwrap(),\n        Value::from(\"HELLO42\")\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_seq_with_no_len", "code": "pub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec_pretty(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_serialize_seq_with_no_len() {\n    #[derive(Clone, Debug, PartialEq)]\n    struct MyVec<T>(Vec<T>);\n\n    impl<T> ser::Serialize for MyVec<T>\n    where\n        T: ser::Serialize,\n    {\n        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: ser::Serializer,\n        {\n            let mut seq = serializer.serialize_seq(None)?;\n            for elem in &self.0 {\n                seq.serialize_element(elem)?;\n            }\n            seq.end()\n        }\n    }\n\n    struct Visitor<T> {\n        marker: PhantomData<MyVec<T>>,\n    }\n\n    impl<'de, T> de::Visitor<'de> for Visitor<T>\n    where\n        T: de::Deserialize<'de>,\n    {\n        type Value = MyVec<T>;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(\"array\")\n        }\n\n        fn visit_unit<E>(self) -> Result<MyVec<T>, E>\n        where\n            E: de::Error,\n        {\n            Ok(MyVec(Vec::new()))\n        }\n\n        fn visit_seq<V>(self, mut visitor: V) -> Result<MyVec<T>, V::Error>\n        where\n            V: de::SeqAccess<'de>,\n        {\n            let mut values = Vec::new();\n\n            while let Some(value) = visitor.next_element()? {\n                values.push(value);\n            }\n\n            Ok(MyVec(values))\n        }\n    }\n\n    impl<'de, T> de::Deserialize<'de> for MyVec<T>\n    where\n        T: de::Deserialize<'de>,\n    {\n        fn deserialize<D>(deserializer: D) -> Result<MyVec<T>, D::Error>\n        where\n            D: de::Deserializer<'de>,\n        {\n            deserializer.deserialize_map(Visitor {\n                marker: PhantomData,\n            })\n        }\n    }\n\n    let mut vec = Vec::new();\n    vec.push(MyVec(Vec::new()));\n    vec.push(MyVec(Vec::new()));\n    let vec: MyVec<MyVec<u32>> = MyVec(vec);\n\n    test_encode_ok(&[(vec.clone(), \"[[],[]]\")]);\n\n    let s = to_string_pretty(&vec).unwrap();\n    let expected = pretty_str!([[], []]);\n    assert_eq!(s, expected);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_loss_and_retry_too_low_mtu", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "test": "fn packet_loss_and_retry_too_low_mtu() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(b\"hello\").unwrap();\n    pair.drive();\n\n    // Nothing will get past this mtu\n    pair.mtu = 10;\n    pair.client_send(client_ch, s).write(b\" world\").unwrap();\n    pair.drive_client();\n\n    // The packet was dropped\n    assert!(pair.client.outbound.is_empty());\n    assert!(pair.server.inbound.is_empty());\n\n    // Restore the default mtu, so future packets are properly transmitted\n    pair.mtu = DEFAULT_MTU;\n\n    // The lost packet is resent\n    pair.drive();\n    assert!(pair.client.outbound.is_empty());\n\n    let recv = pair.server_recv(server_ch, s);\n    let buf = stream_chunks(recv);\n\n    assert_eq!(buf, b\"hello world\".as_slice());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_pop_none", "code": "fn assert_engine_error<T>(r: engine_traits::Result<T>) {\n    match r {\n        Err(engine_traits::Error::Engine(_)) => {}\n        Err(e) => panic!(\"expected Error::Engine, got {:?}\", e),\n        Ok(_) => panic!(\"expected Error::Engine, got Ok\"),\n    }\n}", "test": "fn save_point_pop_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::two_case_switch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn two_case_switch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            switch (a) {\n                case 5:\n                    a = 15;\n                    break;\n                case 10:\n                    a = 20;\n                    break;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_dir", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"DIR\");\n    ucmd.arg(\"DIR\")\n        .run()\n        .stderr_is(\"tail: error reading 'DIR': Is a directory\\n\")\n        .code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_column", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_column() {\n    let test_file_path = \"column.log\";\n    let expected_test_file_path = \"column.log.expected\";\n    for arg in [\"-3\", \"--column=3\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[\"--pages=3:5\", arg, \"-n\", test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple2_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn tuple2_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_misc", "code": "pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.locations();\n        self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n            text: text,\n            locs: locs,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }", "test": "fn capture_misc() {\n    let re = regex!(r\"(.)(?P<a>a)?(.)(?P<b>.)\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n\n    assert_eq!(5, cap.len());\n\n    assert_eq!((0, 3), { let m = cap.get(0).unwrap(); (m.start(), m.end()) });\n    assert_eq!(None, cap.get(2));\n    assert_eq!((2, 3), { let m = cap.get(4).unwrap(); (m.start(), m.end()) });\n\n    assert_eq!(t!(\"abc\"), match_text!(cap.get(0).unwrap()));\n    assert_eq!(None, cap.get(2));\n    assert_eq!(t!(\"c\"), match_text!(cap.get(4).unwrap()));\n\n    assert_eq!(None, cap.name(\"a\"));\n    assert_eq!(t!(\"c\"), match_text!(cap.name(\"b\").unwrap()));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_msck", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_msck() {\n    let msck = r#\"MSCK REPAIR TABLE db.table_name ADD PARTITIONS\"#;\n    let msck2 = r#\"MSCK REPAIR TABLE db.table_name\"#;\n    hive().verified_stmt(msck);\n    hive().verified_stmt(msck2);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_data_overflows_stream_window", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn recv_data_overflows_stream_window() {\n    // this tests for when streams have smaller windows than their connection\n    h2_support::trace_init!();\n\n    let (io, mut srv) = mock::new();\n\n    let mock = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        // fill the whole window\n        srv.send_frame(frames::data(1, vec![0u8; 16_384])).await;\n        // this frame overflows the window!\n        srv.send_frame(frames::data(1, &[0; 16][..]).eos()).await;\n        srv.recv_frame(frames::reset(1).flow_control()).await;\n    };\n\n    let h2 = async move {\n        let (mut client, conn) = client::Builder::new()\n            .initial_window_size(16_384)\n            .handshake::<_, Bytes>(io)\n            .await\n            .unwrap();\n        let request = Request::builder()\n            .method(Method::GET)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req = async move {\n            let resp = client.send_request(request, true).unwrap().0.await.unwrap();\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let res = util::concat(body).await;\n            let err = res.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"stream error detected: flow-control protocol violated\"\n            );\n        };\n\n        join(async move { conn.await.unwrap() }, req).await;\n    };\n    join(mock, h2).await;\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse() {\n    parse(\"String\").unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_no_create_file_absent", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_no_create_file_absent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_no_create_file_absent\";\n\n    ucmd.arg(\"-c\").arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_some_int_compares", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_some_int_compares() {\n    let scenario = TestScenario::new(util_name!());\n\n    let tests = [\n        [\"0\", \"-eq\", \"0\"],\n        [\"0\", \"-ne\", \"1\"],\n        [\"421\", \"-lt\", \"3720\"],\n        [\"0\", \"-le\", \"0\"],\n        [\"11\", \"-gt\", \"10\"],\n        [\"1024\", \"-ge\", \"512\"],\n        [\"9223372036854775806\", \"-le\", \"9223372036854775807\"],\n    ];\n\n    for test in &tests {\n        scenario.ucmd().args(&test[..]).succeeds();\n    }\n\n    // run the inverse of all these tests\n    for test in &tests {\n        scenario.ucmd().arg(\"!\").args(&test[..]).run().code_is(1);\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::alias_table", "code": "fn drop(&mut self) {\n            let data = mem::take(&mut self.data);\n            assert!(self\n                .buffer\n                .lock()\n                .unwrap()\n                .insert(self.page, Arc::new(data))\n                .is_none());\n        }", "test": "fn alias_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let table = write_txn.open_table(STR_TABLE).unwrap();\n    let result = write_txn.open_table(STR_TABLE);\n    assert!(matches!(\n        result.err().unwrap(),\n        TableError::TableAlreadyOpen(_, _)\n    ));\n    drop(table);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_hard_link", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_hard_link() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.hard_link(SUB_FILE, SUB_LINK);\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    // We do not double count hard links as the inodes are identical\n    _du_hard_link(result.stdout_str());\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_deps_no_indent", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn newline_escape_deps_no_indent() {\n  Test::new()\n    .justfile(\n      \"\n      default: a\\\\\n      b\\\\\n      c\n      a:\n        echo a\n      b:\n        echo b\n      c:\n        echo c\n    \",\n    )\n    .stdout(\"a\\nb\\nc\\n\")\n    .stderr(\"echo a\\necho b\\necho c\\n\")\n    .run();\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::extended_connect_protocol_enabled_during_handshake", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "test": "async fn extended_connect_protocol_enabled_during_handshake() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::headers(1).response(200)).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(\n            req.extensions().get::<crate::ext::Protocol>(),\n            Some(&crate::ext::Protocol::from_static(\"the-bread-protocol\"))\n        );\n\n        let rsp = Response::new(());\n        stream.send_response(rsp, false).unwrap();\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/readme.rs::readme", "code": "pub(crate) fn assert_success(output: &std::process::Output) {\n  if !output.status.success() {\n    eprintln!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n    eprintln!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n    panic!(\"{}\", output.status);\n  }\n}", "test": "fn readme() {\n  let mut justfiles = vec![];\n  let mut current = None;\n\n  for line in fs::read_to_string(\"README.md\").unwrap().lines() {\n    if let Some(mut justfile) = current {\n      if line == \"```\" {\n        justfiles.push(justfile);\n        current = None;\n      } else {\n        justfile += line;\n        justfile += \"\\n\";\n        current = Some(justfile);\n      }\n    } else if line == \"```just\" {\n      current = Some(String::new());\n    }\n  }\n\n  for justfile in justfiles {\n    let tmp = tempdir();\n\n    let path = tmp.path().join(\"justfile\");\n\n    fs::write(path, justfile).unwrap();\n\n    let output = Command::new(executable_path(\"just\"))\n      .current_dir(tmp.path())\n      .arg(\"--dump\")\n      .output()\n      .unwrap();\n\n    assert_success(&output);\n  }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_destroy_uninitialized_peer_when_there_exists_old_peer", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_destroy_uninitialized_peer_when_there_exists_old_peer() {\n    // 4 stores cluster.\n    let mut cluster = new_node_cluster(0, 4);\n    cluster.cfg.raft_store.pd_store_heartbeat_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.hibernate_regions = false;\n\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // Now region 1 only has peer (1, 1);\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let epoch = pd_client.get_region_epoch(r1);\n\n    // Conf version must change.\n    assert!(epoch.get_conf_ver() > 2);\n\n    // Transfer leader to peer (2, 2).\n    cluster.must_transfer_leader(r1, new_peer(2, 2));\n\n    // Isolate node 1\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n\n    cluster.must_put(format!(\"k{}\", 2).as_bytes(), b\"v1\");\n\n    // Remove 3 and add 4\n    pd_client.must_add_peer(r1, new_learner_peer(4, 4));\n    pd_client.must_add_peer(r1, new_peer(4, 4));\n    pd_client.must_remove_peer(r1, new_peer(3, 3));\n\n    cluster.must_put(format!(\"k{}\", 3).as_bytes(), b\"v1\");\n\n    // Ensure 5 drops all snapshot\n    let (notify_tx, _notify_rx) = mpsc::channel();\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(3, Box::new(DropSnapshotFilter::new(notify_tx)));\n\n    // Add learner 5 on store 3\n    pd_client.must_add_peer(r1, new_learner_peer(3, 5));\n\n    cluster.must_put(format!(\"k{}\", 4).as_bytes(), b\"v1\");\n\n    // Remove and destroy the uninitialized 5\n    let peer_5 = new_learner_peer(3, 5);\n    pd_client.must_remove_peer(r1, peer_5.clone());\n    cluster.must_gc_peer(r1, 3, peer_5);\n\n    let region = block_on(pd_client.get_region_by_id(r1)).unwrap();\n    must_region_cleared(&cluster.get_all_engines(3), &region.unwrap());\n\n    // Unisolate 1 and try wakeup 3\n    cluster.clear_send_filters();\n    cluster.sim.wl().clear_recv_filters(3);\n    cluster.partition(vec![1, 3], vec![2, 4]);\n\n    sleep_until_election_triggered(&cluster.cfg);\n\n    let region = block_on(pd_client.get_region_by_id(r1)).unwrap();\n    must_region_cleared(&cluster.get_all_engines(3), &region.unwrap());\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_delimited_identifiers", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_delimited_identifiers() {\n    // check that quoted identifiers in any position remain quoted after serialization\n    let select = clickhouse().verified_only_select(\n        r#\"SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"\"#,\n    );\n    // check FROM\n    match only(select.from).relation {\n        TableFactor::Table {\n            name,\n            alias,\n            args,\n            with_hints,\n            version,\n            partitions: _,\n        } => {\n            assert_eq!(vec![Ident::with_quote('\"', \"a table\")], name.0);\n            assert_eq!(Ident::with_quote('\"', \"alias\"), alias.unwrap().name);\n            assert!(args.is_none());\n            assert!(with_hints.is_empty());\n            assert!(version.is_none());\n        }\n        _ => panic!(\"Expecting TableFactor::Table\"),\n    }\n    // check SELECT\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::CompoundIdentifier(vec![\n            Ident::with_quote('\"', \"alias\"),\n            Ident::with_quote('\"', \"bar baz\"),\n        ]),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::with_quote('\"', \"myfun\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[1]),\n    );\n    match &select.projection[2] {\n        SelectItem::ExprWithAlias { expr, alias } => {\n            assert_eq!(&Expr::Identifier(Ident::with_quote('\"', \"simple id\")), expr);\n            assert_eq!(&Ident::with_quote('\"', \"column alias\"), alias);\n        }\n        _ => panic!(\"Expected ExprWithAlias\"),\n    }\n\n    clickhouse().verified_stmt(r#\"CREATE TABLE \"foo\" (\"bar\" \"int\")\"#);\n    clickhouse().verified_stmt(r#\"ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)\"#);\n    //TODO verified_stmt(r#\"UPDATE foo SET \"bar\" = 5\"#);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_seq_wrong_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_seq_wrong_arg() {\n    new_ucmd!().args(&[\"-w\", \"5\", \"10\", \"33\", \"32\"]).fails();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_nan_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_loop", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_realpath_loop() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.symlink_file(\"2\", \"1\");\n    at.symlink_file(\"3\", \"2\");\n    at.symlink_file(\"1\", \"3\");\n    ucmd.arg(\"1\")\n        .fails()\n        .stderr_contains(\"Too many levels of symbolic links\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large_cli_limit", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir_req_verbose", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_install_dir_req_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"source_file1\";\n    at.touch(file_1);\n    scene\n        .ucmd()\n        .arg(\"-Dv\")\n        .arg(file_1)\n        .arg(\"sub3/a/b/c/file\")\n        .succeeds()\n        .stdout_contains(\"install: creating directory 'sub3'\\ninstall: creating directory 'sub3/a'\\ninstall: creating directory 'sub3/a/b'\\ninstall: creating directory 'sub3/a/b/c'\\n'source_file1' -> 'sub3/a/b/c/file'\");\n\n    scene\n        .ucmd()\n        .arg(\"-t\")\n        .arg(\"sub4/a\")\n        .arg(\"-Dv\")\n        .arg(file_1)\n        .succeeds()\n        .stdout_contains(\"install: creating directory 'sub4'\\ninstall: creating directory 'sub4/a'\\n'source_file1' -> 'sub4/a/source_file1'\");\n\n    at.mkdir(\"sub5\");\n    scene\n        .ucmd()\n        .arg(\"-Dv\")\n        .arg(file_1)\n        .arg(\"sub5/a/b/c/file\")\n        .succeeds()\n        .stdout_contains(\"install: creating directory 'sub5/a'\\ninstall: creating directory 'sub5/a/b'\\ninstall: creating directory 'sub5/a/b/c'\\n'source_file1' -> 'sub5/a/b/c/file'\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_table_properties.rs::test_check_need_gc", "code": "fn get(&self, _: &[u8]) -> Option<&[u8]> {\n        None\n    }", "test": "fn test_check_need_gc() {\n    GC_COMPACTION_FILTER_PERFORM.reset();\n    GC_COMPACTION_FILTER_SKIP.reset();\n\n    let mut cfg = DbConfig::default();\n    cfg.defaultcf.disable_auto_compactions = true;\n    cfg.defaultcf.dynamic_level_bytes = false;\n    let dir = tempfile::TempDir::new().unwrap();\n    let builder = TestEngineBuilder::new().path(dir.path());\n    let engine = builder\n        .api_version(ApiVersion::V2)\n        .build_with_cfg(&cfg)\n        .unwrap();\n    let raw_engine = engine.get_rocksdb();\n    let mut gc_runner = TestGcRunner::new(0);\n\n    do_write(&engine, false, 5);\n\n    // Check init value\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        0\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        0\n    );\n\n    // TEST 1: If ratio_threshold < 1.0 || context.is_bottommost_level() is true,\n    // check_need_gc return true, call dofilter\n    gc_runner\n        .safe_point(TimeStamp::max().into_inner())\n        .gc_raw(&raw_engine);\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        1\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        0\n    );\n\n    // TEST 2: props.num_versions as f64 > props.num_rows as f64 * ratio_threshold\n    // return true.\n    do_write(&engine, false, 5);\n    engine.get_rocksdb().flush_cfs(&[], true).unwrap();\n\n    do_gc(&raw_engine, 2, &mut gc_runner, &dir);\n\n    do_write(&engine, false, 5);\n    engine.get_rocksdb().flush_cfs(&[], true).unwrap();\n\n    // Set ratio_threshold, let (props.num_versions as f64 > props.num_rows as\n    // f64 * ratio_threshold) return true\n    gc_runner.ratio_threshold = Option::Some(0.0f64);\n\n    // is_bottommost_level = false\n    do_gc(&raw_engine, 1, &mut gc_runner, &dir);\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_PERFORM\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        3\n    );\n    assert_eq!(\n        GC_COMPACTION_FILTER_SKIP\n            .with_label_values(&[STAT_RAW_KEYMODE])\n            .get(),\n        0\n    );\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::reinscribe_with_flag", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn reinscribe_with_flag() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let inscribe = CommandBuilder::new(\"wallet inscribe --file tulip.png --fee-rate 5.0 \")\n    .write(\"tulip.png\", [1; 520])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let txid = rpc_server.mine_blocks(1)[0].txdata[2].txid();\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[]);\n  let request = ord_server.request(format!(\"/content/{}\", inscribe.inscriptions[0].id));\n\n  assert_eq!(request.status(), 200);\n\n  let reinscribe = CommandBuilder::new(format!(\n    \"wallet inscribe --file orchid.png --fee-rate 1.1 --reinscribe --satpoint {txid}:0:0\"\n  ))\n  .write(\"orchid.png\", [1; 520])\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[\"--index-sats\"]);\n  let request = ord_server.request(format!(\"/content/{}\", reinscribe.inscriptions[0].id));\n\n  assert_eq!(request.status(), 200);\n  ord_server.assert_response_regex(\n    format!(\"/sat/{}\", 50 * COIN_VALUE),\n    format!(\n      \".*<dt>inscriptions</dt>.*<a href=/inscription/{}>.*<a href=/inscription/{}>.*\",\n      inscribe.inscriptions[0].id, reinscribe.inscriptions[0].id\n    ),\n  );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/os_attributes.rs::os", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn os() {\n  Test::new()\n    .justfile(\n      \"\n      [macos]\n      foo:\n        echo bar\n\n      [windows]\n      foo:\n        echo baz\n\n      [linux]\n      foo:\n        echo quxx\n    \",\n    )\n    .stdout(if cfg!(target_os = \"macos\") {\n      \"bar\\n\"\n    } else if cfg!(windows) {\n      \"baz\\n\"\n    } else if cfg!(target_os = \"linux\") {\n      \"quxx\\n\"\n    } else {\n      panic!(\"unexpected os family\")\n    })\n    .stderr(if cfg!(target_os = \"macos\") {\n      \"echo bar\\n\"\n    } else if cfg!(windows) {\n      \"echo baz\\n\"\n    } else if cfg!(target_os = \"linux\") {\n      \"echo quxx\\n\"\n    } else {\n      panic!(\"unexpected os family\")\n    })\n    .run();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_8", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_8() {\n    let original = r##\"| abc | def |\n| --- | --- |\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n</table>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::object", "code": "fn say_hello(this: &JsValue, _: &[JsValue], _: &mut Context<'_>) -> JsResult<JsValue> {\n        // We check if this is an object.\n        if let Some(object) = this.as_object() {\n            // If it is we downcast the type to type `Person`.\n            if let Some(person) = object.downcast_ref::<Person>() {\n                // and print a message to stdout.\n                println!(\n                    \"Hello my name is {}, I'm {} years old\",\n                    person.name.to_std_string_escaped(),\n                    person.age // Here we can access the native rust fields of the struct.\n                );\n                return Ok(JsValue::undefined());\n            }\n        }\n        // If `this` was not an object or the type of `this` was not a native object `Person`,\n        // we throw a `TypeError`.\n        Err(JsNativeError::typ()\n            .with_message(\"'this' is not a Person object\")\n            .into())\n    }", "test": "fn object() {\n    test_formatting(\n        r#\"\n        let other = {\n            c: 10,\n        };\n        let inst = {\n            val: 5,\n            b: \"hello world\",\n            nested: {\n                a: 5,\n                b: 6,\n            },\n            ...other,\n            say_hi: function() {\n                console.log(\"hello!\");\n            },\n            get a() {\n                return this.val + 1;\n            },\n            set a(new_value) {\n                this.val = new_value;\n            },\n            say_hello(msg) {\n                console.log(\"hello \" + msg);\n            },\n        };\n        inst.a = 20;\n        inst.a;\n        inst.say_hello(\"humans\");\n        \"#,\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/parser.rs::dont_run_duplicate_recipes", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dont_run_duplicate_recipes() {\n  Test::new()\n    .justfile(\n      \"\n      set dotenv-load # foo\n      bar:\n      \",\n    )\n    .run();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/240_array_pretty.rs::small_array", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn small_array() {\n    let arr = &[(), (), ()][..];\n    assert_eq!(\n        to_string_pretty(&arr, PrettyConfig::new().new_line(\"\\n\".to_string())).unwrap(),\n        \"[\n    (),\n    (),\n    (),\n]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .compact_arrays(true)\n        )\n        .unwrap(),\n        \"[(), (), ()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .compact_arrays(true)\n                .separator(\"\".to_string())\n        )\n        .unwrap(),\n        \"[(),(),()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &vec![(1, 2), (3, 4)],\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .separate_tuple_members(true)\n                .compact_arrays(true)\n        )\n        .unwrap(),\n        \"[(\n    1,\n    2,\n), (\n    3,\n    4,\n)]\"\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::trailing_spaces_after_include_are_ignored", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn trailing_spaces_after_include_are_ignored() {\n  Test::new()\n    .tree(tree! {\n      \"include.justfile\": \"\n        a:\n          @echo A\n      \",\n    })\n    .justfile(\"!include ./include.justfile\\x20\")\n    .arg(\"--unstable\")\n    .test_round_trip(false)\n    .stdout(\"A\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_no_file", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_no_file() {\n    let temp = env::temp_dir();\n    let tmpdir = Path::new(&temp);\n    let file = tmpdir.join(\"}surely'none'would'thus'a'file'name\"); // spell-checker:disable-line\n\n    new_ucmd!().arg(file.as_os_str()).fails();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_unknown", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_unknown() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert_error(PathBuf::from(\"prefix/ci.js\"), ErrorEntry::UnknownFileType);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), (\"prefix\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_unknown\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/symbols.rs::test_var_read_write", "code": "fn test() {\n    use crate::tester::Tester;\n\n    let pass = vec![\n        (\"console.log(\\\"abc\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def\\\");\", None),\n        (\"console.log('abc', \\\"def\\\");\", None),\n        (\"console.log(`abc`, \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\\t\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\\n\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"  abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\" abc\\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\"def \\\");\", None),\n        (\"console.log();\", None),\n        (\"console.log(\\\"\\\");\", None),\n        (\"console.log(123);\", None),\n        (\"console.log(null);\", None),\n        (\"console.log(undefined);\", None),\n        (\"console.dir(\\\"abc \\\");\", None),\n        (\"new console.log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"new console.error(\\\" a \\\", \\\" b \\\");\", None),\n        (\"log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"error(\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[log](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[debug](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[info](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[warn](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[error](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console.foo(\\\" a \\\", \\\" b \\\");\", None),\n        (\"foo.log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"foo.debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"foo.info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"foo.warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"foo.error(\\\" a \\\", \\\" b \\\");\", None),\n        (\"lib.console.log(\\\" a \\\", \\\" b \\\");\", None),\n        (\"lib.console.debug(\\\" a \\\", \\\" b \\\");\", None),\n        (\"lib.console.info(\\\" a \\\", \\\" b \\\");\", None),\n        (\"lib.console.warn(\\\" a \\\", \\\" b \\\");\", None),\n        (\"lib.console.error(\\\" a \\\", \\\" b \\\");\", None),\n    ];\n\n    let fail = vec![\n        (\"console.log(\\\"abc \\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\" def\\\");\", None),\n        (\"console.log(\\\" abc \\\", \\\"def\\\");\", None),\n        (\"console.debug(\\\"abc \\\", \\\"def\\\");\", None),\n        (\"console.debug(`abc `, \\\"def\\\");\", None),\n        (\"console.info(\\\"abc \\\", \\\"def\\\");\", None),\n        (\"console.warn(\\\"abc \\\", \\\"def\\\");\", None),\n        (\"console.error(\\\"abc \\\", \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\" def \\\", \\\"ghi\\\");\", None),\n        (\"console.log(\\\"abc \\\", \\\"def \\\", \\\"ghi\\\");\", None),\n        (\"console.log('abc ', \\\"def\\\");\", None),\n        (\"console.log(`abc `, \\\"def\\\");\", None),\n        (\"console.error('abc ', \\\"def\\\");\", None),\n        (\"console.error(`abc `, \\\"def\\\");\", None),\n        (\"console.log(`abc ${1 + 2} `, \\\"def\\\");\", None),\n        (\"console.log(\\\"abc\\\", \\\" def \\\", \\\"ghi\\\");\", None),\n        (\"console.log(\\\"_\\\", \\\" leading\\\", \\\"_\\\")\", None),\n        (\"console.log(\\\"_\\\", \\\"trailing \\\", \\\"_\\\")\", None),\n        (\"console.log(\\\"_\\\", \\\" leading and trailing \\\", \\\"_\\\")\", None),\n        (\"console.error(\\\"abc\\\", \\\" def \\\", \\\"ghi\\\");\", None),\n        (\"console.error(\\\"_\\\", \\\" leading\\\", \\\"_\\\")\", None),\n        (\"console.error(\\\"_\\\", \\\"trailing \\\", \\\"_\\\")\", None),\n        (\"console.error(\\\"_\\\", \\\" leading and trailing \\\", \\\"_\\\")\", None),\n        (\"console.log(\\\"_\\\", \\\" log \\\", \\\"_\\\")\", None),\n        (\"console.debug(\\\"_\\\", \\\" debug \\\", \\\"_\\\")\", None),\n        (\"console.info(\\\"_\\\", \\\" info \\\", \\\"_\\\")\", None),\n        (\"console.warn(\\\"_\\\", \\\" warn \\\", \\\"_\\\")\", None),\n        (\"console.error(\\\"_\\\", \\\" error \\\", \\\"_\\\")\", None),\n        // Note: This behavior differs to `eslint-plugin-unicorn(no-console-spaces)` as it \"passes\" there.\n        (\"console[\\\"log\\\"](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[\\\"debug\\\"](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[\\\"info\\\"](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[\\\"warn\\\"](\\\" a \\\", \\\" b \\\");\", None),\n        (\"console[\\\"error\\\"](\\\" a \\\", \\\" b \\\");\", None),\n    ];\n\n    let fix = vec![\n        (\"console.log(\\\"foo \\\", bar)\", \"console.log(\\\"foo\\\", bar)\", None),\n        (\"console.debug(\\\"foo \\\", bar)\", \"console.debug(\\\"foo\\\", bar)\", None),\n        (\"console.info(\\\"foo \\\", bar)\", \"console.info(\\\"foo\\\", bar)\", None),\n        (\"console.warn(\\\"foo \\\", bar)\", \"console.warn(\\\"foo\\\", bar)\", None),\n        (\"console.error(\\\"foo \\\", bar)\", \"console.error(\\\"foo\\\", bar)\", None),\n        (\"console.log(foo, \\\" bar\\\")\", \"console.log(foo, \\\"bar\\\")\", None),\n        (\"console.debug(foo, \\\" bar\\\")\", \"console.debug(foo, \\\"bar\\\")\", None),\n        (\"console.info(foo, \\\" bar\\\")\", \"console.info(foo, \\\"bar\\\")\", None),\n        (\"console.warn(foo, \\\" bar\\\")\", \"console.warn(foo, \\\"bar\\\")\", None),\n        (\"console.error(foo, \\\" bar\\\")\", \"console.error(foo, \\\"bar\\\")\", None),\n        (\"console.log(`foo `, bar)\", \"console.log(`foo`, bar)\", None),\n        (\"console.debug(`foo `, bar)\", \"console.debug(`foo`, bar)\", None),\n        (\"console.info(`foo `, bar)\", \"console.info(`foo`, bar)\", None),\n        (\"console.warn(`foo `, bar)\", \"console.warn(`foo`, bar)\", None),\n        (\"console.error(`foo `, bar)\", \"console.error(`foo`, bar)\", None),\n        (\"console.log(foo, ` bar`)\", \"console.log(foo, `bar`)\", None),\n        (\"console.debug(foo, ` bar`)\", \"console.debug(foo, `bar`)\", None),\n        (\"console.info(foo, ` bar`)\", \"console.info(foo, `bar`)\", None),\n        (\"console.warn(foo, ` bar`)\", \"console.warn(foo, `bar`)\", None),\n        (\"console.error(foo, ` bar`)\", \"console.error(foo, `bar`)\", None),\n    ];\n\n    Tester::new(NoConsoleSpaces::NAME, pass, fail).expect_fix(fix).test_and_snapshot();\n}", "test": "fn test_var_read_write() {\n    SemanticTester::js(\"let x; x += 1\")\n        .has_root_symbol(\"x\")\n        .has_number_of_references(1)\n        .has_number_of_reads(1)\n        .has_number_of_writes(1)\n        .test();\n\n    SemanticTester::js(\"let a; let b = 1 + (0, ((a)));\")\n        .has_some_symbol(\"a\")\n        .has_number_of_reads(1)\n        .has_number_of_writes(0)\n        .test();\n\n    SemanticTester::js(\n        \"\n        let x;\n        function foo(a) {\n            console.log(x(a))\n        }\",\n    )\n    .has_some_symbol(\"x\")\n    .has_number_of_reads(1)\n    .has_number_of_writes(0)\n    .test();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_priority", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_priority() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    let state_cnt = Arc::new(AtomicUsize::new(0));\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                r.register(1, BasicMailbox::new(tx, runner, state_cnt.clone()));\n                let (tx2, mut runner2) = Runner::new(10);\n                runner2.set_priority(Priority::Low);\n                r.register(2, BasicMailbox::new(tx2, runner2, state_cnt));\n                tx_.send(1).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n\n    let tx_ = tx.clone();\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |h: &Handler, r: &mut Runner| {\n                assert_eq!(h.get_priority(), Priority::Normal);\n                assert_eq!(h.get_priority(), r.get_priority());\n                tx_.send(2).unwrap();\n            })),\n        )\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(2));\n\n    router\n        .send(\n            2,\n            Message::Callback(Box::new(move |h: &Handler, r: &mut Runner| {\n                assert_eq!(h.get_priority(), Priority::Low);\n                assert_eq!(h.get_priority(), r.get_priority());\n                tx.send(3).unwrap();\n            })),\n        )\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(3));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::checked_math", "code": "pub fn checked_add(self, offset: TextSize) -> Option<TextRange> {\n        Some(TextRange {\n            start: self.start.checked_add(offset)?,\n            end: self.end.checked_add(offset)?,\n        })\n    }", "test": "fn checked_math() {\n    assert_eq!(size(1).checked_add(size(1)), Some(size(2)));\n    assert_eq!(size(1).checked_sub(size(1)), Some(size(0)));\n    assert_eq!(size(1).checked_sub(size(2)), None);\n    assert_eq!(size(!0).checked_add(size(1)), None);\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_map", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_map() {\n    let mut thing = BTreeMap::new();\n    thing.insert(\"x\".to_owned(), 1);\n    thing.insert(\"y\".to_owned(), 2);\n    let yaml = indoc! {\"\n        x: 1\n        y: 2\n    \"};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_negative_zero_scientific_notation", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_negative_zero_scientific_notation() {\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e0\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e0\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n02\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e0\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-0\\n01\\n02\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e+1\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-00\\n001\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e+1\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-00\\n001\\n002\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0e+1\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-00\\n001\\n002\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e0\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0.000\\n01.000\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e0\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-0.000\\n01.000\\n02.000\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e0\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-0.000\\n01.000\\n02.000\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e-2\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-0.00000\\n01.00000\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e-2\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-0.00000\\n01.00000\\n02.00000\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e-2\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-0.00000\\n01.00000\\n02.00000\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n0000002\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n0000002\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\", \"2\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n0000002\\n\")\n        .no_stderr();\n    new_ucmd!()\n        .args(&[\"-w\", \"-0.000e5\", \"1\", \"2.0\"])\n        .succeeds()\n        .stdout_is(\"-000000\\n0000001\\n0000002\\n\")\n        .no_stderr();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::insert_reserve", "code": "fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> &'a [u8]\n    where\n        Self: 'a,\n        Self: 'b,\n    {\n        &value.data\n    }", "test": "fn insert_reserve() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let def: TableDefinition<&str, &[u8]> = TableDefinition::new(\"x\");\n    let value = \"world\";\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(def).unwrap();\n        let mut reserved = table\n            .insert_reserve(\"hello\", value.len().try_into().unwrap())\n            .unwrap();\n        reserved.as_mut().copy_from_slice(value.as_bytes());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(def).unwrap();\n    assert_eq!(\n        value.as_bytes(),\n        table.get(\"hello\").unwrap().unwrap().value()\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_old_value_cache_without_downstreams", "code": "pub fn recv(&mut self, peer_msg_buf: &mut Vec<PeerMsg>, batch_size: usize) -> usize {\n        let l = peer_msg_buf.len();\n        for i in l..batch_size {\n            match self.receiver.try_recv() {\n                Ok(msg) => peer_msg_buf.push(msg),\n                Err(e) => {\n                    if let TryRecvError::Disconnected = e {\n                        self.is_stopped = true;\n                    }\n                    return i - l;\n                }\n            }\n        }\n        batch_size - l\n    }", "test": "fn test_old_value_cache_without_downstreams() {\n    fn check_old_value_cache(scheduler: &Scheduler<Task>, updates: usize) {\n        let (tx, rx) = mpsc::sync_channel(1);\n        let checker = move |c: &OldValueCache| tx.send(c.update_count()).unwrap();\n        scheduler\n            .schedule(Task::Validate(Validate::OldValueCache(Box::new(checker))))\n            .unwrap();\n        assert_eq!(rx.recv().unwrap(), updates);\n    }\n\n    let mutation = || {\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.key = b\"key\".to_vec();\n        mutation.value = b\"value\".to_vec();\n        mutation\n    };\n\n    fail::cfg(\"cdc_flush_old_value_metrics\", \"return\").unwrap();\n\n    let cluster = new_server_cluster(0, 1);\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let scheduler = suite.endpoints[&1].scheduler();\n\n    // Add a subscription and then check old value cache.\n    let (mut req_tx, event_feed, receive_event) = new_event_feed(suite.get_region_cdc_client(1));\n    let req = suite.new_changedata_request(1);\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    receive_event(false); // Wait until the initialization finishes.\n\n    // Old value cache will be updated because there is 1 capture.\n    suite.must_kv_prewrite(1, vec![mutation()], b\"key\".to_vec(), 3.into());\n    suite.must_kv_commit(1, vec![b\"key\".to_vec()], 3.into(), 4.into());\n    check_old_value_cache(&scheduler, 1);\n\n    drop(req_tx);\n    drop(event_feed);\n    drop(receive_event);\n    sleep_ms(200);\n\n    // Old value cache won't be updated because there is no captures.\n    suite.must_kv_prewrite(1, vec![mutation()], b\"key\".to_vec(), 5.into());\n    suite.must_kv_commit(1, vec![b\"key\".to_vec()], 5.into(), 6.into());\n    check_old_value_cache(&scheduler, 1);\n\n    fail::remove(\"cdc_flush_old_value_metrics\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::quote_properties_parse_errors_letter_case", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn quote_properties_parse_errors_letter_case() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--quote-properties\"),\n                (\"As-needed\"),\n                (\"file.js\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"quote_properties_parse_errors_letter_case\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::seek_to_key_then_forward_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn seek_to_key_then_forward_snapshot() {\n    let db = default_engine();\n    seek_to_key_then_forward(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::custom_ordering", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn custom_ordering() {\n    #[derive(Debug)]\n    struct ReverseKey(Vec<u8>);\n\n    impl RedbValue for ReverseKey {\n        type SelfType<'a> = ReverseKey\n        where\n        Self: 'a;\n        type AsBytes<'a> = &'a [u8]\n        where\n        Self: 'a;\n\n        fn fixed_width() -> Option<usize> {\n            None\n        }\n\n        fn from_bytes<'a>(data: &'a [u8]) -> ReverseKey\n        where\n            Self: 'a,\n        {\n            ReverseKey(data.to_vec())\n        }\n\n        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> &'a [u8]\n        where\n            Self: 'a,\n            Self: 'b,\n        {\n            &value.0\n        }\n\n        fn type_name() -> TypeName {\n            TypeName::new(\"test::ReverseKey\")\n        }\n    }\n\n    impl RedbKey for ReverseKey {\n        fn compare(data1: &[u8], data2: &[u8]) -> Ordering {\n            data2.cmp(data1)\n        }\n    }\n\n    let definition: TableDefinition<ReverseKey, &str> = TableDefinition::new(\"x\");\n\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in 0..10u8 {\n            let key = vec![i];\n            table.insert(&ReverseKey(key), \"value\").unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    let start = ReverseKey(vec![7u8]); // ReverseKey is used, so 7 < 3\n    let end = ReverseKey(vec![3u8]);\n    let mut iter = table.range(start..=end).unwrap();\n    for i in (3..=7u8).rev() {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(&[i], key.value().0.as_slice());\n        assert_eq!(\"value\", value.value());\n    }\n    assert!(iter.next().is_none());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::property_accessor_member_expression_bracket_notation_on_string_literal", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn property_accessor_member_expression_bracket_notation_on_string_literal() {\n    run_test_actions([TestAction::assert_eq(\n        \"typeof 'asd'['matchAll']\",\n        \"function\",\n    )]);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_with_options", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_create_table_with_options() {\n    let sql = \"CREATE TABLE t (c INT) WITH (foo = 'bar', a = 123)\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { with_options, .. } => {\n            assert_eq!(\n                vec![\n                    SqlOption {\n                        name: \"foo\".into(),\n                        value: Value::SingleQuotedString(\"bar\".into()),\n                    },\n                    SqlOption {\n                        name: \"a\".into(),\n                        value: number(\"123\"),\n                    },\n                ],\n                with_options\n            );\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_file_and_links_strip_zero", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_realpath_file_and_links_strip_zero() {\n    let strip_args = [\"-s\", \"--strip\", \"--no-symlinks\"];\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    for strip_arg in strip_args {\n        scene\n            .ucmd()\n            .arg(\"foo\")\n            .arg(strip_arg)\n            .arg(\"-z\")\n            .succeeds()\n            .stdout_contains(\"foo\\u{0}\");\n\n        scene\n            .ucmd()\n            .arg(\"bar\")\n            .arg(strip_arg)\n            .arg(\"-z\")\n            .succeeds()\n            .stdout_contains(\"bar\\u{0}\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_worker.rs::test_orphan_versions_from_compaction_filter", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn test_orphan_versions_from_compaction_filter() {\n    let (cluster, leader, ctx) = must_new_and_configure_cluster(|cluster| {\n        cluster.cfg.gc.enable_compaction_filter = true;\n        cluster.cfg.gc.compaction_filter_skip_version_check = true;\n        cluster.pd_client.disable_default_operator();\n    });\n\n    let env = Arc::new(Environment::new(1));\n    let leader_store = leader.get_store_id();\n    let channel = ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader_store));\n    let client = TikvClient::new(channel);\n\n    init_compaction_filter(&cluster, leader_store);\n    let engine = cluster.engines.get(&leader_store).unwrap();\n\n    let pk = b\"k1\".to_vec();\n    let large_value = vec![b'x'; 300];\n    for &start_ts in &[10, 20, 30, 40] {\n        let commit_ts = start_ts + 5;\n        let op = if start_ts < 40 { Op::Put } else { Op::Del };\n        let muts = vec![new_mutation(op, b\"k1\", &large_value)];\n        must_kv_prewrite(&client, ctx.clone(), muts, pk.clone(), start_ts);\n        let keys = vec![pk.clone()];\n        must_kv_commit(&client, ctx.clone(), keys, start_ts, commit_ts, commit_ts);\n        if start_ts < 40 {\n            let key = Key::from_raw(b\"k1\").append_ts(start_ts.into());\n            let key = data_key(key.as_encoded());\n            assert!(engine.kv.get_value(&key).unwrap().is_some());\n        }\n    }\n\n    let fp = \"write_compaction_filter_flush_write_batch\";\n    fail::cfg(fp, \"return\").unwrap();\n\n    let mut gc_runner = TestGcRunner::new(100);\n    gc_runner.gc_scheduler = cluster.sim.rl().get_gc_worker(1).scheduler();\n    gc_runner.gc(&engine.kv);\n\n    'IterKeys: for &start_ts in &[10, 20, 30] {\n        let key = Key::from_raw(b\"k1\").append_ts(start_ts.into());\n        let key = data_key(key.as_encoded());\n        for _ in 0..100 {\n            if engine.kv.get_value(&key).unwrap().is_some() {\n                thread::sleep(Duration::from_millis(20));\n                continue;\n            }\n            continue 'IterKeys;\n        }\n        panic!(\"orphan versions should already been cleaned by GC worker\");\n    }\n\n    fail::remove(fp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_mtime", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_only_mtime() {\n    let mtime_args = [\"-m\", \"--time=modify\", \"--time=mtime\"];\n    let file = \"test_touch_set_only_mtime\";\n\n    for mtime_arg in mtime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", mtime_arg, file])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime != mtime);\n        assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_empty_directory_no_parents", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_empty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n\n    ucmd.arg(DIR).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(DIR));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_deadline_3", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_deadline_3() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = {\n        let engine = tikv::storage::TestEngineBuilder::new().build().unwrap();\n        let cfg = tikv::server::Config {\n            end_point_request_max_handle_duration: tikv_util::config::ReadableDuration::secs(1),\n            ..Default::default()\n        };\n        init_data_with_details(Context::default(), engine, &product, &data, true, &cfg)\n    };\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"kv_cursor_seek\", \"sleep(2000)\").unwrap();\n    fail::cfg(\"copr_batch_initial_size\", \"return(1)\").unwrap();\n    let cop_resp = handle_request(&endpoint, req);\n    let mut resp = SelectResponse::default();\n    resp.merge_from_bytes(cop_resp.get_data()).unwrap();\n\n    assert!(\n        cop_resp.other_error.contains(\"exceeding the deadline\")\n            || resp\n                .get_error()\n                .get_msg()\n                .contains(\"exceeding the deadline\")\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_tab_counts_as_one_byte", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tab_counts_as_one_byte() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-b\"])\n        .pipe_in(\"1\\t2\\n\")\n        .succeeds()\n        .stdout_is(\"1\\t\\n2\\n\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_does_not_organize_imports_via_cli", "code": "pub fn assert_cli_snapshot(payload: SnapshotPayload<'_>) {\n    let module_path = payload.module_path.to_owned();\n    let test_name = payload.test_name;\n    let cli_snapshot = CliSnapshot::from(payload);\n\n    let content = cli_snapshot.emit_content_snapshot();\n\n    let module_path = module_path.replace(\"::\", \"_\");\n    let snapshot_path = PathBuf::from(\"snapshots\").join(module_path);\n\n    insta::with_settings!({\n        prepend_module_to_snapshot => false,\n        snapshot_path => snapshot_path\n    }, {\n        insta::assert_snapshot!(test_name, content);\n\n    });\n}", "test": "fn ci_does_not_organize_imports_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"file.js\");\n\n    let content = r#\"import { lorem, foom, bar } from \"foo\";\nimport * as something from \"../something\";\n\"#;\n    fs.insert(file_path.into(), content.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--organize-imports-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    // assert!(result.is_ok(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut received = String::new();\n    file.read_to_string(&mut received)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(received, content);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_does_not_organize_imports_via_cli\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_stale_read.rs::test_stale_read_on_learner", "code": "fn to_vec(&self) -> Vec<Option<Enum>> {\n        let mut x = Vec::with_capacity(self.len());\n        for i in 0..self.len() {\n            if let Some(value) = self.values.get_option_ref(i) {\n                let name = self.names.get(i).unwrap().to_vec();\n                x.push(Some(Enum::new(name, *value as u64)));\n            } else {\n                x.push(None);\n            }\n        }\n        x\n    }", "test": "fn test_stale_read_on_learner() {\n    let (cluster, pd_client, leader_client) = prepare_for_stale_read(new_peer(1, 1));\n\n    // Write `(key1, value1)`\n    leader_client.must_kv_write(\n        &pd_client,\n        vec![new_mutation(Op::Put, &b\"key1\"[..], &b\"value1\"[..])],\n        b\"key1\".to_vec(),\n    );\n\n    // Replace peer 2 with learner\n    pd_client.must_remove_peer(1, new_peer(2, 2));\n    pd_client.must_add_peer(1, new_learner_peer(2, 4));\n    let mut learner_client2 = PeerClient::new(&cluster, 1, new_learner_peer(2, 4));\n    learner_client2.ctx.set_stale_read(true);\n\n    // We can read on the learner with the newst ts\n    learner_client2.must_kv_read_equal(b\"key1\".to_vec(), b\"value1\".to_vec(), get_tso(&pd_client));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_role", "code": "pub fn assert_eq_vec<T: ToString>(expected: &[&str], actual: &[T]) {\n    assert_eq!(\n        expected,\n        actual.iter().map(ToString::to_string).collect::<Vec<_>>()\n    );\n}", "test": "fn parse_create_role() {\n    let sql = \"CREATE ROLE consultant\";\n    match verified_stmt(sql) {\n        Statement::CreateRole { names, .. } => {\n            assert_eq_vec(&[\"consultant\"], &names);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"CREATE ROLE IF NOT EXISTS mysql_a, mysql_b\";\n    match verified_stmt(sql) {\n        Statement::CreateRole {\n            names,\n            if_not_exists,\n            ..\n        } => {\n            assert_eq_vec(&[\"mysql_a\", \"mysql_b\"], &names);\n            assert!(if_not_exists);\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_width_decimal_scientific_notation_increment", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_width_decimal_scientific_notation_increment() {\n    new_ucmd!()\n        .args(&[\"-w\", \".1\", \"1e-2\", \".11\"])\n        .succeeds()\n        .stdout_is(\"0.10\\n0.11\\n\")\n        .no_stderr();\n\n    new_ucmd!()\n        .args(&[\"-w\", \".0\", \"1.500e-1\", \".2\"])\n        .succeeds()\n        .stdout_is(\"0.0000\\n0.1500\\n\")\n        .no_stderr();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large_cli_limit", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_flattening_sub_item_shielded_print", "code": "pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n                .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n                .unwrap_or_else(|| context!());\n            slf.inner\n                .lock()\n                .unwrap()\n                .env\n                .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n                .map_err(to_py_error)\n        })\n    }", "test": "fn test_flattening_sub_item_shielded_print() {\n    let bad = Bad {\n        a: 42,\n        more: Value::from(BTreeMap::from([(\"b\", 23)])),\n    };\n\n    let ctx = context!(good => context!(bad));\n    let env = Environment::new();\n\n    // this on the other hand is okay\n    let value = env.render_str(\"{{ good }}\", ctx).unwrap();\n    assert_eq!(\n        value,\n        r#\"{\"bad\": <invalid value: can only flatten structs and maps (got an enum)>}\"#\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_directory", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_trailing_slash_directory() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"directory\");\n    for query in [\"./directory\", \"./directory/\"] {\n        scene\n            .ucmd()\n            .args(&[\"-e\", query])\n            .succeeds()\n            .stdout_contains(\"directory\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/cf_names.rs::cf_names", "code": "fn cf_names(&self, _region_id: u64) -> Vec<String> {\n        engine_traits::DATA_CFS\n            .iter()\n            .map(|s| s.to_string())\n            .collect()\n    }", "test": "fn cf_names() {\n    let db = engine_cfs(ALL_CFS);\n    let names = db.engine.cf_names();\n    assert_eq!(names.len(), ALL_CFS.len());\n    for cf in ALL_CFS {\n        assert!(names.contains(cf));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_file_symlink_after_non_existing_file", "code": "pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    }", "test": "fn test_chmod_file_symlink_after_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let existing = \"file\";\n    let test_existing_symlink = \"file_symlink\";\n\n    let non_existing = \"test_chmod_symlink_non_existing_file\";\n    let test_dangling_symlink = \"test_chmod_symlink_non_existing_file_symlink\";\n    let expected_stdout = &format!(\n        \"failed to change mode of '{test_dangling_symlink}' from 0000 (---------) to 1500 (r-x-----T)\"\n    );\n    let expected_stderr = &format!(\"cannot operate on dangling symlink '{test_dangling_symlink}'\");\n\n    at.touch(existing);\n    set_permissions(at.plus(existing), Permissions::from_mode(0o664)).unwrap();\n    at.symlink_file(non_existing, test_dangling_symlink);\n    at.symlink_file(existing, test_existing_symlink);\n\n    // this cannot succeed since the symbolic link dangles\n    // but the metadata for the existing target should change\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"-v\")\n        .arg(test_dangling_symlink)\n        .arg(test_existing_symlink)\n        .fails()\n        .code_is(1)\n        .stdout_contains(expected_stdout)\n        .stderr_contains(expected_stderr);\n    assert_eq!(\n        at.metadata(test_existing_symlink).permissions().mode(),\n        0o100_764\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_quoting", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_quoting() {\n    new_ucmd!()\n        .pipe_in(\"exec 'echo Hello;:'\\n\")\n        .args(&[\"-b\", \"-\"])\n        .succeeds()\n        .stdout_is(\"LS_COLORS='ex='\\\\''echo Hello;\\\\:'\\\\'':';\\nexport LS_COLORS\\n\")\n        .no_stderr();\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/test_default.rs::disallow_non_utf8", "code": "pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    }", "test": "fn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)\u2603\").is_err());\n}\n\n"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_too_few_xs_suffix_directory", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_too_few_xs_suffix_directory() {\n    new_ucmd!()\n        .args(&[\"-d\", \"--suffix=X\", \"aXX\"])\n        .fails()\n        .stderr_only(\"mktemp: too few X's in template 'aXXX'\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::break_out_of_inner_loop", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn break_out_of_inner_loop() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var a = 0, b = 0;\n                for (let i = 0; i < 2; i++) {\n                    a++;\n                    for (let j = 0; j < 10; j++) {\n                        b++;\n                        if (j == 3)\n                            break;\n                    }\n                    a++;\n                }\n            \"#}),\n        TestAction::assert_eq(\"a\", 4),\n        TestAction::assert_eq(\"b\", 8),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(125);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_yes.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_combined_file_set", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_combined_file_set() {\n    let out = new_ucmd!()\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .arg(\"FOO=bar.alt\")\n        .run()\n        .stdout_move_str();\n\n    assert_eq!(out.lines().filter(|&line| line == \"FOO=bar.alt\").count(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_resolve", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_resolve() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    scene.ucmd().arg(\"bar\").succeeds().stdout_contains(\"foo\\n\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u16_pow10_test() {\n    let values: &[u16] = &[\n        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001, 10005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_as_bytes", "code": "pub fn as_bytes(&self) -> Option<&[u8]> {\n        match &self.0 {\n            ValueRepr::String(ref s, _) => Some(s.as_bytes()),\n            ValueRepr::Bytes(ref b) => Some(&b[..]),\n            _ => None,\n        }\n    }", "test": "fn test_value_as_bytes() {\n    assert_eq!(Value::from(\"foo\").as_bytes(), Some(&b\"foo\"[..]));\n    assert_eq!(Value::from(&b\"foo\"[..]).as_bytes(), Some(&b\"foo\"[..]));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_incompatible_version", "code": "fn to_string(&self) -> String {\n        let (mut buf, word_start_idx, int_len, int_cnt, frac_cnt) = self.prepare_buf();\n        if self.negative {\n            buf.push(b'-');\n        }\n        let padding = int_len - cmp::max(int_cnt, 1);\n        buf.resize(padding as usize + buf.len(), b'0');\n        if int_cnt > 0 {\n            let base_idx = buf.len();\n            let mut idx = base_idx + int_cnt as usize;\n            let mut widx = word_start_idx + word_cnt!(int_cnt) as usize;\n            buf.resize(idx, 0);\n            while idx > base_idx {\n                widx -= 1;\n                let mut x = self.word_buf[widx];\n                for _ in 0..cmp::min((idx - base_idx) as u8, DIGITS_PER_WORD) {\n                    idx -= 1;\n                    buf[idx] = b'0' + (x % 10) as u8;\n                    x /= 10;\n                }\n            }\n        } else {\n            buf.push(b'0');\n        };\n        if frac_cnt > 0 {\n            buf.push(b'.');\n            let mut widx = word_start_idx + word_cnt!(int_cnt) as usize;\n            let exp_idx = buf.len() + frac_cnt as usize;\n            while buf.len() < exp_idx {\n                let mut x = self.word_buf[widx];\n                for _ in 0..cmp::min((exp_idx - buf.len()) as u8, DIGITS_PER_WORD) {\n                    buf.push((x / DIG_MASK) as u8 + b'0');\n                    x = (x % DIG_MASK) * 10;\n                }\n                widx += 1;\n            }\n            while buf.capacity() != buf.len() {\n                buf.push(b'0');\n            }\n        }\n        unsafe { String::from_utf8_unchecked(buf) }\n    }", "test": "fn test_incompatible_version() {\n    let incompatible = Arc::new(Incompatible);\n    let server = MockServer::with_case(1, incompatible);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps, None);\n\n    let resp = block_on(client.ask_batch_split(metapb::Region::default(), 2));\n    assert_eq!(\n        resp.unwrap_err().to_string(),\n        PdError::Incompatible.to_string()\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_dynamic", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_dynamic() {\n    let mut env = Environment::new();\n    let template = String::from(\"Hello World 2!\");\n    env.add_template_owned(\"hello2\", template).unwrap();\n    env.set_loader(|name| match name {\n        \"hello\" => Ok(Some(\"Hello World!\".into())),\n        _ => Ok(None),\n    });\n    let t = env.get_template(\"hello\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World!\");\n    let t = env.get_template(\"hello2\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World 2!\");\n    let err = env.get_template(\"missing\").unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"template not found: template \\\"missing\\\" does not exist\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_off", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_off() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=off\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/byte_order_mark.rs::ignore_leading_byte_order_mark", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn ignore_leading_byte_order_mark() {\n  Test::new()\n    .justfile(\n      \"\n      \\u{feff}foo:\n        echo bar\n    \",\n    )\n    .stderr(\"echo bar\\n\")\n    .stdout(\"bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nothing_is_empty", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_nothing_is_empty() {\n    // -z is a literal here and has nonzero length\n    new_ucmd!().arg(\"-z\").succeeds();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_macro_default_arg_value", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_macro_default_arg_value() {\n    assert_err_msg(\n        r#\"\n{% macro input(label=something) %}\n{% endmacro input %}\n    \"#,\n        &[\"2:22\", \"expected an integer, a float, a string, or `true` or `false`\"],\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_2() {\n    let original = r##\"> This is the song that never ends.\\\n> Yes it goes on and on my friends.[^lambchops]\n>\n> [^lambchops]: <https://www.youtube.com/watch?v=0U2zJOryHKQ>\n\"##;\n    let expected = r##\"<blockquote>\n<p>This is the song that never ends.<br />\nYes it goes on and on my friends.<sup class=\"footnote-reference\"><a href=\"#lambchops\">1</a></sup></p>\n<div class=\"footnote-definition\" id=\"lambchops\"><sup class=\"footnote-definition-label\">1</sup>\n<p><a href=\"https://www.youtube.com/watch?v=0U2zJOryHKQ\">https://www.youtube.com/watch?v=0U2zJOryHKQ</a></p>\n</div>\n</blockquote>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_unsupported", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn datagram_unsupported() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: None,\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), None);\n\n    match pair.client_datagrams(client_ch).send(Bytes::new()) {\n        Err(SendDatagramError::UnsupportedByPeer) => {}\n        Err(e) => panic!(\"unexpected error: {e}\"),\n        Ok(_) => panic!(\"unexpected success\"),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_with_dir_as_target", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_mv_interactive_with_dir_as_target() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file = \"test_mv_interactive_file\";\n    let target_dir = \"target\";\n\n    at.mkdir(target_dir);\n    at.touch(file);\n    at.touch(format!(\"{target_dir}/{file}\"));\n\n    ucmd.arg(file)\n        .arg(target_dir)\n        .arg(\"-i\")\n        .pipe_in(\"n\")\n        .fails()\n        .stderr_does_not_contain(\"cannot move\")\n        .no_stdout();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::regtest_has_no_content_size_limit", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn regtest_has_no_content_size_limit() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n    .network(Network::Regtest)\n    .build();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"--chain regtest wallet inscribe --file degenerate.png --fee-rate 1\")\n    .write(\"degenerate.png\", [1; 1025])\n    .rpc_server(&rpc_server)\n    .stdout_regex(\".*\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::insert_all_std_headers", "code": "pub fn as_str(&self) -> &str {\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        { &CODE_DIGITS[offset..offset+3] }\n\n        #[cfg(not(debug_assertions))]\n        unsafe { CODE_DIGITS.get_unchecked(offset..offset+3) }\n    }", "test": "fn insert_all_std_headers() {\n    let mut m = HeaderMap::new();\n\n    for (i, hdr) in STD.iter().enumerate() {\n        m.insert(hdr.clone(), hdr.as_str().parse().unwrap());\n\n        for j in 0..(i + 1) {\n            assert_eq!(m[&STD[j]], STD[j].as_str());\n        }\n\n        if i != 0 {\n            for j in (i + 1)..STD.len() {\n                assert!(\n                    m.get(&STD[j]).is_none(),\n                    \"contained {}; j={}\",\n                    STD[j].as_str(),\n                    j\n                );\n            }\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_simple_backup", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_simple_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_simple_backup\";\n    let link = \"test_symlink_simple_backup_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-b\", \"-s\", file, link]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_specifics_default", "code": "pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    }", "test": "fn check_specifics_default() {\n    let mut engine = get_blocker_engine_default([\n        \"@@||www.google.*/aclk?$first-party\",\n        \"@@||www.googleadservices.*/aclk?$first-party\",\n    ]);\n    {\n        let request = Request::new(\"https://www.youtube.com/youtubei/v1/log_event?alt=json&key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\", \"\", \"\").unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, true);\n    }\n    {\n        let request = Request::new(\n            \"https://www.google.com/aclk?sa=l&ai=DChcSEwioqMfq5ovjAhVvte0KHXBYDKoYABAJGgJkZw&sig=AOD64_0IL5OYOIkZA7qWOBt0yRmKL4hKJw&ctype=5&q=&ved=0ahUKEwjQ88Hq5ovjAhXYiVwKHWAgB5gQww8IXg&adurl=\",\n            \"https://www.google.com/aclk?sa=l&ai=DChcSEwioqMfq5ovjAhVvte0KHXBYDKoYABAJGgJkZw&sig=AOD64_0IL5OYOIkZA7qWOBt0yRmKL4hKJw&ctype=5&q=&ved=0ahUKEwjQ88Hq5ovjAhXYiVwKHWAgB5gQww8IXg&adurl=\",\n            \"main_frame\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, false, \"Matched on {:?}\", checked.filter);\n    }\n    {\n        let request = Request::new(\n            \"https://www.googleadservices.com/pagead/aclk?sa=L&ai=DChcSEwin96uLgYzjAhWH43cKHf0JA7YYABABGgJlZg&ohost=www.google.com&cid=CAASEuRoSkQKbbu2CAjK-zZJnF-wcw&sig=AOD64_1j63JqPtw22vaMasSE4aN1FRKtEw&ctype=5&q=&ved=0ahUKEwivnaWLgYzjAhUERxUIHWzYDTQQ9A4IzgI&adurl=\",\n            \"https://www.googleadservices.com/pagead/aclk?sa=L&ai=DChcSEwin96uLgYzjAhWH43cKHf0JA7YYABABGgJlZg&ohost=www.google.com&cid=CAASEuRoSkQKbbu2CAjK-zZJnF-wcw&sig=AOD64_1j63JqPtw22vaMasSE4aN1FRKtEw&ctype=5&q=&ved=0ahUKEwivnaWLgYzjAhUERxUIHWzYDTQQ9A4IzgI&adurl=\",\n            \"main_frame\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, false, \"Matched on {:?}\", checked.filter);\n    }\n    {\n        let request = Request::new(\n            \"https://www.researchgate.net/profile/Ruofei_Zhang/publication/221653522_Bid_landscape_forecasting_in_online_Ad_exchange_marketplace/links/53f10c1f0cf2711e0c432641.pdf\",\n            \"https://www.researchgate.net/profile/Ruofei_Zhang/publication/221653522_Bid_landscape_forecasting_in_online_Ad_exchange_marketplace/links/53f10c1f0cf2711e0c432641.pdf\",\n            \"main_frame\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, false, \"Matched on {:?}\", checked.filter);\n    }\n    {\n        let request = Request::new(\n            \"https://www.google.com/search?q=Bid+Landscape+Forecasting+in+Online+Exchange+Marketplace&oq=Landscape+Forecasting+in+Online+Ad+Exchange+Marketplace\",\n            \"https://www.google.com/search?q=Bid+Landscape+Forecasting+in+Online+Exchange+Marketplace&oq=Landscape+Forecasting+in+Online+Ad+Exchange+Marketplace\",\n            \"main_frame\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert_eq!(checked.matched, false, \"Matched on {:?}\", checked.filter);\n    }\n    {\n        engine.use_tags(&[\"fb-embeds\", \"twitter-embeds\"]);\n        let request = Request::new(\n            \"https://platform.twitter.com/widgets.js\",\n            \"https://fmarier.github.io/brave-testing/social-widgets.html\",\n            \"script\",\n        ).unwrap();\n        let checked = engine.check_network_request(&request);\n        assert!(checked.exception.is_some(), \"Expected exception to match\");\n        assert!(checked.filter.is_some(), \"Expected rule to match\");\n        assert_eq!(checked.matched, false, \"Matched on {:?}\", checked.exception)\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_atime", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_only_atime() {\n    let atime_args = [\"-a\", \"--time=access\", \"--time=atime\", \"--time=use\"];\n    let file = \"test_touch_set_only_atime\";\n\n    for atime_arg in atime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", atime_arg, file])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime != mtime);\n        assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_seek_region", "code": "pub fn stop(&mut self) {\n        self.handle.stop_observing();\n    }", "test": "fn test_region_collection_seek_region() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n        .sim\n        .wl()\n        .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        // Test traverse all regions\n        let key = b\"\".to_vec();\n        let (tx, rx) = channel();\n        let tx_ = tx.clone();\n        engine\n            .seek_region(\n                &key,\n                Box::new(move |infos| {\n                    tx_.send(infos.map(|i| i.region.clone()).collect()).unwrap();\n                }),\n            )\n            .unwrap();\n        let sought_regions: Vec<_> = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(sought_regions, regions);\n\n        // Test end_key is exclusive\n        let (tx, rx) = channel();\n        let tx_ = tx.clone();\n        engine\n            .seek_region(\n                b\"k1\",\n                Box::new(move |infos| tx_.send(infos.next().unwrap().region.clone()).unwrap()),\n            )\n            .unwrap();\n        let region = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(region, regions[1]);\n\n        // Test seek from non-starting key\n        let tx_ = tx.clone();\n        engine\n            .seek_region(\n                b\"k6\\xff\\xff\\xff\\xff\\xff\",\n                Box::new(move |infos| tx_.send(infos.next().unwrap().region.clone()).unwrap()),\n            )\n            .unwrap();\n        let region = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(region, regions[3]);\n        let tx_ = tx.clone();\n        engine\n            .seek_region(\n                b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",\n                Box::new(move |infos| tx_.send(infos.next().unwrap().region.clone()).unwrap()),\n            )\n            .unwrap();\n        let region = rx.recv_timeout(Duration::from_secs(3)).unwrap();\n        assert_eq!(region, regions[5]);\n    }\n\n    for (_, p) in region_info_providers {\n        p.stop();\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/unstable.rs::set_unstable_false_with_env_var", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn set_unstable_false_with_env_var() {\n  let justfile = r#\"\ndefault:\n    echo 'foo'\n  \"#;\n  for val in [\"0\", \"\", \"false\"] {\n    Test::new()\n    .justfile(justfile)\n    .args([\"--fmt\"])\n    .env(\"JUST_UNSTABLE\", val)\n    .status(EXIT_FAILURE)\n    .stderr(\"error: The `--fmt` command is currently unstable. Invoke `just` with the `--unstable` flag to enable unstable features.\\n\")\n    .run();\n  }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::round_nearest_tie_even_test", "code": "pub(crate) fn round_nearest_tie_even(fp: &mut ExtendedFloat, shift: i32) {\n    let (is_above, is_halfway) = round_nearest(fp, shift);\n    tie_even(fp, is_above, is_halfway);\n}", "test": "fn round_nearest_tie_even_test() {\n    // Check round-up, halfway\n    let mut fp = ExtendedFloat { mant: 0x60, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 2);\n\n    // Check round-down, halfway\n    let mut fp = ExtendedFloat { mant: 0x20, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 0);\n\n    // Check round-up, above halfway\n    let mut fp = ExtendedFloat { mant: 0x61, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 2);\n\n    let mut fp = ExtendedFloat { mant: 0x21, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    // Check round-down, below halfway\n    let mut fp = ExtendedFloat { mant: 0x5F, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 1);\n\n    let mut fp = ExtendedFloat { mant: 0x1F, exp: 0 };\n    round_nearest_tie_even(&mut fp, 6);\n    assert_eq!(fp.mant, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_negative_interval", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_negative_interval() {\n    new_ucmd!()\n        .args(&[\"--\", \"-1\", \"sleep\", \"0\"])\n        .fails()\n        .usage_error(\"invalid time interval '-1'\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_paging_scan", "code": "async fn handle_request(&mut self) -> Result<MemoryTraceGuard<Response>> {\n        let ret = match self.req.get_tp() {\n            AnalyzeType::TypeIndex | AnalyzeType::TypeCommonHandle => {\n                let req = self.req.take_idx_req();\n                let ranges = std::mem::take(&mut self.ranges);\n                table::check_table_ranges::<F>(&ranges)?;\n                let mut scanner = RangesScanner::<_, F>::new(RangesScannerOptions {\n                    storage: self.storage.take().unwrap(),\n                    ranges: ranges\n                        .into_iter()\n                        .map(|r| Range::from_pb_range(r, false))\n                        .collect(),\n                    scan_backward_in_range: false,\n                    is_key_only: true,\n                    is_scanned_range_aware: false,\n                });\n                let res = AnalyzeContext::handle_index(\n                    req,\n                    &mut scanner,\n                    self.req.get_tp() == AnalyzeType::TypeCommonHandle,\n                )\n                .await;\n                scanner.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeColumn => {\n                let col_req = self.req.take_col_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n                let mut builder = SampleBuilder::<_, F>::new(col_req, None, storage, ranges)?;\n                let res = AnalyzeContext::handle_column(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            // Type mixed is analyze common handle and columns by scan table rows once.\n            AnalyzeType::TypeMixed => {\n                let col_req = self.req.take_col_req();\n                let idx_req = self.req.take_idx_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n                let mut builder =\n                    SampleBuilder::<_, F>::new(col_req, Some(idx_req), storage, ranges)?;\n                let res = AnalyzeContext::handle_mixed(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeFullSampling => {\n                let col_req = self.req.take_col_req();\n                let storage = self.storage.take().unwrap();\n                let ranges = std::mem::take(&mut self.ranges);\n\n                let mut builder = RowSampleBuilder::<_, F>::new(\n                    col_req,\n                    storage,\n                    ranges,\n                    self.quota_limiter.clone(),\n                    self.is_auto_analyze,\n                )?;\n\n                let res = AnalyzeContext::handle_full_sampling(&mut builder).await;\n                builder.data.collect_storage_stats(&mut self.storage_stats);\n                res\n            }\n\n            AnalyzeType::TypeSampleIndex => Err(Error::Other(\n                \"Analyze of this kind not implemented\".to_string(),\n            )),\n        };\n        match ret {\n            Ok(data) => {\n                let memory_size = data.capacity();\n                let mut resp = Response::default();\n                resp.set_data(data);\n                Ok(MEMTRACE_ANALYZE.trace_guard(resp, memory_size))\n            }\n            Err(Error::Other(e)) => {\n                let mut resp = Response::default();\n                resp.set_other_error(e);\n                Ok(resp.into())\n            }\n            Err(e) => Err(e),\n        }\n    }", "test": "fn test_paging_scan() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n    // set batch size and grow size to 1, so that only 1 row will be scanned in each\n    // batch.\n    fail::cfg(\"copr_batch_initial_size\", \"return(1)\").unwrap();\n    fail::cfg(\"copr_batch_grow_size\", \"return(1)\").unwrap();\n    for desc in [false, true] {\n        for paging_size in 1..=4 {\n            let mut exp = data.clone();\n            if desc {\n                exp.reverse();\n            }\n\n            let req = DagSelect::from(&product)\n                .paging_size(paging_size as u64)\n                .desc(desc)\n                .build();\n            let resp = handle_request(&endpoint, req);\n            let mut select_resp = SelectResponse::default();\n            select_resp.merge_from_bytes(resp.get_data()).unwrap();\n\n            let mut row_count = 0;\n            let spliter = DagChunkSpliter::new(select_resp.take_chunks().into(), 3);\n            for (row, (id, name, cnt)) in spliter.zip(exp) {\n                let name_datum = name.unwrap().as_bytes().into();\n                let expected_encoded = datum::encode_value(\n                    &mut EvalContext::default(),\n                    &[Datum::I64(id), name_datum, Datum::I64(cnt)],\n                )\n                .unwrap();\n                let result_encoded =\n                    datum::encode_value(&mut EvalContext::default(), &row).unwrap();\n                assert_eq!(result_encoded, &*expected_encoded);\n                row_count += 1;\n            }\n            assert_eq!(row_count, paging_size);\n\n            let res_range = resp.get_range();\n            let (res_start_key, res_end_key) = match desc {\n                true => (res_range.get_end(), res_range.get_start()),\n                false => (res_range.get_start(), res_range.get_end()),\n            };\n            let start_key = match desc {\n                true => product.get_record_range_one(i64::MAX),\n                false => product.get_record_range_one(i64::MIN),\n            };\n            let end_key = match desc {\n                true => product.get_record_range_one(data[data.len() - paging_size].0),\n                false => product.get_record_range_one(data[paging_size - 1].0),\n            };\n            assert_eq!(res_start_key, start_key.get_start());\n            assert_ge!(res_end_key, end_key.get_start());\n            assert_le!(res_end_key, end_key.get_end());\n        }\n\n        // test limit with early return\n        let req = DagSelect::from(&product)\n            .paging_size(2)\n            .limit(1)\n            .desc(desc)\n            .build();\n        let resp = handle_request(&endpoint, req);\n        assert!(resp.range.is_none());\n        assert!(resp.range.is_none());\n\n        let agg_req = DagSelect::from(&product)\n            .count(&product[\"count\"])\n            .group_by(&[&product[\"name\"]])\n            .output_offsets(Some(vec![0, 1]))\n            .desc(desc)\n            .paging_size(2)\n            .build();\n        let resp = handle_request(&endpoint, agg_req);\n        assert!(resp.range.is_some());\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_delete_lock_proposed_before_proposing_locks", "code": "pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    }", "test": "fn test_delete_lock_proposed_before_proposing_locks() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 20.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n        .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let mut req = CleanupRequest::default();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_region_epoch(cluster.get_region_epoch(region_id));\n    ctx.set_peer(leader);\n    req.set_context(ctx);\n    req.set_key(b\"key\".to_vec());\n    req.set_start_version(10);\n    req.set_current_ts(u64::MAX);\n\n    // Pause the command before it actually removes locks.\n    fail::cfg(\"scheduler_async_write_finish\", \"pause\").unwrap();\n    let (tx, resp_rx) = mpsc::channel();\n    thread::spawn(move || tx.send(client.kv_cleanup(&req).unwrap()).unwrap());\n\n    thread::sleep(Duration::from_millis(200));\n    resp_rx.try_recv().unwrap_err();\n\n    cluster.transfer_leader(1, new_peer(2, 2));\n    thread::sleep(Duration::from_millis(200));\n\n    // Transfer leader will not make the command fail.\n    fail::remove(\"scheduler_async_write_finish\");\n    let resp = resp_rx.recv().unwrap();\n    assert!(!resp.has_region_error());\n\n    for _ in 0..10 {\n        thread::sleep(Duration::from_millis(100));\n        cluster.reset_leader_of_region(region_id);\n        if cluster.leader_of_region(region_id).unwrap().id == 2 {\n            let snapshot = cluster.must_get_snapshot_of_region(1);\n            assert!(\n                snapshot\n                    .get_cf(CF_LOCK, &Key::from_raw(b\"key\"))\n                    .unwrap()\n                    .is_none()\n            );\n            return;\n        }\n    }\n    panic!(\"region should succeed to transfer leader to peer 2\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_before_propose_deadline", "code": "pub fn recv(&mut self, peer_msg_buf: &mut Vec<PeerMsg>, batch_size: usize) -> usize {\n        let l = peer_msg_buf.len();\n        for i in l..batch_size {\n            match self.receiver.try_recv() {\n                Ok(msg) => peer_msg_buf.push(msg),\n                Err(e) => {\n                    if let TryRecvError::Disconnected = e {\n                        self.is_stopped = true;\n                    }\n                    return i - l;\n                }\n            }\n        }\n        batch_size - l\n    }", "test": "fn test_before_propose_deadline() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster.sim.read().unwrap().storages[&1].clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n    ctx.max_execution_duration_ms = 200;\n    let (tx, rx) = channel();\n    fail::cfg(\"pause_on_peer_collect_message\", \"sleep(500)\").unwrap();\n    storage\n        .sched_txn_command(\n            commands::Rollback::new(vec![Key::from_raw(b\"k\")], 10.into(), ctx),\n            Box::new(move |res: storage::Result<_>| {\n                tx.send(res).unwrap();\n            }),\n        )\n        .unwrap();\n    let res = rx.recv().unwrap();\n    assert!(\n        matches!(\n            res,\n            Err(StorageError(box StorageErrorInner::Kv(KvError(\n                box KvErrorInner::Request(_),\n            ))))\n        ),\n        \"actual: {:?}\",\n        res\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::single_downwards", "code": "fn search_test<P: AsRef<Path>>(path: P, args: &[&str]) {\n  let binary = executable_path(\"just\");\n\n  let output = Command::new(binary)\n    .current_dir(path)\n    .args(args)\n    .output()\n    .expect(\"just invocation failed\");\n\n  assert_eq!(output.status.code().unwrap(), 0);\n\n  let stdout = str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(stdout, \"ok\\n\");\n\n  let stderr = str::from_utf8(&output.stderr).unwrap();\n  assert_eq!(stderr, \"echo ok\\n\");\n}", "test": "fn single_downwards() {\n  let tmp = temptree! {\n    justfile: \"default:\\n\\techo ok\",\n    child: {},\n  };\n\n  let path = tmp.path();\n\n  search_test(path, &[\"child/\"]);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/key_log_file_env.rs::exercise_key_log_file_for_server", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn exercise_key_log_file_for_server() {\n    serialized(|| {\n        let mut server_config = make_server_config(KeyType::Rsa);\n\n        env::set_var(\"SSLKEYLOGFILE\", \"./sslkeylogfile.txt\");\n        server_config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n            do_handshake(&mut client, &mut server);\n            transfer(&mut client, &mut server);\n            server.process_new_packets().unwrap();\n        }\n    })\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression20", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn regression20() {\n    let tmpfile = create_tempfile();\n\n    let table_def: MultimapTableDefinition<'static, u128, u128> =\n        MultimapTableDefinition::new(\"some-table\");\n\n    for _ in 0..3 {\n        let mut db = Database::builder().create(tmpfile.path()).unwrap();\n        db.check_integrity().unwrap();\n\n        let txn = db.begin_write().unwrap();\n        let mut table = txn.open_multimap_table(table_def).unwrap();\n\n        for i in 0..1024 {\n            table.insert(0, i).unwrap();\n        }\n        drop(table);\n\n        txn.commit().unwrap();\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_no_options", "code": "pub fn stdout_is_fixture<T: AsRef<OsStr>>(&self, file_rel_path: T) -> &Self {\n        let contents = read_scenario_fixture(&self.tmpd, file_rel_path);\n        self.stdout_is(String::from_utf8(contents).unwrap())\n    }", "test": "fn test_no_options() {\n    // spell-checker:disable-next-line\n    for fixture in [\"empty.txt\", \"alpha.txt\", \"nonewline.txt\"] {\n        // Give fixture through command line file argument\n        new_ucmd!()\n            .args(&[fixture])\n            .succeeds()\n            .stdout_is_fixture(fixture);\n        // Give fixture through stdin\n        new_ucmd!()\n            .pipe_in_fixture(fixture)\n            .succeeds()\n            .stdout_is_fixture(fixture);\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::pow_test", "code": "pub fn vec_from_u32<const SIZE: usize>(x: &[u32]) -> StackVec<SIZE> {\n    let mut vec = StackVec::<SIZE>::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as Limb;\n                    let xi1 = xi[1] as Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn pow_test() {\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 2);\n    let expected = VecType::from_u32(25);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 15);\n    let expected: VecType = vec_from_u32(&[452807053, 7]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 16);\n    let expected: VecType = vec_from_u32(&[2264035265, 35]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 17);\n    let expected: VecType = vec_from_u32(&[2730241733, 177]);\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u32(1);\n    bigint::pow(&mut x, 5, 302);\n    let expected: VecType = vec_from_u32(&[\n        2443090281, 2149694430, 2297493928, 1584384001, 1279504719, 1930002239, 3312868939,\n        3735173465, 3523274756, 2025818732, 1641675015, 2431239749, 4292780461, 3719612855,\n        4174476133, 3296847770, 2677357556, 638848153, 2198928114, 3285049351, 2159526706,\n        626302612,\n    ]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_small_file", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_small_file() {\n    new_ucmd!()\n        .args(&[\"-n -10\"])\n        .pipe_in(\"a\\nb\\nc\\nd\\ne\\n\")\n        .succeeds()\n        .stdout_is(\"a\\nb\\nc\\nd\\ne\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_resize_async_ios_failed_2", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_resize_async_ios_failed_2() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.cfg.raft_store.store_io_pool_size = 0;\n    cluster.pd_client.disable_default_operator();\n    let _ = cluster.run_conf_change();\n\n    // Save current async-io tids before shrinking\n    let org_writers_tids = get_async_writers_tids();\n    assert_eq!(0, org_writers_tids.len());\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    // Update config, expand from sync-mode(async-ios == 0) to\n    // async-mode(async-ios == 2).\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store-io-pool-size\".to_owned(), \"2\".to_owned());\n            change\n        };\n\n        assert!(cfg_controller.update(change).is_err());\n        assert_eq!(\n            cfg_controller.get_current().raft_store.store_io_pool_size,\n            0\n        );\n    }\n    // Save current async-io tids after scaling up, and compared with the\n    // orginial one before scaling up, the thread num should be added up to TWO.\n    let cur_writers_tids = get_async_writers_tids();\n    assert_eq!(cur_writers_tids.len(), org_writers_tids.len());\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_suffix", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mktemp_suffix() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE6)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE7)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"--suffix\")\n        .arg(\"suf\")\n        .arg(TEST_TEMPLATE8)\n        .fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_processing_multiple_operands", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_tee_processing_multiple_operands() {\n    // POSIX says: \"Processing of at least 13 file operands shall be supported.\"\n\n    let content = \"tee_sample_content\";\n    for n in [1, 2, 12, 13] {\n        let files = (1..=n).map(|x| x.to_string()).collect::<Vec<_>>();\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&files)\n            .pipe_in(content)\n            .succeeds()\n            .stdout_is(content);\n\n        for file in &files {\n            assert!(at.file_exists(file));\n            assert_eq!(at.read(file), content);\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cut.rs::test_zero_terminated_only_delimited", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_zero_terminated_only_delimited() {\n    new_ucmd!()\n        .args(&[\"-d_\", \"-z\", \"-s\", \"-f\", \"1\"])\n        .pipe_in(\"91\\n\\082\\n7_3\")\n        .succeeds()\n        .stdout_only(\"82\\n7\\0\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_type_check_works", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "test": "fn dynamic_type_check_works() {\n    let mut store = test_setup();\n    let identity = Func::wrap(&mut store, |value: i32| value);\n    let mut result = Value::I32(0);\n    // Case: Too few inputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[], core::slice::from_mut(&mut result)),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too many inputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0), Value::I32(1)],\n            core::slice::from_mut(&mut result)\n        ),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too few outputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[Value::I32(0)], &mut [],),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Too many outputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0)],\n            &mut [Value::I32(0), Value::I32(1)],\n        ),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Mismatching type given as input to function.\n    for input in &[\n        Value::I64(0),\n        Value::F32(0.0.into()),\n        Value::F64(0.0.into()),\n    ] {\n        assert_matches!(\n            identity.call(\n                &mut store,\n                core::slice::from_ref(input),\n                core::slice::from_mut(&mut result)\n            ),\n            Err(Error::Func(FuncError::MismatchingParameterType))\n        );\n    }\n    // Case: Allow for incorrect result type.\n    //\n    // The result type will be overwritten anyways.\n    assert_matches!(\n        identity.call(&mut store, &[Value::I32(0)], &mut [Value::I64(0)]),\n        Ok(_)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_no_operand", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_rm_force_no_operand() {\n    let mut ucmd = new_ucmd!();\n\n    ucmd.arg(\"-f\").succeeds().no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_error", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_mv_interactive_error() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_errors_dir\";\n    let file_a = \"test_mv_errors_file_a\";\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    // $ at.mkdir dir && at.touch file\n    // $ mv -i dir file\n    // err == mv: cannot overwrite non-directory 'file' with directory 'dir'\n    assert!(!scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(dir)\n        .arg(file_a)\n        .pipe_in(\"y\")\n        .fails()\n        .stderr_str()\n        .is_empty());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_return_downcast", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn test_trap_return_downcast() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    #[derive(Debug)]\n    struct MyTrap;\n    impl std::fmt::Display for MyTrap {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"my trap\")\n        }\n    }\n    impl std::error::Error for MyTrap {}\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::from(MyTrap))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func\n        .call(&mut store, ())\n        .err()\n        .expect(\"error calling function\");\n    let dbg = format!(\"{:?}\", e);\n    println!(\"{}\", dbg);\n\n    assert!(!e.to_string().contains(\"my trap\"));\n    assert!(dbg.contains(\"Caused by:\\n    my trap\"));\n\n    e.downcast_ref::<MyTrap>()\n        .expect(\"error downcasts to MyTrap\");\n    let bt = e\n        .downcast_ref::<WasmBacktrace>()\n        .expect(\"error downcasts to WasmBacktrace\");\n    assert_eq!(bt.frames().len(), 1);\n    println!(\"{:?}\", bt);\n\n    Ok(())\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/multiline.rs::read_lines_test", "code": "pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n  many0(read_line)(input)\n}", "test": "fn read_lines_test() {\n  let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n  assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n  assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/raftstore-v2/tests/integrations/test_merge.rs::test_merge", "code": "pub fn get_tablet_index(&self) -> u64 {\n        self.tablet_index\n    }", "test": "fn test_merge() {\n    let mut cluster = Cluster::default();\n    let store_id = cluster.node(0).id();\n    let raft_engine = cluster.node(0).running_state().unwrap().raft_engine.clone();\n    let router = &mut cluster.routers[0];\n\n    let do_split =\n        |r: &mut TestRouter, region: Region, peer: &Peer, v: u64| -> (Region, Region, Peer) {\n            let rid = region.get_id();\n            let old_region_state = raft_engine\n                .get_region_state(rid, u64::MAX)\n                .unwrap()\n                .unwrap();\n            let new_peer = new_peer(store_id, peer.get_id() + 1);\n            let (lhs, rhs) = split_region(\n                r,\n                region,\n                peer.clone(),\n                rid + 1,\n                new_peer.clone(),\n                Some(format!(\"k{}{}\", rid, v).as_bytes()),\n                Some(format!(\"k{}{}\", rid + 1, v).as_bytes()),\n                format!(\"k{}\", rid + 1).as_bytes(),\n                format!(\"k{}\", rid + 1).as_bytes(),\n                false,\n            );\n            let region_state = raft_engine\n                .get_region_state(rid, u64::MAX)\n                .unwrap()\n                .unwrap();\n            assert!(region_state.get_tablet_index() > old_region_state.get_tablet_index());\n            assert_eq!(\n                region_state.get_region().get_region_epoch().get_version(),\n                old_region_state\n                    .get_region()\n                    .get_region_epoch()\n                    .get_version()\n                    + 1,\n            );\n            let region_state = raft_engine\n                .get_region_state(rid + 1, u64::MAX)\n                .unwrap()\n                .unwrap();\n            assert_eq!(region_state.get_tablet_index(), RAFT_INIT_LOG_INDEX);\n            (lhs, rhs, new_peer)\n        };\n\n    let region_1 = router.region_detail(2);\n    let peer_1 = region_1.get_peers()[0].clone();\n    router.wait_applied_to_current_term(2, Duration::from_secs(3));\n\n    // Split into 6.\n    let (region_1, region_2, peer_2) = do_split(router, region_1, &peer_1, 1);\n    let (region_2, region_3, peer_3) = do_split(router, region_2, &peer_2, 2);\n    let (region_3, region_4, peer_4) = do_split(router, region_3, &peer_3, 3);\n    let (region_4, region_5, peer_5) = do_split(router, region_4, &peer_4, 4);\n    let (region_5, region_6, peer_6) = do_split(router, region_5, &peer_5, 5);\n    drop(raft_engine);\n    // The last region version is smaller.\n    for (i, v) in [1, 2, 3, 4, 5, 5].iter().enumerate() {\n        let rid = region_1.get_id() + i as u64;\n        let snapshot = router.stale_snapshot(rid);\n        let key = format!(\"k{rid}{v}\");\n        assert!(\n            snapshot.get_value(key.as_bytes()).unwrap().is_some(),\n            \"{} {:?}\",\n            rid,\n            key\n        );\n    }\n\n    let region_2 = merge_region(&cluster, 0, region_1.clone(), peer_1, region_2, true);\n    {\n        let snapshot = cluster.routers[0].stale_snapshot(region_2.get_id());\n        let key = format!(\"k{}1\", region_1.get_id());\n        assert!(snapshot.get_value(key.as_bytes()).unwrap().is_some());\n    }\n    let region_5 = merge_region(&cluster, 0, region_6.clone(), peer_6, region_5, true);\n    {\n        let snapshot = cluster.routers[0].stale_snapshot(region_5.get_id());\n        let key = format!(\"k{}5\", region_6.get_id());\n        assert!(snapshot.get_value(key.as_bytes()).unwrap().is_some());\n    }\n    let region_3 = merge_region(&cluster, 0, region_2, peer_2, region_3, true);\n    let region_4 = merge_region(&cluster, 0, region_3, peer_3, region_4, true);\n    let region_5 = merge_region(&cluster, 0, region_4, peer_4, region_5, true);\n\n    cluster.restart(0);\n    let snapshot = cluster.routers[0].stale_snapshot(region_5.get_id());\n    for (i, v) in [1, 2, 3, 4, 5, 5].iter().enumerate() {\n        let rid = region_1.get_id() + i as u64;\n        let key = format!(\"k{rid}{v}\");\n        assert!(\n            snapshot.get_value(key.as_bytes()).unwrap().is_some(),\n            \"{} {:?}\",\n            rid,\n            key\n        );\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression11", "code": "fn commit(self) {\n        self.file.sync_all().unwrap();\n        self.inner.commit().unwrap();\n    }", "test": "fn regression11() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 1204];\n        t.insert(&118749, v.as_slice()).unwrap();\n        let v = vec![0u8; 2062];\n        t.insert(&153697, v.as_slice()).unwrap();\n        let v = vec![0u8; 2980];\n        t.insert(&110557, v.as_slice()).unwrap();\n        let v = vec![0u8; 1999];\n        t.insert(&677853, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 691];\n        t.insert(&103591, v.as_slice()).unwrap();\n        let v = vec![0u8; 952];\n        t.insert(&118757, v.as_slice()).unwrap();\n    }\n    tx.abort().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    tx.commit().unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_server_split_epoch_not_match_left_derive", "code": "fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n        .iter()\n        .map(|&k| pd_client.get_region(k).unwrap())\n        .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec![\n        // All regions should be returned as request uses an oldest epoch.\n        (get_old, regions.clone()),\n        // Only new split regions should be returned.\n        (get_middle, regions[1..].to_vec()),\n        // Epoch is too new that TiKV can't offer any useful hint.\n        (get_new, vec![regions[3].clone()]),\n    ];\n    if right_derive {\n        // TiKV search backward when right derive.\n        cases[0].1.reverse();\n        cases[1].1.reverse();\n    }\n    for (get, exp) in cases {\n        let resp = cluster\n            .call_command_on_leader(get.clone(), Duration::from_secs(5))\n            .unwrap();\n        assert!(resp.get_header().has_error(), \"{:?}\", get);\n        assert!(\n            resp.get_header().get_error().has_epoch_not_match(),\n            \"{:?}\",\n            get\n        );\n        assert_eq!(\n            resp.get_header()\n                .get_error()\n                .get_epoch_not_match()\n                .get_current_regions(),\n            &*exp,\n            \"{:?}\",\n            get\n        );\n    }\n}", "test": "fn test_server_split_epoch_not_match_left_derive() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_split_epoch_not_match(&mut cluster, false);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_scalar_subqueries", "code": "pub fn verified_expr(&self, sql: &str) -> Expr {\n        self.expr_parses_to(sql, sql)\n    }", "test": "fn parse_scalar_subqueries() {\n    let sql = \"(SELECT 1) + (SELECT 2)\";\n    assert_matches!(\n        verified_expr(sql),\n        Expr::BinaryOp {\n            op: BinaryOperator::Plus,\n            ..\n        }\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::mismatched_arguments", "code": "pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    }", "test": "fn mismatched_arguments() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (func (export \"foo\") (param i32))\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_func(&mut store, \"foo\").unwrap();\n    assert_eq!(\n        func.call(&mut store, &[], &mut []).unwrap_err().to_string(),\n        \"expected 1 arguments, got 0\"\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::F32(0)], &mut [])\n            .unwrap_err()\n            .to_string(),\n        \"argument type mismatch: found f32 but expected i32\",\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::I32(0), Val::I32(1)], &mut [])\n            .unwrap_err()\n            .to_string(),\n        \"expected 1 arguments, got 2\"\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_negative_offset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_too_small_line_num_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/-5\", \"10\", \"/40/\"])\n        .succeeds()\n        .stdout_only(\"33\\n0\\n75\\n33\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 15));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), generate(15, 40));\n    assert_eq!(at.read(\"xx03\"), generate(40, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_chroot", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_chroot() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let dir = \"CHROOT_DIR\";\n    at.mkdir(dir);\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"whoami\"]) {\n        result.success().no_stderr().stdout_is(\"root\");\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"pwd\"]) {\n        result.success().no_stderr().stdout_is(\"/\");\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/snap.rs::test_update_server_config", "code": "pub fn get_speed_limit(&self) -> f64 {\n        self.core.limiter.speed_limit()\n    }", "test": "fn test_update_server_config() {\n    let (mut config, _dir) = TikvConfig::with_tmp().unwrap();\n    config.validate().unwrap();\n    let (cfg_controller, snap_worker, snap_mgr) = start_server(config.clone(), &_dir);\n    let mut svr_cfg = config.server.clone();\n    // dispatch updated config\n    let change = {\n        let mut m = std::collections::HashMap::new();\n        m.insert(\n            \"server.snap-io-max-bytes-per-sec\".to_owned(),\n            \"512MB\".to_owned(),\n        );\n        m.insert(\n            \"server.concurrent-send-snap-limit\".to_owned(),\n            \"100\".to_owned(),\n        );\n        m\n    };\n    cfg_controller.update(change).unwrap();\n\n    svr_cfg.snap_io_max_bytes_per_sec = ReadableSize::mb(512);\n    svr_cfg.concurrent_send_snap_limit = 100;\n    // config should be updated\n    assert_eq!(snap_mgr.get_speed_limit() as u64, 536870912);\n    validate(&snap_worker.scheduler(), move |cfg: &ServerConfig| {\n        assert_eq!(cfg, &svr_cfg);\n    });\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_untagged_b_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_untagged_b_ser() {\n    let v = EnumStructUntagged::VariantB { foo: 1, bar: 2 };\n    let e = \"(foo:1,bar:2)\";\n    test_ser(&v, e);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtf_spec_test", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "test": "fn sqrtf_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtf(-1.0).is_nan());\n    assert!(libm::sqrtf(f32::NAN).is_nan());\n    for f in [0.0, -0.0, f32::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtf(f), f);\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/equals.rs::export_recipe", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn export_recipe() {\n  Test::new()\n    .justfile(\n      \"\n      export foo='bar':\n        echo {{foo}}\n    \",\n    )\n    .stdout(\"bar\\n\")\n    .stderr(\"echo bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_remove_symlink_dangling", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_rmdir_remove_symlink_dangling() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.symlink_dir(\"dir\", \"dl\");\n\n    ucmd.arg(\"dl/\")\n        .fails()\n        .stderr_is(\"rmdir: failed to remove 'dl/': Symbolic link not followed\\n\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_elif", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_elif() {\n    assert_err_msg(\n        r#\"\n{% if true %}\n{% else %}\n{% elif false %}\n{% endif %}\n    \"#,\n        &[\"4:1\", \"unexpected tag; expected an endif tag (`{% endif %}`) or some content\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_r", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_semicolon_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator=;\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;4;\");\n    assert_eq!(file_read(&at, \"xab\"), \"2;5;\");\n    assert_eq!(file_read(&at, \"xac\"), \"3;\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_and_tabs_shortcut_mixed", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_and_tabs_shortcut_mixed() {\n    new_ucmd!()\n        .args(&[\"-2\", \"--tabs=5\", \"-7\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"  a  b c\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::data_size", "code": "fn data_size(&self) -> usize {\n        panic!()\n    }", "test": "fn data_size() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let size1 = wb.data_size();\n    wb.put(b\"a\", b\"\").unwrap();\n    let size2 = wb.data_size();\n    assert!(size1 < size2);\n    wb.write().unwrap();\n    let size3 = wb.data_size();\n    assert_eq!(size2, size3);\n    wb.clear();\n    let size4 = wb.data_size();\n    assert_eq!(size4, size1);\n    wb.put(b\"a\", b\"\").unwrap();\n    let size5 = wb.data_size();\n    assert!(size4 < size5);\n    wb.delete(b\"a\").unwrap();\n    let size6 = wb.data_size();\n    assert!(size5 < size6);\n    wb.delete_range(b\"a\", b\"b\").unwrap();\n    let size7 = wb.data_size();\n    assert!(size6 < size7);\n    wb.clear();\n    let size8 = wb.data_size();\n    assert_eq!(size8, size1);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    let size1 = wb.data_size();\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    let size2 = wb.data_size();\n    assert!(size1 < size2);\n    wb.write().unwrap();\n    let size3 = wb.data_size();\n    assert_eq!(size2, size3);\n    wb.clear();\n    let size4 = wb.data_size();\n    assert_eq!(size4, size1);\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    let size5 = wb.data_size();\n    assert!(size4 < size5);\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.delete(&x).unwrap();\n    }\n    let size6 = wb.data_size();\n    assert!(size5 < size6);\n    wb.delete_range(&0_usize.to_be_bytes(), &(max_keys * 2).to_be_bytes())\n        .unwrap();\n    let size7 = wb.data_size();\n    assert!(size6 < size7);\n    wb.clear();\n    let size8 = wb.data_size();\n    assert_eq!(size8, size1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix_hyphen_value", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_custom_suffix_hyphen_value() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_all_repeated_followed_by_filename", "code": "pub fn write_all(self, settings: &GlobalSettings, output: Output) -> UResult<()> {\n        let mut out = output.into_write();\n        self.write_all_to(settings, &mut out)\n    }", "test": "fn test_all_repeated_followed_by_filename() {\n    let filename = \"test.txt\";\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let mut file = at.make_file(filename);\n    file.write_all(b\"a\\na\\n\").unwrap();\n\n    ucmd.args(&[\"--all-repeated\", filename])\n        .run()\n        .success()\n        .stdout_is(\"a\\na\\n\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::mantissa_exponent_test", "code": "pub(crate) fn mantissa_exponent(exponent: i32, fraction_digits: usize, truncated: usize) -> i32 {\n    if fraction_digits > truncated {\n        exponent.saturating_sub(into_i32(fraction_digits - truncated))\n    } else {\n        exponent.saturating_add(into_i32(truncated - fraction_digits))\n    }\n}", "test": "fn mantissa_exponent_test() {\n    assert_eq!(mantissa_exponent(10, 5, 0), 5);\n    assert_eq!(mantissa_exponent(0, 5, 0), -5);\n    assert_eq!(\n        mantissa_exponent(i32::max_value(), 5, 0),\n        i32::max_value() - 5\n    );\n    assert_eq!(mantissa_exponent(i32::max_value(), 0, 5), i32::max_value());\n    assert_eq!(mantissa_exponent(i32::min_value(), 5, 0), i32::min_value());\n    assert_eq!(\n        mantissa_exponent(i32::min_value(), 0, 5),\n        i32::min_value() + 5\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_macro_call", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_macro_call() {\n    assert_err_msg(\"{{ my::macro( }}\", &[\"1:15\", \"expected an identifier (must start with a-z)\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_split_region_keep_records", "code": "pub fn is_empty(&self) -> bool {\n        self.key.is_empty() && self.iv.is_empty()\n    }", "test": "fn test_split_region_keep_records() {\n    let mut cluster = test_raftstore_v2::new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    let leader = cluster.leader_of_region(r1).unwrap();\n    cluster.add_send_filter_on_node(\n        leader.get_store_id(),\n        Box::new(DropMessageFilter::new(Arc::new(|m: &RaftMessage| {\n            // Drop all gc peer requests and responses.\n            !(m.has_extra_msg()\n                && (m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerRequest\n                    || m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerResponse))\n        }))),\n    );\n\n    // Make sure split has applied.\n    let region = pd_client.get_region(b\"\").unwrap();\n    cluster.must_split(&region, b\"k1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region_state = cluster.region_local_state(r1, leader.get_store_id());\n    assert!(\n        !region_state.get_removed_records().is_empty(),\n        \"{:?}\",\n        region_state\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_page_range", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_page_range() {\n    let test_file_path = \"test.log\";\n    let expected_test_file_path = \"test_page_range_1.log.expected\";\n    let expected_test_file_path1 = \"test_page_range_2.log.expected\";\n    for arg in [\"--pages=15\", \"+15\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[arg, test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n    for arg in [\"--pages=15:17\", \"+15:17\"] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[arg, test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(\n                expected_test_file_path1,\n                &[(\"{last_modified_time}\", &value)],\n            );\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_gc2_with_less_keys", "code": "fn test_txn_store_gc_multiple_keys(key_prefix_len: usize, n: usize) {\n    let prefix = String::from_utf8(vec![b'k'; key_prefix_len]).unwrap();\n    test_txn_store_gc_multiple_keys_cluster_storage(n, prefix.clone());\n    test_txn_store_gc_multiple_keys_single_storage(n, prefix);\n}", "test": "fn test_txn_store_gc2_with_less_keys() {\n    test_txn_store_gc_multiple_keys(1, 3);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_pull_non_witness_availability", "code": "fn test_non_witness_availability(fp: &str) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.check_peers_availability_interval = ReadableDuration::millis(20);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // non-witness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    std::thread::sleep(Duration::from_millis(100));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n\n    fail::cfg(fp, \"return\").unwrap();\n\n    // witness -> non-witness\n    cluster\n        .pd_client\n        .switch_witnesses(region.get_id(), vec![peer_on_store3.get_id()], vec![false]);\n    std::thread::sleep(Duration::from_millis(500));\n    // snapshot applied\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    assert_eq!(cluster.pd_client.get_pending_peers().len(), 0);\n    fail::remove(fp);\n}", "test": "fn test_pull_non_witness_availability() {\n    test_non_witness_availability(\"ignore notify leader the peer is available\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::fallback_from_subdir_message", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn fallback_from_subdir_message() {\n  Test::new()\n    .justfile(\"bar:\\n echo bar\")\n    .write(\n      \"sub/justfile\",\n      unindent(\n        \"\n        set fallback\n\n        @foo:\n          echo foo\n      \",\n      ),\n    )\n    .args([\"sub/bar\"])\n    .stderr(path(\"echo bar\\n\"))\n    .stdout(\"bar\\n\")\n    .run();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::dtor_runs", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn dtor_runs() {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let mut store = Store::<()>::default();\n    let a = A;\n    assert_eq!(HITS.load(SeqCst), 0);\n    Func::wrap(&mut store, move || {\n        let _ = &a;\n    });\n    drop(store);\n    assert_eq!(HITS.load(SeqCst), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_suffix", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"-b\")\n        .arg(\"--suffix\")\n        .arg(\".bak\")\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.bak\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::dot_justfile_conflicts_with_justfile", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dot_justfile_conflicts_with_justfile() {\n  Test::new()\n    .justfile(\n      \"\n        foo:\n    \",\n    )\n    .tree(tree! {\n      \".justfile\": \"\n        foo:\n      \",\n    })\n    .stderr_regex(\"error: Multiple candidate justfiles found in `.*`: `.justfile` and `justfile`\\n\")\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_suffixes_exhausted", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_suffixes_exhausted() {\n    new_ucmd!()\n        .args(&[\"-b\", \"1\", \"-a\", \"1\", \"asciilowercase.txt\"])\n        .fails()\n        .stderr_only(\"split: output file suffixes exhausted\\n\");\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_wildcard", "code": "pub(super) fn req(text: &str) -> VersionReq {\n    VersionReq(crate::util::req(text))\n}", "test": "pub fn test_wildcard() {\n    let err = req_err(\"\");\n    assert_to_string(\n        err,\n        \"unexpected end of input while parsing major version number\",\n    );\n\n    let ref r = req(\"*\");\n    assert_match_all(r, &[\"0.9.1\", \"2.9.0\", \"0.0.9\", \"1.0.1\", \"1.1.1\"]);\n    assert_match_none(r, &[\"1.0.0-pre\"]);\n\n    for s in &[\"x\", \"X\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.1\", \"1.1.1\", \"1.3.0\"]);\n    assert_match_none(r, &[\"0.0.9\", \"1.2.0-pre\"]);\n\n    for s in &[\"1.x\", \"1.X\", \"1.*.*\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.2.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.2\", \"1.2.4\"]);\n    assert_match_none(r, &[\"1.9.0\", \"1.0.9\", \"2.0.1\", \"0.1.3\", \"1.2.2-pre\"]);\n\n    for s in &[\"1.2.x\", \"1.2.X\"] {\n        assert_eq!(*r, req(s));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_mktemp", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mktemp_mktemp() {\n    let scene = TestScenario::new(util_name!());\n\n    let pathname = scene.fixtures.as_string();\n\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE6)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE7)\n        .succeeds();\n    scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(TEST_TEMPLATE8)\n        .fails();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/footnotes.rs::footnotes_test_8", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn footnotes_test_8() {\n    let original = r##\"[^Doh] Ray Me Fa So La Te Do! [^1]\n\n[^Doh]: I know. Wrong Doe. And it won't render right.\n[^1]: Common for people practicing music.\n\"##;\n    let expected = r##\"<p><sup class=\"footnote-reference\"><a href=\"#Doh\">1</a></sup> Ray Me Fa So La Te Do! <sup class=\"footnote-reference\"><a href=\"#1\">2</a></sup></p>\n<div class=\"footnote-definition\" id=\"Doh\"><sup class=\"footnote-definition-label\">1</sup>\n<p>I know. Wrong Doe. And it won't render right.\n<sup class=\"footnote-reference\"><a href=\"#1\">2</a></sup>: Common for people practicing music.</p>\n</div>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::type_aliases", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn type_aliases() {\n    let source = r#\"type X[T: str, U, *Ts, **P] = list[T]\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_unfixed_floats", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_unfixed_floats() {\n    test_helper(\n        \"numeric_unfixed_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user_group", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_no_change_to_user_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\"43:43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\n                \"ownership of '{file}' retained as {user_name}:{group_name}\\n\"\n            ));\n    }\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::inscribe_to_address_on_different_network", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn inscribe_to_address_on_different_network() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\n    \"wallet inscribe --destination tb1qsgx55dp6gn53tsmyjjv4c2ye403hgxynxs0dnm --file degenerate.png --fee-rate 1\"\n  )\n  .write(\"degenerate.png\", [1; 520])\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .stderr_regex(\"error: address tb1qsgx55dp6gn53tsmyjjv4c2ye403hgxynxs0dnm belongs to network testnet which is different from required bitcoin\\n\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_empty_directory_verbose", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_empty_directory_verbose() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_empty_directory_verbose\";\n\n    at.mkdir(dir);\n\n    ucmd.arg(\"-d\")\n        .arg(\"-v\")\n        .arg(dir)\n        .succeeds()\n        .stdout_only(format!(\"removed directory '{dir}'\\n\"));\n\n    assert!(!at.dir_exists(dir));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::mixed_durable_commit", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn mixed_durable_commit() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(Durability::None);\n    {\n        let mut table = txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &0).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue352", "code": "pub fn from_str(s: &'i str) -> Self {\n        Self::new(Reader::from_str(s))\n    }", "test": "fn issue352() {\n    use std::borrow::Cow;\n\n    #[derive(Deserialize)]\n    struct Root<'a> {\n        #[serde(borrow)]\n        #[serde(rename = \"@attribute\")]\n        attribute: Cow<'a, str>,\n    }\n\n    let r: Root = from_str(\"<Root attribute='borrowed value'></Root>\").unwrap();\n\n    assert!(matches!(r.attribute, Cow::Borrowed(_)));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_column_across_option_and_column_separator", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_column_across_option_and_column_separator() {\n    let test_file_path = \"column.log\";\n    for (arg, expected) in [\n        (\"-s|\", \"column_across_sep.log.expected\"),\n        (\"-Sdivide\", \"column_across_sep1.log.expected\"),\n    ] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(&[\"--pages=3:5\", \"--column=3\", arg, \"-a\", \"-n\", test_file_path])\n            .succeeds()\n            .stdout_is_templated_fixture(expected, &[(\"{last_modified_time}\", &value)]);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_cpu.rs::test_get", "code": "fn get(&self, mut req: Get) -> PdFuture<pb::GetResponse> {\n        self.prepare_header(req.inner.mut_header());\n        self.inner.get(req)\n    }", "test": "fn test_get() {\n    let tag = \"tag_get\";\n\n    let (test_suite, mut store, _) = setup_test_suite();\n    fail::cfg_callback(\"point_getter_get\", || cpu_load(Duration::from_millis(100))).unwrap();\n    defer!(fail::remove(\"point_getter_get\"));\n\n    let jh = test_suite\n        .rt\n        .spawn(require_cpu_time_not_zero(&test_suite, tag));\n\n    let table = ProductTable::new();\n    let insert = prepare_insert(&mut store, &table);\n    insert.execute();\n    store.commit();\n\n    let storage = store.get_storage();\n    for (k, v) in store.export() {\n        let mut ctx = Context::default();\n        ctx.set_resource_group_tag(tag.as_bytes().to_vec());\n        assert_eq!(\n            storage\n                .get(ctx, &Key::from_raw(&k), TimeStamp::max())\n                .unwrap()\n                .0\n                .unwrap()\n                .as_slice(),\n            v.as_slice()\n        );\n    }\n\n    assert!(block_on(jh).unwrap());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::hoisting", "code": "pub fn get_or_intern_static(&mut self, utf8: &'static str, utf16: &'static [u16]) -> Sym {\n        // Uses the utf8 because it's quicker to check inside `COMMON_STRINGS_UTF8`\n        // (which is a perfect hash set) than to check inside `COMMON_STRINGS_UTF16`\n        // (which is a lazy static hash set).\n        self.get(utf8).unwrap_or_else(|| {\n            let index = self.utf8_interner.intern(utf8.as_bytes());\n            let utf16_index = self.utf16_interner.intern(utf16);\n\n            // Just to check everything is okay\n            debug_assert_eq!(index, utf16_index);\n\n            index\n                .checked_add(1 + COMMON_STRINGS_UTF8.len())\n                .and_then(Sym::new)\n                .expect(\"Cannot intern new string: integer overflow\")\n        })\n    }", "test": "fn hoisting() {\n    let interner = &mut Interner::default();\n    let hello = interner.get_or_intern_static(\"hello\", utf16!(\"hello\"));\n    let a = interner.get_or_intern_static(\"a\", utf16!(\"a\"));\n    check_script_parser(\n        r\"\n            var a = hello();\n            a++;\n\n            function hello() { return 10 }\",\n        vec![\n            Statement::Var(VarDeclaration(\n                vec![Variable::from_identifier(\n                    a.into(),\n                    Some(Call::new(Identifier::new(hello).into(), Box::default()).into()),\n                )]\n                .try_into()\n                .unwrap(),\n            ))\n            .into(),\n            Statement::Expression(Expression::from(Update::new(\n                UpdateOp::IncrementPost,\n                UpdateTarget::Identifier(Identifier::new(a)),\n            )))\n            .into(),\n            Declaration::Function(Function::new(\n                Some(hello.into()),\n                FormalParameterList::default(),\n                FunctionBody::new(\n                    vec![Statement::Return(Return::new(Some(Literal::from(10).into()))).into()]\n                        .into(),\n                ),\n            ))\n            .into(),\n        ],\n        interner,\n    );\n\n    let interner = &mut Interner::default();\n    let a = interner.get_or_intern_static(\"a\", utf16!(\"a\"));\n    check_script_parser(\n        r\"\n            a = 10;\n            a++;\n\n            var a;\",\n        vec![\n            Statement::Expression(Expression::from(Assign::new(\n                AssignOp::Assign,\n                Identifier::new(a).into(),\n                Literal::from(10).into(),\n            )))\n            .into(),\n            Statement::Expression(Expression::from(Update::new(\n                UpdateOp::IncrementPost,\n                UpdateTarget::Identifier(Identifier::new(a)),\n            )))\n            .into(),\n            Statement::Var(VarDeclaration(\n                vec![Variable::from_identifier(a.into(), None)]\n                    .try_into()\n                    .unwrap(),\n            ))\n            .into(),\n        ],\n        interner,\n    );\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/issues.rs::issue_655", "code": "fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  }", "test": "fn issue_655() {\n  use nom::character::streaming::{line_ending, not_line_ending};\n  fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  }\n\n  assert_eq!(twolines(\"foo\\nbar\\n\"), Ok((\"\", (\"foo\", \"bar\"))));\n  assert_eq!(twolines(\"f\u00e9o\\nbar\\n\"), Ok((\"\", (\"f\u00e9o\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\r\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n}\n\n#[cf"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_node_tombstone", "code": "fn test_tombstone<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, b\"k1\");\n    must_get_none(&engine_2, b\"k3\");\n    let mut existing_kvs = vec![];\n    for cf in engine_2.cf_names() {\n        engine_2\n            .scan(cf, b\"\", &[0xFF], false, |k, v| {\n                existing_kvs.push((k.to_vec(), v.to_vec()));\n                Ok(true)\n            })\n            .unwrap();\n    }\n    // only tombstone key and store ident key exist.\n    assert_eq!(existing_kvs.len(), 2);\n    existing_kvs.sort();\n    assert_eq!(existing_kvs[0].0.as_slice(), keys::STORE_IDENT_KEY);\n    assert_eq!(existing_kvs[1].0, keys::region_state_key(r1));\n\n    let mut ident = StoreIdent::default();\n    ident.merge_from_bytes(&existing_kvs[0].1).unwrap();\n    assert_eq!(ident.get_store_id(), 2);\n    assert_eq!(ident.get_cluster_id(), cluster.id());\n\n    let mut state = RegionLocalState::default();\n    state.merge_from_bytes(&existing_kvs[1].1).unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // The peer 2 may be destroyed by:\n    // 1. Apply the ConfChange RemovePeer command, the tombstone ConfVer is 4\n    // 2. Receive a GC command before applying 1, the tombstone ConfVer is 3\n    let conf_ver = state.get_region().get_region_epoch().get_conf_ver();\n    assert!(conf_ver == 4 || conf_ver == 3);\n\n    // Send a stale raft message to peer (2, 2)\n    let mut raft_msg = RaftMessage::default();\n\n    raft_msg.set_region_id(r1);\n    // Use an invalid from peer to ignore gc peer message.\n    raft_msg.set_from_peer(new_peer(100, 100));\n    raft_msg.set_to_peer(new_peer(2, 2));\n    raft_msg.mut_region_epoch().set_conf_ver(0);\n    raft_msg.mut_region_epoch().set_version(0);\n\n    cluster.send_raft_msg(raft_msg).unwrap();\n\n    // We must get RegionNotFound error.\n    let region_status = new_status_request(r1, new_peer(2, 2), new_region_leader_cmd());\n    let resp = cluster\n        .call_command(region_status, Duration::from_secs(5))\n        .unwrap();\n    assert!(\n        resp.get_header().get_error().has_region_not_found(),\n        \"region must not found, but got {:?}\",\n        resp\n    );\n}", "test": "fn test_node_tombstone() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_tombstone(&mut cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/iterator.rs::iter_forward_then_reverse_snapshot", "code": "fn iterator(&self, cf: &str) -> Result<Self::Iterator> {\n        self.iterator_opt(cf, IterOptions::default())\n    }", "test": "fn iter_forward_then_reverse_snapshot() {\n    let db = default_engine();\n    iter_forward_then_reverse(&db.engine, |e| e.snapshot().iterator(CF_DEFAULT).unwrap());\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_a_roundtrip", "code": "fn test_roundtrip<T>(value: T)\nwhere\n    T: Serialize + for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let s = to_string(&value).expect(\"Failed to serialize\");\n    let actual: Result<T, _> = from_str(&s);\n    assert_eq!(actual, Ok(value));\n}", "test": "fn test_adjacently_a_roundtrip() {\n    let v = EnumStructAdjacently::VariantA {\n        foo: 1,\n        bar: 2,\n        different: Inner::Foo,\n    };\n    test_roundtrip(v);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_region_created_replicate", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_region_created_replicate() {\n    let cluster = new_server_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let region = suite.cluster.get_region(&[]);\n    suite\n        .cluster\n        .must_transfer_leader(region.id, new_peer(2, 2));\n    suite\n        .cluster\n        .pd_client\n        .must_remove_peer(region.id, new_peer(1, 1));\n\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 1)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    );\n    suite.cluster.sim.wl().add_recv_filter(1, recv_filter);\n    suite\n        .cluster\n        .pd_client\n        .must_add_peer(region.id, new_peer(1, 1));\n    let region = suite.cluster.get_region(&[]);\n    let req = suite.new_changedata_request(region.id);\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    sleep_ms(1000);\n    suite.cluster.sim.wl().clear_recv_filters(1);\n\n    let mut counter = 0;\n    let mut previous_ts = 0;\n    loop {\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            assert!(resolved_ts.ts >= previous_ts);\n            assert!(resolved_ts.regions == vec![region.id]);\n            previous_ts = resolved_ts.ts;\n            counter += 1;\n        }\n        if counter > 5 {\n            break;\n        }\n    }\n    event_feed_wrap.replace(None);\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nul_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_line_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_line_syntax() {\n    new_ucmd!()\n        .args(&[\"-n\", \"2048m\"])\n        .pipe_in(\"a\\n\")\n        .run()\n        .stdout_is(\"a\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_no_args", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_no_args() {\n    new_ucmd!()\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"missing operand\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_multiple_obs_lines_within_combined", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_multiple_obs_lines_within_combined() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"multiple-obs-lines\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-d5000x\", \"-e200d\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_semantic/tests/scopes.rs::test_function_level_strict", "code": "pub fn test(self) {\n        let res: Result<_, _> = self.into();\n\n        res.unwrap();\n    }", "test": "fn test_function_level_strict() {\n    let tester = SemanticTester::js(\n        r#\"\n    function foo() {\n        \"use strict\";\n        let x = 1;\n        return x\n    }\n    \"#,\n    )\n    .with_module(false);\n\n    tester.has_some_symbol(\"x\")\n        .is_in_scope(ScopeFlags::StrictMode | ScopeFlags::Function)\n        .expect(|(semantic, symbol_id)| -> Result<(), &'static str> {\n            let scope_id = semantic.symbol_scope(symbol_id);\n            let Some(parent_scope_id) = semantic.scopes().get_parent_id(scope_id) else {\n                return Err(\"Expected x's scope to have a parent\")\n            };\n            let parent_flags = semantic.scopes().get_flags(parent_scope_id);\n            if parent_flags.contains(ScopeFlags::Top) {\n                Ok(())\n            } else {\n                Err(\"Expected x to be in a top-level function declaration, but its parent scope has flags {parent_flags:?}\")\n            }\n        })\n        .test();\n    tester.has_some_symbol(\"foo\").is_not_in_scope(ScopeFlags::StrictMode).test();\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::versions", "code": "fn version_test(\n    client_versions: &[&'static rustls::SupportedProtocolVersion],\n    server_versions: &[&'static rustls::SupportedProtocolVersion],\n    result: Option<ProtocolVersion>,\n) {\n    let client_versions = if client_versions.is_empty() {\n        rustls::ALL_VERSIONS\n    } else {\n        client_versions\n    };\n    let server_versions = if server_versions.is_empty() {\n        rustls::ALL_VERSIONS\n    } else {\n        server_versions\n    };\n\n    let client_config = make_client_config_with_versions(KeyType::Rsa, client_versions);\n    let server_config = make_server_config_with_versions(KeyType::Rsa, server_versions);\n\n    println!(\n        \"version {:?} {:?} -> {:?}\",\n        client_versions, server_versions, result\n    );\n\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    assert_eq!(client.protocol_version(), None);\n    assert_eq!(server.protocol_version(), None);\n    if result.is_none() {\n        let err = do_handshake_until_error(&mut client, &mut server);\n        assert!(err.is_err());\n    } else {\n        do_handshake(&mut client, &mut server);\n        assert_eq!(client.protocol_version(), result);\n        assert_eq!(server.protocol_version(), result);\n    }\n}", "test": "fn versions() {\n    // default -> 1.3\n    version_test(&[], &[], Some(ProtocolVersion::TLSv1_3));\n\n    // client default, server 1.2 -> 1.2\n    #[cfg(feature = \"tls12\")]\n    version_test(\n        &[],\n        &[&rustls::version::TLS12],\n        Some(ProtocolVersion::TLSv1_2),\n    );\n\n    // client 1.2, server default -> 1.2\n    #[cfg(feature = \"tls12\")]\n    version_test(\n        &[&rustls::version::TLS12],\n        &[],\n        Some(ProtocolVersion::TLSv1_2),\n    );\n\n    // client 1.2, server 1.3 -> fail\n    #[cfg(feature = \"tls12\")]\n    version_test(&[&rustls::version::TLS12], &[&rustls::version::TLS13], None);\n\n    // client 1.3, server 1.2 -> fail\n    #[cfg(feature = \"tls12\")]\n    version_test(&[&rustls::version::TLS13], &[&rustls::version::TLS12], None);\n\n    // client 1.3, server 1.2+1.3 -> 1.3\n    #[cfg(feature = \"tls12\")]\n    version_test(\n        &[&rustls::version::TLS13],\n        &[&rustls::version::TLS12, &rustls::version::TLS13],\n        Some(ProtocolVersion::TLSv1_3),\n    );\n\n    // client 1.2+1.3, server 1.2 -> 1.2\n    #[cfg(feature = \"tls12\")]\n    version_test(\n        &[&rustls::version::TLS13, &rustls::version::TLS12],\n        &[&rustls::version::TLS12],\n        Some(ProtocolVersion::TLSv1_2),\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/import/test_sst_service.rs::test_ingest_sst", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_sst() {\n    let mut cfg = TikvConfig::default();\n    cfg.server.grpc_concurrency = 1;\n    let (_cluster, ctx, _tikv, import) = open_cluster_and_tikv_import_client(Some(cfg));\n\n    let temp_dir = Builder::new().prefix(\"test_ingest_sst\").tempdir().unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n\n    // No region id and epoch.\n    send_upload_sst(&import, &meta, &data).unwrap();\n\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta.clone());\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(resp.has_error());\n\n    // Set region id and epoch.\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n    send_upload_sst(&import, &meta, &data).unwrap();\n    // Can't upload the same file again.\n    assert_to_string_contains!(\n        send_upload_sst(&import, &meta, &data).unwrap_err(),\n        \"FileExists\"\n    );\n\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error(), \"{:?}\", resp.get_error());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_wrap_bad_arg", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_wrap_bad_arg() {\n    for wrap_param in [\"-w\", \"--wrap\"] {\n        new_ucmd!()\n            .arg(wrap_param)\n            .arg(\"b\")\n            .fails()\n            .stderr_only(\"base64: invalid wrap size: 'b'\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_rpc_client", "code": "fn get_cluster_id(&self) -> Result<u64> {\n        Ok(self.cluster_id)\n    }", "test": "fn test_rpc_client() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n\n    let client = new_client(eps.clone(), None);\n    assert_ne!(client.get_cluster_id().unwrap(), 0);\n\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    debug!(\"bootstrap store {:?}\", store);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer.clone());\n    debug!(\"bootstrap region {:?}\", region);\n\n    client\n        .bootstrap_cluster(store.clone(), region.clone())\n        .unwrap();\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n\n    let tmp_stores = client.get_all_stores(false).unwrap();\n    assert_eq!(tmp_stores.len(), 1);\n    assert_eq!(tmp_stores[0], store);\n\n    let tmp_store = client.get_store(store_id).unwrap();\n    assert_eq!(tmp_store.get_id(), store.get_id());\n\n    let region_key = region.get_start_key();\n    let tmp_region = client.get_region(region_key).unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader, None);\n\n    let tmp_region = block_on(client.get_region_by_id(region_id))\n        .unwrap()\n        .unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let ts = block_on(client.get_tso()).unwrap();\n    assert_ne!(ts, TimeStamp::zero());\n\n    let ts100 = block_on(client.batch_get_tso(100)).unwrap();\n    assert_eq!(ts.logical() + 100, ts100.logical());\n\n    let mut prev_id = 0;\n    for _ in 0..100 {\n        let client = new_client(eps.clone(), None);\n        let alloc_id = client.alloc_id().unwrap();\n        assert!(alloc_id > prev_id);\n        prev_id = alloc_id;\n    }\n\n    let poller = Builder::new_multi_thread()\n        .thread_name(thd_name!(\"poller\"))\n        .worker_threads(1)\n        .build()\n        .unwrap();\n    let (tx, rx) = mpsc::channel();\n    let f = client.handle_region_heartbeat_response(1, move |resp| {\n        let _ = tx.send(resp);\n    });\n    poller.spawn(f);\n    poller.spawn(client.region_heartbeat(\n        store::RAFT_INIT_LOG_TERM,\n        region.clone(),\n        peer.clone(),\n        RegionStat::default(),\n        None,\n    ));\n    rx.recv_timeout(Duration::from_secs(3)).unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader.unwrap(), peer);\n\n    block_on(client.store_heartbeat(\n        pdpb::StoreStats::default(),\n        None, // store_report\n        None,\n    ))\n    .unwrap();\n    block_on(client.ask_batch_split(metapb::Region::default(), 1)).unwrap();\n    block_on(client.report_batch_split(vec![metapb::Region::default(), metapb::Region::default()]))\n        .unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    client.scatter_region(region_info).unwrap();\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_no_leak", "code": "pub fn load(&self, env: &Environment, key: &str) -> Option<Value> {\n        for frame in self.stack.iter().rev() {\n            // look at locals first\n            if let Some(value) = frame.locals.get(key) {\n                return Some(value.clone());\n            }\n\n            // if we are a loop, check if we are looking up the special loop var.\n            if let Some(ref l) = frame.current_loop {\n                if l.with_loop_var && key == \"loop\" {\n                    return Some(Value::from(l.object.clone()));\n                }\n            }\n\n            // perform a fast lookup.  This one will not produce errors if the\n            // context is undefined or of the wrong type.\n            if let Some(rv) = frame.ctx.get_attr_fast(key) {\n                return Some(rv);\n            }\n        }\n\n        env.get_global(key)\n    }", "test": "fn test_no_leak() {\n    let dropped = Arc::new(AtomicBool::new(false));\n\n    struct X(Arc<AtomicBool>);\n\n    impl StructObject for X {\n        fn get_field(&self, _name: &str) -> Option<Value> {\n            None\n        }\n    }\n\n    impl Drop for X {\n        fn drop(&mut self) {\n            self.0.store(true, std::sync::atomic::Ordering::Relaxed);\n        }\n    }\n\n    let ctx = context! {\n        x => Value::from_struct_object(X(dropped.clone())),\n    };\n    let mut env = Environment::new();\n    env.add_template(\"x\", \"{% macro meh() %}{{ x }}{{ meh }}{% endmacro %}\")\n        .unwrap();\n    let rv = env\n        .render_str(\n            r#\"\n        {%- from 'x' import meh %}\n        {{- meh() }}\n        {%- set closure = x %}\n        {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}\n        {{- foo() -}}\n\n        {%- for y in range(3) %}\n            {%- set closure = x %}\n            {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}\n            {{- foo() -}}\n        {%- endfor -%}\n    \"#,\n            ctx,\n        )\n        .unwrap();\n\n    assert!(dropped.load(std::sync::atomic::Ordering::Relaxed));\n    assert_eq!(\n        rv,\n        \"{}<macro meh><macro foo>{}<macro foo>{}<macro foo>{}<macro foo>{}\"\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_limit_accepts_all", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_limit_accepts_all() {\n    one_statement_parses_to(\n        \"SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT ALL\",\n        \"SELECT id, fname, lname FROM customer WHERE id = 1\",\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_tuples", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_tuples() {\n    let sql = \"SELECT (1, 2), (1), ('foo', 3, baz)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        vec![\n            SelectItem::UnnamedExpr(Expr::Tuple(vec![\n                Expr::Value(number(\"1\")),\n                Expr::Value(number(\"2\")),\n            ])),\n            SelectItem::UnnamedExpr(Expr::Nested(Box::new(Expr::Value(number(\"1\"))))),\n            SelectItem::UnnamedExpr(Expr::Tuple(vec![\n                Expr::Value(Value::SingleQuotedString(\"foo\".into())),\n                Expr::Value(number(\"3\")),\n                Expr::Identifier(Ident::new(\"baz\")),\n            ])),\n        ],\n        select.projection\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_chown_directory_invalid", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_install_chown_directory_invalid() {\n    let scene = TestScenario::new(util_name!());\n\n    scene\n        .ucmd()\n        .arg(\"-o\")\n        .arg(\"test_invalid_user\")\n        .arg(\"-d\")\n        .arg(\"dir1/dir2\")\n        .fails()\n        .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n\n    scene\n        .ucmd()\n        .arg(\"-g\")\n        .arg(\"test_invalid_group\")\n        .arg(\"-d\")\n        .arg(\"dir1/dir2\")\n        .fails()\n        .stderr_contains(\"install: invalid group: 'test_invalid_group'\");\n\n    scene\n        .ucmd()\n        .arg(\"-o\")\n        .arg(\"test_invalid_user\")\n        .arg(\"-g\")\n        .arg(\"test_invalid_group\")\n        .arg(\"-d\")\n        .arg(\"dir1/dir2\")\n        .fails()\n        .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n\n    scene\n        .ucmd()\n        .arg(\"-g\")\n        .arg(\"test_invalid_group\")\n        .arg(\"-o\")\n        .arg(\"test_invalid_user\")\n        .arg(\"-d\")\n        .arg(\"dir1/dir2\")\n        .fails()\n        .stderr_contains(\"install: invalid user: 'test_invalid_user'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_a_bunch_of_not", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_a_bunch_of_not() {\n    new_ucmd!()\n        .args(&[\"!\", \"\", \"!=\", \"\", \"-a\", \"!\", \"\", \"!=\", \"\"])\n        .succeeds();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/sqlite_tests.rs::test_init_journal", "code": "pub fn schema_up(&mut self) -> PersistenceResult<i64> {\n        while self.version < CURRENT_VERSION {\n            match self.version + 1 {\n                0 => self.version = self.init_up()?,\n                1 => self.version = self.records_up()?,\n                _ => panic!(\"incorrect version somewhere\"), // valid panic, non-recoverable state\n            }\n\n            self.update_schema_version(self.version)?;\n        }\n\n        Ok(self.version)\n    }", "test": "fn test_init_journal() {\n    let conn = Connection::open_in_memory().expect(\"could not create in memory DB\");\n    let mut journal = Journal::new(conn).unwrap();\n    let version = journal.schema_up().unwrap();\n    assert_eq!(version, CURRENT_VERSION);\n    assert_eq!(\n        Journal::select_schema_version(&journal.conn()).unwrap(),\n        CURRENT_VERSION\n    );\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_lifetime", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse_lifetime() {\n    parse(\"'static\").unwrap_err();\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_02", "code": "pub fn resume<T>(\n        self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        inputs: &[Value],\n        outputs: &mut [Value],\n    ) -> Result<ResumableCall, Error> {\n        self.engine\n            .resolve_func_type(self.host_func().ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(inputs, true)\n            })?;\n        self.engine\n            .resolve_func_type(self.func.ty_dedup(ctx.as_context()), |func_type| {\n                func_type.match_results(outputs, false)?;\n                func_type.prepare_outputs(outputs);\n                <Result<(), Error>>::Ok(()) // TODO: why do we need types here?\n            })?;\n        self.engine\n            .clone()\n            .resume_func(ctx.as_context_mut(), self, inputs, outputs)\n            .map_err(Into::into)\n            .map(ResumableCall::new)\n    }", "test": "fn resumable_call_smoldot_02() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (if (result i32) (i32.ne (call $host_fn) (i32.const 0))\n                    (then\n                        (i32.const 11) ;; EXPECTED\n                    )\n                    (else\n                        (i32.const 22) ;; FAILURE\n                    )\n                )\n            )\n        )\n        \"#,\n    );\n    let invocation = wasm_fn.call_resumable(&mut store, ()).unwrap_resumable();\n    match invocation.resume(&mut store, &[Value::I32(42)]).unwrap() {\n        TypedResumableCall::Finished(result) => assert_eq!(result, 11),\n        TypedResumableCall::Resumable(_) => panic!(\"expected TypeResumableCall::Finished\"),\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::reopen_table", "code": "pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    }", "test": "fn reopen_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &0).unwrap();\n    }\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&1, &1).unwrap();\n    }\n    write_txn.commit().unwrap();\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_compare_and_swap", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_compare_and_swap() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client\n        .compare_and_swap(current.clone(), new.clone(), origin.clone())\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(new.name(), new.dns_class(), new.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n\n    // check the it fails if tried again.\n    new.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n\n    let result = client\n        .compare_and_swap(current, new.clone(), origin)\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = client\n        .query(new.name(), new.dns_class(), new.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::defaultcheck_order_two_different_bad_order_files", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn defaultcheck_order_two_different_bad_order_files() {\n    new_ucmd!()\n        .args(&[\"bad_order_1\", \"bad_order_2\"])\n        .fails()\n        .stdout_is_fixture(\"bad_order12.nocheck_order.expected\")\n        .stderr_is(\"error to be defined\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_inheritance", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn can_remove_whitespace_inheritance() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\"{%- extends \"base\" -%} {% block content %}{{super()}}{% endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" -%} {% block content -%}{{super()}}{%- endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" %} {%- block content -%}{{super()}}{%- endblock -%} \"#, \" Hey! \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"base\", \"{% block content %} Hey! {% endblock %}\"),\n            (\"tpl\", input),\n        ])\n        .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_custom_suffix() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_byte_literal", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_byte_literal() {\n    let sql = r#\"SELECT B'abc', B\"abc\"\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::DoubleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT b'abc', b\"abc\"\"#;\n    bigquery().one_statement_parses_to(sql, r#\"SELECT B'abc', B\"abc\"\"#);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_preserve_final_newline_when_line_less_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_preserve_final_newline_when_line_less_than_fold() {\n    new_ucmd!().pipe_in(\"1234\\n\").succeeds().stdout_is(\"1234\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_and_not_is_false", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_and_not_is_false() {\n    new_ucmd!().args(&[\"-a\", \"!\"]).run().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_ascii_5_gibi_to_file", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "test": "fn test_ascii_5_gibi_to_file() {\n    let tname = \"ascii-5G\";\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"status=none\",\n        \"count=5G\",\n        \"iflag=count_bytes\",\n        \"if=/dev/zero\",\n        of!(tmp_fn),\n    ])\n    .run()\n    .no_stderr()\n    .no_stdout()\n    .success();\n\n    assert_eq!(5 * 1024 * 1024 * 1024, fix.metadata(&tmp_fn).len());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_long_header_option", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_long_header_option() {\n    let test_file_path = \"test_one_page.log\";\n    let expected_test_file_path = \"test_one_page_header.log.expected\";\n    let header = \"new file\";\n    for args in [&[\"-h\", header][..], &[\"--header=new file\"][..]] {\n        let mut scenario = new_ucmd!();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        scenario\n            .args(args)\n            .arg(test_file_path)\n            .succeeds()\n            .stdout_is_templated_fixture(\n                expected_test_file_path,\n                &[(\"{last_modified_time}\", &value), (\"{header}\", header)],\n            );\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::logical_nullish_assignment", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn logical_nullish_assignment() {\n    run_test_actions([\n        TestAction::assert_eq(\"{ let a = undefined; a ??= 10; a }\", 10),\n        TestAction::assert_eq(\"{ let a = 20; a ??= 10; a }\", 20),\n    ]);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_17", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_17() {\n    let original = r##\"# H1 {.z .a .zz}\n\"##;\n    let expected = r##\"<h1 class=\"z a zz\">H1</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_space_only", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_space_only() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \" \"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        .stdout_is(\"a       b       c\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_attribute.rs::test_meta_item_list_word", "code": "fn test(input: &str) -> Meta {\n    let attrs = Attribute::parse_outer.parse_str(input).unwrap();\n\n    assert_eq!(attrs.len(), 1);\n    let attr = attrs.into_iter().next().unwrap();\n\n    attr.meta\n}", "test": "fn test_meta_item_list_word() {\n    let meta = test(\"#[foo(bar)]\");\n\n    snapshot!(meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`bar`),\n    }\n    \"###);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_linked_func", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "test": "fn call_linked_func() -> Result<(), Error> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate(&mut store, &module)?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call(&mut store, &[], &mut [])?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    export.typed::<(), ()>(&store)?.call(&mut store, ())?;\n\n    assert_eq!(store.data().calls_into_host, 2);\n    assert_eq!(store.data().returns_from_host, 2);\n    assert_eq!(store.data().calls_into_wasm, 2);\n    assert_eq!(store.data().returns_from_wasm, 2);\n\n    Ok(())\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    let _guard = TEST_MUTEX.lock();\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/choose.rs::chooser", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn chooser() {\n  Test::new()\n    .arg(\"--choose\")\n    .arg(\"--chooser\")\n    .arg(\"head -n1\")\n    .justfile(\n      \"\n        foo:\n          echo foo\n\n        bar:\n          echo bar\n      \",\n    )\n    .stderr(\"echo bar\\n\")\n    .stdout(\"bar\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_zero", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_ls_zero() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"0-test-zero\");\n    at.touch(at.plus_as_string(\"2-test-zero\"));\n    at.touch(at.plus_as_string(\"3-test-zero\"));\n\n    let ignored_opts = [\n        \"--quoting-style=c\",\n        \"--color=always\",\n        \"-m\",\n        \"--hide-control-chars\",\n    ];\n\n    scene\n        .ucmd()\n        .arg(\"--zero\")\n        .succeeds()\n        .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n\n    for opt in ignored_opts {\n        scene\n            .ucmd()\n            .args(&[opt, \"--zero\"])\n            .succeeds()\n            .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n    }\n\n    scene\n        .ucmd()\n        .args(&[\"--zero\", \"--quoting-style=c\"])\n        .succeeds()\n        .stdout_only(\"\\\"0-test-zero\\\"\\x00\\\"2-test-zero\\\"\\x00\\\"3-test-zero\\\"\\x00\");\n\n    scene\n        .ucmd()\n        .args(&[\"--zero\", \"--color=always\"])\n        .succeeds()\n        .stdout_only(\"\\x1b[1;34m0-test-zero\\x1b[0m\\x002-test-zero\\x003-test-zero\\x00\");\n\n    scene\n        .ucmd()\n        .args(&[\"--zero\", \"-m\"])\n        .succeeds()\n        .stdout_only(\"0-test-zero, 2-test-zero, 3-test-zero\\x00\");\n\n    scene\n        .ucmd()\n        .args(&[\"--zero\", \"--hide-control-chars\"])\n        .succeeds()\n        .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n\n    scene\n        .ucmd()\n        .args(&[\"--zero\", \"--quoting-style=c\", \"--zero\"])\n        .succeeds()\n        .stdout_only(\"0-test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n\n    #[cfg(unix)]\n    {\n        at.touch(at.plus_as_string(\"1\\ntest-zero\"));\n\n        let ignored_opts = [\n            \"--quoting-style=c\",\n            \"--color=always\",\n            \"-m\",\n            \"--hide-control-chars\",\n        ];\n\n        scene\n            .ucmd()\n            .arg(\"--zero\")\n            .succeeds()\n            .stdout_only(\"0-test-zero\\x001\\ntest-zero\\x002-test-zero\\x003-test-zero\\x00\");\n\n        for opt in ignored_opts {\n            scene\n                .ucmd()\n                .args(&[opt, \"--zero\"])\n                .succeeds()\n                .stdout_only(\"0-test-zero\\x001\\ntest-zero\\x002-test-zero\\x003-test-zero\\x00\");\n        }\n\n        scene\n            .ucmd()\n            .args(&[\"--zero\", \"--quoting-style=c\"])\n            .succeeds()\n            .stdout_only(\n                \"\\\"0-test-zero\\\"\\x00\\\"1\\\\ntest-zero\\\"\\x00\\\"2-test-zero\\\"\\x00\\\"3-test-zero\\\"\\x00\",\n            );\n\n        scene\n            .ucmd()\n            .args(&[\"--zero\", \"--color=always\"])\n            .succeeds()\n            .stdout_only(\n                \"\\x1b[1;34m0-test-zero\\x1b[0m\\x001\\ntest-zero\\x002-test-zero\\x003-test-zero\\x00\",\n            );\n\n        scene\n            .ucmd()\n            .args(&[\"--zero\", \"-m\"])\n            .succeeds()\n            .stdout_only(\"0-test-zero, 1\\ntest-zero, 2-test-zero, 3-test-zero\\x00\");\n\n        scene\n            .ucmd()\n            .args(&[\"--zero\", \"--hide-control-chars\"])\n            .succeeds()\n            .stdout_only(\"0-test-zero\\x001?test-zero\\x002-test-zero\\x003-test-zero\\x00\");\n    }\n\n    scene\n        .ucmd()\n        .args(&[\"-l\", \"--zero\"])\n        .succeeds()\n        .stdout_contains(\"total \");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_multiple_snapshots_not_together", "code": "fn test_node_merge_multiple_snapshots(together: bool) {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    ignore_merge_target_integrity(&mut cluster.cfg, &cluster.pd_client);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    // make it gc quickly to trigger snapshot easily\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(10);\n    cluster.cfg.raft_store.merge_max_log_gap = 9;\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n\n    let target_leader = right\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() == 1)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(right.get_id(), target_leader);\n    let target_leader = left\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() == 2)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(left.get_id(), target_leader);\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n\n    // So cluster becomes:\n    //  left region: 1         2(leader) I 3\n    // right region: 1(leader) 2         I 3\n    // I means isolation.(here just means 3 can not receive append log)\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(right.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n\n    // Add a collect snapshot filter, it will delay snapshots until have collected\n    // multiple snapshots from different peers\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(LeadingDuplicatedSnapshotFilter::new(\n            Arc::new(AtomicBool::new(false)),\n            together,\n        )),\n    );\n    // Write some data to trigger a snapshot of right region.\n    for i in 200..210 {\n        let key = format!(\"k{}\", i);\n        let value = format!(\"v{}\", i);\n        cluster.must_put(key.as_bytes(), value.as_bytes());\n    }\n    // Wait for snapshot to generate and send\n    thread::sleep(Duration::from_millis(100));\n\n    // Merge left and right region, due to isolation, the regions on store 3 are not\n    // merged yet.\n    pd_client.must_merge(left.get_id(), right.get_id());\n    thread::sleep(Duration::from_millis(200));\n\n    // Let peer of right region on store 3 to make append response to trigger a new\n    // snapshot one is snapshot before merge, the other is snapshot after merge.\n    // Here blocks raftstore for a while to make it not to apply snapshot and\n    // receive new log now.\n    fail::cfg(\"on_raft_ready\", \"sleep(100)\").unwrap();\n    cluster.clear_send_filters();\n    thread::sleep(Duration::from_millis(200));\n    // Filter message again to make sure peer on store 3 can not catch up\n    // CommitMerge log\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(right.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    // Cause filter is added again, no need to block raftstore anymore\n    fail::cfg(\"on_raft_ready\", \"off\").unwrap();\n\n    // Wait some time to let already merged peer on store 1 or store 2 to notify\n    // the peer of left region on store 3 is stale.\n    thread::sleep(Duration::from_millis(300));\n\n    cluster.must_put(b\"k9\", b\"v9\");\n    // let follower can reach the new log, then commit merge\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(3), b\"k9\", b\"v9\");\n}", "test": "fn test_node_merge_multiple_snapshots_not_together() {\n    test_node_merge_multiple_snapshots(false)\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_pat.rs::test_pat_ident", "code": "fn parse2(self, tokens: TokenStream) -> Result<T> {\n        let buf = TokenBuffer::new2(tokens);\n        let state = tokens_to_parse_buffer(&buf);\n        let node = self(&state)?;\n        state.check_unexpected()?;\n        if let Some(unexpected_span) = span_of_unexpected_ignoring_nones(state.cursor()) {\n            Err(Error::new(unexpected_span, \"unexpected token\"))\n        } else {\n            Ok(node)\n        }\n    }", "test": "fn test_pat_ident() {\n    match Pat::parse_single.parse2(quote!(self)).unwrap() {\n        Pat::Ident(_) => (),\n        value => panic!(\"expected PatIdent, got {:?}\", value),\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_position_not_function_columns", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_position_not_function_columns() {\n    snowflake_and_generic()\n        .verified_stmt(\"SELECT position FROM tbl1 WHERE position NOT IN ('first', 'last')\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_bootstrap.rs::test_bootstrap_half_way_failure_after_bootstrap_store", "code": "fn test_bootstrap_half_way_failure() {\n    let server = test_pd::Server::new(1);\n    let eps = server.bind_addrs();\n    let pd_client = test_pd::util::new_client(eps, None);\n    let path = TempDir::new().unwrap();\n    let engines = engine_test::new_temp_engine(&path);\n    let bootstrap = || {\n        let logger = slog_global::borrow_global().new(o!());\n        let mut bootstrap = Bootstrap::new(&engines.raft, 0, &pd_client, logger);\n        match bootstrap.bootstrap_store() {\n            Ok(store_id) => {\n                let mut store = Store::default();\n                store.set_id(store_id);\n                bootstrap.bootstrap_first_region(&store, store_id)\n            }\n            Err(e) => Err(e),\n        }\n    };\n\n    // Try to start this node, return after persisted some keys.\n    fail::cfg(\"node_after_bootstrap_store\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_store\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    let ident = engines.raft.get_store_ident().unwrap().unwrap();\n    assert_ne!(ident.get_store_id(), 0);\n\n    // Check whether it can bootstrap cluster successfully.\n    fail::remove(\"node_after_bootstrap_store\");\n    fail::cfg(\"node_after_prepare_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_prepare_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    fail::remove(\"node_after_prepare_bootstrap_cluster\");\n    fail::cfg(\"node_after_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    // Although aborted by error, rebootstrap should continue.\n    bootstrap().unwrap().unwrap();\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    // Second bootstrap should be noop.\n    assert_eq!(bootstrap().unwrap(), None);\n\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n}", "test": "fn test_bootstrap_half_way_failure_after_bootstrap_store() {\n    let fp = \"node_after_bootstrap_store\";\n    test_bootstrap_half_way_failure(fp);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_merge_pessimistic_locks_with_concurrent_prewrite", "code": "pub fn is_writable(&self) -> bool {\n        self.status == LocksStatus::Normal\n    }", "test": "fn test_merge_pessimistic_locks_with_concurrent_prewrite() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    cluster.must_transfer_leader(right.id, new_peer(2, 2));\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let snapshot = cluster.must_get_snapshot_of_region(left.id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    let lock = PessimisticLock {\n        primary: b\"k0\".to_vec().into_boxed_slice(),\n        start_ts: 10.into(),\n        ttl: 3000,\n        for_update_ts: 20.into(),\n        min_commit_ts: 30.into(),\n        last_change_ts: 15.into(),\n        versions_to_last_change: 3,\n    };\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![\n            (Key::from_raw(b\"k0\"), lock.clone()),\n            (Key::from_raw(b\"k1\"), lock),\n        ])\n        .unwrap();\n\n    let mut mutation = Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.set_key(b\"k0\".to_vec());\n    mutation.set_value(b\"v\".to_vec());\n    let mut req = PrewriteRequest::default();\n    req.set_context(cluster.get_ctx(b\"k0\"));\n    req.set_mutations(vec![mutation].into());\n    req.set_pessimistic_actions(vec![DoPessimisticCheck]);\n    req.set_start_version(10);\n    req.set_for_update_ts(40);\n    req.set_primary_lock(b\"k0\".to_vec());\n\n    // First, pause apply and prewrite.\n    fail::cfg(\"on_handle_apply\", \"pause\").unwrap();\n    let req2 = req.clone();\n    let client2 = client.clone();\n    let resp = thread::spawn(move || client2.kv_prewrite(&req2).unwrap());\n    thread::sleep(Duration::from_millis(500));\n\n    // Then, start merging. PrepareMerge should wait until prewrite is done.\n    cluster.merge_region(left.id, right.id, Callback::None);\n    thread::sleep(Duration::from_millis(500));\n    assert!(txn_ext.pessimistic_locks.read().is_writable());\n\n    // But a later prewrite request should fail because we have already banned all\n    // later proposals.\n    req.mut_mutations()[0].set_key(b\"k1\".to_vec());\n    let resp2 = thread::spawn(move || client.kv_prewrite(&req).unwrap());\n\n    fail::remove(\"on_handle_apply\");\n    let resp = resp.join().unwrap();\n    assert!(!resp.has_region_error(), \"{:?}\", resp);\n\n    let resp2 = resp2.join().unwrap();\n    assert!(resp2.has_region_error());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_header() {\n    new_ucmd!()\n        .args(&[\"--from=si\", \"--header=2\"])\n        .pipe_in(\"header\\nheader2\\n1K\\n1.1M\\n0.1G\")\n        .run()\n        .stdout_is(\"header\\nheader2\\n1000\\n1100000\\n100000000\\n\");\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/search.rs::test_justfile_search", "code": "fn join() {\n  assert_eval_eq(\"join('a', 'b', 'c', 'd')\", \"a/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', 'c', 'd')\", \"/b/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', 'd')\", \"/c/d\");\n  assert_eval_eq(\"join('a', '/b', '/c', '/d')\", \"/d\");\n}", "test": "fn test_justfile_search() {\n  let tmp = temptree! {\n    justfile: \"default:\\n\\techo ok\",\n    a: {\n      b: {\n        c: {\n          d: {},\n        },\n      },\n    },\n  };\n\n  search_test(tmp.path().join(\"a/b/c/d\"), &[]);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::not_regression", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn not_regression() {\n    // https://github.com/googleprojectzero/weggli/issues/2\n    let needle = \"{free($handle); not: $handle= NULL;}\";\n    let source = r\"\n    void func()\n    {\n        free(data); //this should not match\n        data = NULL ; \n        \n        free(handle); //this should match\n    }\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::store_with_context", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "fn store_with_context() -> Result<()> {\n    struct Ctx {\n        called: bool,\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\"\", \"\", |mut caller: Caller<'_, Ctx>| {\n        caller.data_mut().called = true;\n    })?;\n\n    let mut store = Store::new(&engine, Ctx { called: false });\n\n    let f = linker.get(&mut store, \"\", \"\").unwrap().into_func().unwrap();\n    f.call(&mut store, &[], &mut [])?;\n\n    assert!(store.data().called);\n\n    Ok(())\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::vba", "code": "pub fn get_module(&self, name: &str) -> Result<String, VbaError> {\n        debug!(\"read module {}\", name);\n        let data = self.get_module_raw(name)?;\n        Ok(self.encoding.decode_all(data))\n    }", "test": "fn vba() {\n    setup();\n\n    let path = format!(\"{}/tests/vba.xlsm\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let mut vba = excel.vba_project().unwrap().unwrap();\n    assert_eq!(\n        vba.to_mut().get_module(\"testVBA\").unwrap(),\n        \"Attribute VB_Name = \\\"testVBA\\\"\\r\\nPublic Sub test()\\r\\n    MsgBox \\\"Hello from \\\n         vba!\\\"\\r\\nEnd Sub\\r\\n\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/lock_manager.rs::test_detect_deadlock_when_transfer_region", "code": "fn must_detect_deadlock(cluster: &mut Cluster<ServerCluster>, key: &[u8], ts: u64) {\n    // Sometimes, deadlocks can't be detected at once due to leader change, but it\n    // will be detected.\n    for _ in 0..5 {\n        let (client, ctx) = build_leader_client(cluster, key);\n        if deadlock(&client, ctx, key, ts) {\n            return;\n        }\n    }\n    panic!(\"failed to detect deadlock\");\n}", "test": "fn test_detect_deadlock_when_transfer_region() {\n    let mut cluster = new_cluster_for_deadlock_test(4);\n    // Transfer the leader region to store(4) and the leader of deadlock detector\n    // should be also transferred.\n    must_transfer_region(&mut cluster, b\"k\", 1, 4, 4);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n\n    must_split_region(&mut cluster, b\"\", b\"k1\");\n    // Transfer the new region to store(1). It shouldn't affect deadlock detector.\n    must_transfer_region(&mut cluster, b\"k1\", 4, 1, 5);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n\n    // Transfer the new region back to store(4) which will send a role change\n    // message with empty key range. It shouldn't affect deadlock detector.\n    must_transfer_region(&mut cluster, b\"k1\", 1, 4, 6);\n    deadlock_detector_leader_must_be(&mut cluster, 4);\n    must_detect_deadlock(&mut cluster, b\"k\", 10);\n    must_detect_deadlock(&mut cluster, b\"k1\", 10);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_table", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_drop_table() {\n    let sql = \"DROP TABLE foo\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            object_type,\n            if_exists,\n            names,\n            cascade,\n            purge: _,\n            temporary,\n            ..\n        } => {\n            assert!(!if_exists);\n            assert_eq!(ObjectType::Table, object_type);\n            assert_eq!(\n                vec![\"foo\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert!(!cascade);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"DROP TABLE IF EXISTS foo, bar CASCADE\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            object_type,\n            if_exists,\n            names,\n            cascade,\n            purge: _,\n            temporary,\n            ..\n        } => {\n            assert!(if_exists);\n            assert_eq!(ObjectType::Table, object_type);\n            assert_eq!(\n                vec![\"foo\", \"bar\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert!(cascade);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"DROP TABLE\";\n    assert_eq!(\n        ParserError::ParserError(\"Expected identifier, found: EOF\".to_string()),\n        parse_sql_statements(sql).unwrap_err(),\n    );\n\n    let sql = \"DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT\";\n    assert_eq!(\n        ParserError::ParserError(\"Cannot specify both CASCADE and RESTRICT in DROP\".to_string()),\n        parse_sql_statements(sql).unwrap_err(),\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_to_dir_2args", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_to_dir_2args() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let filename = \"test_symlink_to_dir_2args_file\";\n    let from_file = &format!(\"{}/{}\", at.as_string(), filename);\n    let to_dir = \"test_symlink_to_dir_2args_to_dir\";\n    let to_file = &format!(\"{to_dir}/{filename}\");\n\n    at.mkdir(to_dir);\n    at.touch(from_file);\n\n    ucmd.args(&[\"-s\", from_file, to_dir]).succeeds().no_stderr();\n\n    assert!(at.file_exists(to_file));\n    assert!(at.is_symlink(to_file));\n    assert_eq!(at.resolve_link(to_file), filename);\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_reserve", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "test": "fn TinyVec_reserve() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(2);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 10);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_value_in_map_key", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "test": "fn test_raw_value_in_map_key() {\n    #[derive(RefCast)]\n    #[repr(transparent)]\n    struct RawMapKey(RawValue);\n\n    impl<'de> Deserialize<'de> for &'de RawMapKey {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: serde::Deserializer<'de>,\n        {\n            let raw_value = <&RawValue>::deserialize(deserializer)?;\n            Ok(RawMapKey::ref_cast(raw_value))\n        }\n    }\n\n    impl PartialEq for RawMapKey {\n        fn eq(&self, other: &Self) -> bool {\n            self.0.get() == other.0.get()\n        }\n    }\n\n    impl Eq for RawMapKey {}\n\n    impl Hash for RawMapKey {\n        fn hash<H: Hasher>(&self, hasher: &mut H) {\n            self.0.get().hash(hasher);\n        }\n    }\n\n    let map_from_str: HashMap<&RawMapKey, &RawValue> =\n        serde_json::from_str(r#\" {\"\\\\k\":\"\\\\v\"} \"#).unwrap();\n    let (map_k, map_v) = map_from_str.into_iter().next().unwrap();\n    assert_eq!(\"\\\"\\\\\\\\k\\\"\", map_k.0.get());\n    assert_eq!(\"\\\"\\\\\\\\v\\\"\", map_v.get());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_additional_suffix_hyphen_value", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_additional_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_additional_suffix\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[\"--additional-suffix\", \"-300\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]-300$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "test": "fn TinyVec_capacity() {\n  let mut tv: TinyVec<[i32; 1]> = Default::default();\n  assert_eq!(tv.capacity(), 1);\n  tv.move_to_the_heap();\n  tv.extend_from_slice(&[1, 2, 3, 4]);\n  assert_eq!(tv.capacity(), 4);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_negative", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn indent_size_parse_errors_negative() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=-1\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_negative\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_normal_format", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_normal_format() {\n    let args = [\"-c\", NORMAL_FORMAT_STR, \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let expected_stdout = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    ts.ucmd().args(&args).succeeds().stdout_is(expected_stdout);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_octal", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_octal() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\0100\"])\n        .succeeds()\n        .stdout_only(\"@\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::trap_start_function_import", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn trap_start_function_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"\" (func $foo))\n                (start $foo)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let sig = FuncType::new(None, None);\n    let func = Func::new(&mut store, sig, |_, _, _| bail!(\"user trap\"));\n    let err = Instance::new(&mut store, &module, &[func.into()]).unwrap_err();\n    assert!(format!(\"{err:?}\").contains(\"user trap\"));\n    Ok(())\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::from_float", "code": "fn assert_normalized_eq(mut x: ExtendedFloat, mut y: ExtendedFloat) {\n    x.normalize();\n    y.normalize();\n    assert_eq!(x, y);\n}", "test": "fn from_float() {\n    let values: [f32; 26] = [\n        1e-40, 2e-40, 1e-35, 2e-35, 1e-30, 2e-30, 1e-25, 2e-25, 1e-20, 2e-20, 1e-15, 2e-15, 1e-10,\n        2e-10, 1e-5, 2e-5, 1.0, 2.0, 1e5, 2e5, 1e10, 2e10, 1e15, 2e15, 1e20, 2e20,\n    ];\n    for value in &values {\n        assert_normalized_eq(\n            ExtendedFloat::from_float(*value),\n            ExtendedFloat::from_float(*value as f64),\n        );\n    }\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call", "code": "fn run_test_typed(wasm_fn: Func, mut store: &mut Store<()>, wasm_trap: bool) {\n    let invocation = wasm_fn\n        .typed::<i32, i32>(&store)\n        .unwrap()\n        .call_resumable(&mut store, wasm_trap as i32)\n        .unwrap()\n        .assert_resumable(store, 10, &[ValueType::I32]);\n    let invocation = invocation\n        .resume(&mut store, &[Value::I32(2)])\n        .unwrap()\n        .assert_resumable(store, 20, &[ValueType::I32]);\n    let call = invocation.resume(&mut store, &[Value::I32(3)]);\n    if wasm_trap {\n        match call.unwrap_err() {\n            Error::Trap(trap) => {\n                assert!(matches!(\n                    trap.trap_code(),\n                    Some(TrapCode::UnreachableCodeReached)\n                ));\n            }\n            _ => panic!(\"expected Wasm trap\"),\n        }\n    } else {\n        assert_eq!(call.unwrap().assert_finish(), 4);\n    }\n}", "test": "fn resumable_call() {\n    let (mut store, mut linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, |input: i32| -> Result<i32, Trap> {\n        match input {\n            1 => Err(Trap::i32_exit(10)),\n            2 => Err(Trap::i32_exit(20)),\n            n => Ok(n + 1),\n        }\n    });\n    linker.define(\"env\", \"host_fn\", host_fn).unwrap();\n    let wasm = wat::parse_str(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (param i32) (result i32)))\n            (func (export \"wasm_fn\") (param $wasm_trap i32) (result i32)\n                (local $i i32)\n                (local.set $i (i32.const 0))\n                (local.set $i (call $host_fn (local.get $i))) ;; Ok\n                (local.set $i (call $host_fn (local.get $i))) ;; Trap::i32_exit(1)\n                (local.set $i (call $host_fn (local.get $i))) ;; Trap::i32_exit(2)\n                (local.set $i (call $host_fn (local.get $i))) ;; Ok\n                (if (i32.eq (local.get $wasm_trap) (i32.const 1))\n                    (then unreachable)                        ;; trap in Wasm if $wasm_trap == 1\n                )\n                (local.get $i)                                ;; return i == 4\n            )\n        )\n        \"#,\n    )\n    .unwrap();\n\n    let module = Module::new(store.engine(), &mut &wasm[..]).unwrap();\n    let instance = linker\n        .instantiate(&mut store, &module)\n        .unwrap()\n        .start(&mut store)\n        .unwrap();\n    let wasm_fn = instance\n        .get_export(&store, \"wasm_fn\")\n        .and_then(Extern::into_func)\n        .unwrap();\n\n    run_test(wasm_fn, &mut store, false);\n    run_test(wasm_fn, &mut store, true);\n    run_test_typed(wasm_fn, &mut store, false);\n    run_test_typed(wasm_fn, &mut store, true);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::normalize_test", "code": "fn check_normalize(mant: u64, exp: i32, ymant: u64, yexp: i32) {\n    let mut x = ExtendedFloat80 {\n        mant,\n        exp,\n    };\n    if x.mant != 0 {\n        assert_eq!(x.mant & (1 << 63), 0);\n        compact::normalize(&mut x);\n        assert_eq!(x.mant & (1 << 63), 1 << 63);\n    }\n    assert_eq!(\n        x,\n        ExtendedFloat80 {\n            mant: ymant,\n            exp: yexp\n        }\n    );\n}", "test": "fn normalize_test() {\n    // f32 cases\n    check_normalize(0, 0, 0, 0);\n    check_normalize(1, -149, 9223372036854775808, -212);\n    check_normalize(71362, -149, 10043308644012916736, -196);\n    check_normalize(12379400, -90, 13611294244890214400, -130);\n    check_normalize(8388608, -23, 9223372036854775808, -63);\n    check_normalize(11368684, 43, 12500000250510966784, 3);\n    check_normalize(16777213, 104, 18446740775174668288, 64);\n\n    // Test a few cases from radix float writer errors.\n    check_normalize(5178144, -22, 11386859076597055488, -63);\n\n    // f64 cases\n    check_normalize(1, -1074, 9223372036854775808, -1137);\n    check_normalize(6448907850777164, -883, 13207363278391631872, -894);\n    check_normalize(7371020360979573, -551, 15095849699286165504, -562);\n    check_normalize(6427752177035961, -202, 13164036458569648128, -213);\n    check_normalize(4903985730770844, -185, 10043362776618688512, -196);\n    check_normalize(6646139978924579, -119, 13611294676837537792, -130);\n    check_normalize(4503599627370496, -52, 9223372036854775808, -63);\n    check_normalize(6103515625000000, 14, 12500000000000000000, 3);\n    check_normalize(8271806125530277, 80, 16940658945086007296, 69);\n    check_normalize(5503284107318959, 446, 11270725851789228032, 435);\n    check_normalize(6290184345309700, 778, 12882297539194265600, 767);\n    check_normalize(9007199254740991, 971, 18446744073709549568, 960);\n\n    // Check with errors from power-of-two.\n    check_normalize(72057594037927936, -1078, 9223372036854775808, -1085);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_standalone", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_obs_lines_standalone() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-standalone\";\n    RandomFile::new(&at, name).add_lines(4);\n    ucmd.args(&[\"-2\", name]).succeeds().no_stderr().no_stdout();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::semicolon_expression_stop", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn semicolon_expression_stop() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            var a = 1;\n            + 1;\n            a\n        \"#},\n        1,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_store_resolve_with_illegal_tso", "code": "pub fn resolve_lock_with_illegal_tso(\n        &self,\n        start_ts: impl Into<TimeStamp>,\n        commit_ts: Option<impl Into<TimeStamp>>,\n    ) {\n        let start_ts = start_ts.into();\n        let commit_ts = commit_ts.map(Into::into);\n        let resp = self\n            .store\n            .resolve_lock(self.ctx.clone(), start_ts, commit_ts);\n        self.expect_invalid_tso_err(resp, start_ts, commit_ts.unwrap())\n    }", "test": "fn test_store_resolve_with_illegal_tso() {\n    let store = AssertionStorage::default();\n    let commit_ts = Some(4);\n    let start_ts = 5;\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"primary\"), b\"p-5\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"secondary\"), b\"s-5\".to_vec()),\n        ],\n        b\"primary\",\n        start_ts,\n    );\n    store.resolve_lock_with_illegal_tso(start_ts, commit_ts);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_gc_metrics.rs::test_txn_gc_keys_handled", "code": "fn get(&self, mut req: Get) -> PdFuture<GetResponse> {\n        let timer = Instant::now();\n        self.fill_cluster_id_for(req.inner.mut_header());\n        let executor = move |client: &Client, req: GetRequest| {\n            let handler = {\n                let inner = client.inner.rl();\n                let r = inner\n                    .meta_storage\n                    .get_async_opt(&req, call_option_inner(&inner));\n                futures::future::ready(r).err_into().try_flatten()\n            };\n            Box::pin(async move {\n                fail::fail_point!(\"meta_storage_get\", req.key.ends_with(b\"rejectme\"), |_| {\n                    Err(super::Error::Grpc(grpcio::Error::RemoteStopped))\n                });\n                let resp = handler.await?;\n                PD_REQUEST_HISTOGRAM_VEC\n                    .meta_storage_get\n                    .observe(timer.saturating_elapsed_secs());\n                Ok(resp)\n            }) as _\n        };\n\n        self.pd_client\n            .request(req.into(), executor, LEADER_CHANGE_RETRY)\n            .execute()\n    }", "test": "fn test_txn_gc_keys_handled() {\n    let store_id = 1;\n    GC_COMPACTION_FILTER_MVCC_DELETION_MET.reset();\n    GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED.reset();\n\n    let engine = TestEngineBuilder::new().build().unwrap();\n    let mut prefixed_engine = PrefixedEngine(engine.clone());\n\n    let (tx, _rx) = mpsc::channel();\n    let feature_gate = FeatureGate::default();\n    feature_gate.set_version(\"5.0.0\").unwrap();\n    let mut gc_worker = GcWorker::new(\n        prefixed_engine.clone(),\n        tx,\n        GcConfig::default(),\n        feature_gate,\n        Arc::new(MockRegionInfoProvider::new(vec![])),\n    );\n    gc_worker.start(store_id).unwrap();\n\n    let mut r1 = Region::default();\n    r1.set_id(1);\n    r1.mut_region_epoch().set_version(1);\n    r1.set_start_key(b\"\".to_vec());\n    r1.set_end_key(b\"\".to_vec());\n    r1.mut_peers().push(Peer::default());\n    r1.mut_peers()[0].set_store_id(store_id);\n\n    let sp_provider = MockSafePointProvider(200);\n    let mut host = CoprocessorHost::<RocksEngine>::default();\n    let ri_provider = RegionInfoAccessor::new(&mut host);\n    let auto_gc_cfg = AutoGcConfig::new(sp_provider, ri_provider, 1);\n    let safe_point = Arc::new(AtomicU64::new(500));\n\n    gc_worker.start_auto_gc(auto_gc_cfg, safe_point).unwrap();\n    host.on_region_changed(&r1, RegionChangeEvent::Create, StateRole::Leader);\n\n    let db = engine.kv_engine().unwrap().as_inner().clone();\n    let cf = get_cf_handle(&db, CF_WRITE).unwrap();\n\n    for i in 0..3 {\n        let k = format!(\"k{:02}\", i).into_bytes();\n        must_prewrite_put(&mut prefixed_engine, &k, b\"value\", &k, 101);\n        must_commit(&mut prefixed_engine, &k, 101, 102);\n        must_prewrite_delete(&mut prefixed_engine, &k, &k, 151);\n        must_commit(&mut prefixed_engine, &k, 151, 152);\n    }\n\n    db.flush_cf(cf, true, false).unwrap();\n\n    db.compact_range_cf(cf, None, None);\n\n    // This compaction can schedule gc task\n    db.compact_range_cf(cf, None, None);\n    thread::sleep(Duration::from_millis(100));\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_MVCC_DELETION_MET\n            .with_label_values(&[STAT_TXN_KEYMODE])\n            .get(),\n        6\n    );\n\n    assert_eq!(\n        GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED\n            .with_label_values(&[STAT_TXN_KEYMODE])\n            .get(),\n        3\n    );\n\n    GC_COMPACTION_FILTER_MVCC_DELETION_MET.reset();\n    GC_COMPACTION_FILTER_MVCC_DELETION_HANDLED.reset();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_fetch.rs::test_node_compact_entry_cache", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_node_compact_entry_cache() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(50);\n    cluster.cfg.raft_store.raft_log_reserve_max_ticks = 2;\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_remove_peer(1, new_peer(5, 5));\n\n    // pause snapshot applied\n    fail::cfg(\"before_region_gen_snap\", \"pause\").unwrap();\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    // change one peer to learner\n    cluster.pd_client.add_peer(1, new_learner_peer(5, 5));\n\n    // cause log lag and pause async fetch to check if entry cache is reserved for\n    // the learner\n    for i in 1..6 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n    }\n    std::thread::sleep(Duration::from_millis(100));\n\n    fail::remove(\"before_region_gen_snap\");\n    cluster.pd_client.must_have_peer(1, new_learner_peer(5, 5));\n\n    // if entry cache is not reserved, the learner will not be able to catch up.\n    must_get_equal(&cluster.get_engine(5), b\"5\", b\"5\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_linter_is_disabled_when_run_apply", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn no_lint_if_linter_is_disabled_when_run_apply() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled_when_run_apply\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_comm.rs::no_arguments", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn no_arguments() {\n    new_ucmd!().fails().no_stdout();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_local_read.rs::test_consistency_after_lease_pass", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_consistency_after_lease_pass() {\n    let mut cluster = new_server_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run();\n    let leader = new_peer(1, 1);\n    cluster.must_transfer_leader(1, leader);\n\n    // Create clients.\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(Arc::clone(&env)).connect(&cluster.sim.rl().get_addr(1));\n    let client = TikvClient::new(channel);\n\n    let region = cluster.get_region(&b\"key1\"[..]);\n    let region_id = region.id;\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_peer(leader.clone());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n\n    must_raw_put(&client, ctx.clone(), b\"key1\".to_vec(), b\"value1\".to_vec());\n    must_get_equal(&cluster.get_engine(1), b\"key1\", b\"value1\");\n\n    // Ensure the request is executed by the local reader\n    fail::cfg(\"localreader_before_redirect\", \"panic\").unwrap();\n\n    // Lease read works correctly\n    assert_eq!(\n        must_raw_get(&client, ctx.clone(), b\"key1\".to_vec()).unwrap(),\n        b\"value1\".to_vec()\n    );\n\n    // we pause just after pass the lease check, and then remove the peer. We can\n    // still read the relevant value as we should have already got the snapshot when\n    // passing the lease check.\n    fail::cfg(\"after_pass_lease_check\", \"pause\").unwrap();\n\n    let mut get_req = RawGetRequest::default();\n    get_req.set_context(ctx);\n    get_req.key = b\"key1\".to_vec();\n    let mut receiver = client.raw_get_async(&get_req).unwrap();\n\n    thread::sleep(Duration::from_millis(200));\n\n    let mut peer = leader.clone();\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n    pd_client.must_remove_peer(region_id, leader);\n    peer.id = 1000;\n    // After we pass the lease check, we should have got the snapshot, so the data\n    // that the region contains cannot be deleted.\n    // So we need to add the new peer for this region and stop before applying the\n    // snapshot so that the old data will be deleted and the snapshot data has not\n    // been written.\n    fail::cfg(\"apply_snap_cleanup_range\", \"pause\").unwrap();\n    pd_client.must_add_peer(region_id, peer);\n\n    // Wait for data to be cleaned\n    must_get_none(&cluster.get_engine(1), b\"key1\");\n    fail::cfg(\"after_pass_lease_check\", \"off\").unwrap();\n\n    assert_eq!(b\"value1\", receiver.receive_sync().unwrap().1.get_value());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_string_operator_is_literal_after_bang", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_string_operator_is_literal_after_bang() {\n    let scenario = TestScenario::new(util_name!());\n    let tests = [\n        [\"!\", \"=\"],\n        [\"!\", \"!=\"],\n        [\"!\", \"-eq\"],\n        [\"!\", \"-ne\"],\n        [\"!\", \"-lt\"],\n        [\"!\", \"-le\"],\n        [\"!\", \"-gt\"],\n        [\"!\", \"-ge\"],\n        [\"!\", \"-ef\"],\n        [\"!\", \"-nt\"],\n        [\"!\", \"-ot\"],\n    ];\n\n    for test in &tests {\n        scenario.ucmd().args(&test[..]).run().code_is(1);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_async_io.rs::test_async_io_commit_without_leader_persist", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_async_io_commit_without_leader_persist() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.cmd_batch_concurrent_ready_max_count = 0;\n    cluster.cfg.raft_store.store_io_pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    let peer_1 = find_peer(&region, 1).cloned().unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_transfer_leader(region.get_id(), peer_1);\n\n    let raft_before_save_on_store_1_fp = \"raft_before_save_on_store_1\";\n    fail::cfg(raft_before_save_on_store_1_fp, \"pause\").unwrap();\n\n    for i in 2..10 {\n        cluster\n            .async_put(format!(\"k{}\", i).as_bytes(), b\"v1\")\n            .unwrap();\n    }\n\n    // Although leader can not persist entries, these entries can be committed\n    must_get_equal(&cluster.get_engine(2), b\"k9\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k9\", b\"v1\");\n    // For now, entries must be applied after persisting\n    must_get_none(&cluster.get_engine(1), b\"k9\");\n\n    fail::remove(raft_before_save_on_store_1_fp);\n    must_get_equal(&cluster.get_engine(3), b\"k9\", b\"v1\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hashsum.rs::test_tag", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tag() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.write(\"foobar\", \"foo bar\\n\");\n    scene\n        .ccmd(\"sha256sum\")\n        .arg(\"--tag\")\n        .arg(\"foobar\")\n        .succeeds()\n        .stdout_is(\n            \"SHA256 (foobar) = 1f2ec52b774368781bed1d1fb140a92e0eb6348090619c9291f9a5a3c8e8d151\\n\",\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_long_format_multiple_users", "code": "pub fn stderr_str(&self) -> &str {\n        std::str::from_utf8(&self.stderr).unwrap()\n    }", "test": "fn test_long_format_multiple_users() {\n    // multiple instances of one account we know exists,\n    // the account of the test runner,\n    // and an account that (probably) doesn't exist\n    let runner = match std::env::var(\"USER\") {\n        Ok(user) => user,\n        Err(_) => String::new(),\n    };\n    let args = [\"-l\", \"root\", \"root\", \"root\", &runner, \"no_such_user\"];\n    let ts = TestScenario::new(util_name!());\n    let expect = unwrap_or_return!(expected_result(&ts, &args));\n\n    ts.ucmd()\n        .args(&args)\n        .succeeds()\n        .stdout_is(expect.stdout_str())\n        .stderr_is(expect.stderr_str());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_stdin_squeeze_blank", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_stdin_squeeze_blank() {\n    for same_param in [\"-s\", \"--squeeze-blank\", \"--squeeze\"] {\n        new_ucmd!()\n            .arg(same_param)\n            .pipe_in(\"\\n\\na\\n\\n\\n\\n\\nb\\n\\n\\n\")\n            .succeeds()\n            .stdout_only(\"\\na\\n\\nb\\n\\n\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_mkdir_parent() {\n    let _guard = TEST_MUTEX.lock();\n    let scene = TestScenario::new(util_name!());\n    let test_dir = \"parent_dir/child_dir\";\n\n    scene.ucmd().arg(\"-p\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"-p\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"--parent\").arg(test_dir).succeeds();\n    scene.ucmd().arg(\"--parents\").arg(test_dir).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_with_tab", "code": "pub fn stdout_does_not_contain<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            !self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' contains '{}' but should not\",\n            self.stdout_str(),\n            cmp.as_ref(),\n        );\n        self\n    }", "test": "fn test_with_tab() {\n    new_ucmd!()\n        .arg(\"with-tab.txt\")\n        .succeeds()\n        .stdout_contains(\"        \")\n        .stdout_does_not_contain(\"\\t\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_existing", "code": "pub fn root_dir_resolved(&self) -> String {\n        log_info(\"current_directory_resolved\", \"\");\n        let s = self\n            .subdir\n            .canonicalize()\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .to_owned();\n\n        // Due to canonicalize()'s use of GetFinalPathNameByHandleW() on Windows, the resolved path\n        // starts with '\\\\?\\' to extend the limit of a given path to 32,767 wide characters.\n        //\n        // To address this issue, we remove this prepended string if available.\n        //\n        // Source:\n        // http://stackoverflow.com/questions/31439011/getfinalpathnamebyhandle-without-prepended\n        let prefix = \"\\\\\\\\?\\\\\";\n\n        if let Some(stripped) = s.strip_prefix(prefix) {\n            String::from(stripped)\n        } else {\n            s\n        }\n    }", "test": "fn test_canonicalize_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let actual = ucmd.arg(\"-e\").arg(\".\").run().stdout_move_str();\n    let expect = at.root_dir_resolved() + \"\\n\";\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    assert_eq!(actual, expect);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_axfr_refused", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "async fn test_axfr_refused() {\n    let mut test = create_test();\n    test.set_allow_axfr(false);\n\n    let origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(test)));\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n    query.set_query_type(RecordType::AXFR);\n\n    let mut question: Message = Message::new();\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::Refused);\n    assert!(result.answers().is_empty());\n    assert!(result.name_servers().is_empty());\n    assert!(result.additionals().is_empty());\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::dont_ignore_comments_in_recipe_by_default", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn dont_ignore_comments_in_recipe_by_default() {\n  Test::new()\n    .justfile(\n      \"\n      some_recipe:\n        # A recipe-internal comment\n        echo something-useful\n    \",\n    )\n    .stdout(\"something-useful\\n\")\n    .stderr(\"# A recipe-internal comment\\necho something-useful\\n\")\n    .run();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_nan_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::roundtrip", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn roundtrip() {\n    use ron::{de::from_str, ser::to_string};\n\n    {\n        let s = to_string(&Scene2 {\n            foo: Some((122, 13)),\n        })\n        .unwrap();\n        println!(\"{}\", s);\n        let scene: Value = from_str(&s).unwrap();\n        println!(\"{:?}\", scene);\n    }\n    {\n        let s = to_string(&Scene(Some((13, 122)))).unwrap();\n        println!(\"{}\", s);\n        let scene: Value = from_str(&s).unwrap();\n        println!(\"{:?}\", scene);\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_empty_template", "code": "pub fn parse(input: &str) -> TeraResult<Vec<Node>> {\n    let mut pairs = match TeraParser::parse(Rule::template, input) {\n        Ok(p) => p,\n        Err(e) => {\n            let fancy_e = e.renamed_rules(|rule| {\n                match *rule {\n                    Rule::EOI => \"end of input\".to_string(),\n                    Rule::int => \"an integer\".to_string(),\n                    Rule::float => \"a float\".to_string(),\n                    Rule::string\n                    | Rule::double_quoted_string\n                    | Rule::single_quoted_string\n                    | Rule::backquoted_quoted_string => {\n                        \"a string\".to_string()\n                    }\n                    Rule::string_concat => \"a concatenation of strings\".to_string(),\n                    Rule::string_expr_filter => \"a string or a concatenation of strings\".to_string(),\n                    Rule::all_chars => \"a character\".to_string(),\n                    Rule::array => \"an array of values\".to_string(),\n                    Rule::array_filter => \"an array of values with an optional filter\".to_string(),\n                    Rule::string_array => \"an array of strings\".to_string(),\n                    Rule::basic_val => \"a value\".to_string(),\n                    Rule::basic_op => \"a mathematical operator\".to_string(),\n                    Rule::comparison_op => \"a comparison operator\".to_string(),\n                    Rule::boolean => \"`true` or `false`\".to_string(),\n                    Rule::ident => \"an identifier (must start with a-z)\".to_string(),\n                    Rule::dotted_ident => \"a dotted identifier (identifiers separated by `.`)\".to_string(),\n                    Rule::dotted_square_bracket_ident => \"a square bracketed identifier (identifiers separated by `.` or `[]`s)\".to_string(),\n                    Rule::square_brackets => \"an identifier, string or integer inside `[]`s\".to_string(),\n                    Rule::basic_expr_filter => \"an expression with an optional filter\".to_string(),\n                    Rule::comparison_val => \"a comparison value\".to_string(),\n                    Rule::basic_expr | Rule::comparison_expr => \"an expression\".to_string(),\n                    Rule::logic_val => \"a value that can be negated\".to_string(),\n                    Rule::logic_expr => \"any expressions\".to_string(),\n                    Rule::fn_call => \"a function call\".to_string(),\n                    Rule::kwarg => \"a keyword argument: `key=value` where `value` can be any expressions\".to_string(),\n                    Rule::kwargs => \"a list of keyword arguments: `key=value` where `value` can be any expressions and separated by `,`\".to_string(),\n                    Rule::op_or => \"`or`\".to_string(),\n                    Rule::op_and => \"`and`\".to_string(),\n                    Rule::op_not => \"`not`\".to_string(),\n                    Rule::op_lte => \"`<=`\".to_string(),\n                    Rule::op_gte => \"`>=`\".to_string(),\n                    Rule::op_lt => \"`<`\".to_string(),\n                    Rule::op_gt => \"`>`\".to_string(),\n                    Rule::op_ineq => \"`!=`\".to_string(),\n                    Rule::op_eq => \"`==`\".to_string(),\n                    Rule::op_plus => \"`+`\".to_string(),\n                    Rule::op_minus => \"`-`\".to_string(),\n                    Rule::op_times => \"`*`\".to_string(),\n                    Rule::op_slash => \"`/`\".to_string(),\n                    Rule::op_modulo => \"`%`\".to_string(),\n                    Rule::filter => \"a filter\".to_string(),\n                    Rule::test => \"a test\".to_string(),\n                    Rule::test_not => \"a negated test\".to_string(),\n                    Rule::test_call => \"a test call\".to_string(),\n                    Rule::test_arg => \"a test argument (any expressions including arrays)\".to_string(),\n                    Rule::test_args => \"a list of test arguments (any expression including arrayss)\".to_string(),\n                    Rule::macro_fn | Rule::macro_fn_wrapper => \"a macro function\".to_string(),\n                    Rule::macro_call => \"a macro function call\".to_string(),\n                    Rule::macro_def_arg => {\n                        \"an argument name with an optional default literal value: `id`, `key=1`\".to_string()\n                    }\n                    Rule::macro_def_args => {\n                        \"a list of argument names with an optional default literal value: `id`, `key=1`\".to_string()\n                    }\n                    Rule::endmacro_tag => \"`{% endmacro %}`\".to_string(),\n                    Rule::macro_content => \"the macro content\".to_string(),\n                    Rule::filter_section_content => \"the filter section content\".to_string(),\n                    Rule::set_tag => \"a `set` tag`\".to_string(),\n                    Rule::set_global_tag => \"a `set_global` tag`\".to_string(),\n                    Rule::block_content | Rule::content | Rule::for_content => {\n                        \"some content\".to_string()\n                    },\n                    Rule::text => \"some text\".to_string(),\n                    // Pest will error an unexpected tag as Rule::tag_start\n                    // and just showing `{%` is not clear as some other valid\n                    // tags will also start with `{%`\n                    Rule::tag_start => \"tag\".to_string(),\n                    Rule::tag_end => \"`%}` or `-%}`\".to_string(),\n                    Rule::super_tag => \"`{{ super() }}`\".to_string(),\n                    Rule::raw_tag => \"`{% raw %}`\".to_string(),\n                    Rule::raw_text => \"some raw text\".to_string(),\n                    Rule::raw => \"a raw block (`{% raw %}...{% endraw %}`\".to_string(),\n                    Rule::endraw_tag => \"`{% endraw %}`\".to_string(),\n                    Rule::ignore_missing => \"ignore missing mark for include tag\".to_string(),\n                    Rule::include_tag => r#\"an include tag (`{% include \"...\" %}`)\"#.to_string(),\n                    Rule::comment_tag => \"a comment tag (`{#...#}`)\".to_string(),\n                    Rule::comment_text => \"the context of a comment (`{# ... #}`)\".to_string(),\n                    Rule::variable_tag => \"a variable tag (`{{ ... }}`)\".to_string(),\n                    Rule::filter_tag | Rule::filter_section => {\n                        \"a filter section (`{% filter something %}...{% endfilter %}`)\".to_string()\n                    }\n                    Rule::for_tag | Rule::forloop => {\n                        \"a forloop (`{% for i in something %}...{% endfor %}\".to_string()\n                    },\n                    Rule::endfilter_tag => \"an endfilter tag (`{% endfilter %}`)\".to_string(),\n                    Rule::endfor_tag => \"an endfor tag (`{% endfor %}`)\".to_string(),\n                    Rule::if_tag\n                    | Rule::content_if\n                    | Rule::block_if\n                    | Rule::macro_if\n                    | Rule::for_if\n                    | Rule::filter_section_if => {\n                        \"a `if` tag\".to_string()\n                    }\n                    Rule::elif_tag => \"an `elif` tag\".to_string(),\n                    Rule::else_tag => \"an `else` tag\".to_string(),\n                    Rule::endif_tag => \"an endif tag (`{% endif %}`)\".to_string(),\n                    Rule::WHITESPACE => \"whitespace\".to_string(),\n                    Rule::variable_start => \"a variable start (`{{`)\".to_string(),\n                    Rule::variable_end => \"a variable end (`}}`)\".to_string(),\n                    Rule::comment_start => \"a comment start (`{#`)\".to_string(),\n                    Rule::comment_end => \"a comment end (`#}`)\".to_string(),\n                    Rule::block_start => \"`{{`, `{%` or `{#`\".to_string(),\n                    Rule::import_macro_tag => r#\"an import macro tag (`{% import \"filename\" as namespace %}`\"#.to_string(),\n                    Rule::block | Rule::block_tag => r#\"a block tag (`{% block block_name %}`\"#.to_string(),\n                    Rule::endblock_tag => r#\"an endblock tag (`{% endblock block_name %}`\"#.to_string(),\n                    Rule::macro_definition\n                    | Rule::macro_tag => r#\"a macro definition tag (`{% macro my_macro() %}`\"#.to_string(),\n                    Rule::extends_tag => r#\"an extends tag (`{% extends \"myfile\" %}`\"#.to_string(),\n                    Rule::template => \"a template\".to_string(),\n                    Rule::break_tag => \"a break tag\".to_string(),\n                    Rule::continue_tag => \"a continue tag\".to_string(),\n                    Rule::top_imports => \"top imports\".to_string(),\n                    Rule::in_cond => \"a `in` condition\".to_string(),\n                    Rule::in_cond_container => \"a `in` condition container: a string, an array or an ident\".to_string(),\n                }\n            });\n            return Err(Error::msg(fancy_e));\n        }\n    };\n\n    let mut nodes = vec![];\n\n    // We must have at least a `template` pair if we got there\n    for p in pairs.next().unwrap().into_inner() {\n        match p.as_rule() {\n            Rule::extends_tag => nodes.push(parse_extends(p)),\n            Rule::import_macro_tag => nodes.push(parse_import_macro(p)),\n            Rule::content => nodes.extend(parse_content(p)?),\n            Rule::comment_tag => (),\n            Rule::EOI => (),\n            _ => unreachable!(\"unknown tpl rule: {:?}\", p.as_rule()),\n        }\n    }\n\n    Ok(nodes)\n}", "test": "fn parse_empty_template() {\n    let ast = parse(\"\").unwrap();\n    assert_eq!(ast.len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_backup_arg_first", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_arg_backup_arg_first() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a\";\n    let file_b = \"test_mv_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup\").arg(file_a).arg(file_b).succeeds();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/class.rs::class_declaration_elements_private", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn class_declaration_elements_private() {\n    test_formatting(\n        r#\"\n        class A {\n            #a;\n            #b = 1;\n            #c() {}\n            #d(a, b, c) {\n                return a + b + c;\n            }\n            set #e(value) {}\n            get #e() {}\n        }\n        \"#,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_no_such_dir", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_no_such_dir() {\n    new_ucmd!()\n        .args(&[\"-s\", \"0\", \"a/b\"])\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"cannot open 'a/b' for writing: No such file or directory\");\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue343", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "test": "fn issue343() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Users {\n        users: HashMap<String, User>,\n    }\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Max(u16);\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct User {\n        max: Max,\n    }\n\n    let xml = \"<Users>\\\n                        <users>\\\n                            <roger>\\\n                                <max>10</max>\\\n                            </roger>\\\n                        </users>\\\n                    </Users>\";\n    let users: Users = from_str(xml).unwrap();\n\n    assert_eq!(\n        users,\n        Users {\n            users: HashMap::from([(\"roger\".to_string(), User { max: Max(10) })]),\n        }\n    );\n    assert_eq!(to_string(&users).unwrap(), xml);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_3", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_3() {\n    let original = r##\"# H1 # {#id1}\n## H2 ## with ## multiple ## hashes ## {#id2}\n### with trailing hash # ### {#id3}\n\n#### non-attribute-block {#id4} ####\n\"##;\n    let expected = r##\"<h1 id=\"id1\">H1</h1>\n<h2 id=\"id2\">H2 ## with ## multiple ## hashes</h2>\n<h3 id=\"id3\">with trailing hash #</h3>\n<h4>non-attribute-block {#id4}</h4>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fmt.rs::test_fmt_invalid_goal", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_fmt_invalid_goal() {\n    for param in [\"-g\", \"--goal\"] {\n        new_ucmd!()\n            .args(&[\"one-word-per-line.txt\", param, \"invalid\"])\n            .fails()\n            .code_is(1)\n            .stderr_contains(\"invalid value 'invalid'\");\n    }\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::large_mul_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn large_mul_test() {\n    // Test by empty\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::new();\n    bigint::large_mul(&mut x, &y);\n    let expected = VecType::new();\n    assert_eq!(&*x, &*expected);\n\n    // Simple case\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(5);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);\n    assert_eq!(&*x, &*expected);\n\n    // Large u32, but still just as easy.\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(0xFFFFFFFE);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType = vec_from_u32(&[0x2, 0xFFFFFFFD]);\n    assert_eq!(&*x, &*expected);\n\n    // Let's multiply two large values together.\n    let mut x: VecType = vec_from_u32(&[0xFFFFFFFE, 0x0FFFFFFF, 1]);\n    let y: VecType = vec_from_u32(&[0x99999999, 0x99999999, 0xCCCD9999, 0xCCCC]);\n    bigint::large_mul(&mut x, &y);\n    let expected: VecType =\n        vec_from_u32(&[0xCCCCCCCE, 0x5CCCCCCC, 0x9997FFFF, 0x33319999, 0x999A7333, 0xD999]);\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::signature_lifetimes", "code": "pub(crate) fn commit(\n        &self,\n        data_root: Option<(PageNumber, Checksum)>,\n        system_root: Option<(PageNumber, Checksum)>,\n        freed_root: Option<(PageNumber, Checksum)>,\n        transaction_id: TransactionId,\n        eventual: bool,\n        two_phase: bool,\n    ) -> Result {\n        let result = self.commit_inner(\n            data_root,\n            system_root,\n            freed_root,\n            transaction_id,\n            eventual,\n            two_phase,\n        );\n        if result.is_err() {\n            self.needs_recovery.store(true, Ordering::Release);\n        }\n        result\n    }", "test": "fn signature_lifetimes() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n\n        let _ = {\n            let key = \"hi\".to_string();\n            let value = \"1\".to_string();\n            table.insert(key.as_str(), value.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.get(key.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.remove(key.as_str()).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.range(key.as_str()..).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.drain(key.as_str()..).unwrap()\n        };\n\n        let _ = {\n            let key = \"hi\".to_string();\n            table.drain_filter(key.as_str().., |_, _| true).unwrap()\n        };\n    }\n    write_txn.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_user_id", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_only_user_id() {\n    // test chown 1111 file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    let result = scene.ucmd().arg(user_id).arg(\"--verbose\").arg(file1).run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"0\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mysql.rs::parse_identifiers", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_identifiers() {\n    mysql().verified_stmt(\"SELECT $a$, \u00e0\u00e0\");\n}\n\n"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_ignore_block_size_from_env_in_posix_portability_mode", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "test": "fn test_ignore_block_size_from_env_in_posix_portability_mode() {\n    let default_block_size_header = \"1024-blocks\";\n\n    let output = new_ucmd!()\n        .arg(\"-P\")\n        .env(\"DF_BLOCK_SIZE\", \"111\")\n        .env(\"BLOCK_SIZE\", \"222\")\n        .env(\"BLOCKSIZE\", \"333\")\n        .succeeds()\n        .stdout_move_str();\n    let header = output\n        .lines()\n        .next()\n        .unwrap()\n        .to_string()\n        .split_whitespace()\n        .nth(1)\n        .unwrap()\n        .trim()\n        .to_string();\n\n    assert_eq!(header, default_block_size_header);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_key_live", "code": "pub fn contains_key(&self, key: &JsValue) -> bool {\n        self.map.contains_key(key)\n    }", "test": "fn weak_map_key_live() {\n    run_test(|| {\n        let key = Gc::new(String::from(\"key\"));\n        let key_copy = key.clone();\n\n        let mut map = WeakMap::new();\n\n        map.insert(&key, ());\n\n        assert!(map.contains_key(&key));\n        assert!(map.contains_key(&key_copy));\n\n        assert_eq!(map.remove(&key), Some(()));\n\n        map.insert(&key, ());\n\n        drop(key);\n\n        force_collect();\n\n        assert!(map.contains_key(&key_copy));\n    });\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_negative_offset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%23%-3\"])\n        .succeeds()\n        .stdout_only(\"93\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 1);\n    assert_eq!(at.read(\"xx00\"), generate(20, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_relative_dst_already_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_relative_dst_already_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"file1\");\n    at.symlink_file(\"file1\", \"file2\");\n    ucmd.arg(\"-srf\").arg(\"file1\").arg(\"file2\").succeeds();\n    at.is_symlink(\"file2\");\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_taptree", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_taptree() {\n    let ver = LeafVersion::from_consensus(0).unwrap();\n    let script = ScriptBuf::from(vec![0u8, 1u8, 2u8]);\n    let mut builder = TaprootBuilder::new().add_leaf_with_ver(1, script.clone(), ver).unwrap();\n    builder = builder.add_leaf(1, script).unwrap();\n    let tree = TapTree::try_from(builder).unwrap();\n\n    let got = serialize(&tree).unwrap();\n    let want = include_bytes!(\"data/serde/taptree_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_multiple_name_value_pairs", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_multiple_name_value_pairs() {\n    let out = new_ucmd!().arg(\"FOO=bar\").arg(\"ABC=xyz\").run();\n\n    assert_eq!(\n        out.stdout_str()\n            .lines()\n            .filter(|&line| line == \"FOO=bar\" || line == \"ABC=xyz\")\n            .count(),\n        2\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::funcs_live_on_to_fight_another_day", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "test": "fn funcs_live_on_to_fight_another_day() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    let drop_me = DropMe(flag.clone());\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &drop_me;\n    })?;\n    assert_eq!(flag.load(SeqCst), 0);\n\n    let get_and_call = || -> Result<()> {\n        assert_eq!(flag.load(SeqCst), 0);\n        let mut store = Store::new(&engine, ());\n        let func = linker.get(&mut store, \"\", \"\").unwrap();\n        func.into_func().unwrap().call(&mut store, &[], &mut [])?;\n        assert_eq!(flag.load(SeqCst), 0);\n        Ok(())\n    };\n\n    get_and_call()?;\n    get_and_call()?;\n    drop(linker);\n    assert_eq!(flag.load(SeqCst), 1);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_symlink_non_existing_file_recursive", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_chmod_symlink_non_existing_file_recursive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let non_existing = \"test_chmod_symlink_non_existing_file_recursive\";\n    let test_symlink = \"test_chmod_symlink_non_existing_file_recursive_symlink\";\n    let test_directory = \"test_chmod_symlink_non_existing_file_directory\";\n\n    at.mkdir(test_directory);\n    at.symlink_file(non_existing, &format!(\"{test_directory}/{test_symlink}\"));\n\n    // this should succeed\n    scene\n        .ucmd()\n        .arg(\"-R\")\n        .arg(\"755\")\n        .arg(test_directory)\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    let expected_stdout = &format!(\n        // spell-checker:disable-next-line\n        \"mode of '{test_directory}' retained as 0755 (rwxr-xr-x)\"\n    );\n\n    // '-v': this should succeed without stderr\n    scene\n        .ucmd()\n        .arg(\"-R\")\n        .arg(\"-v\")\n        .arg(\"755\")\n        .arg(test_directory)\n        .succeeds()\n        .stdout_contains(expected_stdout)\n        .no_stderr();\n\n    // '-vf': this should be the same than with just '-v'\n    scene\n        .ucmd()\n        .arg(\"-R\")\n        .arg(\"-v\")\n        .arg(\"-f\")\n        .arg(\"755\")\n        .arg(test_directory)\n        .succeeds()\n        .stdout_contains(expected_stdout)\n        .no_stderr();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_hard_logical_non_exit_fail", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_hard_logical_non_exit_fail() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"/no-such-dir\";\n    let link = \"hard-to-dangle\";\n\n    at.relative_symlink_dir(file_a, \"no-such-dir\");\n\n    scene\n        .ucmd()\n        .args(&[\"-L\", \"no-such-dir\", link])\n        .fails()\n        .stderr_contains(\"failed to access 'no-such-dir'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base32.rs::test_garbage", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_garbage() {\n    let input = \"aGVsbG8sIHdvcmxkIQ==\\0\"; // spell-checker:disable-line\n    new_ucmd!()\n        .arg(\"-d\")\n        .pipe_in(input)\n        .fails()\n        .stderr_only(\"base32: error: invalid input\\n\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_unknown_type", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "test": "fn test_server_unknown_type() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {ipaddr}\");\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n        .name(\"test_server:udp:server\".to_string())\n        .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n        .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n    let client_result = client\n        .query(\n            &Name::from_str(\"www.example.com.\").unwrap(),\n            DNSClass::IN,\n            RecordType::Unknown(65535),\n        )\n        .expect(\"query failed for unknown\");\n\n    assert_eq!(client_result.response_code(), ResponseCode::NoError);\n    assert_eq!(\n        client_result.queries().first().unwrap().query_type(),\n        RecordType::Unknown(65535)\n    );\n    assert!(client_result.answers().is_empty());\n    assert!(!client_result.name_servers().is_empty());\n    // SOA should be the first record in the response\n    assert_eq!(\n        client_result\n            .name_servers()\n            .first()\n            .expect(\"no SOA present\")\n            .record_type(),\n        RecordType::SOA\n    );\n\n    server_continue.store(false, Ordering::Relaxed);\n    server_thread.join().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_number_l", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nl_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=\\n\", \"fivelines.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_trailing_space_0", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_trailing_space_0() {\n    // evil\n    // Individual spaces before fields starting with non blanks should not be\n    // converted, unless they are at the beginning of the line.\n    new_ucmd!()\n        .args(&[\"-t4\"])\n        .pipe_in(\"123 \\t1\\n123 1\\n123 \\n123 \")\n        .run()\n        .stdout_is(\"123\\t\\t1\\n123 1\\n123 \\n123 \");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_failed", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_failed() {\n    new_ucmd!().fails();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_adjacently_a_ser", "code": "fn test_ser<T: Serialize>(value: &T, expected: &str) {\n    let actual = to_string(value).expect(\"Failed to serialize\");\n    assert_eq!(actual, expected);\n}", "test": "fn test_adjacently_a_ser() {\n    let v = EnumStructAdjacently::VariantA {\n        foo: 1,\n        bar: 2,\n        different: Inner::Foo,\n    };\n    let e = \"(type:VariantA,content:(foo:1,bar:2,different:Foo))\";\n    test_ser(&v, e);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_header_error_if_negative", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_header_error_if_negative() {\n    new_ucmd!()\n        .args(&[\"--header=-3\"])\n        .run()\n        .stderr_is(\"numfmt: invalid header value '-3'\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::drop_table_purge", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn drop_table_purge() {\n    let purge = \"DROP TABLE db.table_name PURGE\";\n    hive().verified_stmt(purge);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::empty_statement", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn empty_statement() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            ;;;let a = 10;;\n            if(a) ;\n            a\n        \"#},\n        10,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible_sync", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_compatible_sync() {\n    new_ucmd!().arg(\"--sync\").succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_batch_raft_fallback", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_batch_raft_fallback() {\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), false);\n    let (mock_server, port) = create_mock_server(service, 60000, 60100).unwrap();\n\n    let mut raft_client = get_raft_client_by_port(port);\n    (0..100).for_each(|_| {\n        raft_client.send(RaftMessage::default()).unwrap();\n        thread::sleep(time::Duration::from_millis(10));\n        raft_client.flush();\n    });\n\n    assert!(msg_count.load(Ordering::SeqCst) > 0);\n    assert_eq!(batch_msg_count.load(Ordering::SeqCst), 0);\n    drop(mock_server)\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_apply_snapshot_with_network_isolation", "code": "pub fn as_bytes(&self) -> Option<BytesRef<'_>> {\n        EvaluableRef::borrow_scalar_value(self)\n    }", "test": "fn test_witness_apply_snapshot_with_network_isolation() {\n    let mut cluster = new_server_cluster(0, 3);\n    configure_for_snapshot(&mut cluster.cfg);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    pd_client.must_add_peer(r1, new_witness_peer(3, 3));\n    // Ensure all peers are initialized.\n    std::thread::sleep(Duration::from_millis(100));\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    for i in 0..20 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n    sleep_ms(500);\n\n    // Ignore witness's MsgAppendResponse, after applying snaphost\n    let dropped_msgs = Arc::new(Mutex::new(Vec::new()));\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(r1, 1)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppendResponse)\n            .reserve_dropped(Arc::clone(&dropped_msgs)),\n    );\n    cluster.sim.wl().add_recv_filter(1, recv_filter);\n\n    cluster.clear_send_filters();\n    // Wait for leader send snapshot.\n    sleep_ms(500);\n\n    cluster.sim.wl().clear_recv_filters(1);\n\n    // Witness's ProgressState must have been changed to Probe\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    for i in 20..25 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_list_all_signals_as_table", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_kill_list_all_signals_as_table() {\n    // Check for a few signals.  Do not try to be comprehensive.\n    new_ucmd!()\n        .arg(\"-t\")\n        .succeeds()\n        .stdout_contains(\"KILL\")\n        .stdout_contains(\"TERM\")\n        .stdout_contains(\"HUP\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_head_invalid_num", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_head_invalid_num() {\n    new_ucmd!()\n        .args(&[\"-c\", \"1024R\", \"emptyfile.txt\"])\n        .fails()\n        .stderr_is(\"head: invalid number of bytes: '1024R'\\n\");\n    new_ucmd!()\n        .args(&[\"-n\", \"1024R\", \"emptyfile.txt\"])\n        .fails()\n        .stderr_is(\"head: invalid number of lines: '1024R'\\n\");\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n        .args(&[\"-c\", \"1Y\", \"emptyfile.txt\"])\n        .fails()\n        .stderr_is(\"head: invalid number of bytes: '1Y': Value too large for defined data type\\n\");\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n        .args(&[\"-n\", \"1Y\", \"emptyfile.txt\"])\n        .fails()\n        .stderr_is(\"head: invalid number of lines: '1Y': Value too large for defined data type\\n\");\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let sizes = [\"1000G\", \"10T\"];\n        for size in &sizes {\n            new_ucmd!().args(&[\"-c\", size]).succeeds();\n        }\n    }\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let sizes = [\"-1000G\", \"-10T\"];\n        for size in &sizes {\n            new_ucmd!()\n                .args(&[\"-c\", size])\n                .fails()\n                .stderr_is(\"head: out of range integral type conversion attempted: number of bytes is too large\\n\");\n        }\n    }\n    new_ucmd!()\n        .args(&[\"-c\", \"-\u00b3\"])\n        .fails()\n        .stderr_is(\"head: invalid number of bytes: '\u00b3'\\n\");\n}\n\n"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_single_quoted_aliases", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_mssql_single_quoted_aliases() {\n    let _ = ms_and_generic().one_statement_parses_to(\"SELECT foo 'alias'\", \"SELECT foo AS 'alias'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nproc.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_sort", "code": "pub fn sort(state: &State, value: Value, kwargs: Kwargs) -> Result<Value, Error> {\n        let mut items = ok!(state.undefined_behavior().try_iter(value).map_err(|err| {\n            Error::new(ErrorKind::InvalidOperation, \"cannot convert value to list\").with_source(err)\n        }))\n        .collect::<Vec<_>>();\n        let case_sensitive = ok!(kwargs.get::<Option<bool>>(\"case_sensitive\")).unwrap_or(false);\n        if let Some(attr) = ok!(kwargs.get::<Option<&str>>(\"attribute\")) {\n            items.sort_by(|a, b| match (a.get_path(attr), b.get_path(attr)) {\n                (Ok(a), Ok(b)) => sort_helper(&a, &b, case_sensitive),\n                _ => Ordering::Equal,\n            });\n        } else {\n            items.sort_by(|a, b| sort_helper(a, b, case_sensitive))\n        }\n        if let Some(true) = ok!(kwargs.get(\"reverse\")) {\n            items.reverse();\n        }\n        ok!(kwargs.assert_all_used());\n        Ok(Value::from(items))\n    }", "test": "fn test_sort() {\n    let mut v = vec![\n        Value::from(100u64),\n        Value::from(80u32),\n        Value::from(30i16),\n        Value::from(true),\n        Value::from(false),\n        Value::from(99i128),\n        Value::from(1000f32),\n    ];\n    v.sort();\n    insta::assert_debug_snapshot!(&v, @r###\"\n    [\n        false,\n        true,\n        30,\n        80,\n        99,\n        100,\n        1000.0,\n    ]\n    \"###);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_nonexistent_file_does_not_exist", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_nonexistent_file_does_not_exist() {\n    new_ucmd!()\n        .args(&[\"-e\", \"nonexistent_file\"])\n        .run()\n        .code_is(1);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::print_error_from_parent_if_recipe_not_found_in_current", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn print_error_from_parent_if_recipe_not_found_in_current() {\n  Test::new()\n    .tree(tree! {\n      bar: {\n        justfile: \"\n          set fallback := true\n\n          baz:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\"foo:\\n echo {{bar}}\")\n    .args([\"foo\"])\n    .current_dir(\"bar\")\n    .stderr(\n      \"\n      error: Variable `bar` not defined\n        |\n      2 |  echo {{bar}}\n        |         ^^^\n    \",\n    )\n    .status(EXIT_FAILURE)\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_once_prompt", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_interactive_once_prompt() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_once_recursive_prompt_file1\";\n    let file2 = \"test_rm_interactive_once_recursive_prompt_file2\";\n    let file3 = \"test_rm_interactive_once_recursive_prompt_file3\";\n    let file4 = \"test_rm_interactive_once_recursive_prompt_file4\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n    at.touch(file4);\n\n    ucmd.arg(\"--interactive=once\")\n        .arg(file1)\n        .arg(file2)\n        .arg(file3)\n        .arg(file4)\n        .pipe_in(\"y\")\n        .succeeds()\n        .stderr_contains(\"remove 4 arguments?\");\n\n    assert!(!at.file_exists(file1));\n    assert!(!at.file_exists(file2));\n    assert!(!at.file_exists(file3));\n    assert!(!at.file_exists(file4));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_skip_to_match_context_overflow", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_skip_to_match_context_overflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%45%+10\"])\n        .fails()\n        .stderr_is(\"csplit: '%45%+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"%45%+10\", \"-k\"])\n        .fails()\n        .stderr_only(\"csplit: '%45%+10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_suffix_length_short_concatenated_with_value", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_suffix_length_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-a4\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]][[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_new_keyword", "code": "pub fn new(lifetime: Lifetime) -> Self {\n        LifetimeParam {\n            attrs: Vec::new(),\n            lifetime,\n            colon_token: None,\n            bounds: Punctuated::new(),\n        }\n    }", "test": "fn ident_new_keyword() {\n    new(\"abstract\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_verbose_slash", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_verbose_slash() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_verbose_slash_directory\";\n    let file_a = &format!(\"{dir}/test_rm_verbose_slash_file_a\");\n\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    let file_a_normalized = &format!(\n        \"{}{}test_rm_verbose_slash_file_a\",\n        dir,\n        std::path::MAIN_SEPARATOR\n    );\n\n    ucmd.arg(\"-r\")\n        .arg(\"-f\")\n        .arg(\"-v\")\n        .arg(&format!(\"{dir}///\"))\n        .succeeds()\n        .stdout_only(format!(\n            \"removed '{file_a_normalized}'\\nremoved directory '{dir}'\\n\"\n        ));\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_default", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_sync_default() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=simple\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::tagged_template", "code": "fn concat() {\n    run_test_actions([\n        TestAction::run_harness(),\n        // Empty ++ Empty\n        TestAction::assert(\"arrayEquals([].concat([]), [])\"),\n        // Empty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([].concat([1]), [1])\"),\n        // NonEmpty ++ Empty\n        TestAction::assert(\"arrayEquals([1].concat([]), [1])\"),\n        // NonEmpty ++ NonEmpty\n        TestAction::assert(\"arrayEquals([1].concat([1]), [1, 1])\"),\n    ]);\n}", "test": "fn tagged_template() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::assert(indoc! {r#\"\n                function tag(t, ...args) {\n                    let a = []\n                    a = a.concat([t[0], t[1], t[2]]);\n                    a = a.concat([t.raw[0], t.raw[1], t.raw[2]]);\n                    a = a.concat([args[0], args[1]]);\n                    return a\n                }\n                let a = 10;\n\n                arrayEquals(\n                    tag`result: ${a} \\x26 ${a+10}`,\n                    [ \"result: \", \" & \", \"\", \"result: \", \" \\\\x26 \", \"\", 10, 20 ]\n                )\n            \"#}),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_not_is_not_empty", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_not_is_not_empty() {\n    new_ucmd!().args(&[\"!\", \"-s\", \"regular_file\"]).succeeds();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_inexact", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_inexact() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    db.engine.put(b\"g\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"f\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"g\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    db.engine.put(b\"g\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    for i in (0..256_usize).step_by(2) {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.delete_range(b\"b\", b\"f\").unwrap();\n    wb.delete_range(&0_usize.to_be_bytes(), &252_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"g\").unwrap().is_some());\n    for i in 0..252_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n    assert!(\n        db.engine\n            .get_value(&252_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&253_usize.to_be_bytes())\n            .unwrap()\n            .is_none()\n    );\n    assert!(\n        db.engine\n            .get_value(&254_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_numbered_with_t", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_numbered_with_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=t\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_continue_outside_loop", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_continue_outside_loop() {\n    assert_err_msg(r#\"{% continue %}\"#, &[\"1:1\", \"{% continue %}\", \"expected a template\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_yes.rs::test_args", "code": "pub fn run(&mut self) -> CmdResult {\n        self.run_no_wait().wait().unwrap()\n    }", "test": "fn test_args() {\n    run(&[\"a\", \"bar\", \"c\"], b\"a bar c\\na bar c\\na ba\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_reboot_majority_followers", "code": "fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };\n\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        // Once we see a response on the wire we know a prevote round is happening.\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with failure prevote notifier, got {:?}\", received);\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during failure.\",\n        );\n    }\n\n    // Let the cluster recover.\n    match failure_type {\n        FailureType::Partition(..) => {\n            cluster.clear_send_filters();\n        }\n        FailureType::Reboot(peers) => {\n            cluster.clear_send_filters();\n            peers.iter().for_each(|&peer| {\n                cluster.run_node(peer).unwrap();\n            });\n        }\n    };\n\n    // Prepare to listen.\n    let rx = if let Some((id, _)) = detect_during_recovery {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached recovery prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    if let Some(leader_id) = leader_after_failure_id.into() {\n        cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    };\n\n    // Once we see a response on the wire we know a prevote round is happening.\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with recovery prevote notifier, got {:?}\", received);\n\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during recovery.\",\n        );\n    };\n\n    cluster.must_put(b\"k3\", b\"v3\");\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n}", "test": "fn test_prevote_reboot_majority_followers() {\n    let mut cluster = new_node_cluster(0, 5);\n    // A prevote round will start, but nothing will succeed.\n    test_prevote(\n        &mut cluster,\n        FailureType::Reboot(&[3, 4, 5]),\n        1,\n        (1, true),\n        None,\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_download_sst_blocking_sst_writer", "code": "pub fn get_is_empty(&self) -> bool {\n        self.is_empty\n    }", "test": "fn test_download_sst_blocking_sst_writer() {\n    let (_cluster, ctx, tikv, import) = new_cluster_and_tikv_import_client();\n    let temp_dir = Builder::new()\n        .prefix(\"test_download_sst_blocking_sst_writer\")\n        .tempdir()\n        .unwrap();\n\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, _) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    // Sleep 20s, make sure it is large than grpc_keepalive_timeout (3s).\n    let sst_writer_open_fp = \"on_open_sst_writer\";\n    fail::cfg(sst_writer_open_fp, \"sleep(20000)\").unwrap();\n\n    // Now perform a proper download.\n    let mut download = DownloadRequest::default();\n    download.set_sst(meta.clone());\n    download.set_storage_backend(external_storage_export::make_local_backend(temp_dir.path()));\n    download.set_name(\"test.sst\".to_owned());\n    download.mut_sst().mut_range().set_start(vec![sst_range.1]);\n    download\n        .mut_sst()\n        .mut_range()\n        .set_end(vec![sst_range.1 + 1]);\n    download.mut_sst().mut_range().set_start(Vec::new());\n    download.mut_sst().mut_range().set_end(Vec::new());\n    let result = import.download(&download).unwrap();\n    assert!(!result.get_is_empty());\n    assert_eq!(result.get_range().get_start(), &[sst_range.0]);\n    assert_eq!(result.get_range().get_end(), &[sst_range.1 - 1]);\n\n    fail::remove(sst_writer_open_fp);\n\n    // Do an ingest and verify the result is correct.\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error());\n\n    check_ingested_kvs(&tikv, &ctx, sst_range);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::cannot_use_borrow_for_own", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn cannot_use_borrow_for_own() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core module $m\n                    (func (export \"f\") (param i32) (result i32)\n                        local.get 0\n                    )\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (borrow $t)) (result (own $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), (Resource<MyType>,)>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource,)).unwrap_err();\n    assert_eq!(err.to_string(), \"cannot lift own resource from a borrow\");\n    Ok(())\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_i64", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_parse_i64() {\n    test_parse_ok(vec![\n        (\"-2\", -2),\n        (\"-1234\", -1234),\n        (\" -1234 \", -1234),\n        (&i64::MIN.to_string(), i64::MIN),\n        (&i64::MAX.to_string(), i64::MAX),\n    ]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::should_write_to_engine_but_whatever", "code": "fn should_write_to_engine(&self) -> bool {\n        panic!()\n    }", "test": "fn should_write_to_engine_but_whatever() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() > max_keys {\n            assert!(wb.should_write_to_engine());\n        }\n        if key.len() == max_keys * 2 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        assert!(db.engine.get_value(&key).unwrap().is_some());\n        if key.len() == max_keys * 2 {\n            break;\n        }\n    }\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = KvTestEngine::WRITE_BATCH_MAX_KEYS;\n\n    let mut key = vec![];\n\n    loop {\n        key.push(b'a');\n        wb.put(&key, b\"\").unwrap();\n        if key.len() <= max_keys {\n            assert!(!wb.should_write_to_engine());\n        }\n        if key.len() > max_keys {\n            assert!(wb.should_write_to_engine());\n        }\n        if key.len() == max_keys * 2 {\n            assert!(wb.should_write_to_engine());\n            wb.write().unwrap();\n            break;\n        }\n    }\n\n    let mut key = vec![];\n    loop {\n        key.push(b'a');\n        assert!(db.engine.get_value(&key).unwrap().is_some());\n        if key.len() == max_keys * 2 {\n            break;\n        }\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::do_while_loop_continue", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn do_while_loop_continue() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var i = 0, a = 0, b = 0;\n                do {\n                    i++;\n                    if (i < 2) {\n                        a++;\n                        continue;\n                    }\n                    b++;\n                } while (i < 3)\n            \"#}),\n        TestAction::assert_eq(\"a\", 1),\n        TestAction::assert_eq(\"b\", 2),\n    ]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_delete_lock_proposed_after_proposing_locks_1", "code": "fn test_delete_lock_proposed_after_proposing_locks_impl(transfer_msg_count: usize) {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_heartbeat_ticks = 20;\n    cluster.run();\n\n    let region_id = 1;\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let snapshot = cluster.must_get_snapshot_of_region(region_id);\n    let txn_ext = snapshot.txn_ext.unwrap();\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(\n            Key::from_raw(b\"key\"),\n            PessimisticLock {\n                primary: b\"key\".to_vec().into_boxed_slice(),\n                start_ts: 10.into(),\n                ttl: 1000,\n                for_update_ts: 10.into(),\n                min_commit_ts: 20.into(),\n                last_change_ts: 5.into(),\n                versions_to_last_change: 3,\n            },\n        )])\n        .unwrap();\n\n    let addr = cluster.sim.rl().get_addr(1);\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(env).connect(&addr);\n    let client = TikvClient::new(channel);\n\n    let mut req = CleanupRequest::default();\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_region_epoch(cluster.get_region_epoch(region_id));\n    ctx.set_peer(leader);\n    req.set_context(ctx);\n    req.set_key(b\"key\".to_vec());\n    req.set_start_version(10);\n    req.set_current_ts(u64::MAX);\n\n    // Pause the command after it mark the lock as deleted.\n    fail::cfg(\"raftkv_async_write\", \"pause\").unwrap();\n    let (tx, resp_rx) = mpsc::channel();\n    thread::spawn(move || tx.send(client.kv_cleanup(&req).unwrap()).unwrap());\n\n    thread::sleep(Duration::from_millis(200));\n    resp_rx.try_recv().unwrap_err();\n\n    for _ in 0..transfer_msg_count {\n        cluster.transfer_leader(1, new_peer(2, 2));\n    }\n    thread::sleep(Duration::from_millis(200));\n\n    // Transfer leader will not make the command fail.\n    fail::remove(\"raftkv_async_write\");\n    let resp = resp_rx.recv().unwrap();\n    assert!(!resp.has_region_error());\n\n    for _ in 0..10 {\n        thread::sleep(Duration::from_millis(100));\n        cluster.reset_leader_of_region(region_id);\n        if cluster.leader_of_region(region_id).unwrap().id == 2 {\n            let snapshot = cluster.must_get_snapshot_of_region(1);\n            assert!(\n                snapshot\n                    .get_cf(CF_LOCK, &Key::from_raw(b\"key\"))\n                    .unwrap()\n                    .is_none()\n            );\n            return;\n        }\n    }\n    panic!(\"region should succeed to transfer leader to peer 2\");\n}", "test": "fn test_delete_lock_proposed_after_proposing_locks_1() {\n    test_delete_lock_proposed_after_proposing_locks_impl(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_read_from_file", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn unexpand_read_from_file() {\n    new_ucmd!()\n        .arg(\"with_spaces.txt\")\n        .arg(\"-t4\")\n        .run()\n        .success();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_lock_primary", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_txn_store_lock_primary() {\n    let store = AssertionStorage::default();\n    // txn1 locks \"p\" then aborts.\n    store.prewrite_ok(\n        vec![Mutation::make_put(Key::from_raw(b\"p\"), b\"p1\".to_vec())],\n        b\"p\",\n        1,\n    );\n\n    // txn2 wants to write \"p\", \"s\".\n    store.prewrite_locked(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p\"), b\"p2\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s\"), b\"s2\".to_vec()),\n        ],\n        b\"p\",\n        2,\n        vec![(b\"p\", b\"p\", 1.into())],\n    );\n    // txn2 cleanups txn1's lock.\n    store.rollback_ok(vec![b\"p\"], 1);\n    store.resolve_lock_ok(1, None::<TimeStamp>);\n\n    // txn3 wants to write \"p\", \"s\", neither of them should be locked.\n    store.prewrite_ok(\n        vec![\n            Mutation::make_put(Key::from_raw(b\"p\"), b\"p3\".to_vec()),\n            Mutation::make_put(Key::from_raw(b\"s\"), b\"s3\".to_vec()),\n        ],\n        b\"p\",\n        3,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_tmpdir", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_mktemp_tmpdir() {\n    let scene = TestScenario::new(util_name!());\n    let dir = tempdir().unwrap();\n    let path = dir.path().join(scene.fixtures.as_string());\n    let pathname = path.as_os_str();\n\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE1)\n        .succeeds();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE2)\n        .fails();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE3)\n        .fails();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE4)\n        .fails();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE5)\n        .succeeds();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE6)\n        .succeeds();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE7)\n        .succeeds();\n    scene\n        .ucmd()\n        .arg(\"-p\")\n        .arg(pathname)\n        .arg(TEST_TEMPLATE8)\n        .fails();\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_smashed_to_lowercase", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "test": "fn server_exposes_offered_sni_smashed_to_lowercase() {\n    // webpki actually does this for us in its DnsName type\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"SECOND.TESTServer.com\"))\n                .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_sort_floating_nodes", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_sort_floating_nodes() {\n    new_ucmd!()\n        .pipe_in(\"d d\\nc c\\na a\\nb b\")\n        .succeeds()\n        .stdout_only(\"a\\nb\\nc\\nd\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_invalid_usage", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_separator_invalid_usage() {\n    let scene = TestScenario::new(util_name!());\n    scene\n        .ucmd()\n        .args(&[\"--separator=xx\"])\n        .ignore_stdin_write_error()\n        .pipe_in(\"a\\n\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: multi-character separator 'xx'\");\n    scene\n        .ucmd()\n        .args(&[\"-ta\", \"-tb\"])\n        .ignore_stdin_write_error()\n        .pipe_in(\"a\\n\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: multiple separator characters specified\");\n    scene\n        .ucmd()\n        .args(&[\"-t'\\n'\", \"-tb\"])\n        .ignore_stdin_write_error()\n        .pipe_in(\"a\\n\")\n        .fails()\n        .no_stdout()\n        .stderr_contains(\"split: multiple separator characters specified\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_update_config", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_update_config() {\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n\n    // normal update\n    cfg_controller\n        .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n        .unwrap();\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update not support config\n    let res = cfg_controller.update(change(\"server.addr\", \"localhost:3000\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update to invalid config\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"0\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // bad update request\n    let res = cfg_controller.update(change(\"xxx.yyy\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.xxx\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_order_by", "code": "fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }", "test": "fn parse_select_order_by() {\n    fn chk(sql: &str) {\n        let select = verified_query(sql);\n        assert_eq!(\n            vec![\n                OrderByExpr {\n                    expr: Expr::Identifier(Ident::new(\"lname\")),\n                    asc: Some(true),\n                    nulls_first: None,\n                },\n                OrderByExpr {\n                    expr: Expr::Identifier(Ident::new(\"fname\")),\n                    asc: Some(false),\n                    nulls_first: None,\n                },\n                OrderByExpr {\n                    expr: Expr::Identifier(Ident::new(\"id\")),\n                    asc: None,\n                    nulls_first: None,\n                },\n            ],\n            select.order_by\n        );\n    }\n    chk(\"SELECT id, fname, lname FROM customer WHERE id < 5 ORDER BY lname ASC, fname DESC, id\");\n    // make sure ORDER is not treated as an alias\n    chk(\"SELECT id, fname, lname FROM customer ORDER BY lname ASC, fname DESC, id\");\n    chk(\"SELECT 1 AS lname, 2 AS fname, 3 AS id, 4 ORDER BY lname ASC, fname DESC, id\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::instant_close_2", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn instant_close_2() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config());\n    // Unlike `instant_close`, the server sees a valid Initial packet first.\n    pair.drive_client();\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(42), Bytes::new());\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::ConnectionClosed(ConnectionClose {\n                error_code: TransportErrorCode::APPLICATION_ERROR,\n                ..\n            }),\n        })\n    );\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::array", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn array() {\n    test(\"[]\", \"[];\");\n    test(\"[,]\", \"[,];\");\n    test(\"[,,]\", \"[,,];\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_do_not_use_unified_readpool_with_legacy_config", "code": "pub fn is_unified_pool_enabled(&self) -> bool {\n        self.storage.use_unified_pool() || self.coprocessor.use_unified_pool()\n    }", "test": "fn test_do_not_use_unified_readpool_with_legacy_config() {\n    let content = r#\"\n        [readpool.storage]\n        normal-concurrency = 1\n\n        [readpool.coprocessor]\n        normal-concurrency = 1\n    \"#;\n    let cfg: TikvConfig = toml::from_str(content).unwrap();\n    assert!(!cfg.readpool.is_unified_pool_enabled());\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_string_variable", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn test_string_variable() {\n    let needle = r#\"{printf(\"$x\");}\"#;\n    let source = r#\"\n    void func()\n    {\n        printf(\"foo\");\n        printf(\"bar\");\n        printf(id);\n    }\"#;\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 2);\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/snapshots.rs::convert_spv_all", "code": "fn convert_spv(name: &str, adjust_coordinate_space: bool, targets: Targets) {\n    let _ = env_logger::try_init();\n\n    let input = Input::new(Some(\"spv\"), name, \"spv\");\n    let mut module = naga::front::spv::parse_u8_slice(\n        &input.read_bytes(),\n        &naga::front::spv::Options {\n            adjust_coordinate_space,\n            strict_capabilities: false,\n            block_ctx_dump_prefix: None,\n        },\n    )\n    .unwrap();\n    check_targets(&input, &mut module, targets, None);\n}", "test": "fn convert_spv_all() {\n    convert_spv(\n        \"quad-vert\",\n        false,\n        Targets::METAL | Targets::GLSL | Targets::HLSL | Targets::WGSL,\n    );\n    convert_spv(\"shadow\", true, Targets::IR | Targets::ANALYSIS);\n    convert_spv(\n        \"inv-hyperbolic-trig-functions\",\n        true,\n        Targets::HLSL | Targets::WGSL,\n    );\n    convert_spv(\n        \"empty-global-name\",\n        true,\n        Targets::HLSL | Targets::WGSL | Targets::METAL,\n    );\n    convert_spv(\"degrees\", false, Targets::empty());\n    convert_spv(\"binding-arrays.dynamic\", true, Targets::WGSL);\n    convert_spv(\"binding-arrays.static\", true, Targets::WGSL);\n    convert_spv(\n        \"do-while\",\n        true,\n        Targets::METAL | Targets::GLSL | Targets::HLSL | Targets::WGSL,\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::get_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn get_none() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    match table.get(&mut store, 0) {\n        Some(Val::FuncRef(None)) => {}\n        _ => panic!(),\n    }\n    assert!(table.get(&mut store, 1).is_none());\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::wasm_file_with_no_abi", "code": "fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        }", "test": "fn wasm_file_with_no_abi() {\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::fib())\n        .env(\"RUST_LOG\", &*RUST_LOG)\n        .assert();\n\n    assert.success();\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_expression_in_if", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn missing_expression_in_if() {\n    assert_err_msg(\"{% if %}\", &[\"1:7\", \"expected a value that can be negated\"]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::eventual_persistence", "code": "fn test_persistence(durability: Durability) {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(durability);\n    let pairs = gen_data(100, 16, 20);\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..ELEMENTS {\n            let (key, value) = &pairs[i % pairs.len()];\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n\n    let mut key_order: Vec<usize> = (0..ELEMENTS).collect();\n    key_order.shuffle(&mut rand::thread_rng());\n\n    {\n        for i in &key_order {\n            let (key, value) = &pairs[*i % pairs.len()];\n            assert_eq!(table.get(key.as_slice()).unwrap().unwrap().value(), value);\n        }\n    }\n}", "test": "fn eventual_persistence() {\n    test_persistence(Durability::Eventual);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::max_diagnostics", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn max_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    for i in 0..60 {\n        let file_path = PathBuf::from(format!(\"src/file_{i}.js\"));\n        fs.insert(file_path, UNFORMATTED.as_bytes());\n    }\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), (\"--max-diagnostics\"), (\"10\"), (\"src\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut diagnostic_count = 0;\n    let mut filtered_messages = Vec::new();\n\n    for msg in console.out_buffer {\n        let MarkupBuf(nodes) = &msg.content;\n        let is_diagnostic = nodes.iter().any(|node| {\n            node.content\n                .contains(\"File content differs from formatting output\")\n                || node.content.contains(\"format\")\n                || node.content.contains(\"ci\")\n        });\n\n        if is_diagnostic {\n            diagnostic_count += 1;\n        } else {\n            filtered_messages.push(msg);\n        }\n    }\n\n    console.out_buffer = filtered_messages;\n\n    for i in 0..60 {\n        let file_path = format!(\"src/file_{i}.js\");\n        fs.remove(Path::new(&file_path));\n    }\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"max_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n\n    assert_eq!(diagnostic_count, 10);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/edit.rs::editor_precedence", "code": "pub(crate) fn assert_stdout(output: &std::process::Output, stdout: &str) {\n  assert_success(output);\n  assert_eq!(String::from_utf8_lossy(&output.stdout), stdout);\n}", "test": "fn editor_precedence() {\n  let tmp = temptree! {\n    justfile: JUSTFILE,\n  };\n\n  let output = Command::new(executable_path(\"just\"))\n    .current_dir(tmp.path())\n    .arg(\"--edit\")\n    .env(\"VISUAL\", \"cat\")\n    .env(\"EDITOR\", \"this-command-doesnt-exist\")\n    .output()\n    .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n\n  let output = Command::new(executable_path(\"just\"))\n    .current_dir(tmp.path())\n    .arg(\"--edit\")\n    .env_remove(\"VISUAL\")\n    .env(\"EDITOR\", \"cat\")\n    .output()\n    .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n\n  let cat = which(\"cat\").unwrap();\n  let vim = tmp.path().join(format!(\"vim{EXE_SUFFIX}\"));\n\n  #[cfg(unix)]\n  std::os::unix::fs::symlink(cat, vim).unwrap();\n\n  #[cfg(windows)]\n  std::os::windows::fs::symlink_file(cat, vim).unwrap();\n\n  let path = env::join_paths(\n    iter::once(tmp.path().to_owned()).chain(env::split_paths(&env::var_os(\"PATH\").unwrap())),\n  )\n  .unwrap();\n\n  let output = Command::new(executable_path(\"just\"))\n    .current_dir(tmp.path())\n    .arg(\"--edit\")\n    .env(\"PATH\", path)\n    .env_remove(\"VISUAL\")\n    .env_remove(\"EDITOR\")\n    .output()\n    .unwrap();\n\n  assert_stdout(&output, JUSTFILE);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_fixed_floats", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_fixed_floats() {\n    test_helper(\n        \"numeric_fixed_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_in_parent_block", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_location_in_parent_block() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"Hello {{ greeting }} {% block bob %}{{ 1 + true }}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\' (error happened in 'parent').\"\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_boolean_key", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_boolean_key() {\n    let map = treemap!(false => 0, true => 1);\n    let j = r#\"{\"false\":0,\"true\":1}\"#;\n    test_encode_ok(&[(&map, j)]);\n    test_parse_ok(vec![(j, map)]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uniq.rs::test_case2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_case2() {\n    new_ucmd!().pipe_in(\"a\\na\\n\").run().stdout_is(\"a\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::create_get_set_externref_tables_via_api", "code": "pub fn get(&self, index: u32) -> Option<TableElement> {\n        self.elements()\n            .get(index as usize)\n            .map(|p| unsafe { TableElement::clone_from_table_value(self.element_type(), *p) })\n    }", "test": "fn create_get_set_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(\n        &mut store,\n        table_ty,\n        Val::ExternRef(Some(ExternRef::new(42_usize))),\n    )?;\n\n    assert_eq!(\n        *table\n            .get(&mut store, 5)\n            .unwrap()\n            .unwrap_externref()\n            .unwrap()\n            .data()\n            .downcast_ref::<usize>()\n            .unwrap(),\n        42\n    );\n    table.set(&mut store, 5, Val::ExternRef(None))?;\n    assert!(table\n        .get(&mut store, 5)\n        .unwrap()\n        .unwrap_externref()\n        .is_none());\n\n    Ok(())\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_filter_section", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_filter_section() {\n    let inputs = vec![\n        (\"{% filter upper %}Hello{% endfilter %}\", \"HELLO\"),\n        (\"{% filter upper %}Hello{% if true %} world{% endif %}{% endfilter %}\", \"HELLO WORLD\"),\n        (\"{% filter upper %}Hello {% for i in range(end=3) %}i{% endfor %}{% endfilter %}\", \"HELLO III\"),\n        (\n            \"{% filter upper %}Hello {% for i in range(end=3) %}{% if i == 1 %}{% break %} {% endif %}i{% endfor %}{% endfilter %}\",\n            \"HELLO I\",\n        ),\n        (\"{% filter title %}Hello {% if true %}{{ 'world' | upper | safe }}{% endif %}{% endfilter %}\", \"Hello World\"),\n        (\"{% filter safe %}{% filter upper %}<Hello>{% endfilter %}{% endfilter%}\", \"<HELLO>\")\n    ];\n\n    let context = Context::new();\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_node_pending_peers", "code": "fn test_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.pd_heartbeat_tick_interval = ReadableDuration::millis(100);\n\n    let region_worker_fp = \"region_apply_snap\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let region_id = cluster.run_conf_change();\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n\n    // To ensure peer 2 is not pending.\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n\n    fail::cfg(region_worker_fp, \"sleep(2000)\").unwrap();\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    sleep_ms(1000);\n    let pending_peers = pd_client.get_pending_peers();\n    // Region worker is not started, snapshot should not be applied yet.\n    assert_eq!(pending_peers[&3], new_peer(3, 3));\n    // But it will be applied finally.\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    sleep_ms(100);\n    let pending_peers = pd_client.get_pending_peers();\n    assert!(pending_peers.is_empty());\n}", "test": "fn test_node_pending_peers() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_pending_peers(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cksum.rs::test_crc_for_bigger_than_32_bytes", "code": "fn next(&mut self) -> Option<Self::Item> {\n        if self.first_iteration {\n            self.first_iteration = false;\n        } else {\n            self.number.increment().ok()?;\n        }\n        // The first and third parts are just taken directly from the\n        // struct parameters unchanged.\n        Some(format!(\n            \"{}{}{}\",\n            self.prefix, self.number, self.additional_suffix\n        ))\n    }", "test": "fn test_crc_for_bigger_than_32_bytes() {\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    let result = ucmd.arg(\"chars.txt\").succeeds();\n\n    let mut stdout_split = result.stdout_str().split(' ');\n\n    let cksum: i64 = stdout_split.next().unwrap().parse().unwrap();\n    let bytes_cnt: i64 = stdout_split.next().unwrap().parse().unwrap();\n\n    assert_eq!(cksum, 586_047_089);\n    assert_eq!(bytes_cnt, 16);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_rejects_nan", "code": "pub fn usage_error<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.stderr_only(format!(\n            \"{0}: {2}\\nTry '{1} {0} --help' for more information.\\n\",\n            self.util_name.as_ref().unwrap(), // This shouldn't be called using a normal command\n            self.bin_path.display(),\n            msg.as_ref()\n        ))\n    }", "test": "fn test_rejects_nan() {\n    new_ucmd!()\n        .arg(\"NaN\")\n        .fails()\n        .usage_error(\"invalid 'not-a-number' argument: 'NaN'\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_tail_01", "code": "pub fn call_resumable<T>(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        inputs: &[Value],\n        outputs: &mut [Value],\n    ) -> Result<ResumableCall, Error> {\n        self.verify_and_prepare_inputs_outputs(ctx.as_context(), inputs, outputs)?;\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context()\n            .store\n            .engine()\n            .clone()\n            .execute_func_resumable(ctx.as_context_mut(), self, inputs, outputs)\n            .map_err(Into::into)\n            .map(ResumableCall::new)\n    }", "test": "fn resumable_call_smoldot_tail_01() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (return_call $host_fn)\n            )\n        )\n        \"#,\n    );\n    assert_eq!(\n        wasm_fn\n            .call_resumable(&mut store, ())\n            .unwrap_err()\n            .i32_exit_status(),\n        Some(100),\n    );\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::factor_test", "code": "pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}", "test": "fn factor_test() {\n  assert_eq!(\n    factor(\"  3  \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"3\")))\n  );\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::drain_entry", "code": "pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }", "test": "fn drain_entry() {\n    let mut headers = HeaderMap::new();\n\n    headers.insert(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world\".parse().unwrap(),\n    );\n    headers.insert(\n        \"zomg\".parse::<HeaderName>().unwrap(),\n        \"foo\".parse().unwrap(),\n    );\n    headers.append(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world2\".parse().unwrap(),\n    );\n    headers.insert(\n        \"more\".parse::<HeaderName>().unwrap(),\n        \"words\".parse().unwrap(),\n    );\n    headers.append(\n        \"more\".parse::<HeaderName>().unwrap(),\n        \"insertions\".parse().unwrap(),\n    );\n    assert_eq!(5, headers.len());\n\n    // Using insert_mult\n    {\n        let mut e = match headers.entry(\"hello\") {\n            Entry::Occupied(e) => e,\n            _ => panic!(),\n        };\n\n        let vals: Vec<_> = e.insert_mult(\"wat\".parse().unwrap()).collect();\n        assert_eq!(2, vals.len());\n        assert_eq!(vals[0], \"world\");\n        assert_eq!(vals[1], \"world2\");\n    }\n\n    assert_eq!(5-2+1, headers.len());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_lines_chars", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_lines_chars() {\n    new_ucmd!()\n        .arg(\"-ml\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     25     442\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_set_time_zone", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_set_time_zone() {\n    match verified_stmt(\"SET TIMEZONE = 'UTC'\") {\n        Statement::SetVariable {\n            local,\n            hivevar,\n            variable,\n            value,\n        } => {\n            assert!(!local);\n            assert!(!hivevar);\n            assert_eq!(variable, ObjectName(vec![\"TIMEZONE\".into()]));\n            assert_eq!(\n                value,\n                vec![Expr::Value(Value::SingleQuotedString(\"UTC\".into()))]\n            );\n        }\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\"SET TIME ZONE TO 'UTC'\", \"SET TIMEZONE = 'UTC'\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_multiple_folders", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_multiple_folders() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let target_dir = \"test_mv_multiple_dirs_dir\";\n    let dir_a = \"test_mv_multiple_dir_a\";\n    let dir_b = \"test_mv_multiple_dir_b\";\n\n    at.mkdir(target_dir);\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n\n    ucmd.arg(dir_a)\n        .arg(dir_b)\n        .arg(target_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_a}\")));\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_b}\")));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple_type_lifetime", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn tuple_type_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table\n            .insert(&(String::from(\"hello\").as_str(), 5), &(0, 123))\n            .unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_first_1000_integers_with_exponents", "code": "fn finalize<T>(\n    output: &mut Output,\n    rstat: ReadStat,\n    wstat: WriteStat,\n    start: Instant,\n    prog_tx: &mpsc::Sender<ProgUpdate>,\n    output_thread: thread::JoinHandle<T>,\n) -> std::io::Result<()> {\n    // Flush the output, if configured to do so.\n    output.sync()?;\n\n    // Truncate the file to the final cursor location.\n    //\n    // Calling `set_len()` may result in an error (for example,\n    // when calling it on `/dev/null`), but we don't want to\n    // terminate the process when that happens. Instead, we\n    // suppress the error by calling `Result::ok()`. This matches\n    // the behavior of GNU `dd` when given the command-line\n    // argument `of=/dev/null`.\n    if !output.settings.oconv.notrunc {\n        output.dst.truncate().ok();\n    }\n\n    // Print the final read/write statistics.\n    let prog_update = ProgUpdate::new(rstat, wstat, start.elapsed(), true);\n    prog_tx.send(prog_update).unwrap_or(());\n    // Wait for the output thread to finish\n    output_thread\n        .join()\n        .expect(\"Failed to join with the output thread.\");\n    Ok(())\n}", "test": "fn test_first_1000_integers_with_exponents() {\n    use hex_literal::hex;\n    use sha1::{Digest, Sha1};\n\n    let n_integers = 1000;\n    let mut input_string = String::new();\n    for i in 0..=n_integers {\n        input_string.push_str(&(format!(\"{i} \"))[..]);\n    }\n\n    println!(\"STDIN='{input_string}'\");\n    let result = new_ucmd!()\n        .arg(\"-h\")\n        .pipe_in(input_string.as_bytes())\n        .succeeds();\n\n    // Using factor from GNU Coreutils 9.2\n    // `seq 0 1000 | factor -h | sha1sum` => \"45f5f758a9319870770bd1fec2de23d54331944d\"\n    let mut hasher = Sha1::new();\n    hasher.update(result.stdout());\n    let hash_check = hasher.finalize();\n    assert_eq!(\n        hash_check[..],\n        hex!(\"45f5f758a9319870770bd1fec2de23d54331944d\")\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_multi_server_latency", "code": "fn test_multi_latency<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n    cluster.add_send_filter(CloneFilterFactory(DelayFilter::new(Duration::from_millis(\n        30,\n    ))));\n    test_multi_base_after_bootstrap(cluster);\n}", "test": "fn test_multi_server_latency() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_multi_latency(&mut cluster);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::trapping", "code": "pub fn last(&self) -> Option<&V> {\n        self.elems.last()\n    }", "test": "fn trapping() -> Result<(), Error> {\n    const TRAP_IN_F: i32 = 0;\n    const TRAP_NEXT_CALL_HOST: i32 = 1;\n    const TRAP_NEXT_RETURN_HOST: i32 = 2;\n    const TRAP_NEXT_CALL_WASM: i32 = 3;\n    const TRAP_NEXT_RETURN_WASM: i32 = 4;\n\n    let engine = Engine::default();\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |mut caller: Caller<State>, action: i32, recur: i32| -> Result<()> {\n            assert_eq!(caller.data().context.last(), Some(&Context::Host));\n            assert_eq!(caller.data().calls_into_host, caller.data().calls_into_wasm);\n\n            match action {\n                TRAP_IN_F => bail!(\"trapping in f\"),\n                TRAP_NEXT_CALL_HOST => caller.data_mut().trap_next_call_host = true,\n                TRAP_NEXT_RETURN_HOST => caller.data_mut().trap_next_return_host = true,\n                TRAP_NEXT_CALL_WASM => caller.data_mut().trap_next_call_wasm = true,\n                TRAP_NEXT_RETURN_WASM => caller.data_mut().trap_next_return_wasm = true,\n                _ => {} // Do nothing\n            }\n\n            // recur so that we can trigger a next call.\n            // propogate its trap, if it traps!\n            if recur > 0 {\n                let _ = caller\n                    .get_export(\"export\")\n                    .expect(\"caller exports \\\"export\\\"\")\n                    .into_func()\n                    .expect(\"export is a func\")\n                    .typed::<(i32, i32), ()>(&caller)\n                    .expect(\"export typing\")\n                    .call(&mut caller, (action, 0))?;\n            }\n\n            Ok(())\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i32)))\n            (func (export \"export\") (param i32) (param i32)\n                (call $f (local.get 0) (local.get 1)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let run = |action: i32, recur: bool| -> (State, Option<Error>) {\n        let mut store = Store::new(&engine, State::default());\n        store.call_hook(State::call_hook);\n        let inst = linker\n            .instantiate(&mut store, &module)\n            .expect(\"instantiate\");\n        let export = inst\n            .get_export(&mut store, \"export\")\n            .expect(\"get export\")\n            .into_func()\n            .expect(\"export is func\");\n\n        let r = export.call(\n            &mut store,\n            &[Val::I32(action), Val::I32(if recur { 1 } else { 0 })],\n            &mut [],\n        );\n        (store.into_data(), r.err())\n    };\n\n    let (s, e) = run(TRAP_IN_F, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"trapping in f\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to host. No calls after the bit is set, so this trap shouldn't happen\n    let (s, e) = run(TRAP_NEXT_CALL_HOST, false);\n    assert!(e.is_none());\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to host. recur, so the second call into host traps:\n    let (s, e) = run(TRAP_NEXT_CALL_HOST, true);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on CallingHost\"));\n    assert_eq!(s.calls_into_host, 2);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 2);\n    assert_eq!(s.returns_from_wasm, 2);\n\n    // trap in the return from host. should trap right away, without recursion\n    let (s, e) = run(TRAP_NEXT_RETURN_HOST, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on ReturningFromHost\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to wasm. No calls after the bit is set, so this trap shouldnt happen:\n    let (s, e) = run(TRAP_NEXT_CALL_WASM, false);\n    assert!(e.is_none());\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to wasm. recur, so the second call into wasm traps:\n    let (s, e) = run(TRAP_NEXT_CALL_WASM, true);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on CallingWasm\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 2);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in the return from wasm. should trap right away, without recursion\n    let (s, e) = run(TRAP_NEXT_RETURN_WASM, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on ReturningFromWasm\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::copy_wrong", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "test": "fn copy_wrong() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table1 = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    let ty = TableType::new(ValType::ExternRef, 1, None);\n    let table2 = Table::new(&mut store, ty, Val::ExternRef(None)).unwrap();\n    assert_eq!(\n        Table::copy(&mut store, &table1, 0, &table2, 0, 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"tables do not have the same element type\"\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/unstable.rs::set_unstable_false_with_env_var_unset", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn set_unstable_false_with_env_var_unset() {\n  let justfile = r#\"\ndefault:\n    echo 'foo'\n  \"#;\n  Test::new()\n    .justfile(justfile)\n    .args([\"--fmt\"])\n    .status(EXIT_FAILURE)\n    .stderr(\"error: The `--fmt` command is currently unstable. Invoke `just` with the `--unstable` flag to enable unstable features.\\n\")\n    .run();\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_exr", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_exr() {\n    truncate_images(\"exr\");\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::scientific_exponent_test", "code": "pub(crate) fn scientific_exponent(\n    exponent: i32,\n    integer_digits: usize,\n    fraction_start: usize,\n) -> i32 {\n    if integer_digits == 0 {\n        let fraction_start = into_i32(fraction_start);\n        exponent.saturating_sub(fraction_start).saturating_sub(1)\n    } else {\n        let integer_shift = into_i32(integer_digits - 1);\n        exponent.saturating_add(integer_shift)\n    }\n}", "test": "fn scientific_exponent_test() {\n    // 0 digits in the integer\n    assert_eq!(scientific_exponent(0, 0, 5), -6);\n    assert_eq!(scientific_exponent(10, 0, 5), 4);\n    assert_eq!(scientific_exponent(-10, 0, 5), -16);\n\n    // >0 digits in the integer\n    assert_eq!(scientific_exponent(0, 1, 5), 0);\n    assert_eq!(scientific_exponent(0, 2, 5), 1);\n    assert_eq!(scientific_exponent(0, 2, 20), 1);\n    assert_eq!(scientific_exponent(10, 2, 20), 11);\n    assert_eq!(scientific_exponent(-10, 2, 20), -9);\n\n    // Underflow\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 0),\n        i32::min_value()\n    );\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 5),\n        i32::min_value()\n    );\n\n    // Overflow\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 0, 0),\n        i32::max_value() - 1\n    );\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 5, 0),\n        i32::max_value()\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::redefining_loop_value_doesnt_break_loop", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn redefining_loop_value_doesnt_break_loop() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- set string = \"abcdefghdijklm\" | split(pat=\"d\") -%}\n{% for i in string -%}\n    {%- set j = i ~ \"lol\" ~ \" \" -%}\n    {{ j }}\n{%- endfor -%}\n        \"#,\n    )\n    .unwrap();\n    let context = Context::new();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"abclol efghlol ijklmlol \");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_sync_data_but_not_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_sync_data_but_not_file() {\n    new_ucmd!()\n        .arg(\"--data\")\n        .fails()\n        .stderr_contains(\"sync: --data needs at least one argument\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_read_leader_with_unapplied_log", "code": "fn test_read_leader_with_unapplied_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // if peer 2 is unreachable, leader will not send MsgAppend to peer 2, and the\n    // leader will send MsgAppend with committed information to peer 2 after\n    // network recovered, and peer 2 will apply the entry regardless of we add\n    // an filter, so we put k0/v0 to make sure the network is reachable.\n    let (k0, v0) = (b\"k0\", b\"v0\");\n    cluster.must_put(k0, v0);\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), k0, v0);\n    }\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv)\n            .allow(1),\n    ));\n\n    // Make peer 2's msg won't be replicated when it becomes leader,\n    // so the uncommitted entries won't be applied immediately.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Send),\n    ));\n\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it's still follower.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgHeartbeat)\n            .direction(Direction::Recv),\n    ));\n\n    let (k, v) = (b\"k\", b\"v\");\n    cluster.must_put(k, v);\n\n    // peer 1 must have committed, but peer 2 has not.\n    must_get_equal(&cluster.get_engine(1), k, v);\n\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    // leader's term not equal applied index's term, if we read local, we may get\n    // old value in this situation we need use raft read\n    must_get_none(&cluster.get_engine(2), k);\n\n    // internal read will use raft read no matter read_quorum is false or true,\n    // cause applied index's term not equal leader's term, and will failed with\n    // timeout\n    let req = get_with_timeout(cluster, k, false, Duration::from_secs(10)).unwrap();\n    assert!(\n        req.get_header().get_error().has_stale_command(),\n        \"read should be dropped immediately, but got {:?}\",\n        req\n    );\n\n    // recover network\n    cluster.clear_send_filters();\n\n    assert_eq!(cluster.get(k).unwrap(), v);\n}", "test": "fn test_node_read_leader_with_unapplied_log() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_read_leader_with_unapplied_log(&mut cluster);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/dotenv.rs::path_resolves", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn path_resolves() {\n  Test::new()\n    .justfile(\n      \"\n      foo:\n        @echo $NAME\n    \",\n    )\n    .tree(tree! {\n      subdir: {\n        \".env\": \"NAME=bar\"\n      }\n    })\n    .args([\"--dotenv-path\", \"subdir/.env\"])\n    .stdout(\"bar\\n\")\n    .status(EXIT_SUCCESS)\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_node_lease_expired", "code": "fn test_lease_expired<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, Some(50), None);\n\n    let node_id = 3u64;\n    let store_id = 3u64;\n    let peer = new_peer(store_id, node_id);\n    cluster.run();\n\n    // Write the initial value for a key.\n    let key = b\"k\";\n    cluster.must_put(key, b\"v1\");\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    // Isolate the leader `peer` from other peers.\n    cluster.add_send_filter(IsolationFilterFactory::new(store_id));\n\n    // Wait for the leader lease to expire and a new leader is elected.\n    thread::sleep(election_timeout * 2);\n\n    // Issue a read request and check the value on response.\n    must_error_read_on_peer(cluster, peer, region, key, Duration::from_secs(1));\n}", "test": "fn test_node_lease_expired() {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    test_lease_expired(&mut cluster);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::ignore_comments_in_recipe", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn ignore_comments_in_recipe() {\n  Test::new()\n    .justfile(\n      \"\n      set ignore-comments\n\n      some_recipe:\n        # A recipe-internal comment\n        echo something-useful\n    \",\n    )\n    .stdout(\"something-useful\\n\")\n    .stderr(\"echo something-useful\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_same_file", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_mv_same_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_same_file_a\";\n\n    at.touch(file_a);\n    ucmd.arg(file_a)\n        .arg(file_a)\n        .fails()\n        .stderr_is(format!(\"mv: '{file_a}' and '{file_a}' are the same file\\n\",));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::template_literal", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn template_literal() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            `result: ${a} and ${a+10}`;\n        \"#},\n        \"result: 10 and 20\",\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_conf_change.rs::test_write_after_destroy", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_write_after_destroy() {\n    // 3 nodes cluster.\n    let mut cluster = new_server_cluster(0, 3);\n\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // Now region 1 only has peer (1, 1);\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    let apply_fp = \"apply_on_conf_change_1_3_1\";\n    fail::cfg(apply_fp, \"pause\").unwrap();\n\n    cluster.must_transfer_leader(r1, new_peer(1, 1));\n    let conf_change = new_change_peer_request(ConfChangeType::RemoveNode, new_peer(3, 3));\n    let mut epoch = cluster.pd_client.get_region_epoch(r1);\n    let mut admin_req = new_admin_request(r1, &epoch, conf_change);\n    admin_req.mut_header().set_peer(new_peer(1, 1));\n    let (cb1, mut rx1) = make_cb(&admin_req);\n    let engines_3 = cluster.get_all_engines(3);\n    let region = block_on(cluster.pd_client.get_region_by_id(r1))\n        .unwrap()\n        .unwrap();\n    let reqs = vec![new_put_cmd(b\"k5\", b\"v5\")];\n    let new_version = epoch.get_conf_ver() + 1;\n    epoch.set_conf_ver(new_version);\n    let mut put = new_request(r1, epoch, reqs, false);\n    put.mut_header().set_peer(new_peer(1, 1));\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, admin_req, cb1)\n        .unwrap();\n    for _ in 0..100 {\n        let (cb2, _rx2) = make_cb(&put);\n        cluster\n            .sim\n            .rl()\n            .async_command_on_node(1, put.clone(), cb2)\n            .unwrap();\n    }\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k5\", b\"v5\");\n    fail::remove(apply_fp);\n    let resp = rx1.recv_timeout(Duration::from_secs(2)).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n    std::thread::sleep(Duration::from_secs(3));\n    must_get_none(&engine_3, b\"k5\");\n    must_region_cleared(&engines_3, &region);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/gc_worker.rs::test_gc_config_validate", "code": "pub fn validate(&self) -> std::result::Result<(), Box<dyn std::error::Error>> {\n        if self.split_balance_score > 1.0\n            || self.split_balance_score < 0.0\n            || self.split_contained_score > 1.0\n            || self.split_contained_score < 0.0\n        {\n            return Err(\n                (\"split_balance_score or split_contained_score should be between 0 and 1.\").into(),\n            );\n        }\n        if self.sample_num >= self.qps_threshold {\n            return Err(\n                (\"sample_num should be less than qps_threshold for load-base-split.\").into(),\n            );\n        }\n        if self.grpc_thread_cpu_overload_threshold_ratio > 1.0\n            || self.grpc_thread_cpu_overload_threshold_ratio < 0.0\n            || self.unified_read_pool_thread_cpu_overload_threshold_ratio > 1.0\n            || self.unified_read_pool_thread_cpu_overload_threshold_ratio < 0.0\n            || self.region_cpu_overload_threshold_ratio > 1.0\n            || self.region_cpu_overload_threshold_ratio < 0.0\n        {\n            return Err((\"threshold ratio should be between 0 and 1.\").into());\n        }\n        Ok(())\n    }", "test": "fn test_gc_config_validate() {\n    let cfg = GcConfig::default();\n    cfg.validate().unwrap();\n\n    let mut invalid_cfg = GcConfig::default();\n    invalid_cfg.batch_keys = 0;\n    invalid_cfg.validate().unwrap_err();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::bigger_switch_example", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn bigger_switch_example() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                function f(a) {\n                    let b;\n\n                    switch (a) {\n                        case 0:\n                            b = \"Mon\";\n                            break;\n                        case 1:\n                            b = \"Tue\";\n                            break;\n                        case 2:\n                            b = \"Wed\";\n                            break;\n                        case 3:\n                            b = \"Thurs\";\n                            break;\n                        case 4:\n                            b = \"Fri\";\n                            break;\n                        case 5:\n                            b = \"Sat\";\n                            break;\n                        case 6:\n                            b = \"Sun\";\n                            break;\n                    }\n                    return b;\n                }\n            \"#}),\n        TestAction::assert_eq(\"f(0)\", \"Mon\"),\n        TestAction::assert_eq(\"f(1)\", \"Tue\"),\n        TestAction::assert_eq(\"f(2)\", \"Wed\"),\n        TestAction::assert_eq(\"f(3)\", \"Thurs\"),\n        TestAction::assert_eq(\"f(4)\", \"Fri\"),\n        TestAction::assert_eq(\"f(5)\", \"Sat\"),\n        TestAction::assert_eq(\"f(6)\", \"Sun\"),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_fifo_missing_operand", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_create_fifo_missing_operand() {\n    new_ucmd!().fails().stderr_is(\"mkfifo: missing operand\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_unnest", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_unnest() {\n    let sql = \"SELECT UNNEST(make_array(1, 2, 3))\";\n    one_statement_parses_to(sql, sql);\n    let sql = \"SELECT UNNEST(make_array(1, 2, 3), make_array(4, 5))\";\n    one_statement_parses_to(sql, sql);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_symlink_to_regular_file", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_trailing_slash_symlink_to_regular_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"regfile\");\n    at.relative_symlink_file(\"regfile\", \"link\");\n    scene\n        .ucmd()\n        .args(&[\"-ev\", \"./link/\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(NOT_A_DIRECTORY)\n        .no_stdout();\n    scene\n        .ucmd()\n        .args(&[\"-e\", \"./link\"])\n        .succeeds()\n        .stdout_contains(\"regfile\");\n    scene\n        .ucmd()\n        .args(&[\"-e\", \"./link/more\"])\n        .fails()\n        .code_is(1)\n        .no_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_one_slash_multi", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_one_slash_multi() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\\", \"bar\"])\n        .succeeds()\n        .stdout_only(\"foo\\\\ bar\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_empty", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_realpath_empty() {\n    new_ucmd!().fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_carriage_return_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_carriage_return_should_be_preserved() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"\\r\")\n        .succeeds()\n        .stdout_is(\"\\r\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::simple", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn simple() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"a\" (func $log (param \"a\" string)))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func (export \"call\")\n                (canon lift (core func $i \"call\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            *store.data_mut() = Some(s);\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    instance\n        .get_typed_func::<(), ()>(&mut store, \"call\")?\n        .call(&mut store, ())?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = None;\n    let mut linker = Linker::new(&engine);\n    linker.root().func_new(\n        &component,\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {\n            if let Val::String(s) = &args[0] {\n                assert!(store.data().is_none());\n                *store.data_mut() = Some(s.to_string());\n                Ok(())\n            } else {\n                panic!()\n            }\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    instance\n        .get_func(&mut store, \"call\")\n        .unwrap()\n        .call(&mut store, &[], &mut [])?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/security.rs::test_check_cn_success", "code": "pub fn kv_get(&self, req: &super::kvrpcpb::GetRequest) -> ::grpcio::Result<super::kvrpcpb::GetResponse> {\n        self.kv_get_opt(req, ::grpcio::CallOption::default())\n    }", "test": "fn test_check_cn_success() {\n    let mut cluster = new_server_cluster(0, 1);\n    let mut allowed_cn = HashSet::default();\n    allowed_cn.insert(\"tikv-server\".to_owned());\n    cluster.cfg.security = test_util::new_security_cfg(Some(allowed_cn));\n    cluster.run();\n\n    let leader = cluster.get_region(b\"\").get_peers()[0].clone();\n    let addr = cluster.sim.rl().get_addr(leader.get_store_id());\n\n    let env = Arc::new(Environment::new(1));\n    let cred = test_util::new_channel_cred();\n    let channel = ChannelBuilder::new(env).secure_connect(&addr, cred);\n\n    let client = TikvClient::new(channel);\n    client.kv_get(&GetRequest::default()).unwrap();\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/init.rs::write_error", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn write_error() {\n  let test = Test::new();\n\n  let justfile_path = test.justfile_path();\n\n  fs::create_dir(justfile_path).unwrap();\n\n  test\n    .no_justfile()\n    .args([\"--init\"])\n    .status(EXIT_FAILURE)\n    .stderr_regex(if cfg!(windows) {\n      r\"error: Failed to write justfile to `.*`: Access is denied. \\(os error 5\\)\\n\"\n    } else {\n      r\"error: Failed to write justfile to `.*`: Is a directory \\(os error 21\\)\\n\"\n    })\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_unicode_filenames", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_unicode_filenames() {\n    let tname = \"\ud83d\ude0e\ud83d\udc9a\ud83e\udd8a\";\n    let test_fn = format!(\"{tname}.txt\");\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    assert_fixture_exists!(test_fn);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", inf!(test_fn), of!(tmp_fn)])\n        .run()\n        .no_stderr()\n        .no_stdout()\n        .success();\n\n    cmp_file!(\n        File::open(fixture_path!(&test_fn)).unwrap(),\n        fix.open(&tmp_fn)\n    );\n}\n\n#[test]"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_tombstone_block_list", "code": "pub fn send(&mut self, msg: RaftMessage) -> result::Result<(), DiscardReason> {\n        let store_id = msg.get_to_peer().store_id;\n        let grpc_raft_conn_num = self.builder.cfg.value().grpc_raft_conn_num as u64;\n        let conn_id = if grpc_raft_conn_num == 1 {\n            0\n        } else {\n            if self.last_hash.0 == 0 || msg.region_id != self.last_hash.0 {\n                self.last_hash = (\n                    msg.region_id,\n                    seahash::hash(&msg.region_id.to_ne_bytes()) % grpc_raft_conn_num,\n                );\n            };\n            self.last_hash.1 as usize\n        };\n\n        #[allow(unused_mut)]\n        let mut transport_on_send_store_fp = || {\n            fail_point!(\n                \"transport_on_send_snapshot\",\n                msg.get_message().get_msg_type() == raft::eraftpb::MessageType::MsgSnapshot,\n                |sid| if let Some(sid) = sid {\n                    let sid: u64 = sid.parse().unwrap();\n                    if sid == store_id {\n                        // Forbid building new connections.\n                        fail::cfg(_ON_RESOLVE_FP, &format!(\"1*return({})\", sid)).unwrap();\n                        self.cache.remove(&(store_id, conn_id));\n                        self.pool\n                            .lock()\n                            .unwrap()\n                            .connections\n                            .remove(&(store_id, conn_id));\n                    }\n                }\n            )\n        };\n        transport_on_send_store_fp();\n        loop {\n            if let Some(s) = self.cache.get_mut(&(store_id, conn_id)) {\n                match s.queue.push(msg) {\n                    Ok(_) => {\n                        if !s.dirty {\n                            s.dirty = true;\n                            self.need_flush.push((store_id, conn_id));\n                        }\n                        return Ok(());\n                    }\n                    Err(DiscardReason::Full) => {\n                        s.queue.notify();\n                        s.dirty = false;\n                        if !s.full {\n                            s.full = true;\n                            self.full_stores.push((store_id, conn_id));\n                        }\n                        return Err(DiscardReason::Full);\n                    }\n                    Err(DiscardReason::Disconnected) => break,\n                    Err(DiscardReason::Paused) => return Err(DiscardReason::Paused),\n                    Err(DiscardReason::Filtered) => return Err(DiscardReason::Filtered),\n                }\n            }\n            if !self.load_stream(store_id, conn_id) {\n                return Err(DiscardReason::Disconnected);\n            }\n        }\n        self.cache.remove(&(store_id, conn_id));\n        Err(DiscardReason::Disconnected)\n    }", "test": "fn test_tombstone_block_list() {\n    let pd_server = test_pd::Server::new(1);\n    let eps = pd_server.bind_addrs();\n    let pd_client = Arc::new(test_pd::util::new_client(eps, None));\n    let bg_worker = WorkerBuilder::new(thd_name!(\"background\"))\n        .thread_count(2)\n        .create();\n    let resolver = resolve::new_resolver(pd_client, &bg_worker, FakeExtension).0;\n\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), true);\n    let (_mock_server, port) = create_mock_server(service, 60200, 60300).unwrap();\n\n    let mut raft_client = get_raft_client(FakeExtension, resolver);\n\n    let mut store1 = metapb::Store::default();\n    store1.set_id(1);\n    store1.set_address(format!(\"127.0.0.1:{}\", port));\n    pd_server.default_handler().add_store(store1.clone());\n\n    // `send` should success.\n    for _ in 0..10 {\n        // 5M per RaftMessage.\n        let mut raft_m = RaftMessage::default();\n        raft_m.mut_to_peer().set_store_id(1);\n        for _ in 0..(5 * 1024) {\n            let mut e = Entry::default();\n            e.set_data(vec![b'a'; 1024].into());\n            raft_m.mut_message().mut_entries().push(e);\n        }\n        raft_client.send(raft_m).unwrap();\n    }\n    raft_client.flush();\n\n    check_msg_count(500, &msg_count, 10);\n\n    let mut store2 = metapb::Store::default();\n    store2.set_id(2);\n    store2.set_address(store1.get_address().to_owned());\n    store2.set_state(metapb::StoreState::Tombstone);\n    pd_server.default_handler().add_store(store2);\n    let mut message = RaftMessage::default();\n    message.mut_to_peer().set_store_id(2);\n    // First message should be OK.\n    raft_client.send(message.clone()).unwrap();\n    // Wait some time for the resolve result.\n    thread::sleep(time::Duration::from_millis(50));\n    // Second message should fail as the store should be added to block list.\n    assert_eq!(\n        DiscardReason::Disconnected,\n        raft_client.send(message).unwrap_err()\n    );\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_4", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_4() {\n    let original = r##\"# spaces {#myid1}    \n## tabs {#myid2}        \n\"##;\n    let expected = r##\"<h1 id=\"myid1\">spaces</h1>\n<h2 id=\"myid2\">tabs</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_padding_with_overflow", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_padding_with_overflow() {\n    new_ucmd!()\n        .args(&[\"-i\", \"1000\", \"-s\", \"x\", \"-n\", \"rz\", \"-w\", \"4\", \"simple.txt\"])\n        .run()\n        .stdout_is(\n            \"0001xL1\\n1001xL2\\n2001xL3\\n3001xL4\\n4001xL5\\n5001xL6\\n6001xL7\\n7001xL8\\n8001xL9\\n\\\n             9001xL10\\n10001xL11\\n11001xL12\\n12001xL13\\n13001xL14\\n14001xL15\\n\",\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_older_than_src", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_older_dest_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_older_file1\";\n    let new = \"test_cp_arg_update_dest_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), \"new content\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::delete_variable_in_strict", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn delete_variable_in_strict() {\n    // Checks as per https://tc39.es/ecma262/#sec-delete-operator-static-semantics-early-errors\n    // that delete on a variable name is an error in strict mode code.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            let x = 10;\n            delete x;\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"cannot delete variables in strict mode at line 3, col 1\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_too_large_block_size", "code": "fn run_command(size: &str) {\n        new_ucmd!()\n            .arg(format!(\"--block-size={size}\"))\n            .fails()\n            .stderr_contains(format!(\"--block-size argument '{size}' too large\"));\n    }", "test": "fn test_too_large_block_size() {\n    fn run_command(size: &str) {\n        new_ucmd!()\n            .arg(format!(\"--block-size={size}\"))\n            .fails()\n            .stderr_contains(format!(\"--block-size argument '{size}' too large\"));\n    }\n\n    let too_large_sizes = vec![\"1Y\", \"1Z\"];\n\n    for size in too_large_sizes {\n        run_command(size);\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_bytes_ser", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "test": "fn test_bytes_ser() {\n    let buf = vec![];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[]\".to_string());\n\n    let buf = vec![1, 2, 3];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_effective_suffix_hex_last", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_effective_suffix_hex_last() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"-n\",\n        \"4\",\n        \"--hex-suffixes=7\",\n        \"--numeric-suffixes=4\",\n        \"-x\",\n        \"-d\",\n        \"--hex-suffixes=9\",\n        \"threebytes.txt\",\n    ])\n    .succeeds()\n    .no_stdout()\n    .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_context_underflow", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_context_underflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/5/-10\"])\n        .fails()\n        .stdout_is(\"0\\n141\\n\")\n        .stderr_is(\"csplit: '/5/-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/5/-10\", \"-k\"])\n        .fails()\n        .stdout_is(\"0\\n141\\n\")\n        .stderr_is(\"csplit: '/5/-10': line number out of range\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"counting splits\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), \"\");\n    assert_eq!(at.read(\"xx01\"), generate(1, 51));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_22", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_22() {\n    let original = r##\"# H1 {.foo}bar}\n\"##;\n    let expected = r##\"<h1>H1 {.foo}bar}</h1>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_flag_a_0", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_flag_a_0() {\n    new_ucmd!()\n        .args(&[\"--\"])\n        .pipe_in(\"e     E\\nf      F\\ng       G\\nh        H\\n\")\n        .run()\n        .stdout_is(\"e     E\\nf      F\\ng       G\\nh        H\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::passthrough_wrong_type", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn passthrough_wrong_type() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"a\" (borrow $t)) (result (own $t))))\n\n                (core func $f (canon lower (func $f)))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32) (result i32)))\n                    (func (export \"f2\") (param i32)\n                        (drop (call $f (local.get 0)))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n        .root()\n        .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| Ok((r,)))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource,)).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"cannot lower a `borrow` resource into an `own`\"),\n        \"bad error: {err:?}\"\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_conflict_options", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_output_conflict_options() {\n    for option in [\"-i\", \"-T\", \"-P\"] {\n        new_ucmd!().arg(\"--output=source\").arg(option).fails();\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_window_update_on_stream_closed_by_data_frame", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn recv_window_update_on_stream_closed_by_data_frame() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let (response, mut stream) = client.send_request(request, false).unwrap();\n\n        // Wait for the response\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n\n        // Send a data frame, this will also close the connection\n        stream.send_data(\"hello\".into(), true).unwrap();\n\n        // keep `stream` from being dropped in order to prevent\n        // it from sending an RST_STREAM frame.\n        //\n        // i know this is kind of evil, but it's necessary to\n        // ensure that the stream is closed by the EOS frame,\n        // and not by the RST_STREAM.\n        std::mem::forget(stream);\n\n        // Wait for the connection to close\n        h2.await.unwrap();\n    };\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames::data(1, \"hello\").eos()).await;\n        srv.send_frame(frames::window_update(1, 5)).await;\n    };\n    join(srv, h2).await;\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/ignore_comments.rs::ignore_recipe_comments_with_shell_setting", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn ignore_recipe_comments_with_shell_setting() {\n  Test::new()\n    .justfile(\n      \"\n      set shell := ['echo', '-n']\n      set ignore-comments\n\n      some_recipe:\n        # Alternate shells still ignore comments\n        echo something-useful\n    \",\n    )\n    .stdout(\"something-useful\\n\")\n    .stderr(\"echo something-useful\\n\")\n    .run();\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/large_number.rs::test_large_integer_to_float", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_large_integer_to_float() {\n    use ron::value::Float;\n    let test_var = std::i64::MAX as u64 + 1;\n    let expected = test_var as f64; // Is exactly representable by f64\n    let test_ser = ron::ser::to_string(&test_var).unwrap();\n    assert_eq!(test_ser, test_var.to_string());\n    let test_deser = ron::de::from_str::<Value>(&test_ser);\n\n    assert_eq!(\n        test_deser.unwrap(),\n        Value::Number(Number::Float(Float::new(expected))),\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_stale_peer.rs::test_server_stale_peer_without_data_left_derive_when_split", "code": "fn test_stale_peer_without_data<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    let region = cluster.get_region(b\"\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    cluster.must_split(&region, b\"k2\");\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine3 = cluster.get_engine(3);\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    let new_region = if right_derive {\n        cluster.get_region(b\"k1\")\n    } else {\n        cluster.get_region(b\"k3\")\n    };\n    let new_region_id = new_region.get_id();\n    // Block peer (3, 4) at receiving snapshot, but not the heartbeat\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(new_region_id, 3).msg_type(MessageType::MsgSnapshot),\n    ));\n\n    pd_client.must_add_peer(new_region_id, new_peer(3, 4));\n\n    // Wait for the heartbeat broadcasted from peer (1, 1000) to peer (3, 4).\n    cluster.must_region_exist(new_region_id, 3);\n\n    // And then isolate peer (3, 4) from peer (1, 1000).\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_remove_peer(new_region_id, new_peer(3, 4));\n\n    cluster.must_remove_region(3, new_region_id);\n\n    // There must be no data on store 3 belongs to new region\n    if right_derive {\n        must_get_none(&engine3, b\"k1\");\n    } else {\n        must_get_none(&engine3, b\"k3\");\n    }\n\n    // Check whether peer(3, 4) is destroyed.\n    // Before peer 4 is destroyed, a tombstone mark will be written into the engine.\n    // So we could check the tombstone mark to make sure peer 4 is destroyed.\n    let state_key = keys::region_state_key(new_region_id);\n    let state: RegionLocalState = engine3.get_msg_cf(CF_RAFT, &state_key).unwrap().unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // other region should not be affected.\n    if right_derive {\n        must_get_equal(&engine3, b\"k3\", b\"v3\");\n    } else {\n        must_get_equal(&engine3, b\"k1\", b\"v1\");\n    }\n}", "test": "fn test_server_stale_peer_without_data_left_derive_when_split() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    test_stale_peer_without_data(&mut cluster, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_failing_no_such_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_install_failing_no_such_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"inexistent_file\";\n    let dir1 = \"target_dir\";\n\n    at.mkdir(dir1);\n    at.touch(file1);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(dir1)\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_empty", "code": "pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n            .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    }", "test": "fn test_cp_sparse_always_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 4;\n    let buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=always\", \"src_file1\", \"dst_file_sparse\"])\n        .succeeds();\n\n    assert_eq!(at.read_bytes(\"dst_file_sparse\"), buf);\n    assert_eq!(at.metadata(\"dst_file_sparse\").blocks(), 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_enter_joint_state", "code": "pub fn is_in_joint(&self, region_id: u64) -> bool {\n        let region = block_on(self.get_region_by_id(region_id))\n            .unwrap()\n            .expect(\"region not exist\");\n        region.get_peers().iter().any(|p| {\n            p.get_role() == PeerRole::IncomingVoter || p.get_role() == PeerRole::DemotingVoter\n        })\n    }", "test": "fn test_enter_joint_state() {\n    let mut cluster = new_node_cluster(0, 4);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // normal confchange request will not enter joint state\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    assert!(!pd_client.is_in_joint(region_id));\n    pd_client.must_add_peer(region_id, new_peer(3, 3));\n    assert!(!pd_client.is_in_joint(region_id));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // confchange_v2 request with one conchange request will not enter joint state\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![(ConfChangeType::RemoveNode, new_peer(3, 3))],\n    );\n    assert!(!pd_client.is_in_joint(region_id));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    pd_client.must_joint_confchange(region_id, vec![(ConfChangeType::AddNode, new_peer(3, 3))]);\n    assert!(!pd_client.is_in_joint(region_id));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Enter joint\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(3, 3)),\n            (ConfChangeType::AddNode, new_peer(4, 4)),\n        ],\n    );\n    assert!(pd_client.is_in_joint(region_id));\n\n    // In joint state any confchange request besides leave joint request\n    // will be rejected\n    let resp = call_conf_change(\n        &mut cluster,\n        region_id,\n        ConfChangeType::RemoveNode,\n        new_learner_peer(3, 3),\n    )\n    .unwrap();\n    must_contains_error(&resp, \"in joint\");\n\n    let resp = call_conf_change_v2(\n        &mut cluster,\n        region_id,\n        vec![change_peer(\n            ConfChangeType::RemoveNode,\n            new_learner_peer(3, 3),\n        )],\n    )\n    .unwrap();\n    must_contains_error(&resp, \"in joint\");\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_cmd_epoch_checker.rs::test_not_invoke_committed_cb_when_fail_to_commit", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_not_invoke_committed_cb_when_fail_to_commit() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k\", b\"v\");\n\n    // Partition the leader and followers to let the leader fails to commit the\n    // proposal.\n    cluster.partition(vec![1], vec![2, 3]);\n    let write_req = make_write_req(&mut cluster, b\"k1\");\n    let (cb, mut cb_receivers) = make_cb(&write_req);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, write_req, cb)\n        .unwrap();\n    // Check the request is proposed but not committed.\n    cb_receivers\n        .committed\n        .recv_timeout(Duration::from_millis(200))\n        .unwrap_err();\n    cb_receivers.proposed.try_recv().unwrap();\n\n    // The election timeout is 250ms by default.\n    let election_timeout = cluster.cfg.raft_store.raft_base_tick_interval.0\n        * cluster.cfg.raft_store.raft_election_timeout_ticks as u32;\n    std::thread::sleep(2 * election_timeout);\n\n    // Make sure a new leader is elected and will discard the previous proposal when\n    // partition is recovered.\n    cluster.must_put(b\"k2\", b\"v\");\n    cluster.clear_send_filters();\n\n    let resp = cb_receivers\n        .applied\n        .recv_timeout(Duration::from_secs(1))\n        .unwrap();\n    assert!(resp.get_header().has_error(), \"{:?}\", resp);\n    // The committed callback shouldn't be invoked.\n    cb_receivers.committed.try_recv().unwrap_err();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::round_to_f64_test", "code": "fn check_round_to_f64(mant: u64, exp: i32, r_mant: u64, r_exp: i32) {\n    let mut x = ExtendedFloat { mant, exp };\n    x.round_to_native::<f64, _>(round_nearest_tie_even);\n    assert_eq!(\n        x,\n        ExtendedFloat {\n            mant: r_mant,\n            exp: r_exp\n        }\n    );\n}", "test": "fn round_to_f64_test() {\n    // This is lossy, so some of these values are **slightly** rounded.\n\n    // underflow\n    check_round_to_f64(9223372036854775808, -1138, 0, -1074);\n\n    // min value\n    check_round_to_f64(9223372036854775808, -1137, 1, -1074);\n\n    // 1.0e-250\n    check_round_to_f64(15095849699286165504, -562, 7371020360979573, -551);\n\n    // 1.0e-150\n    check_round_to_f64(15095849699286165504, -562, 7371020360979573, -551);\n\n    // 1.0e-45\n    check_round_to_f64(13164036458569648128, -213, 6427752177035961, -202);\n\n    // 1.0e-40\n    check_round_to_f64(10043362776618688512, -196, 4903985730770844, -185);\n\n    // 1.0e-20\n    check_round_to_f64(13611294676837537792, -130, 6646139978924579, -119);\n\n    // 1.0\n    check_round_to_f64(9223372036854775808, -63, 4503599627370496, -52);\n\n    // 1e20\n    check_round_to_f64(12500000000000000000, 3, 6103515625000000, 14);\n\n    // 1e40\n    check_round_to_f64(16940658945086007296, 69, 8271806125530277, 80);\n\n    // 1e150\n    check_round_to_f64(11270725851789228032, 435, 5503284107318959, 446);\n\n    // 1e250\n    check_round_to_f64(12882297539194265600, 767, 6290184345309700, 778);\n\n    // max value\n    check_round_to_f64(18446744073709549568, 960, 9007199254740991, 971);\n\n    // Bug fixes\n    // 1.2345e-308\n    check_round_to_f64(10234494226754558294, -1086, 2498655817078750, -1074);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_when_symlink_is_absolute_and_enoent", "code": "pub fn stderr_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stderr_str(), msg.as_ref());\n        self\n    }", "test": "fn test_realpath_when_symlink_is_absolute_and_enoent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"dir2\");\n    at.touch(\"dir2/bar\");\n\n    at.mkdir(\"dir1\");\n    at.symlink_file(\"dir2/bar\", \"dir1/foo1\");\n    at.symlink_file(\"/dir2/bar\", \"dir1/foo2\");\n    at.relative_symlink_file(\"../dir2/baz\", \"dir1/foo3\");\n\n    #[cfg(unix)]\n    ucmd.arg(\"dir1/foo1\")\n        .arg(\"dir1/foo2\")\n        .arg(\"dir1/foo3\")\n        .run()\n        .stdout_contains(\"/dir2/bar\\n\")\n        .stdout_contains(\"/dir2/baz\\n\")\n        .stderr_is(\"realpath: dir1/foo2: No such file or directory\\n\");\n\n    #[cfg(windows)]\n    ucmd.arg(\"dir1/foo1\")\n        .arg(\"dir1/foo2\")\n        .arg(\"dir1/foo3\")\n        .run()\n        .stdout_contains(\"\\\\dir2\\\\bar\\n\")\n        .stdout_contains(\"\\\\dir2\\\\baz\\n\")\n        .stderr_is(\"realpath: dir1/foo2: No such file or directory\\n\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::large_keys", "code": "fn commit(self) -> Result<(), ()> {\n        self.txn.commit().map_err(|_| ())\n    }", "test": "fn large_keys() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; 1024];\n    let value = vec![0u8; 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..100 {\n            key[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..100 {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_intrinsics", "code": "pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    }", "test": "fn mismatch_intrinsics() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                ;; note the mismatch where this is an intrinsic for `u` but\n                ;; we're typing it as `t`\n                (core func $t_ctor (canon resource.new $u))\n\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    assert_eq!(\n        ctor.call(&mut store, (100,)).unwrap_err().to_string(),\n        \"unknown handle index 0\"\n    );\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_shortcut", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_shortcut() {\n    new_ucmd!()\n        .args(&[\"-2\", \"-5\", \"-7\"])\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"  a  b c\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_line_length_words", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_line_length_words() {\n    new_ucmd!()\n        .arg(\"-Lw\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     87      48\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_offset_repeat_twice", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_offset_repeat_twice() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/+3\", \"{2}\"])\n        .succeeds()\n        .stdout_only(\"24\\n30\\n30\\n57\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 4);\n    assert_eq!(at.read(\"xx00\"), generate(1, 12));\n    assert_eq!(at.read(\"xx01\"), generate(12, 22));\n    assert_eq!(at.read(\"xx02\"), generate(22, 32));\n    assert_eq!(at.read(\"xx03\"), generate(32, 51));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_no_hex", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_no_hex() {\n    new_ucmd!()\n        .args(&[\"-e\", \"foo\\\\x bar\"])\n        .succeeds()\n        .stdout_only(\"foo\\\\x bar\\n\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_new_underscore", "code": "pub fn new(lifetime: Lifetime) -> Self {\n        LifetimeParam {\n            attrs: Vec::new(),\n            lifetime,\n            colon_token: None,\n            bounds: Punctuated::new(),\n        }\n    }", "test": "fn ident_new_underscore() {\n    new(\"_\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::ceil_divmod_test", "code": "fn ceil_divmod(self, y: Self) -> (Self, i32) {\n        let q = self / y;\n        let r = self % y;\n        match r == Self::ZERO {\n            true  => (q, i32::as_cast(r)),\n            false => (q + Self::ONE, i32::as_cast(r) - i32::as_cast(y))\n        }\n    }", "test": "fn ceil_divmod_test() {\n    use lexical_util::num::Integer;\n\n    assert_eq!(5usize.ceil_divmod(7), (1, -2));\n    assert_eq!(0usize.ceil_divmod(7), (0, 0));\n    assert_eq!(35usize.ceil_divmod(7), (5, 0));\n    assert_eq!(36usize.ceil_divmod(7), (6, -6));\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::sort_by", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn sort_by() {\n    let sort_by = \"SELECT * FROM db.table SORT BY a\";\n    hive().verified_stmt(sort_by);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_btc_locks_inscriptions", "code": "fn parse(witnesses: &[Witness]) -> Vec<ParsedEnvelope> {\n    ParsedEnvelope::from_transaction(&Transaction {\n      version: 0,\n      lock_time: LockTime::ZERO,\n      input: witnesses\n        .iter()\n        .map(|witness| TxIn {\n          previous_output: OutPoint::null(),\n          script_sig: ScriptBuf::new(),\n          sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n          witness: witness.clone(),\n        })\n        .collect(),\n      output: Vec::new(),\n    })\n  }", "test": "fn send_btc_locks_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let (_, reveal) = inscribe(&rpc_server);\n\n  let output =\n    CommandBuilder::new(\"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 1btc\")\n      .rpc_server(&rpc_server)\n      .run_and_deserialize_output::<Output>();\n\n  assert_eq!(\n    output.transaction,\n    \"0000000000000000000000000000000000000000000000000000000000000000\"\n      .parse()\n      .unwrap()\n  );\n\n  assert_eq!(\n    rpc_server.sent(),\n    &[Sent {\n      amount: 1.0,\n      address: \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\"\n        .parse::<Address<NetworkUnchecked>>()\n        .unwrap()\n        .assume_checked(),\n      locked: vec![OutPoint {\n        txid: reveal,\n        vout: 0,\n      }]\n    }]\n  )\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_limits_table_only", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_limits_table_only() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, StoreLimitsBuilder::new().table_elements(5).build());\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    // Test instance exports and host objects *not* hitting the limit\n    for memory in IntoIterator::into_iter([\n        instance.get_memory(&mut store, \"m\").unwrap(),\n        Memory::new(&mut store, MemoryType::new(0, None))?,\n    ]) {\n        memory.grow(&mut store, 3)?;\n        memory.grow(&mut store, 5)?;\n        memory.grow(&mut store, 2)?;\n        memory.grow(&mut store, 1)?;\n    }\n\n    // Test instance exports and host objects hitting the limit\n    for table in IntoIterator::into_iter([\n        instance.get_table(&mut store, \"t\").unwrap(),\n        Table::new(\n            &mut store,\n            TableType::new(ValType::FuncRef, 0, None),\n            Val::FuncRef(None),\n        )?,\n    ]) {\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n\n        assert_eq!(\n            table\n                .grow(&mut store, 1, Val::FuncRef(None))\n                .map_err(|e| e.to_string())\n                .unwrap_err(),\n            \"failed to grow table by `1`\"\n        );\n    }\n\n    Ok(())\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_recv_buffer_overflow", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn datagram_recv_buffer_overflow() {\n    let _guard = subscribe();\n    const WINDOW: usize = 100;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: Some(WINDOW),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_eq!(\n        pair.client_conn_mut(client_ch).datagrams().max_size(),\n        Some(WINDOW - Datagram::SIZE_BOUND)\n    );\n\n    const DATA1: &[u8] = &[0xAB; (WINDOW / 3) + 1];\n    const DATA2: &[u8] = &[0xBC; (WINDOW / 3) + 1];\n    const DATA3: &[u8] = &[0xCD; (WINDOW / 3) + 1];\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA2.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA3.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA2);\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA3);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.drive();\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA1);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/sst.rs::other_external_sst_info", "code": "fn smallest_key(&self) -> &[u8] {\n        panic!()\n    }", "test": "fn other_external_sst_info() -> Result<()> {\n    let tempdir = tempdir();\n    let sst_path = tempdir\n        .path()\n        .join(\"test-data.sst\")\n        .to_string_lossy()\n        .to_string();\n    let sst_builder = <KvTestEngine as SstExt>::SstWriterBuilder::new();\n    let mut sst_writer = sst_builder.build(&sst_path)?;\n\n    sst_writer.put(b\"k1\", b\"v11\")?;\n    sst_writer.put(b\"k9\", b\"v9\")?;\n\n    let info = sst_writer.finish()?;\n\n    assert_eq!(b\"k1\", info.smallest_key());\n    assert_eq!(b\"k9\", info.largest_key());\n    assert_eq!(2, info.num_entries());\n\n    let size = fs::metadata(&sst_path).unwrap().len();\n\n    assert_eq!(size, info.file_size());\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_custom_suffix_via_env", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_custom_suffix_via_env() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::cpp_namespace", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn cpp_namespace() {\n    let source = r#\"\n    void Test::abcdef::hello() {\n        int size = 1;\n        return;\n    }\n    \"#;\n\n    let needle = \"_ $fn(){\n        size = 1;\n        }\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n\n    let needle = \"_ _::$fn(){\n        size = 1;\n        }\";\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/code_removal.rs::undefined_return", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn undefined_return() {\n    test(\"function f(){return undefined;}\", \"function f(){return}\");\n    test(\"function f(){return void 0;}\", \"function f(){return}\");\n    test(\"function f(){return void foo();}\", \"function f(){return void foo()}\");\n    test(\"function f(){if(a()){return undefined;}}\", \"function f(){if(a())return}\");\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_comment", "code": "pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    }", "test": "fn test_offset_err_comment() {\n    let mut r = Reader::from_str(\"<a><!--b>\");\n    r.trim_text(true);\n\n    next_eq!(r, Start, b\"a\");\n    assert_eq!(r.buffer_position(), 3);\n\n    match r.read_event() {\n        // error at char 4: no closing --> tag found\n        Err(e) => assert_eq!(\n            r.buffer_position(),\n            4,\n            \"expecting buf_pos = 4, found {}, err {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::client_stateless_reset", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn client_stateless_reset() {\n    let _guard = subscribe();\n    let mut reset_key = vec![0; 64];\n    let mut rng = rand::thread_rng();\n    rng.fill_bytes(&mut reset_key);\n    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);\n\n    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));\n\n    let mut pair = Pair::new(endpoint_config.clone(), server_config());\n    let (_, server_ch) = pair.connect();\n    pair.client.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);\n    // Send something big enough to allow room for a smaller stateless reset.\n    pair.server.connections.get_mut(&server_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        (&[0xab; 128][..]).into(),\n    );\n    info!(\"resetting\");\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::Reset\n        })\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::bad_import_alignment", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn bad_import_alignment() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"unaligned-retptr\" (func $unaligned_retptr (result string)))\n  (type $many_arg (tuple\n    string string string string\n    string string string string\n    string\n  ))\n  (import \"unaligned-argptr\" (func $unaligned_argptr (param \"a\" $many_arg)))\n  (core module $libc_panic\n    (memory (export \"memory\") 1)\n    (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n      unreachable)\n  )\n  (core instance $libc_panic (instantiate $libc_panic))\n\n  (core func $unaligned_retptr_lower\n    (canon lower (func $unaligned_retptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n  (core func $unaligned_argptr_lower\n    (canon lower (func $unaligned_argptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n\n  (core module $m\n    (import \"host\" \"unaligned-retptr\" (func $unaligned_retptr (param i32)))\n    (import \"host\" \"unaligned-argptr\" (func $unaligned_argptr (param i32)))\n\n    (func (export \"unaligned-retptr\")\n     (call $unaligned_retptr (i32.const 1)))\n    (func (export \"unaligned-argptr\")\n     (call $unaligned_argptr (i32.const 1)))\n  )\n  (core instance $m (instantiate $m\n    (with \"host\" (instance\n      (export \"unaligned-retptr\" (func $unaligned_retptr_lower))\n      (export \"unaligned-argptr\" (func $unaligned_argptr_lower))\n    ))\n  ))\n\n  (func (export \"unaligned-retptr2\")\n    (canon lift (core func $m \"unaligned-retptr\"))\n  )\n  (func (export \"unaligned-argptr2\")\n    (canon lift (core func $m \"unaligned-argptr\"))\n  )\n)\n        \"#\n    );\n\n    let engine = super::engine();\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"unaligned-retptr\", |_, _: ()| -> Result<(String,)> {\n            Ok((String::new(),))\n        })?;\n    linker.root().func_wrap(\n        \"unaligned-argptr\",\n        |_,\n         _: ((\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n        ),)|\n         -> Result<()> { unreachable!() },\n    )?;\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"unaligned-retptr2\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"pointer not aligned\"),\n        \"{}\",\n        trap\n    );\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"unaligned-argptr2\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"pointer not aligned\"),\n        \"{}\",\n        trap\n    );\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_integration.rs::test_sync_host_func", "code": "fn into(self) -> MemArg {\n        match self {\n            StackAMode::FPOffset(off, _ty) => MemArg::InitialSPOffset { off },\n            StackAMode::NominalSPOffset(off, _ty) => MemArg::NominalSPOffset { off },\n            StackAMode::SPOffset(off, _ty) => {\n                MemArg::reg_plus_off(stack_reg(), off, MemFlags::trusted())\n            }\n        }\n    }", "test": "fn test_sync_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    integration::add_atoms_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"int_float_args_shim\")\n        .unwrap()\n        .call(&mut store, &[0i32.into(), 123.45f32.into()], &mut results)\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"int_float_args errno\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_bootstrap.rs::test_bootstrap_half_way_failure_after_bootstrap_cluster", "code": "fn test_bootstrap_half_way_failure() {\n    let server = test_pd::Server::new(1);\n    let eps = server.bind_addrs();\n    let pd_client = test_pd::util::new_client(eps, None);\n    let path = TempDir::new().unwrap();\n    let engines = engine_test::new_temp_engine(&path);\n    let bootstrap = || {\n        let logger = slog_global::borrow_global().new(o!());\n        let mut bootstrap = Bootstrap::new(&engines.raft, 0, &pd_client, logger);\n        match bootstrap.bootstrap_store() {\n            Ok(store_id) => {\n                let mut store = Store::default();\n                store.set_id(store_id);\n                bootstrap.bootstrap_first_region(&store, store_id)\n            }\n            Err(e) => Err(e),\n        }\n    };\n\n    // Try to start this node, return after persisted some keys.\n    fail::cfg(\"node_after_bootstrap_store\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_store\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    let ident = engines.raft.get_store_ident().unwrap().unwrap();\n    assert_ne!(ident.get_store_id(), 0);\n\n    // Check whether it can bootstrap cluster successfully.\n    fail::remove(\"node_after_bootstrap_store\");\n    fail::cfg(\"node_after_prepare_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_prepare_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    fail::remove(\"node_after_prepare_bootstrap_cluster\");\n    fail::cfg(\"node_after_bootstrap_cluster\", \"return\").unwrap();\n    let s = format!(\"{}\", bootstrap().unwrap_err());\n    assert!(s.contains(\"node_after_bootstrap_cluster\"), \"{}\", s);\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(Some(_)));\n\n    // Although aborted by error, rebootstrap should continue.\n    bootstrap().unwrap().unwrap();\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n\n    // Second bootstrap should be noop.\n    assert_eq!(bootstrap().unwrap(), None);\n\n    assert_matches!(engines.raft.get_prepare_bootstrap_region(), Ok(None));\n}", "test": "fn test_bootstrap_half_way_failure_after_bootstrap_cluster() {\n    let fp = \"node_after_bootstrap_cluster\";\n    test_bootstrap_half_way_failure(fp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_prefix_template_separator", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_prefix_template_separator() {\n    new_ucmd!().args(&[\"-p\", \".\", \"-t\", \"a.XXXX\"]).succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_to_file_with_ibs_obs", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_to_file_with_ibs_obs() {\n    let tname = \"zero-256k\";\n    let test_fn = format!(\"{tname}.txt\");\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    assert_fixture_exists!(test_fn);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"status=none\",\n        inf!(test_fn),\n        of!(tmp_fn),\n        \"ibs=222\",\n        \"obs=111\",\n    ])\n    .run()\n    .no_stderr()\n    .no_stdout()\n    .success();\n\n    cmp_file!(\n        File::open(fixture_path!(&test_fn)).unwrap(),\n        fix.open(&tmp_fn)\n    );\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic.rs::parens_test", "code": "fn expr(input: &[u8]) -> IResult<&[u8], i64> {\n  let (input, init) = term(input)?;\n  fold_many0(\n    pair(one_of(\"+-\"), term),\n    move || init,\n    |acc, (op, val)| {\n      if op == '+' {\n        acc + val\n      } else {\n        acc - val\n      }\n    },\n  )(input)\n}", "test": "fn parens_test() {\n  assert_eq!(expr(\" (  2 )\"), Ok((\"\", 2)));\n  assert_eq!(expr(\" 2* (  3 + 4 ) \"), Ok((\"\", 14)));\n  assert_eq!(expr(\"  2*2 / ( 5 - 1) + 3\"), Ok((\"\", 4)));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_offset_date_and_reference", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_both_offset_date_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_date_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let five_days_later = str_to_filetime(\"%Y%m%d%H%M\", \"201501061234\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-d\", \"+5 days\", \"-r\", ref_file, file])\n        .succeeds()\n        .no_stderr();\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, five_days_later);\n    assert_eq!(mtime, five_days_later);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_resolved_ts_with_learners", "code": "pub fn get_resolved_ts(&self, region_id: &u64) -> Option<u64> {\n        self.registry\n            .lock()\n            .unwrap()\n            .get(region_id)\n            .map(|rp| rp.resolved_ts())\n    }", "test": "fn test_resolved_ts_with_learners() {\n    let cluster = new_server_cluster(0, 2);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new()\n        .cluster(cluster)\n        .build_with_cluster_runner(|cluster| {\n            let r = cluster.run_conf_change();\n            cluster.pd_client.must_add_peer(r, new_learner_peer(2, 2));\n        });\n\n    let rid = suite.cluster.get_region(&[]).id;\n    let req = suite.new_changedata_request(rid);\n    let (mut req_tx, _, receive_event) = new_event_feed(suite.get_region_cdc_client(rid));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n\n    for _ in 0..10 {\n        let event = receive_event(true);\n        if event.has_resolved_ts() {\n            assert!(event.get_resolved_ts().regions == vec![rid]);\n            drop(receive_event);\n            suite.stop();\n            return;\n        }\n    }\n    panic!(\"resolved timestamp should be advanced correctly\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_in_var_object", "code": "pub fn concat(&self, items: &[JsValue], context: &mut Context<'_>) -> JsResult<Self> {\n        let object = Array::concat(&self.inner.clone().into(), items, context)?\n            .as_object()\n            .cloned()\n            .expect(\"Array.prototype.filter should always return object\");\n\n        Self::from_object(object)\n    }", "test": "fn for_in_var_object() {\n    run_test_actions([\n        TestAction::run_harness(),\n        TestAction::run(indoc! {r#\"\n                let result = [];\n                let obj = { a: \"a\", b: 2};\n                for (var i in obj) {\n                    result = result.concat([i]);\n                }\n            \"#}),\n        TestAction::assert(\"arrayEquals(result, ['a', 'b'])\"),\n    ]);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/aot.rs::bare_bones", "code": "pub fn precompile_component(&self, bytes: &[u8]) -> Result<Vec<u8>> {\n        #[cfg(feature = \"wat\")]\n        let bytes = wat::parse_bytes(&bytes)?;\n        let (mmap, _) = crate::component::Component::build_artifacts(self, &bytes)?;\n        Ok(mmap.to_vec())\n    }", "test": "fn bare_bones() -> Result<()> {\n    let engine = super::engine();\n    let component = Component::new(&engine, \"(component)\")?.serialize()?;\n    assert_eq!(component, engine.precompile_component(b\"(component)\")?);\n\n    let component = unsafe { Component::deserialize(&engine, &component)? };\n    let mut store = Store::new(&engine, ());\n    Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_trailing_plus", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_trailing_plus() {\n    new_ucmd!()\n        .arg(\"--tabs=1,+5\")\n        .pipe_in(\"\\ta\\tb\\tc\")\n        .succeeds()\n        //          0         1\n        //          012345678901\n        .stdout_is(\" a    b    c\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_resource_types", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn mismatch_resource_types() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                (core func $t_ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n\n                (core func $u_dtor (canon resource.drop $u))\n                (func (export \"dtor\") (param \"x\" (own $u))\n                    (canon lift (core func $u_dtor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    let dtor = i.get_typed_func::<(ResourceAny,), ()>(&mut store, \"dtor\")?;\n\n    let (t,) = ctor.call(&mut store, (100,))?;\n    ctor.post_return(&mut store)?;\n    assert_eq!(\n        dtor.call(&mut store, (t,)).unwrap_err().to_string(),\n        \"mismatched resource types\"\n    );\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_circular", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_circular() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let link = \"test_symlink_circular\";\n\n    ucmd.args(&[\"-s\", link]).succeeds().no_stderr();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), link);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_node_readd_peer", "code": "fn test_readd_peer<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(2));\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    pd_client.must_add_peer(r1, new_peer(2, 4));\n\n    cluster.clear_send_filters();\n    cluster.must_put(b\"k4\", b\"v4\");\n    let engine = cluster.get_engine(2);\n    must_get_equal(&engine, b\"k4\", b\"v4\");\n\n    // Stale gc message should be ignored.\n    let epoch = pd_client.get_region_epoch(r1);\n    let mut gc_msg = RaftMessage::default();\n    gc_msg.set_region_id(r1);\n    gc_msg.set_from_peer(new_peer(1, 1));\n    gc_msg.set_to_peer(new_peer(2, 2));\n    gc_msg.set_region_epoch(epoch);\n    gc_msg.set_is_tombstone(true);\n    cluster.send_raft_msg(gc_msg).unwrap();\n    // Fixme: find a better way to check if the message is ignored.\n    thread::sleep(Duration::from_secs(1));\n    must_get_equal(&engine, b\"k4\", b\"v4\");\n}", "test": "fn test_node_readd_peer() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_readd_peer(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_output_arg", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_df_output_arg() {\n    new_ucmd!().args(&[\"--output=source\", \"-iPT\"]).fails();\n    new_ucmd!().args(&[\"-iPT\", \"--output=source\"]).fails();\n    new_ucmd!()\n        .args(&[\"--output=source\", \"--output=source\"])\n        .fails();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_duckdb.rs::parse_div_infix", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_div_infix() {\n    duckdb_and_generic().verified_stmt(r#\"SELECT 5 // 2\"#);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_single", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_single() {\n    let mut env = Environment::new();\n    env.add_template(\"simple\", \"Hello {{ name }}!\").unwrap();\n    let tmpl = env.get_template(\"simple\").unwrap();\n    let rv = tmpl.render(context!(name => \"Peter\")).unwrap();\n    assert_eq!(rv, \"Hello Peter!\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_existing", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_existing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::get_invalid", "code": "fn is_none(&self) -> bool {\n        self.index == !0\n    }", "test": "fn get_invalid() {\n    let mut headers = HeaderMap::new();\n    headers.insert(\"foo\", \"bar\".parse().unwrap());\n    assert!(headers.get(\"Evil\\r\\nKey\").is_none());\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_min_max", "code": "pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -46 || m10 == 0 {\n        // Number is less than 1e-46, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n    if m10digits + e10 >= 40 {\n        // Number is larger than 1e+39, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u32;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits; better to\n        // have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the FLOAT_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(f2s::FLOAT_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        m2 = mul_pow5_div_pow2(m10, e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(f2s::FLOAT_POW5_INV_BITCOUNT);\n        m2 = mul_pow5_inv_div_pow2(m10, -e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))\n        //\n        // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10))\n        // divides m10, which is the case iff pow5(m10) >= -e10 AND pow2(m10) >=\n        // e2-e10.\n        //\n        // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) /\n        // 5^(-e10)] above, and we need to check whether 5^(-e10) divides (m10 *\n        // 2^(e10-e2)), which is the case iff pow5(m10 * 2^(e10-e2)) = pow5(m10)\n        // >= -e10.\n        trailing_zeros = (e2 < e10\n            || (e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32)))\n            && multiple_of_power_of_5_32(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + FLOAT_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0xfe {\n        // Final IEEE exponent is larger than the maximum representable; return\n        // +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(FLOAT_EXPONENT_BIAS as i32)\n        .wrapping_sub(f2s::FLOAT_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u32 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u32);\n    debug_assert!(ieee_m2 <= 1_u32 << (f2s::FLOAT_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u32 << f2s::FLOAT_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Rounding up may overflow the mantissa.\n        // In this case we move a trailing zero of the mantissa into the\n        // exponent.\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u32) << f2s::FLOAT_EXPONENT_BITS) | ieee_e2)\n        << f2s::FLOAT_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f32::from_bits(ieee))\n}", "test": "fn test_min_max() {\n    assert_eq!(1e-45, s2f(b\"1e-45\").unwrap());\n    assert_eq!(f32::MIN_POSITIVE, s2f(b\"1.1754944e-38\").unwrap());\n    assert_eq!(f32::MAX, s2f(b\"3.4028235e+38\").unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_snapshot_failed", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_snapshot_failed() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"rockskv_async_snapshot\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"snapshot failed\"));\n}"}
{"test_id": "pyfisch-cbor/pyfisch-cbor-347a3f0/tests/ser.rs::test_list", "code": "fn serialize_and_compare<T: Serialize>(value: T, expected: &[u8]) {\n    let mut slice = [0u8; 64];\n    let writer = SliceWrite::new(&mut slice);\n    let mut serializer = Serializer::new(writer);\n    value.serialize(&mut serializer).unwrap();\n    let writer = serializer.into_inner();\n    let end = writer.bytes_written();\n    let slice = writer.into_inner();\n    assert_eq!(&slice[..end], expected);\n}", "test": "fn test_list() {\n    serialize_and_compare(&[1, 2, 3], b\"\\x83\\x01\\x02\\x03\");\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_timeformat", "code": "pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    }", "test": "fn test_timeformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"TIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|timeformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"18:37:22\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"18:37:22.5\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"unix\")).unwrap().to_string(),\n        \"1687624642\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"iso\")).unwrap().to_string(),\n        \"2023-06-24T18:37:22+02:00\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|timeformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"19:37\");\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-migrated.rs::test_parse_string", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "test": "fn test_parse_string() {\n    test_parse_ok(&[\n        (\n            \"<bla>This is a String</bla>\",\n            \"This is a String\".to_string(),\n        ),\n        (\"<bla></bla>\", \"\".to_string()),\n        (\"<bla>     </bla>\", \"\".to_string()),\n        (\"<bla>&lt;boom/&gt;</bla>\", \"<boom/>\".to_string()),\n        (\"<bla>&#9835;</bla>\", \"\u266b\".to_string()),\n        (\"<bla>&#x266B;</bla>\", \"\u266b\".to_string()),\n        //(\n        //    \"<bla>\u266b<![CDATA[<cookies/>]]>\u266b</bla>\",\n        //    \"\u266b<cookies/>\u266b\".to_string(),\n        //),\n    ]);\n}\n\n#[test]\n#["}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_with_table_alias", "code": "pub fn verified_only_select(&self, query: &str) -> Select {\n        match *self.verified_query(query).body {\n            SetExpr::Select(s) => *s,\n            _ => panic!(\"Expected SetExpr::Select\"),\n        }\n    }", "test": "fn parse_select_with_table_alias() {\n    let select = verified_only_select(\"SELECT a, b, c FROM lineitem AS l (A, B, C)\");\n    assert_eq!(\n        select.projection,\n        vec![\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"a\")),),\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"b\")),),\n            SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"c\")),),\n        ]\n    );\n    assert_eq!(\n        select.from,\n        vec![TableWithJoins {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(\"lineitem\")]),\n                alias: Some(TableAlias {\n                    name: Ident::new(\"l\"),\n                    columns: vec![Ident::new(\"A\"), Ident::new(\"B\"), Ident::new(\"C\"),],\n                }),\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            joins: vec![],\n        }]\n    );\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::math", "code": "fn size(x: u32) -> TextSize {\n    TextSize::from(x)\n}", "test": "fn math() {\n    assert_eq!(size(10) + size(5), size(15));\n    assert_eq!(size(10) - size(5), size(5));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_succeed_and_become_leader", "code": "pub fn must_transfer_leader(&mut self, region_id: u64, leader: metapb::Peer) {\n        let timer = Instant::now();\n        loop {\n            self.reset_leader_of_region(region_id);\n            let cur_leader = self.leader_of_region(region_id);\n            if let Some(ref cur_leader) = cur_leader {\n                if cur_leader.get_id() == leader.get_id()\n                    && cur_leader.get_store_id() == leader.get_store_id()\n                {\n                    return;\n                }\n            }\n            if timer.saturating_elapsed() > Duration::from_secs(5) {\n                panic!(\n                    \"failed to transfer leader to [{}] {:?}, current leader: {:?}\",\n                    region_id, leader, cur_leader\n                );\n            }\n            self.transfer_leader(region_id, leader.clone());\n        }\n    }", "test": "fn test_when_warmup_succeed_and_become_leader() {\n    let mut cluster = run_cluster_and_warm_up_cache_for_store2();\n\n    // Generally, the cache will be compacted during post_apply.\n    // However, if the cache is warmed up recently, the cache should be kept.\n    let applied_index = cluster.apply_state(1, 2).applied_index;\n    cluster.must_put(b\"kk1\", b\"vv1\");\n    cluster.wait_applied_index(1, 2, applied_index + 1);\n\n    // It should ack the message when cache is already warmed up.\n    // It needs not to fetch raft log anymore.\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.sim.wl().clear_recv_filters(1);\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_create_multiple_fifos", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_create_multiple_fifos() {\n    new_ucmd!()\n        .arg(\"abcde\")\n        .arg(\"def\")\n        .arg(\"sed\")\n        .arg(\"dum\")\n        .succeeds();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::allow_empty_blocks", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn allow_empty_blocks() {\n    let needle = \"{if ($x){}}\";\n    let source = r\"\n    void func(){\n    if (foo) {\n        a = 1;\n        b = 2;\n        c = 3;\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_ecdsa_sig", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_ecdsa_sig() {\n    let s = include_str!(\"data/serde/ecdsa_sig_hex\");\n    let sig = ecdsa::Signature {\n        sig: secp256k1::ecdsa::Signature::from_str(s.trim()).unwrap(),\n        hash_ty: EcdsaSighashType::All,\n    };\n\n    let got = serialize(&sig).unwrap();\n    let want = include_bytes!(\"data/serde/ecdsa_sig_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_drop_partition", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_drop_partition() {\n    let drop = \"ALTER TABLE db.table DROP PARTITION (a = 1)\";\n    hive().verified_stmt(drop);\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/msrv.rs::ci_files_are_up_to_date", "code": "fn ensure_file_contents(path: impl AsRef<Path>, contents: impl AsRef<str>) {\n    let path = path.as_ref();\n    let contents = contents.as_ref();\n\n    if let Ok(old_contents) = std::fs::read_to_string(path) {\n        if contents == old_contents {\n            // File is already up to date\n            return;\n        }\n    }\n\n    let display_path = path.strip_prefix(project_root()).unwrap_or(path);\n\n    eprintln!(\"{} was not up-to-date, updating...\", display_path.display());\n\n    if std::env::var(\"CI\").is_ok() {\n        eprintln!(\"Note: run `cargo test` locally and commit the updated files\");\n    }\n\n    if let Some(parent) = path.parent() {\n        let _ = std::fs::create_dir_all(parent);\n    }\n    std::fs::write(&path, contents).unwrap();\n    panic!(\n        \"\\\"{}\\\" was not up to date and has been updated. Please commit the changes and re-run the tests.\",\n        path.strip_prefix(project_root()).unwrap_or(path).display()\n    );\n}", "test": "fn ci_files_are_up_to_date() {\n    let pattern = Regex::new(r#\"MSRV:\\s*\"\\d+\\.\\d+\"\"#).unwrap();\n    let replacement = format!(\"MSRV: \\\"{}\\\"\", MSRV.as_str());\n    let workflows = project_root().join(\".github\").join(\"workflows\");\n\n    for result in workflows.read_dir().unwrap() {\n        let path = result.unwrap().path();\n\n        let contents = std::fs::read_to_string(&path).unwrap();\n        let expected = pattern.replace_all(&contents, &replacement);\n\n        ensure_file_contents(path, expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_should_not_add_newline_when_line_less_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_should_not_add_newline_when_line_less_than_fold() {\n    new_ucmd!().pipe_in(\"1234\").succeeds().stdout_is(\"1234\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sync.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_capitalize", "code": "fn capitalize(&self) -> String {\n        self.char_indices()\n            .fold(String::with_capacity(self.len()), |mut acc, x| {\n                if x.0 == 0 {\n                    acc.push(x.1.to_ascii_uppercase());\n                } else {\n                    acc.push(x.1);\n                }\n                acc\n            })\n    }", "test": "fn test_capitalize() {\n    assert_eq!(\"Zbnmasd\", \"zbnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"Abnmasd\", \"Abnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"1masd\", \"1masd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"\", \"\".capitalize());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_none", "code": "fn assert_engine_error<T>(r: engine_traits::Result<T>) {\n    match r {\n        Err(engine_traits::Error::Engine(_)) => {}\n        Err(e) => panic!(\"expected Error::Engine, got {:?}\", e),\n        Ok(_) => panic!(\"expected Error::Engine, got Ok\"),\n    }\n}", "test": "fn save_point_rollback_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    let err = wb.rollback_to_save_point();\n    assert_engine_error(err);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_disk_full.rs::test_almost_and_already_full_behavior", "code": "pub fn has_disk_full(&self) -> bool {\n        self.disk_full.is_some()\n    }", "test": "fn test_almost_and_already_full_behavior() {\n    let mut cluster = new_server_cluster(0, 5);\n    // To ensure the thread has full store disk usage infomation.\n    cluster.cfg.raft_store.store_batch_system.pool_size = 1;\n    cluster.pd_client.disable_default_operator();\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_transfer_leader(region.get_id(), new_peer(1, 1));\n    // To ensure followers have reported disk usages to the leader.\n    for i in [2u64, 3] {\n        fail::cfg(get_fp(DiskUsage::AlmostFull, i), \"return\").unwrap();\n    }\n    for i in [4u64, 5] {\n        fail::cfg(get_fp(DiskUsage::AlreadyFull, i), \"return\").unwrap();\n    }\n    for i in 1..5 {\n        ensure_disk_usage_is_reported(&mut cluster, i + 1, i + 1, &region);\n    }\n\n    let lead_client = PeerClient::new(&cluster, 1, new_peer(1, 1));\n    let prewrite_ts = get_tso(&cluster.pd_client);\n    let res = lead_client.try_kv_prewrite(\n        vec![new_mutation(Op::Put, b\"k2\", b\"v2\")],\n        b\"k2\".to_vec(),\n        prewrite_ts,\n        DiskFullOpt::AllowedOnAlmostFull,\n    );\n    assert!(!res.get_region_error().has_disk_full());\n    lead_client.must_kv_commit(\n        vec![b\"k2\".to_vec()],\n        prewrite_ts,\n        get_tso(&cluster.pd_client),\n    );\n\n    let index_1 = cluster.raft_local_state(1, 1).last_index;\n    let index_2 = cluster.raft_local_state(1, 2).last_index;\n    let index_3 = cluster.raft_local_state(1, 3).last_index;\n    let index_4 = cluster.raft_local_state(1, 4).last_index;\n    let index_5 = cluster.raft_local_state(1, 5).last_index;\n    assert!(\n        index_1 >= index_2\n            && index_1 >= index_3\n            && index_2 > index_4\n            && index_2 > index_5\n            && index_3 > index_4\n            && index_3 > index_5\n    );\n\n    for i in [2u64, 3] {\n        fail::remove(get_fp(DiskUsage::AlmostFull, i));\n    }\n    for i in [4u64, 5] {\n        fail::remove(get_fp(DiskUsage::AlreadyFull, i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_duplicate_files", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_duplicate_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds()\n        .stderr_contains(\"specified more than once\");\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_simple", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_simple() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=simple\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::dont_see_stale_stack_walking_registers", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn dont_see_stale_stack_walking_registers() -> Result<()> {\n    let engine = Engine::default();\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"host_start\" (func $host_start))\n                (import \"\" \"host_get_trap\" (func $host_get_trap))\n                (export \"get_trap\" (func $host_get_trap))\n\n                ;; We enter and exit Wasm, which saves registers in the\n                ;; `VMRuntimeLimits`. Later, when we call a re-exported host\n                ;; function, we should not accidentally reuse those saved\n                ;; registers.\n                (start $start)\n                (func $start\n                    (call $host_start)\n                )\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n\n    let host_start = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Ok(()),\n    );\n    linker.define(&store, \"\", \"host_start\", host_start)?;\n\n    let host_get_trap = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Err(anyhow::anyhow!(\"trap!!!\")),\n    );\n    linker.define(&store, \"\", \"host_get_trap\", host_get_trap)?;\n\n    let instance = linker.instantiate(&mut store, &module)?;\n    let get_trap = instance.get_func(&mut store, \"get_trap\").unwrap();\n\n    let err = get_trap.call(&mut store, &[], &mut []).unwrap_err();\n    assert!(err.to_string().contains(\"trap!!!\"));\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber_inferred_arg", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_no_clobber_inferred_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--no-clob\")\n        .fails();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_args_dir_symlinks", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "test": "fn valid_context_directory_recursive_follow_args_dir_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    /*\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(\"c\", lc_path.to_str().unwrap());\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap(),\n        None\n    );\n    */\n\n    // -H: if a command line argument is a symbolic link to a directory, traverse it.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-H\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    /*\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    */\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_empty_file", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_line_bytes_no_empty_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"1\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\");\n    assert_eq!(at.read(\"xab\"), \"\\n\");\n    assert_eq!(at.read(\"xac\"), \"2\");\n    assert_eq!(at.read(\"xad\"), \"2\");\n    assert_eq!(at.read(\"xae\"), \"2\");\n    assert_eq!(at.read(\"xaf\"), \"2\");\n    assert_eq!(at.read(\"xag\"), \"\\n\");\n    assert_eq!(at.read(\"xah\"), \"3\");\n    assert_eq!(at.read(\"xai\"), \"\\n\");\n    assert_eq!(at.read(\"xaj\"), \"4\");\n    assert!(!at.plus(\"xak\").exists());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_fail_and_its_timeout_is_too_long", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_when_warmup_fail_and_its_timeout_is_too_long() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.max_entry_cache_warmup_duration = ReadableDuration::secs(1000);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n\n    fail::cfg(\"worker_async_fetch_raft_log\", \"pause\").unwrap();\n    cluster.transfer_leader(1, new_peer(2, 2));\n    // Theoretically, the leader transfer can't succeed unless it sleeps\n    // max_entry_cache_warmup_duration.\n    sleep_ms(50);\n    let leader = cluster.leader_of_region(1).unwrap();\n    assert_eq!(leader.get_id(), 1);\n}"}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/cjk_compat_variants.rs::test_cjk_compat_variants", "code": "fn next (& mut self) -> Option < char > { let next = self . iter . next () ; if let Some (c) = next { if canonical_combining_class (c) != 0 { * self . value . borrow_mut () += 1 ; } } next }", "test": "fn test_cjk_compat_variants() {\n    // These codepoints have singleton decompositions in the canonical\n    // decomposition, and can use standardized variations.\n    let s = \"\\u{2f999}\\u{2f8a6}\";\n\n    // These codepoints have canonical decompositions.\n    let mut nfd_iter = s.chars().nfd();\n    assert_eq!(nfd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfd_iter.next(), None);\n\n    let mut nfkd_iter = s.chars().nfkd();\n    assert_eq!(nfkd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfkd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfkd_iter.next(), None);\n\n    let mut nfc_iter = s.chars().nfc();\n    assert_eq!(nfc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfc_iter.next(), None);\n\n    let mut nfkc_iter = s.chars().nfkc();\n    assert_eq!(nfkc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(nfkc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(nfkc_iter.next(), None);\n\n    // However they also have standardized variants.\n    let mut var_iter = s.chars().cjk_compat_variants();\n    assert_eq!(var_iter.next(), Some('\\u{831d}'));\n    assert_eq!(var_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_iter.next(), Some('\\u{6148}'));\n    assert_eq!(var_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_iter.next(), None);\n\n    // The standardized variants are normalization-stable.\n    let mut var_nfc_iter = s.chars().cjk_compat_variants().nfc();\n    assert_eq!(var_nfc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(var_nfc_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(var_nfc_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfc_iter.next(), None);\n\n    let mut var_nfd_iter = s.chars().cjk_compat_variants().nfd();\n    assert_eq!(var_nfd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(var_nfd_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(var_nfd_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfd_iter.next(), None);\n\n    let mut var_nfkc_iter = s.chars().cjk_compat_variants().nfkc();\n    assert_eq!(var_nfkc_iter.next(), Some('\\u{831d}'));\n    assert_eq!(var_nfkc_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfkc_iter.next(), Some('\\u{6148}'));\n    assert_eq!(var_nfkc_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfkc_iter.next(), None);\n\n    let mut var_nfkd_iter = s.chars().cjk_compat_variants().nfkd();\n    assert_eq!(var_nfkd_iter.next(), Some('\\u{831d}'));\n    assert_eq!(var_nfkd_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfkd_iter.next(), Some('\\u{6148}'));\n    assert_eq!(var_nfkd_iter.next(), Some('\\u{fe00}'));\n    assert_eq!(var_nfkd_iter.next(), None);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_macros", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn can_remove_whitespace_macros() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\" {%- import \"macros\" as macros -%} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {% import \"macros\" as macros %} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {%- import \"macros\" as macros %} {%- set hey = macros::hey() -%} {{hey}}\"#, \"Hey!\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"macros\", \"{% macro hey() -%} Hey! {%- endmacro %}\"),\n            (\"tpl\", input),\n        ])\n        .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::specify_env", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn specify_env() -> Result<()> {\n    // By default no env is inherited\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"tests/all/cli_tests/print_env.wat\"])\n        .env(\"THIS_WILL_NOT\", \"show up in the output\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n\n    // Specify a single env var\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--env\",\n            \"FOO=bar\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a single env var\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"--env\", \"FOO\", \"tests/all/cli_tests/print_env.wat\"])\n        .env(\"FOO\", \"bar\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a nonexistent env var\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--env\",\n            \"SURELY_THIS_ENV_VAR_DOES_NOT_EXIST_ANYWHERE_RIGHT\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n        .output()?;\n    assert!(!output.status.success());\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_restart_after_apply_premerge_before_apply_compact_log", "code": "pub fn get_engine(&self, node_id: u64) -> WrapFactory<EK> {\n        WrapFactory::new(\n            self.pd_client.clone(),\n            self.raft_engines[&node_id].clone(),\n            self.tablet_registries[&node_id].clone(),\n        )\n    }", "test": "fn test_node_merge_restart_after_apply_premerge_before_apply_compact_log() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(11);\n    // Rely on this config to trigger a compact log\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize(1));\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(10);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    // Prevent gc_log_tick to propose a compact log\n    let raft_gc_log_tick_fp = \"on_raft_gc_log_tick\";\n    fail::cfg(raft_gc_log_tick_fp, \"return()\").unwrap();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n    let left_peer_1 = find_peer(&left, 1).cloned().unwrap();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1);\n\n    // Make log gap between store 1 and store 3, for min_index in preMerge\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    for i in 0..6 {\n        cluster.must_put(format!(\"k1{}\", i).as_bytes(), b\"v1\");\n    }\n    // Prevent on_apply_res to update merge_state in Peer\n    // If not, almost everything cannot propose including compact log\n    let on_apply_res_fp = \"on_apply_res\";\n    fail::cfg(on_apply_res_fp, \"return()\").unwrap();\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n\n    cluster.clear_send_filters();\n    // Prevent apply fsm to apply compact log\n    let handle_apply_fp = \"on_handle_apply\";\n    fail::cfg(handle_apply_fp, \"return()\").unwrap();\n    fail::remove(raft_gc_log_tick_fp);\n\n    // Wait for compact log to be proposed and committed maybe\n    sleep_ms(30);\n\n    cluster.shutdown();\n\n    fail::remove(handle_apply_fp);\n    fail::remove(on_apply_res_fp);\n    // Prevent sched_merge_tick to propose CommitMerge\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    cluster.start().unwrap();\n\n    let last_index = cluster.raft_local_state(left.get_id(), 1).get_last_index();\n    // Wait for compact log to apply\n    let timer = Instant::now();\n    loop {\n        let apply_index = cluster.apply_state(left.get_id(), 1).get_applied_index();\n        if apply_index >= last_index {\n            break;\n        }\n        if timer.saturating_elapsed() > Duration::from_secs(3) {\n            panic!(\"logs are not applied after 3 seconds\");\n        }\n        thread::sleep(Duration::from_millis(20));\n    }\n    // Now schedule merge\n    fail::remove(schedule_merge_fp);\n\n    pd_client.check_merged_timeout(left.get_id(), Duration::from_secs(5));\n\n    cluster.must_put(b\"k123\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k123\", b\"v2\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::instanceofoperator_rhs_not_callable", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn instanceofoperator_rhs_not_callable() {\n    run_test_actions([TestAction::assert_native_error(\n        \"let s = new String(); s instanceof {}\",\n        JsNativeErrorKind::Type,\n        \"right-hand side of 'instanceof' is not callable\",\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_sst_recovery.rs::test_sst_recovery_basic", "code": "fn lock(primary: &[u8]) -> PessimisticLock {\n        PessimisticLock {\n            primary: primary.to_vec().into_boxed_slice(),\n            start_ts: 100.into(),\n            ttl: 3000,\n            for_update_ts: 110.into(),\n            min_commit_ts: 110.into(),\n            last_change_ts: 105.into(),\n            versions_to_last_change: 2,\n        }\n    }", "test": "fn test_sst_recovery_basic() {\n    let (mut cluster, pd_client, engine1) = create_tikv_cluster_with_one_node_damaged();\n\n    // Test that only sst recovery can delete the sst file, remove peer don't delete\n    // it.\n    fail::cfg(\"sst_recovery_before_delete_files\", \"pause\").unwrap();\n\n    let store_meta = cluster.store_metas.get(&1).unwrap().clone();\n    std::thread::sleep(CHECK_DURATION);\n    assert_eq!(\n        store_meta\n            .lock()\n            .unwrap()\n            .get_all_damaged_region_ids()\n            .len(),\n        2\n    );\n\n    // Remove peers for safe deletion of files in sst recovery.\n    let region = cluster.get_region(b\"2\");\n    let peer = find_peer(&region, 1).unwrap();\n    pd_client.must_remove_peer(region.id, peer.clone());\n    let region = cluster.get_region(b\"4\");\n    let peer = find_peer(&region, 1).unwrap();\n    pd_client.must_remove_peer(region.id, peer.clone());\n\n    // Read from other store must success.\n    assert_eq!(cluster.must_get(b\"4\").unwrap(), b\"val\");\n\n    std::thread::sleep(CHECK_DURATION);\n\n    must_get_equal(&engine1, b\"1\", b\"val\");\n    must_get_equal(&engine1, b\"7\", b\"val\");\n    assert_corruption(engine1.get_value(b\"z4\"));\n\n    fail::remove(\"sst_recovery_before_delete_files\");\n    std::thread::sleep(CHECK_DURATION);\n\n    must_get_equal(&engine1, b\"1\", b\"val\");\n    must_get_equal(&engine1, b\"7\", b\"val\");\n    assert!(engine1.get_value(b\"z4\").unwrap().is_none());\n\n    // Damaged file has been deleted.\n    let files = engine1.as_inner().get_live_files();\n    assert_eq!(files.get_files_count(), 2);\n    assert_eq!(store_meta.lock().unwrap().damaged_ranges.len(), 0);\n\n    // only store 1 remove peer so key \"4\" should be accessed by cluster.\n    assert_eq!(cluster.must_get(b\"4\").unwrap(), b\"val\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_fail_id", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_fail_id() {\n    // test chown 1111. file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}:\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}.\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_backspaced_char_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_backspaced_char_should_be_preserved() {\n    new_ucmd!()\n        .arg(\"-b\")\n        .pipe_in(\"x\\x08\")\n        .succeeds()\n        .stdout_is(\"x\\x08\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::integers", "code": "fn call_and_post_return(&self, mut store: impl AsContextMut, params: P) -> Result<R> {\n        let result = self.call(&mut store, params)?;\n        self.post_return(&mut store)?;\n        Ok(result)\n    }", "test": "fn integers() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"take-i32-100\") (param i32)\n                    local.get 0\n                    i32.const 100\n                    i32.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"take-i64-100\") (param i64)\n                    local.get 0\n                    i64.const 100\n                    i64.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"ret-i32-0\") (result i32) i32.const 0)\n                (func (export \"ret-i64-0\") (result i64) i64.const 0)\n                (func (export \"ret-i32-minus-1\") (result i32) i32.const -1)\n                (func (export \"ret-i64-minus-1\") (result i64) i64.const -1)\n                (func (export \"ret-i32-100000\") (result i32) i32.const 100000)\n            )\n            (core instance $i (instantiate (module $m)))\n            (func (export \"take-u8\") (param \"a\" u8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s8\") (param \"a\" s8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u16\") (param \"a\" u16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s16\") (param \"a\" s16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u32\") (param \"a\" u32) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s32\") (param \"a\" s32) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u64\") (param \"a\" u64) (canon lift (core func $i \"take-i64-100\")))\n            (func (export \"take-s64\") (param \"a\" s64) (canon lift (core func $i \"take-i64-100\")))\n\n            (func (export \"ret-u8\") (result u8) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s8\") (result s8) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u16\") (result u16) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s16\") (result s16) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u32\") (result u32) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s32\") (result s32) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u64\") (result u64) (canon lift (core func $i \"ret-i64-0\")))\n            (func (export \"ret-s64\") (result s64) (canon lift (core func $i \"ret-i64-0\")))\n\n            (func (export \"retm1-u8\") (result u8) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s8\") (result s8) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u16\") (result u16) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s16\") (result s16) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u32\") (result u32) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s32\") (result s32) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u64\") (result u64) (canon lift (core func $i \"ret-i64-minus-1\")))\n            (func (export \"retm1-s64\") (result s64) (canon lift (core func $i \"ret-i64-minus-1\")))\n\n            (func (export \"retbig-u8\") (result u8) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s8\") (result s8) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-u16\") (result u16) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s16\") (result s16) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-u32\") (result u32) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s32\") (result s32) (canon lift (core func $i \"ret-i32-100000\")))\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let new_instance = |store: &mut Store<()>| Linker::new(&engine).instantiate(store, &component);\n    let instance = new_instance(&mut store)?;\n\n    // Passing in 100 is valid for all primitives\n    instance\n        .get_typed_func::<(u8,), ()>(&mut store, \"take-u8\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i8,), ()>(&mut store, \"take-s8\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u16,), ()>(&mut store, \"take-u16\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i16,), ()>(&mut store, \"take-s16\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u32,), ()>(&mut store, \"take-u32\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i32,), ()>(&mut store, \"take-s32\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u64,), ()>(&mut store, \"take-u64\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i64,), ()>(&mut store, \"take-s64\")?\n        .call_and_post_return(&mut store, (100,))?;\n\n    // This specific wasm instance traps if any value other than 100 is passed\n    new_instance(&mut store)?\n        .get_typed_func::<(u8,), ()>(&mut store, \"take-u8\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i8,), ()>(&mut store, \"take-s8\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u16,), ()>(&mut store, \"take-u16\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i16,), ()>(&mut store, \"take-s16\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u32,), ()>(&mut store, \"take-u32\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i32,), ()>(&mut store, \"take-s32\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u64,), ()>(&mut store, \"take-u64\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i64,), ()>(&mut store, \"take-s64\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n\n    // Zero can be returned as any integer\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"ret-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"ret-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"ret-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"ret-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"ret-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"ret-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u64,)>(&mut store, \"ret-u64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i64,)>(&mut store, \"ret-s64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n\n    // Returning -1 should reinterpret the bytes as defined by each type.\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"retm1-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"retm1-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"retm1-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"retm1-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"retm1-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffffffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"retm1-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u64,)>(&mut store, \"retm1-u64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffffffff_ffffffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i64,)>(&mut store, \"retm1-s64\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n\n    // Returning 100000 should chop off bytes as necessary\n    let ret: u32 = 100000;\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"retbig-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as u8,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"retbig-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i8,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"retbig-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as u16,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"retbig-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i16,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"retbig-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"retbig-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i32,),\n    );\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_quiet_n_verbose_used_multiple_times", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_quiet_n_verbose_used_multiple_times() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"--verbose\")\n        .arg(\"--verbose\")\n        .arg(\"file\")\n        .succeeds();\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"--quiet\")\n        .arg(\"--quiet\")\n        .arg(\"file\")\n        .succeeds();\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/table.rs::table_test_4", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn table_test_4() {\n    let original = r##\" 1. First entry\n 2. Second entry\n\n    Col 1|Col 2\n    -|-\n    Row 1|Part 2\n    Row 2|Part 2\n\"##;\n    let expected = r##\"<ol>\n<li>\n<p>First entry</p>\n</li>\n<li>\n<p>Second entry</p>\n<table><thead><tr><th>Col 1</th><th>Col 2</th></tr></thead>\n<tr><td>Row 1</td><td>Part 2</td></tr>\n<tr><td>Row 2</td><td>Part 2</td></tr>\n</table>\n</li>\n</ol>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_37", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_37() {\n    let original = r##\"{}\n==\n\n\\{}\n--\n\n\\\n--\n\n{\\}\n==\n\n{}{}\n--\n\"##;\n    let expected = r##\"<h1></h1>\n<h2>\\</h2>\n<h2>\\</h2>\n<h1>{}</h1>\n<h2>{}</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_server_data_sent", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn buffered_server_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, server.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n\n        check_read(&mut client.reader(), b\"hello\");\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_15", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_15() {\n    let original = r##\"# *H1* { #id1 }\n## **H2** {#id2}\n### _H3_ {#id3}\n#### ~~H4~~ {#id4}\n##### [text](uri) {#id5}\n\"##;\n    let expected = r##\"<h1 id=\"id1\"><em>H1</em></h1>\n<h2 id=\"id2\"><strong>H2</strong></h2>\n<h3 id=\"id3\"><em>H3</em></h3>\n<h4 id=\"id4\"><del>H4</del></h4>\n<h5 id=\"id5\"><a href=\"uri\">text</a></h5>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_host", "code": "pub fn i32_exit_status(&self) -> Option<i32> {\n        if let Self::I32Exit(status) = self {\n            return Some(*status);\n        }\n        None\n    }", "test": "fn resumable_call_host() {\n    let (mut store, _linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, || -> Result<(), Trap> {\n        Err(Trap::i32_exit(100))\n    });\n    // Even though the called host function traps we expect a normal error\n    // since the host function is the root function of the call and therefore\n    // it would not make sense to resume it.\n    let error = host_fn\n        .call_resumable(&mut store, &[], &mut [])\n        .unwrap_err();\n    match error {\n        Error::Trap(trap) => {\n            assert_eq!(trap.i32_exit_status(), Some(100));\n        }\n        _ => panic!(\"expected Wasm trap\"),\n    }\n    // The same test for `TypedFunc`:\n    let trap = host_fn\n        .typed::<(), ()>(&store)\n        .unwrap()\n        .call_resumable(&mut store, ())\n        .unwrap_err();\n    assert_eq!(trap.i32_exit_status(), Some(100));\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/find.rs::no_satoshi_index", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn no_satoshi_index() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  CommandBuilder::new(\"find 0\")\n    .rpc_server(&rpc_server)\n    .expected_stderr(\"error: find requires index created with `--index-sats` flag\\n\")\n    .expected_exit_code(1)\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_base_not_prefix_of_relative_to", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_relative_base_not_prefix_of_relative_to() {\n    let result = new_ucmd!()\n        .args(&[\n            \"-sm\",\n            \"--relative-base=/usr/local\",\n            \"--relative-to=/usr\",\n            \"/usr\",\n            \"/usr/local\",\n        ])\n        .succeeds();\n\n    #[cfg(windows)]\n    result.stdout_matches(&Regex::new(r\"^.*:\\\\usr\\n.*:\\\\usr\\\\local\\n$\").unwrap());\n\n    #[cfg(not(windows))]\n    result.stdout_is(\"/usr\\n/usr/local\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_negative_duration", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_sleep_negative_duration() {\n    new_ucmd!().args(&[\"-1\"]).fails();\n    new_ucmd!().args(&[\"-1s\"]).fails();\n    new_ucmd!().args(&[\"-1m\"]).fails();\n    new_ucmd!().args(&[\"-1h\"]).fails();\n    new_ucmd!().args(&[\"-1d\"]).fails();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_numeric_floats", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_numeric_floats() {\n    test_helper(\n        \"numeric_floats\",\n        &[\"-n\", \"--numeric-sort\", \"--sort=numeric\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::test_tabs_shortcut_combined_with_all_arg", "code": "fn run_cmd(arg: &str, expected_prefix: &str, expected_suffix: &str) {\n        let expected_msg = format!(\n            \"{} specifier not at start of number: {}\",\n            expected_prefix.quote(),\n            expected_suffix.quote()\n        );\n        new_ucmd!().arg(arg).fails().stderr_contains(expected_msg);\n    }", "test": "fn test_tabs_shortcut_combined_with_all_arg() {\n    fn run_cmd(all_arg: &str) {\n        new_ucmd!()\n            .args(&[all_arg, \"-3\"])\n            .pipe_in(\"a  b  c\")\n            .run()\n            .stdout_is(\"a\\tb\\tc\");\n    }\n\n    let all_args = vec![\"-a\", \"--all\"];\n\n    for arg in all_args {\n        run_cmd(arg);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_too_small_line_num_repeat", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_too_small_line_num_repeat() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"10\", \"{*}\"])\n        .fails()\n        .stderr_is(\"csplit: '10': line number out of range on repetition 5\\n\")\n        .stdout_is(\"48\\n0\\n0\\n30\\n30\\n30\\n3\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 0);\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/20/\", \"10\", \"{*}\", \"-k\"])\n        .fails()\n        .stderr_is(\"csplit: '10': line number out of range on repetition 5\\n\")\n        .stdout_is(\"48\\n0\\n0\\n30\\n30\\n30\\n3\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 7);\n    assert_eq!(at.read(\"xx00\"), generate(1, 20));\n    assert_eq!(at.read(\"xx01\"), \"\");\n    assert_eq!(at.read(\"xx02\"), \"\");\n    assert_eq!(at.read(\"xx03\"), generate(20, 30));\n    assert_eq!(at.read(\"xx04\"), generate(30, 40));\n    assert_eq!(at.read(\"xx05\"), generate(40, 50));\n    assert_eq!(at.read(\"xx06\"), \"50\\n\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/statement.rs::r#try", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn r#try() {\n    test_formatting(\n        r#\"\n        try {\n            throw \"hello\";\n        } catch(e) {\n            console.log(e);\n        } finally {\n            console.log(\"things\");\n        }\n        try {\n            throw \"hello\";\n        } catch {\n            console.log(\"something went wrong\");\n        }\n        \"#,\n    );\n}"}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encode_all_ascii", "code": "fn compare_encode(expected: &str, target: &[u8]) {\n    assert_eq!(expected, STANDARD.encode(target));\n}", "test": "fn encode_all_ascii() {\n    let ascii: Vec<u8> = (0..=127).collect();\n\n    compare_encode(\n        \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7P\\\n         D0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn8\\\n         =\",\n        &ascii,\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_final_newline", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_line_bytes_no_final_newline() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"2\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n\");\n    assert_eq!(at.read(\"xab\"), \"22\");\n    assert_eq!(at.read(\"xac\"), \"22\");\n    assert_eq!(at.read(\"xad\"), \"\\n\");\n    assert_eq!(at.read(\"xae\"), \"3\\n\");\n    assert_eq!(at.read(\"xaf\"), \"4\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_hex_suffix_with_value_spaced", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_short_hex_suffix_with_value_spaced() {\n    new_ucmd!()\n        .args(&[\"-n\", \"4\", \"-x\", \"9\", \"threebytes.txt\"])\n        .fails()\n        .stderr_contains(\"split: cannot open '9' for reading: No such file or directory\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::test_unknown_import_error", "code": "pub(crate) fn module(&self) -> &Arc<Module> {\n        self.runtime_info.module()\n    }", "test": "fn test_unknown_import_error() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"unknown-module\" \"unknown-name\" (func)))\"#,\n    )?;\n    let err = linker\n        .instantiate(&mut store, &module)\n        .expect_err(\"should fail\");\n    let unknown_import: UnknownImportError = err.downcast()?;\n    assert_eq!(unknown_import.module(), \"unknown-module\");\n    assert_eq!(unknown_import.name(), \"unknown-name\");\n    unknown_import.ty().unwrap_func();\n    Ok(())\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/issues.rs::issue94", "code": "pub fn read_event(&mut self) -> Result<Event<'i>> {\n        self.read_event_impl(())\n    }", "test": "fn issue94() {\n    let data = br#\"<Run>\n<!B>\n</Run>\"#;\n    let mut reader = Reader::from_reader(&data[..]);\n    reader.trim_text(true);\n    loop {\n        match reader.read_event() {\n            Ok(Event::Eof) | Err(..) => break,\n            _ => (),\n        }\n    }\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_iteration", "code": "fn next(&mut self) -> Option<Self::Item> {\n    self.iter.next().map(take)\n  }", "test": "fn ArrayVec_iteration() {\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut i = av.into_iter();\n  assert_eq!(i.next(), Some(10));\n  assert_eq!(i.next(), Some(11));\n  assert_eq!(i.next(), Some(12));\n  assert_eq!(i.next(), Some(13));\n  assert_eq!(i.next(), None);\n\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut av2: ArrayVec<[i32; 4]> = av.clone().into_iter().collect();\n  assert_eq!(av, av2);\n\n  // IntoIterator for &mut ArrayVec\n  for x in &mut av2 {\n    *x = -*x;\n  }\n\n  // IntoIterator for &ArrayVec\n  assert!(av.iter().zip(&av2).all(|(&a, &b)| a == -b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_backspace", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_backspace() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\b\"])\n        .succeeds()\n        .stdout_only(\"\\x08\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_bytes", "code": "pub fn stdout_contains_line<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().lines().any(|line| line == cmp.as_ref()),\n            \"'{}' does not contain line '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_du_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(\"a/b\");\n\n    at.write(\"a/b/file1\", \"foo\");\n    at.write(\"a/b/file2\", \"foobar\");\n\n    let result = ucmd.args(&[\"--bytes\", \"--all\", \"a\"]).succeeds();\n\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        result.stdout_contains_line(\"6\\ta/b/file2\");\n        result.stdout_contains_line(\"3\\ta/b/file1\");\n        result.stdout_contains_line(\"9\\ta/b\");\n        result.stdout_contains_line(\"9\\ta\");\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        result.stdout_contains_line(\"6\\ta\\\\b\\\\file2\");\n        result.stdout_contains_line(\"3\\ta\\\\b\\\\file1\");\n        result.stdout_contains_line(\"9\\ta\\\\b\");\n        result.stdout_contains_line(\"9\\ta\");\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_calling_export.rs::test_import_calling_export", "code": "pub fn expect(self, msg: &str) -> T {\n        self.expand().expect(msg)\n    }", "test": "fn test_import_calling_export() {\n    const WAT: &str = r#\"\n    (module\n      (type $t0 (func))\n      (import \"\" \"imp\" (func $.imp (type $t0)))\n      (func $run call $.imp)\n      (func $other)\n      (export \"run\" (func $run))\n      (export \"other\" (func $other))\n    )\n    \"#;\n\n    let mut store = Store::<Option<Func>>::default();\n    let module = Module::new(store.engine(), WAT).expect(\"failed to create module\");\n\n    let callback_func = Func::new(\n        &mut store,\n        FuncType::new(None, None),\n        move |mut caller, _, _| {\n            caller\n                .data()\n                .unwrap()\n                .call(&mut caller, &[], &mut [])\n                .expect(\"expected function not to trap\");\n            Ok(())\n        },\n    );\n\n    let imports = vec![callback_func.into()];\n    let instance = Instance::new(&mut store, &module, imports.as_slice())\n        .expect(\"failed to instantiate module\");\n\n    let run_func = instance\n        .get_func(&mut store, \"run\")\n        .expect(\"expected a run func in the module\");\n\n    let other_func = instance\n        .get_func(&mut store, \"other\")\n        .expect(\"expected an other func in the module\");\n    *store.data_mut() = Some(other_func);\n\n    run_func\n        .call(&mut store, &[], &mut [])\n        .expect(\"expected function not to trap\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_custom_backup_suffix", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_custom_backup_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_custom_backup_suffix\";\n    let link = \"test_symlink_custom_backup_suffix_link\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let arg = &format!(\"--suffix={suffix}\");\n    ucmd.args(&[\"-b\", arg, \"-s\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}{suffix}\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_work", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_work() {\n    let work = Work::from_le_bytes(le_bytes());\n    let got = serialize(&work).unwrap();\n    let want = include_bytes!(\"data/serde/u256_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_log.rs::test_node_compact_log", "code": "fn test_compact_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let mut before_states = HashMap::default();\n\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        before_states.insert(id, state.take_truncated_state());\n    }\n\n    for i in 1..1000 {\n        let (k, v) = (format!(\"key{}\", i), format!(\"value{}\", i));\n        let key = k.as_bytes();\n        let value = v.as_bytes();\n        cluster.must_put(key, value);\n\n        if i > 100\n            && check_compacted(\n                &cluster.engines,\n                &before_states,\n                1,\n                false, // must_compacted\n            )\n        {\n            return;\n        }\n    }\n\n    check_compacted(\n        &cluster.engines,\n        &before_states,\n        1,\n        true, // must_compacted\n    );\n}", "test": "fn test_node_compact_log() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_compact_log(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_pr_core_utils_tests", "code": "pub fn stdout_is_templated_fixture<T: AsRef<OsStr>>(\n        &self,\n        file_rel_path: T,\n        template_vars: &[(&str, &str)],\n    ) -> &Self {\n        let mut contents =\n            String::from_utf8(read_scenario_fixture(&self.tmpd, file_rel_path)).unwrap();\n        for kv in template_vars {\n            contents = contents.replace(kv.0, kv.1);\n        }\n        self.stdout_is(contents)\n    }", "test": "fn test_with_pr_core_utils_tests() {\n    let test_cases = vec![\n        (\"\", vec![\"0Ft\"], vec![\"0F\"], 0),\n        (\"\", vec![\"0Fnt\"], vec![\"0F\"], 0),\n        (\"+3\", vec![\"0Ft\"], vec![\"3-0F\"], 0),\n        (\"+3 -f\", vec![\"0Ft\"], vec![\"3f-0F\"], 0),\n        (\"-a -3\", vec![\"0Ft\"], vec![\"a3-0F\"], 0),\n        (\"-a -3 -f\", vec![\"0Ft\"], vec![\"a3f-0F\"], 0),\n        (\"-a -3 -f\", vec![\"0Fnt\"], vec![\"a3f-0F\"], 0),\n        (\"+3 -a -3 -f\", vec![\"0Ft\"], vec![\"3a3f-0F\"], 0),\n        (\"-l 24\", vec![\"FnFn\"], vec![\"l24-FF\"], 0),\n        (\"-W 20 -l24 -f\", vec![\"tFFt-ll\"], vec![\"W20l24f-ll\"], 0),\n    ];\n\n    for test_case in test_cases {\n        let (flags, input_file, expected_file, return_code) = test_case;\n        let mut scenario = new_ucmd!();\n        let input_file_path = input_file.first().unwrap();\n        let test_file_path = expected_file.first().unwrap();\n        let value = file_last_modified_time(&scenario, test_file_path);\n        let mut arguments: Vec<&str> = flags\n            .split(' ')\n            .filter(|i| i.trim() != \"\")\n            .collect::<Vec<&str>>();\n\n        arguments.extend(input_file.clone());\n\n        let scenario_with_args = scenario.args(&arguments);\n\n        let scenario_with_expected_status = if return_code == 0 {\n            scenario_with_args.succeeds()\n        } else {\n            scenario_with_args.fails()\n        };\n\n        scenario_with_expected_status.stdout_is_templated_fixture(\n            test_file_path,\n            &[\n                (\"{last_modified_time}\", &value),\n                (\"{file_name}\", input_file_path),\n            ],\n        );\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/errors.rs::test_fuzzer_input_3", "code": "fn parse_all_options(md: &str) {\n    let parser = Parser::new_ext(md, Options::all());\n\n    for _ in parser {}\n}", "test": "fn test_fuzzer_input_3() {\n    parse_all_options(\"\\n # #\\r\\u{1c} \");\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_target", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_target() {\n    let target = Target::from_le_bytes(le_bytes());\n    let got = serialize(&target).unwrap();\n    let want = include_bytes!(\"data/serde/u256_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_realpath_long_redirection_to_root", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_realpath_long_redirection_to_root() {\n    // Create a 255-character path to root\n    let dir = path_concat!(\"..\", ..85);\n    let expect = get_root_path().to_owned() + \"\\n\";\n    new_ucmd!().arg(dir).succeeds().stdout_is(expect);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_can_get_server_cert", "code": "fn get_chain(&self) -> Vec<rustls::Certificate> {\n        rustls_pemfile::certs(&mut io::BufReader::new(\n            fs::File::open(self.path_for(\"end.fullchain\")).unwrap(),\n        ))\n        .unwrap()\n        .iter()\n        .map(|v| rustls::Certificate(v.clone()))\n        .collect()\n    }", "test": "fn client_can_get_server_cert() {\n    for kt in ALL_KEY_TYPES.iter() {\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_configs(client_config, make_server_config(*kt));\n            do_handshake(&mut client, &mut server);\n\n            let certs = client.peer_certificates();\n            assert_eq!(certs, Some(kt.get_chain().as_slice()));\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_invalid_buffer_size", "code": "pub fn stderr_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stdout().stderr_is(msg)\n    }", "test": "fn test_invalid_buffer_size() {\n    new_ucmd!()\n        .arg(\"-S\")\n        .arg(\"asd\")\n        .fails()\n        .code_is(2)\n        .stderr_only(\"sort: invalid --buffer-size argument 'asd'\\n\");\n\n    new_ucmd!()\n        .arg(\"-S\")\n        .arg(\"100f\")\n        .fails()\n        .code_is(2)\n        .stderr_only(\"sort: invalid suffix in --buffer-size argument '100f'\\n\");\n\n    #[cfg(not(target_pointer_width = \"128\"))]\n    new_ucmd!()\n        .arg(\"-n\")\n        .arg(\"-S\")\n        .arg(\"1Y\")\n        .arg(\"ext_sort.txt\")\n        .fails()\n        .code_is(2)\n        .stderr_only(\"sort: --buffer-size argument '1Y' too large\\n\");\n\n    #[cfg(target_pointer_width = \"32\")]\n    {\n        let buffer_sizes = [\"1000G\", \"10T\"];\n        for buffer_size in &buffer_sizes {\n            new_ucmd!()\n                .arg(\"-n\")\n                .arg(\"-S\")\n                .arg(buffer_size)\n                .arg(\"ext_sort.txt\")\n                .fails()\n                .code_is(2)\n                .stderr_only(format!(\n                    \"sort: --buffer-size argument '{}' too large\\n\",\n                    buffer_size\n                ));\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_directory_and_file", "code": "pub fn stdout_is_fixture<T: AsRef<OsStr>>(&self, file_rel_path: T) -> &Self {\n        let contents = read_scenario_fixture(&self.tmpd, file_rel_path);\n        self.stdout_is(String::from_utf8(contents).unwrap())\n    }", "test": "fn test_directory_and_file() {\n    let s = TestScenario::new(util_name!());\n    s.fixtures.mkdir(\"test_directory2\");\n    // spell-checker:disable-next-line\n    for fixture in [\"empty.txt\", \"alpha.txt\", \"nonewline.txt\"] {\n        s.ucmd()\n            .args(&[\"test_directory2\", fixture])\n            .fails()\n            .stderr_is(\"cat: test_directory2: Is a directory\\n\")\n            .stdout_is_fixture(fixture);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_rollback_partial", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_rollback_partial() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n    let a = db.engine.get_value(b\"a\").unwrap();\n    assert!(a.is_some());\n    let b = db.engine.get_value(b\"b\").unwrap();\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.set_save_point();\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in max_keys..2 * max_keys {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n    let a = db.engine.get_value(b\"a\").unwrap();\n    assert!(a.is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n    let b = db.engine.get_value(b\"b\").unwrap();\n    assert!(b.is_none());\n    for i in max_keys..2 * max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_cname_additionals", "code": "pub fn message_type(&self) -> MessageType {\n        self.message_type\n    }", "test": "async fn test_cname_additionals() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::from_str(\"alias.example.com.\").unwrap());\n    query.set_query_type(RecordType::A);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let answers: &[Record] = result.answers();\n    assert_eq!(answers.len(), 1);\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::CNAME);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"www.example.com.\").unwrap()))\n    );\n\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(additionals.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        additionals.first().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::forward_call_works", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn forward_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (export \"foo\") (result i32)\n                    call 1)\n                (func (result i32)\n                    i32.const 4)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_no_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--hex-suffixes\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x0a\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x0b\"), \"99\\n\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::with_reinscribe_flag_but_not_actually_a_reinscription", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn with_reinscribe_flag_but_not_actually_a_reinscription() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(\"wallet inscribe --file tulip.png --fee-rate 5.0 \")\n    .write(\"tulip.png\", [1; 520])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  let coinbase = rpc_server.mine_blocks(1)[0].txdata[0].txid();\n\n  CommandBuilder::new(format!(\n    \"wallet inscribe --file orchid.png --fee-rate 1.1 --reinscribe --satpoint {coinbase}:0:0\"\n  ))\n  .write(\"orchid.png\", [1; 520])\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .stderr_regex(\"error: reinscribe flag set but this would not be a reinscription.*\")\n  .run_and_extract_stdout();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/operators.rs::instanceofoperator_rhs_not_object", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn instanceofoperator_rhs_not_object() {\n    run_test_actions([TestAction::assert_native_error(\n        \"let s = new String(); s instanceof 1\",\n        JsNativeErrorKind::Type,\n        \"right-hand side of 'instanceof' should be an object, got `number`\",\n    )]);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression19", "code": "fn open_table<'txn, K: RedbKey + 'static, V: RedbValue + 'static>(\n        &'txn mut self,\n        table: TableDefinition<K, V>,\n    ) -> SpecialValuesTable<'db, 'txn, K, V> {\n        let def: TableDefinition<K, (u64, u64)> = TableDefinition::new(table.name());\n        SpecialValuesTable {\n            inner: self.inner.open_table(def).unwrap(),\n            file: self.file,\n            _value_type: Default::default(),\n        }\n    }", "test": "fn regression19() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::builder().create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 100];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    let savepoint0 = tx.ephemeral_savepoint().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 101];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let value = vec![0xFF; 102];\n        t.insert(&1, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.restore_savepoint(&savepoint0).unwrap();\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    tx.open_table(table_def).unwrap();\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/encodings.rs::test_koi8_r_encoding", "code": "pub fn unescape(raw: &str) -> Result<Cow<str>, EscapeError> {\n    unescape_with(raw, |_| None)\n}", "test": "fn test_koi8_r_encoding() {\n    let src = include_bytes!(\"documents/opennews_all.rss\").as_ref();\n    let mut buf = vec![];\n    let mut r = Reader::from_reader(src);\n    r.trim_text(true);\n    loop {\n        match r.read_event_into(&mut buf) {\n            Ok(Event::Text(e)) => {\n                e.unescape().unwrap();\n            }\n            Ok(Event::Eof) => break,\n            _ => (),\n        }\n    }\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::regex_string", "code": "pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }", "test": "fn regex_string() {\n    assert_eq!(r\"[a-zA-Z0-9]+\", regex!(r\"[a-zA-Z0-9]+\").as_str());\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{}\", regex!(r\"[a-zA-Z0-9]+\")));\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{:?}\", regex!(r\"[a-zA-Z0-9]+\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_nano_seconds", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_nano_seconds() {\n    // %N     nanoseconds (000000000..999999999)\n    let re = Regex::new(r\"^\\d{1,9}\\n$\").unwrap();\n    new_ucmd!().arg(\"+%N\").succeeds().stdout_matches(&re);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pd_client.rs::test_slow_periodical_update", "code": "pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    }", "test": "fn test_slow_periodical_update() {\n    let pd_client_reconnect_fp = \"pd_client_reconnect\";\n    let server = MockServer::new(1);\n    let eps = server.bind_addrs();\n\n    let mut cfg = new_config(eps);\n    let env = Arc::new(EnvBuilder::new().cq_count(1).build());\n    let mgr = Arc::new(SecurityManager::new(&SecurityConfig::default()).unwrap());\n\n    // client1 updates leader frequently (100ms).\n    cfg.update_interval = ReadableDuration(Duration::from_millis(100));\n    let _client1 = RpcClientV2::new(&cfg, Some(env.clone()), mgr.clone()).unwrap();\n\n    // client2 never updates leader in the test.\n    cfg.update_interval = ReadableDuration(Duration::from_secs(100));\n    let mut client2 = RpcClientV2::new(&cfg, Some(env), mgr).unwrap();\n\n    fail::cfg(pd_client_reconnect_fp, \"pause\").unwrap();\n    // Wait for the PD client thread blocking on the fail point.\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    let (tx, rx) = mpsc::channel();\n    let handle = thread::spawn(move || {\n        client2.alloc_id().unwrap();\n        tx.send(()).unwrap();\n    });\n\n    let timeout = Duration::from_millis(500);\n    if rx.recv_timeout(timeout).is_err() {\n        panic!(\"pd client2 is blocked\");\n    }\n\n    // Clean up the fail point.\n    fail::remove(pd_client_reconnect_fp);\n    handle.join().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_missing_arguments", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_missing_arguments() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let no_target_dir = \"no-target_dir\";\n\n    scene\n        .ucmd()\n        .fails()\n        .code_is(1)\n        .usage_error(\"missing file operand\");\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(format!(\"-t {no_target_dir}\"))\n        .fails()\n        .usage_error(\"missing file operand\");\n    assert!(!at.dir_exists(no_target_dir));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_guest_twice", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn drop_guest_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n\n                (core func $ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $ctor)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    let dtor = i.get_typed_func::<(&ResourceAny,), ()>(&mut store, \"dtor\")?;\n\n    let (t,) = ctor.call(&mut store, (100,))?;\n    ctor.post_return(&mut store)?;\n    dtor.call(&mut store, (&t,))?;\n    dtor.post_return(&mut store)?;\n\n    assert_eq!(\n        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),\n        \"unknown handle index 0\"\n    );\n\n    Ok(())\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::missing_variable_name_in_set", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn missing_variable_name_in_set() {\n    assert_err_msg(\"{% set = 1 %}\", &[\"1:8\", \"expected an identifier (must start with a-z)\"]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_fullblock", "code": "pub fn stderr(&self) -> &[u8] {\n        &self.stderr\n    }", "test": "fn test_fullblock() {\n    let tname = \"fullblock-from-urand\";\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n    let exp_stats = vec![\n        \"1+0 records in\\n\",\n        \"1+0 records out\\n\",\n        \"134217728 bytes (134 MB, 128 MiB) copied,\",\n    ];\n    let exp_stats = exp_stats.into_iter().fold(Vec::new(), |mut acc, s| {\n        acc.extend(s.bytes());\n        acc\n    });\n\n    let ucmd = new_ucmd!()\n        .args(&[\n            \"if=/dev/urandom\",\n            of!(&tmp_fn),\n            \"bs=128M\",\n            // Note: In order for this test to actually test iflag=fullblock, the bs=VALUE\n            // must be big enough to 'overwhelm' the urandom store of bytes.\n            // Try executing 'dd if=/dev/urandom bs=128M count=1' (i.e without iflag=fullblock).\n            // The stats should contain the line: '0+1 records in' indicating a partial read.\n            // Since my system only copies 32 MiB without fullblock, I expect 128 MiB to be\n            // a reasonable value for testing most systems.\n            \"count=1\",\n            \"iflag=fullblock\",\n        ])\n        .run();\n    ucmd.success();\n\n    let run_stats = &ucmd.stderr()[..exp_stats.len()];\n    assert_eq!(exp_stats, run_stats);\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::storage1d", "code": "fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n}", "test": "fn storage1d() {\n    require(\n        &[Ca::Image1D],\n        r#\"\n        @group(0) @binding(0)\n        var image_1d: texture_storage_1d<rgba8unorm,write>;\n    \"#,\n    );\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::setting_accepts_value", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn setting_accepts_value() {\n  Test::new()\n    .tree(tree! {\n      bar: {\n        justfile: \"\n          set fallback := true\n\n          baz:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\n      \"\n      foo:\n        echo root\n    \",\n    )\n    .args([\"foo\"])\n    .current_dir(\"bar\")\n    .stderr(\n      \"\n      echo root\n    \",\n    )\n    .stdout(\"root\\n\")\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_deadline", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_deadline() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"deadline_check_fail\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_other_error().contains(\"exceeding the deadline\"));\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_a_wasi_executable", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn run_a_wasi_executable() {\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::qjs())\n        .arg(\"--\")\n        .arg(\"--eval\")\n        .arg(\"console.log('Hello, World!')\")\n        .env(\"RUST_LOG\", &*RUST_LOG)\n        .assert();\n\n    assert.success().stdout(contains(\"Hello, World!\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkfifo.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::basic_async_hook", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "test": "async fn basic_async_hook() -> Result<(), Error> {\n    struct HandlerR;\n\n    #[async_trait::async_trait]\n    impl CallHookHandler<State> for HandlerR {\n        async fn handle_call_event(&self, obj: &mut State, ch: CallHook) -> Result<()> {\n            State::call_hook(obj, ch)\n        }\n    }\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook_async(HandlerR {});\n\n    assert_eq!(store.data().calls_into_host, 0);\n    assert_eq!(store.data().returns_from_host, 0);\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call_async(&mut store, &[], &mut []).await?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_zero_terminated_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_zero_terminated_syntax() {\n    new_ucmd!()\n        .args(&[\"-z\", \"-n\", \"1\"])\n        .pipe_in(\"x\\0y\")\n        .run()\n        .stdout_is(\"x\\0\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_when_using_variable_set_in_included_templates_outside", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_when_using_variable_set_in_included_templates_outside() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"included\", r#\"{{a}}{% set b = \"hi\" %}-{{b}}\"#),\n        (\"base\", r#\"{{a}}{% include \"included\" %}{{b}}\"#),\n    ])\n    .unwrap();\n    let mut context = Context::new();\n    context.insert(\"a\", &10);\n    let result = tera.render(\"base\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `b` not found in context while rendering \\'base\\'\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_utf8_chars_words", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_utf8_chars_words() {\n    new_ucmd!()\n        .arg(\"-mw\")\n        .pipe_in_fixture(\"UTF_8_weirdchars.txt\")\n        .run()\n        .stdout_is(\"     87     442\\n\");\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/conversions.rs::test_rgbu8_to_rgbu16", "code": "fn convert(&self) -> ImageBuffer<ToType, Vec<ToType::Subpixel>> {\n        let mut buffer: ImageBuffer<ToType, Vec<ToType::Subpixel>> =\n            ImageBuffer::new(self.width, self.height);\n        for (to, from) in buffer.pixels_mut().zip(self.pixels()) {\n            to.from_color(from)\n        }\n        buffer\n    }", "test": "fn test_rgbu8_to_rgbu16() {\n    // Create an all white image using Rgb<u16>s for pixel values\n    let image_u16 =\n        ImageBuffer::from_pixel(2, 2, image::Rgb::<u16>([u16::MAX, u16::MAX, u16::MAX]));\n\n    // Create an all white image using Rgb<u8>s for pixel values and convert it\n    // to Rgb<u16>s.\n    let image_u8 = ImageBuffer::from_pixel(2, 2, image::Rgb::<u8>([u8::MAX, u8::MAX, u8::MAX]));\n    let image_converted: ImageBuffer<Rgb<u16>, _> = image_u8.convert();\n\n    assert_eq!(image_u16, image_converted);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_invalid_combined_shorts", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_split_obs_lines_within_invalid_combined_shorts() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\"file\");\n\n    scene\n        .ucmd()\n        .args(&[\"-2fb\", \"file\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"error: unexpected argument '-f' found\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_arch.rs::test_arch", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_arch() {\n    new_ucmd!().succeeds();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_env_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_env_help() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .succeeds()\n        .no_stderr()\n        .stdout_contains(\"Options:\");\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_raw_pair", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_raw_pair() {\n    let pair = Pair {\n        key: Key { type_value: 1u8, key: vec![0u8, 1u8, 2u8, 3u8] },\n        value: vec![0u8, 1u8, 2u8, 3u8],\n    };\n    let got = serialize(&pair).unwrap();\n    let want = include_bytes!(\"data/serde/raw_pair_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/includes.rs::include_fails_without_unstable", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn include_fails_without_unstable() {\n  Test::new()\n    .justfile(\"!include ./include.justfile\")\n    .status(EXIT_FAILURE)\n    .stderr(\"error: The !include directive is currently unstable. Invoke `just` with the `--unstable` flag to enable unstable features.\\n\")\n    .run();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_unsafe_recovery_already_in_joint_state", "code": "pub fn sleep_ms(ms: u64) {\n    std::thread::sleep(Duration::from_millis(ms));\n}", "test": "fn test_unsafe_recovery_already_in_joint_state() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n    let peer_on_store0 = find_peer(&region, nodes[0]).unwrap();\n    let peer_on_store2 = find_peer(&region, nodes[2]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store2.clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store2.clone());\n    cluster.pd_client.must_add_peer(\n        region.get_id(),\n        new_learner_peer(nodes[2], peer_on_store2.get_id()),\n    );\n    // Wait the new learner to be initialized.\n    sleep_ms(100);\n    pd_client.must_joint_confchange(\n        region.get_id(),\n        vec![\n            (\n                ConfChangeType::AddLearnerNode,\n                new_learner_peer(nodes[0], peer_on_store0.get_id()),\n            ),\n            (\n                ConfChangeType::AddNode,\n                new_peer(nodes[2], peer_on_store2.get_id()),\n            ),\n        ],\n    );\n    cluster.stop_node(nodes[1]);\n    cluster.stop_node(nodes[2]);\n    cluster.must_wait_for_leader_expire(nodes[0], region.get_id());\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n    cluster.must_enter_force_leader(region.get_id(), nodes[0], vec![nodes[1], nodes[2]]);\n\n    let to_be_removed: Vec<metapb::Peer> = region\n        .get_peers()\n        .iter()\n        .filter(|&peer| peer.get_store_id() != nodes[0])\n        .cloned()\n        .collect();\n    let mut plan = pdpb::RecoveryPlan::default();\n    let mut demote = pdpb::DemoteFailedVoters::default();\n    demote.set_region_id(region.get_id());\n    demote.set_failed_voters(to_be_removed.into());\n    plan.mut_demotes().push(demote);\n    pd_client.must_set_unsafe_recovery_plan(nodes[0], plan);\n    cluster.must_send_store_heartbeat(nodes[0]);\n\n    let mut demoted = true;\n    let mut promoted = false;\n    for _ in 0..10 {\n        let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n\n        promoted = region\n            .get_peers()\n            .iter()\n            .find(|peer| peer.get_store_id() == nodes[0])\n            .unwrap()\n            .get_role()\n            == metapb::PeerRole::Voter;\n\n        demoted = region\n            .get_peers()\n            .iter()\n            .filter(|peer| peer.get_store_id() != nodes[0])\n            .all(|peer| peer.get_role() == metapb::PeerRole::Learner);\n        if demoted && promoted {\n            break;\n        }\n        sleep_ms(100);\n    }\n    assert!(demoted);\n    assert!(promoted);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_start", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn timeout_in_start() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-start.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_value.rs::test_nan", "code": "pub fn is_f64(&self) -> bool {\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n    }", "test": "fn test_nan() {\n    let pos_nan = serde_yaml::from_str::<Value>(\".nan\").unwrap();\n    assert!(pos_nan.is_f64());\n    assert_eq!(pos_nan, pos_nan);\n\n    let neg_fake_nan = serde_yaml::from_str::<Value>(\"-.nan\").unwrap();\n    assert!(neg_fake_nan.is_string());\n\n    let significand_mask = 0xF_FFFF_FFFF_FFFF;\n    let bits = (f64::NAN.copysign(1.0).to_bits() ^ significand_mask) | 1;\n    let different_pos_nan = Value::Number(Number::from(f64::from_bits(bits)));\n    assert_eq!(pos_nan, different_pos_nan);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_numfmt.rs::test_no_op", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_no_op() {\n    new_ucmd!()\n        .pipe_in(\"1024\\n1234567\")\n        .run()\n        .stdout_is(\"1024\\n1234567\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_after_delete.rs::test_node_compact_after_update_v2", "code": "pub fn get(&self, idx: usize) -> Option<BytesRef<'_>> {\n        assert!(idx < self.len());\n        if self.bitmap.get(idx) {\n            Some(&self.data[self.var_offset[idx]..self.var_offset[idx + 1]])\n        } else {\n            None\n        }\n    }", "test": "fn test_node_compact_after_update_v2() {\n    let count = 1;\n    let mut cluster = test_raftstore_v2::new_node_cluster(0, count);\n\n    cluster.cfg.raft_store.region_compact_check_interval = ReadableDuration::millis(100);\n    // disable it\n    cluster.cfg.raft_store.region_compact_min_tombstones = 1000000;\n    cluster.cfg.raft_store.region_compact_redundant_rows_percent = 40;\n    cluster.cfg.raft_store.region_compact_min_redundant_rows = 50;\n    cluster.cfg.raft_store.region_compact_check_step = Some(2);\n    cluster.cfg.rocksdb.titan.enabled = true;\n    cluster.run();\n\n    let region = cluster.get_region(b\"\");\n    let (split_key, _) = gen_mvcc_put_kv(b\"k100\", b\"\", 1.into(), 2.into());\n    cluster.must_split(&region, &split_key);\n\n    for i in 0..200 {\n        let (k, v) = (format!(\"k{:03}\", i), format!(\"value{}\", i));\n        let (k, v) = gen_mvcc_put_kv(k.as_bytes(), v.as_bytes(), 1.into(), 2.into());\n        cluster.must_put_cf(CF_WRITE, &k, &v);\n\n        let (k, v) = (format!(\"k{:03}\", i), format!(\"value{}\", i));\n        let (k, v) = gen_mvcc_put_kv(k.as_bytes(), v.as_bytes(), 3.into(), 4.into());\n        cluster.must_put_cf(CF_WRITE, &k, &v);\n    }\n    for (registry, _) in &cluster.engines {\n        registry.for_each_opened_tablet(|_, db: &mut CachedTablet<_>| {\n            if let Some(db) = db.latest() {\n                db.flush_cf(CF_WRITE, true).unwrap();\n            }\n            true\n        })\n    }\n\n    fail::cfg(\"on_collect_regions_to_compact\", \"pause\").unwrap();\n    let mut db_size_before_compact = HashMap::default();\n    for (registry, _) in &cluster.engines {\n        registry.for_each_opened_tablet(|id, db: &mut CachedTablet<_>| {\n            if let Some(db) = db.latest() {\n                let cf_handle = get_cf_handle(db.as_inner(), CF_WRITE).unwrap();\n                let approximate_size = db\n                    .as_inner()\n                    .get_approximate_sizes_cf(cf_handle, &[Range::new(b\"\", DATA_MAX_KEY)])[0];\n                db_size_before_compact.insert(id, approximate_size);\n            }\n            true\n        })\n    }\n    fail::remove(\"on_collect_regions_to_compact\");\n\n    let (sender, receiver) = mpsc::channel();\n    let sync_sender = Mutex::new(sender);\n    fail::cfg_callback(\"raftstore-v2::CheckAndCompact::AfterCompact\", move || {\n        let sender = sync_sender.lock().unwrap();\n        sender.send(true).unwrap();\n    })\n    .unwrap();\n\n    // wait for 2 regions' compaction.\n    receiver.recv_timeout(Duration::from_millis(5000)).unwrap();\n    receiver.recv_timeout(Duration::from_millis(5000)).unwrap();\n\n    for (registry, _) in &cluster.engines {\n        registry.for_each_opened_tablet(|id, db: &mut CachedTablet<_>| {\n            if let Some(db) = db.latest() {\n                let cf_handle = get_cf_handle(db.as_inner(), CF_WRITE).unwrap();\n                let approximate_size = db\n                    .as_inner()\n                    .get_approximate_sizes_cf(cf_handle, &[Range::new(b\"\", DATA_MAX_KEY)])[0];\n                let size_before = db_size_before_compact.get(&id).unwrap();\n                assert!(approximate_size < *size_before);\n            }\n            true\n        })\n    }\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::add_set_values_in_context", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn add_set_values_in_context() {\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"hey\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"admin\", &true);\n    context.insert(\"num\", &1);\n\n    let inputs = vec![\n        (\"{% set i = 1 %}{{ i }}\", \"1\"),\n        (\"{% set i = 1 + 2 %}{{ i }}\", \"3\"),\n        (r#\"{% set i = \"hey\" %}{{ i }}\"#, \"hey\"),\n        (r#\"{% set i = \"<html>\" %}{{ i | safe }}\"#, \"<html>\"),\n        (r#\"{% set i = \"<html>\" %}{{ i }}\"#, \"&lt;html&gt;\"),\n        (\"{% set i = my_var %}{{ i }}\", \"hey\"),\n        (\"{% set i = malicious %}{{ i | safe }}\", \"<html>\"),\n        (\"{% set i = malicious %}{{ i }}\", \"&lt;html&gt;\"),\n        (\"{% set i = my_var | upper %}{{ i }}\", \"HEY\"),\n        (\"{% set i = range(end=3) %}{{ i }}\", \"[0, 1, 2]\"),\n        (\"{% set i = admin or true %}{{ i }}\", \"true\"),\n        (\"{% set i = admin and num > 0 %}{{ i }}\", \"true\"),\n        (\"{% set i = 0 / 0 %}{{ i }}\", \"NaN\"),\n        (\"{% set i = [1,2] %}{{ i }}\", \"[1, 2]\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_version", "code": "fn test_helper(file_name: &str, term: &str) {\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-c\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.csh.expected\"));\n\n    new_ucmd!()\n        .env(\"TERM\", term)\n        .arg(\"-b\")\n        .arg(format!(\"{file_name}.txt\"))\n        .run()\n        .stdout_is_fixture(format!(\"{file_name}.sh.expected\"));\n}", "test": "fn test_version() {\n    test_helper(\"version\", &[\"-V\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_txn_store_batch_get_command", "code": "pub fn batch_get_command_ok(&self, keys: &[&[u8]], ts: u64, expect: Vec<&[u8]>) {\n        let result: Vec<Option<Vec<u8>>> = self\n            .store\n            .batch_get_command(self.ctx.clone(), keys, ts)\n            .unwrap()\n            .into_iter()\n            .collect();\n        let expect: Vec<Option<Vec<u8>>> = expect\n            .into_iter()\n            .map(|x| if x.is_empty() { None } else { Some(x.to_vec()) })\n            .collect();\n        assert_eq!(result, expect);\n    }", "test": "fn test_txn_store_batch_get_command() {\n    let store = AssertionStorage::default();\n    // not exist\n    store.get_none(b\"a\", 10);\n    store.get_none(b\"b\", 10);\n    // after put\n    store.put_ok(b\"a\", b\"x\", 5, 10);\n    store.put_ok(b\"b\", b\"x\", 5, 10);\n    store.batch_get_command_ok(&[b\"a\", b\"b\", b\"c\"], 10, vec![b\"x\", b\"x\", b\"\"]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_tombstone", "code": "fn test_tombstone<T: Simulator>(cluster: &mut Cluster<T>) {\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_equal(&engine_2, b\"k1\", b\"v1\");\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let engine_3 = cluster.get_engine(3);\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n\n    // Remove peer (2, 2) from region 1.\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    // After new leader is elected, the change peer must be finished.\n    cluster.leader_of_region(r1).unwrap();\n    let (key, value) = (b\"k3\", b\"v3\");\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    let engine_2 = cluster.get_engine(2);\n    must_get_none(&engine_2, b\"k1\");\n    must_get_none(&engine_2, b\"k3\");\n    let mut existing_kvs = vec![];\n    for cf in engine_2.cf_names() {\n        engine_2\n            .scan(cf, b\"\", &[0xFF], false, |k, v| {\n                existing_kvs.push((k.to_vec(), v.to_vec()));\n                Ok(true)\n            })\n            .unwrap();\n    }\n    // only tombstone key and store ident key exist.\n    assert_eq!(existing_kvs.len(), 2);\n    existing_kvs.sort();\n    assert_eq!(existing_kvs[0].0.as_slice(), keys::STORE_IDENT_KEY);\n    assert_eq!(existing_kvs[1].0, keys::region_state_key(r1));\n\n    let mut ident = StoreIdent::default();\n    ident.merge_from_bytes(&existing_kvs[0].1).unwrap();\n    assert_eq!(ident.get_store_id(), 2);\n    assert_eq!(ident.get_cluster_id(), cluster.id());\n\n    let mut state = RegionLocalState::default();\n    state.merge_from_bytes(&existing_kvs[1].1).unwrap();\n    assert_eq!(state.get_state(), PeerState::Tombstone);\n\n    // The peer 2 may be destroyed by:\n    // 1. Apply the ConfChange RemovePeer command, the tombstone ConfVer is 4\n    // 2. Receive a GC command before applying 1, the tombstone ConfVer is 3\n    let conf_ver = state.get_region().get_region_epoch().get_conf_ver();\n    assert!(conf_ver == 4 || conf_ver == 3);\n\n    // Send a stale raft message to peer (2, 2)\n    let mut raft_msg = RaftMessage::default();\n\n    raft_msg.set_region_id(r1);\n    // Use an invalid from peer to ignore gc peer message.\n    raft_msg.set_from_peer(new_peer(100, 100));\n    raft_msg.set_to_peer(new_peer(2, 2));\n    raft_msg.mut_region_epoch().set_conf_ver(0);\n    raft_msg.mut_region_epoch().set_version(0);\n\n    cluster.send_raft_msg(raft_msg).unwrap();\n\n    // We must get RegionNotFound error.\n    let region_status = new_status_request(r1, new_peer(2, 2), new_region_leader_cmd());\n    let resp = cluster\n        .call_command(region_status, Duration::from_secs(5))\n        .unwrap();\n    assert!(\n        resp.get_header().get_error().has_region_not_found(),\n        \"region must not found, but got {:?}\",\n        resp\n    );\n}", "test": "fn test_server_tombstone() {\n    let count = 5;\n    let mut cluster = new_server_cluster(0, count);\n    test_tombstone(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sleep.rs::test_sleep_when_multiple_inputs_exceed_max_duration_then_no_error", "code": "pub fn no_output(&self) -> &Self {\n        self.no_stdout().no_stderr()\n    }", "test": "fn test_sleep_when_multiple_inputs_exceed_max_duration_then_no_error() {\n    let mut child = new_ucmd!()\n        .arg(format!(\"{}\", u64::MAX))\n        .arg(\"1\")\n        .timeout(Duration::from_secs(10))\n        .run_no_wait();\n\n    #[cfg(unix)]\n    child\n        .delay(100)\n        .kill()\n        .make_assertion()\n        .with_current_output()\n        .signal_is(9) // make sure it was us who terminated the process\n        .no_output();\n    #[cfg(windows)]\n    child\n        .delay(100)\n        .kill()\n        .make_assertion()\n        .with_current_output()\n        .failure()\n        .no_output();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::read_write_memory_via_api", "code": "pub fn write(&mut self, addr: usize, len: usize) -> Result<(), AccessError> {\n        if !self.flag {\n            return Ok(());\n        }\n        if !(self.is_in_bounds_stack(addr, len) || self.is_in_bounds_heap(addr, len)) {\n            return Err(AccessError::OutOfBounds {\n                addr: addr,\n                len: len,\n            });\n        }\n        for i in addr..addr + len {\n            if let MemState::Unallocated = self.metadata[i] {\n                return Err(AccessError::InvalidWrite {\n                    addr: addr,\n                    len: len,\n                });\n            }\n        }\n        for i in addr..addr + len {\n            self.metadata[i] = MemState::ValidToReadWrite;\n        }\n        Ok(())\n    }", "test": "fn read_write_memory_via_api() {\n    let cfg = Config::new();\n    let mut store = Store::new(&Engine::new(&cfg).unwrap(), ());\n    let ty = MemoryType::new(1, None);\n    let mem = Memory::new(&mut store, ty).unwrap();\n    mem.grow(&mut store, 1).unwrap();\n\n    let value = b\"hello wasm\";\n    let size = mem.data_size(&store);\n    mem.write(&mut store, size - value.len(), value).unwrap();\n\n    let mut buffer = [0u8; 10];\n    mem.read(&store, mem.data_size(&store) - buffer.len(), &mut buffer)\n        .unwrap();\n    assert_eq!(value, &buffer);\n\n    // Error conditions.\n\n    // Out of bounds write.\n\n    let size = mem.data_size(&store);\n    let res = mem.write(&mut store, size - value.len() + 1, value);\n    assert!(res.is_err());\n    assert_ne!(\n        mem.data(&store)[mem.data_size(&store) - value.len() + 1],\n        value[0],\n        \"no data is written\",\n    );\n\n    // Out of bounds read.\n\n    buffer[0] = 0x42;\n    let res = mem.read(\n        &store,\n        mem.data_size(&store) - buffer.len() + 1,\n        &mut buffer,\n    );\n    assert!(res.is_err());\n    assert_eq!(buffer[0], 0x42, \"no data is read\");\n\n    // Read offset overflow.\n    let res = mem.read(&store, usize::MAX, &mut buffer);\n    assert!(res.is_err());\n\n    // Write offset overflow.\n    let res = mem.write(&mut store, usize::MAX, &mut buffer);\n    assert!(res.is_err());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_import_service.rs::test_ingest_key_manager_delete_file_failed", "code": "pub fn has_error(&self) -> bool {\n        self.error.is_some()\n    }", "test": "fn test_ingest_key_manager_delete_file_failed() {\n    // test with tde\n    let (_tmp_key_dir, cluster, ctx, _tikv, import) = new_cluster_and_tikv_import_client_tde();\n\n    let temp_dir = Builder::new()\n        .prefix(\"test_download_sst_blocking_sst_writer\")\n        .tempdir()\n        .unwrap();\n    let sst_path = temp_dir.path().join(\"test.sst\");\n    let sst_range = (0, 100);\n    let (mut meta, data) = gen_sst_file(sst_path, sst_range);\n    meta.set_region_id(ctx.get_region_id());\n    meta.set_region_epoch(ctx.get_region_epoch().clone());\n\n    upload_sst(&import, &meta, &data).unwrap();\n\n    let deregister_fp = \"key_manager_fails_before_delete_file\";\n    // the first delete is in check before ingest, the second is in ingest cleanup\n    // set the ingest clean up failed to trigger remove file but not remove key\n    // condition\n    fail::cfg(deregister_fp, \"1*off->1*return->off\").unwrap();\n\n    // Do an ingest and verify the result is correct. Though the ingest succeeded,\n    // the clone file is still in the key manager\n    // TODO: how to check the key manager contains the clone key\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx.clone());\n    ingest.set_sst(meta.clone());\n    let resp = import.ingest(&ingest).unwrap();\n\n    assert!(!resp.has_error());\n\n    fail::remove(deregister_fp);\n\n    let node_id = *cluster.sim.rl().get_node_ids().iter().next().unwrap();\n    let save_path = cluster\n        .sim\n        .rl()\n        .importers\n        .get(&node_id)\n        .unwrap()\n        .get_path(&meta);\n    // wait up to 5 seconds to make sure raw uploaded file is deleted by the async\n    // clean up task.\n    for _ in 0..50 {\n        if !save_path.as_path().exists() {\n            break;\n        }\n        std::thread::sleep(Duration::from_millis(100));\n    }\n    assert!(!save_path.as_path().exists());\n\n    // Do upload and ingest again, though key manager contains this file, the ingest\n    // action should success.\n    upload_sst(&import, &meta, &data).unwrap();\n    let mut ingest = IngestRequest::default();\n    ingest.set_context(ctx);\n    ingest.set_sst(meta);\n    let resp = import.ingest(&ingest).unwrap();\n    assert!(!resp.has_error());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_trailing_slash_symlink_to_missing", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_trailing_slash_symlink_to_missing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"subdir\");\n    at.relative_symlink_file(\"missing\", \"link\");\n    at.relative_symlink_file(\"subdir/missing\", \"link2\");\n    for query in [\n        \"missing\",\n        \"./missing/\",\n        \"link\",\n        \"./link/\",\n        \"link/more\",\n        \"link2\",\n        \"./link2/\",\n        \"link2/more\",\n    ] {\n        scene\n            .ucmd()\n            .args(&[\"-ev\", query])\n            .fails()\n            .code_is(1)\n            .stderr_contains(\"No such file or directory\")\n            .no_stdout();\n    }\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_test_caching_works_for_packages", "code": "pub(crate) fn stderr(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDERR_FILENO)\n    }", "test": "fn run_test_caching_works_for_packages() {\n    // we're testing the cache, so we don't want to reuse the current user's\n    // $WASMER_DIR\n    let wasmer_dir = TempDir::new().unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"/app/test.py\")\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .assert();\n\n    assert\n        .success()\n        .stderr(contains(\"wapm_source: Querying the GraphQL API\"))\n        .stderr(contains(\"builtin_loader: Downloading a webc file\"))\n        .stderr(contains(\"module_cache::filesystem: Saved to disk\"));\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"python/python@0.1.0\")\n        .arg(format!(\"--mapdir=/app:{}\", asset_path().display()))\n        .arg(\"--registry=wasmer.io\")\n        .arg(\"/app/test.py\")\n        .env(\"WASMER_CACHE_DIR\", wasmer_dir.path())\n        .env(\"RUST_LOG\", &*CACHE_RUST_LOG)\n        .assert()\n        .success();\n\n    assert\n        .stderr(contains(\"wapm_source: Cache hit!\"))\n        .stderr(contains(\"builtin_loader: Cache hit!\"))\n        .stderr(contains(\"module_cache::filesystem: Cache hit!\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601_default", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_8601_default() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!().arg(param).succeeds().stdout_matches(&re);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_df_compatible", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_df_compatible() {\n    new_ucmd!().arg(\"-ah\").succeeds();\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::xlsb", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn xlsb() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xlsb\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsb<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"issue2\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [Float(1.), String(\"a\".to_string())],\n            [Float(2.), String(\"b\".to_string())],\n            [Float(3.), String(\"c\".to_string())]\n        ]\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_anyhow_error_return", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn test_anyhow_error_return() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::msg(\"test 1234\"))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n    assert!(!e.to_string().contains(\"test 1234\"));\n    assert!(format!(\"{:?}\", e).contains(\"Caused by:\\n    test 1234\"));\n\n    assert!(e.downcast_ref::<Trap>().is_none());\n    assert!(e.downcast_ref::<WasmBacktrace>().is_some());\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::bad_text_syntax", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn bad_text_syntax() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .arg(\"-Ccache=n\")\n        .arg(\"tests/all/cli_tests/bad-syntax.wat\")\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"--> tests/all/cli_tests/bad-syntax.wat\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_invalid_type_index_variable", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "test": "fn error_invalid_type_index_variable() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[a] }}\")]).unwrap();\n\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n    context.insert(\"a\", &true);\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Only variables evaluating to String or Number can be used as index (`a` of `arr[a]`)\"\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_escape_vertical_tab", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_escape_vertical_tab() {\n    new_ucmd!()\n        .args(&[\"-e\", \"\\\\v\"])\n        .succeeds()\n        .stdout_only(\"\\x0B\\n\");\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::mainnet_has_no_content_size_limit", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn mainnet_has_no_content_size_limit() {\n  let rpc_server = test_bitcoincore_rpc::builder()\n    .network(Network::Bitcoin)\n    .build();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(1);\n\n  CommandBuilder::new(\"wallet inscribe --file degenerate.png --fee-rate 1\")\n    .write(\"degenerate.png\", [1; 1025])\n    .rpc_server(&rpc_server)\n    .stdout_regex(\".*\")\n    .run_and_extract_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_help() {\n    for help_flg in [\"-h\", \"--help\"] {\n        new_ucmd!()\n            .arg(help_flg)\n            .succeeds()\n            .no_stderr()\n            .stdout_contains(\"Usage:\");\n    }\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::run_no_imports_wasm_works", "code": "fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        }", "test": "fn run_no_imports_wasm_works() {\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::fib())\n        .assert()\n        .success();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_symlink_to_itself_verbose", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_symlink_to_itself_verbose() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.relative_symlink_file(\"a\", \"a\");\n    ucmd.args(&[\"-ev\", \"a\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"Too many levels of symbolic links\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_dynamic_config.rs::test_enable", "code": "pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }", "test": "pub fn test_enable() {\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        receiver_address: \"\".to_string(),\n        report_receiver_interval: ReadableDuration::millis(2500),\n        max_resource_groups: 5000,\n        precision: ReadableDuration::secs(1),\n    });\n\n    let port = alloc_port();\n    test_suite.start_receiver_at(port);\n\n    // Workload\n    // [req-1, req-2]\n    test_suite.setup_workload(vec![\"req-1\", \"req-2\"]);\n\n    // | Address |\n    // |   x     |\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n\n    // | Address |\n    // |   x     |\n    test_suite.cfg_receiver_address(\"\");\n    test_suite.flush_receiver();\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_nc_0_wo_follow", "code": "pub fn succeeded(&self) -> bool {\n        self.exit_status.map_or(true, |e| e.success())\n    }", "test": "fn test_nc_0_wo_follow() {\n    // verify that -[nc]0 without -f, exit without reading\n\n    let ts = TestScenario::new(util_name!());\n    ts.ucmd()\n        .args(&[\"-n0\", \"missing\"])\n        .run()\n        .no_stderr()\n        .no_stdout()\n        .succeeded();\n    ts.ucmd()\n        .args(&[\"-c0\", \"missing\"])\n        .run()\n        .no_stderr()\n        .no_stdout()\n        .succeeded();\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::shl_limbs_test", "code": "pub fn vec_from_u32(x: &[u32]) -> VecType {\n    let mut vec = VecType::new();\n    #[cfg(not(all(target_pointer_width = \"64\", not(target_arch = \"sparc\"))))]\n    {\n        for &xi in x {\n            vec.try_push(xi as bigint::Limb).unwrap();\n        }\n    }\n\n    #[cfg(all(target_pointer_width = \"64\", not(target_arch = \"sparc\")))]\n    {\n        for xi in x.chunks(2) {\n            match xi.len() {\n                1 => vec.try_push(xi[0] as bigint::Limb).unwrap(),\n                2 => {\n                    let xi0 = xi[0] as bigint::Limb;\n                    let xi1 = xi[1] as bigint::Limb;\n                    vec.try_push((xi1 << 32) | xi0).unwrap()\n                },\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    vec\n}", "test": "fn shl_limbs_test() {\n    let mut x = VecType::from_u64(0xD2210408);\n    bigint::shl_limbs(&mut x, 2);\n    let expected: VecType = if bigint::LIMB_BITS == 32 {\n        vec_from_u32(&[0, 0, 0xD2210408])\n    } else {\n        vec_from_u32(&[0, 0, 0, 0, 0xD2210408])\n    };\n    assert_eq!(&*x, &*expected);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_rename_compatibility", "code": "pub fn assert_eq_debug<C: PartialEq + Debug>(lhs: &C, rhs: &C) {\n    if lhs == rhs {\n        return;\n    }\n    let lhs_str = format!(\"{:?}\", lhs);\n    let rhs_str = format!(\"{:?}\", rhs);\n\n    fn find_index(l: impl Iterator<Item = (u8, u8)>) -> usize {\n        let it = l\n            .enumerate()\n            .take_while(|(_, (l, r))| l == r)\n            .filter(|(_, (l, _))| *l == b' ');\n        let mut last = None;\n        let mut second = None;\n        for a in it {\n            second = last;\n            last = Some(a);\n        }\n        second.map_or(0, |(i, _)| i)\n    }\n    let cpl = find_index(lhs_str.bytes().zip(rhs_str.bytes()));\n    let csl = find_index(lhs_str.bytes().rev().zip(rhs_str.bytes().rev()));\n    if cpl + csl > lhs_str.len() || cpl + csl > rhs_str.len() {\n        assert_eq!(lhs, rhs);\n    }\n    let lhs_diff = String::from_utf8_lossy(&lhs_str.as_bytes()[cpl..lhs_str.len() - csl]);\n    let rhs_diff = String::from_utf8_lossy(&rhs_str.as_bytes()[cpl..rhs_str.len() - csl]);\n    panic!(\n        \"config not matched:\\nlhs: ...{}...,\\nrhs: ...{}...\",\n        lhs_diff, rhs_diff\n    );\n}", "test": "fn test_rename_compatibility() {\n    let old_content = r#\"\n[server]\nsnap-max-write-bytes-per-sec = \"10MiB\"\n\n[storage]\nengine = \"raft-kv2\"\n    \"#;\n    let new_content = r#\"\n[server]\nsnap-io-max-bytes-per-sec = \"10MiB\"\n\n[storage]\nengine = \"partitioned-raft-kv\"\n    \"#;\n    let old_cfg: TikvConfig = toml::from_str(old_content).unwrap();\n    let new_cfg: TikvConfig = toml::from_str(new_content).unwrap();\n    assert_eq_debug(&old_cfg, &new_cfg);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_base64.rs::test_wrap", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_wrap() {\n    for wrap_param in [\"-w\", \"--wrap\", \"--wr\"] {\n        let input = \"The quick brown fox jumps over the lazy dog.\";\n        new_ucmd!()\n            .arg(wrap_param)\n            .arg(\"20\")\n            .pipe_in(input)\n            .succeeds()\n            // spell-checker:disable-next-line\n            .stdout_only(\"VGhlIHF1aWNrIGJyb3du\\nIGZveCBqdW1wcyBvdmVy\\nIHRoZSBsYXp5IGRvZy4=\\n\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_decrease_pool", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_decrease_pool() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let _ = cluster.run_conf_change();\n\n    // Save current poller tids before shrinking\n    let original_poller_tids = get_poller_thread_ids();\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store_pool_size\".to_owned(), \"1\".to_owned());\n            change.insert(\"raftstore.apply-pool-size\".to_owned(), \"1\".to_owned());\n            change\n        };\n\n        // Update config, shrink from 2 to 1\n        cfg_controller.update(change).unwrap();\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .apply_batch_system\n                .pool_size,\n            1\n        );\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .store_batch_system\n                .pool_size,\n            1\n        );\n    }\n\n    // Save current poller tids after scaling down\n    let current_poller_tids = get_poller_thread_ids();\n    // Compared with before shrinking, the thread num should be reduced by two\n    assert_eq!(current_poller_tids.len(), original_poller_tids.len() - 2);\n    // After shrinking, all the left tids must be there before\n    for tid in current_poller_tids {\n        assert!(original_poller_tids.contains(&tid));\n    }\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/comments.rs::test_simple", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "test": "fn test_simple() {\n    assert_eq!(\n        from_str(\n            \"/*\n * We got a hexadecimal number here!\n *\n */0x507\"\n        ),\n        Ok(0x507)\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_char", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_char() {\n    test_parse_err::<char>(&[\n        (\n            \"\\\"ab\\\"\",\n            \"invalid value: string \\\"ab\\\", expected a character at line 1 column 4\",\n        ),\n        (\n            \"10\",\n            \"invalid type: integer `10`, expected a character at line 1 column 2\",\n        ),\n    ]);\n\n    test_parse_ok(vec![\n        (\"\\\"n\\\"\", 'n'),\n        (\"\\\"\\\\\\\"\\\"\", '\"'),\n        (\"\\\"\\\\\\\\\\\"\", '\\\\'),\n        (\"\\\"/\\\"\", '/'),\n        (\"\\\"\\\\b\\\"\", '\\x08'),\n        (\"\\\"\\\\f\\\"\", '\\x0C'),\n        (\"\\\"\\\\n\\\"\", '\\n'),\n        (\"\\\"\\\\r\\\"\", '\\r'),\n        (\"\\\"\\\\t\\\"\", '\\t'),\n        (\"\\\"\\\\u000b\\\"\", '\\x0B'),\n        (\"\\\"\\\\u000B\\\"\", '\\x0B'),\n        (\"\\\"\\u{3A3}\\\"\", '\\u{3A3}'),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_echo.rs::test_hyphen_values_between", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_hyphen_values_between() {\n    new_ucmd!()\n        .arg(\"test\")\n        .arg(\"-E\")\n        .arg(\"araba\")\n        .run()\n        .success()\n        .stdout_is(\"test -E araba\\n\");\n\n    new_ucmd!()\n        .arg(\"dumdum \")\n        .arg(\"dum dum dum\")\n        .arg(\"-e\")\n        .arg(\"dum\")\n        .run()\n        .success()\n        .stdout_is(\"dumdum  dum dum dum -e dum\\n\");\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::large_initial", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn large_initial() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![vec![0, 0, 0, 42]];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    let protocols = (0..1000u32)\n        .map(|x| x.to_be_bytes().to_vec())\n        .collect::<Vec<_>>();\n    client_crypto.alpn_protocols = protocols;\n    let cfg = ClientConfig::new(Arc::new(client_crypto));\n    let client_ch = pair.begin_connect(cfg);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_reference_with_size_file_not_found", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_reference_with_size_file_not_found() {\n    new_ucmd!()\n        .args(&[\"-r\", \"a\", \"-s\", \"+1\", \"b\"])\n        .fails()\n        .stderr_contains(\"cannot stat 'a': No such file or directory\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_node_leader_change_with_uncommitted_log", "code": "fn test_leader_change_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // So peer 3 won't replicate any message of the region but still can vote.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // peer 1 and peer 2 must have k2, but peer 3 must not.\n    for i in 1..3 {\n        let engine = cluster.get_engine(i);\n        must_get_equal(&engine, b\"k1\", b\"v1\");\n    }\n\n    let engine3 = cluster.get_engine(3);\n    must_get_none(&engine3, b\"k1\");\n\n    // now only peer 1 and peer 2 can step to leader.\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv)\n            .allow(1),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it becomes leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgHeartbeatResponse)\n            .direction(Direction::Send),\n    ));\n    // Make peer 2's msg won't be replicated when it becomes leader,\n    // so the uncommitted entries won't be applied immediately.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it's still follower.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgHeartbeat)\n            .direction(Direction::Recv),\n    ));\n    debug!(\"putting k2\");\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    // peer 1 must have committed, but peer 2 has not.\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n\n    let region = cluster.get_region(b\"\");\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let mut put = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        reqs,\n        false,\n    );\n    debug!(\"requesting: {:?}\", put);\n    put.mut_header().set_peer(new_peer(2, 2));\n    cluster.clear_send_filters();\n    let resp = cluster.call_command(put, Duration::from_secs(5)).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), b\"k2\", b\"v2\");\n        must_get_equal(&cluster.get_engine(i), b\"k3\", b\"v3\");\n    }\n}", "test": "fn test_node_leader_change_with_uncommitted_log() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_leader_change_with_uncommitted_log(&mut cluster);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_write_data_to_source_region_after_merging", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_merge_write_data_to_source_region_after_merging() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(100);\n    // For snapshot after merging\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(12);\n    cluster.cfg.raft_store.apply_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    let mut region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let right_peer_2 = find_peer(&right, 2).cloned().unwrap();\n    assert_eq!(right_peer_2.get_id(), 2);\n\n    // Make sure peer 2 finish split before pause\n    cluster.must_put(b\"k2pause\", b\"vpause\");\n    must_get_equal(&cluster.get_engine(2), b\"k2pause\", b\"vpause\");\n\n    let on_handle_apply_2_fp = \"on_handle_apply_2\";\n    fail::cfg(on_handle_apply_2_fp, \"pause\").unwrap();\n\n    let right_peer_1 = find_peer(&right, 1).cloned().unwrap();\n    cluster.must_transfer_leader(right.get_id(), right_peer_1);\n\n    let left_peer_3 = find_peer(&left, 3).cloned().unwrap();\n    cluster.must_transfer_leader(left.get_id(), left_peer_3.clone());\n\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return()\").unwrap();\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    fail::remove(schedule_merge_fp);\n\n    pd_client.check_merged_timeout(left.get_id(), Duration::from_secs(5));\n\n    region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let state1 = cluster.apply_state(region.get_id(), 1);\n    for i in 0..15 {\n        cluster.must_put(format!(\"k2{}\", i).as_bytes(), b\"v2\");\n    }\n    cluster.wait_log_truncated(region.get_id(), 1, state1.get_applied_index());\n    // Ignore this msg to make left region exist.\n    let on_has_merge_target_fp = \"on_has_merge_target\";\n    fail::cfg(on_has_merge_target_fp, \"return\").unwrap();\n\n    cluster.clear_send_filters();\n    // On store 3, now the right region is updated by snapshot not applying logs\n    // so the left region still exist.\n    // Wait for left region to rollback merge (in previous wrong implementation)\n    sleep_ms(200);\n    // Write data to left region\n    let mut new_left = left;\n    let mut epoch = new_left.take_region_epoch();\n    // prepareMerge => conf_ver + 1, version + 1\n    // rollbackMerge => version + 1\n    epoch.set_conf_ver(epoch.get_conf_ver() + 1);\n    epoch.set_version(epoch.get_version() + 2);\n    let mut req = new_request(\n        new_left.get_id(),\n        epoch,\n        vec![new_put_cf_cmd(\"default\", b\"k11\", b\"v11\")],\n        false,\n    );\n    req.mut_header().set_peer(left_peer_3);\n    if let Ok(()) = cluster\n        .sim\n        .rl()\n        .async_command_on_node(3, req, Callback::None)\n    {\n        sleep_ms(200);\n        // The write must not succeed\n        must_get_none(&cluster.get_engine(2), b\"k11\");\n        must_get_none(&cluster.get_engine(3), b\"k11\");\n    }\n\n    fail::remove(on_handle_apply_2_fp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_accepts_option_argument_directly", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_accepts_option_argument_directly() {\n    new_ucmd!()\n        .arg(\"-s,\")\n        .arg(\"2\")\n        .succeeds()\n        .stdout_is(\"1,2\\n\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_compare_and_swap() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let new = new;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == new));\n    assert!(!result.answers().iter().any(|rr| *rr == current));\n\n    // check the it fails if tried again.\n    let mut not = new.clone();\n    not.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n    let not = not;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current, not.clone(), origin))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == new));\n    assert!(!result.answers().iter().any(|rr| *rr == not));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_finalizer", "code": "pub fn has_value(&self) -> bool {\n        // SAFETY: this is safe because `Ephemeron` is tracked to always point to a valid pointer\n        // `inner_ptr`.\n        unsafe { self.inner_ptr.get().as_ref().value().is_some() }\n    }", "test": "fn eph_finalizer() {\n    #[derive(Clone, Trace)]\n    struct S {\n        #[unsafe_ignore_trace]\n        inner: Rc<Cell<bool>>,\n    }\n\n    impl Finalize for S {\n        fn finalize(&self) {\n            self.inner.set(true);\n        }\n    }\n\n    run_test(|| {\n        let val = S {\n            inner: Rc::new(Cell::new(false)),\n        };\n\n        let key = Gc::new(50u32);\n        let eph = Ephemeron::new(&key, Gc::new(val.clone()));\n        assert!(eph.has_value());\n        // finalize hasn't been run\n        assert!(!val.inner.get());\n\n        drop(key);\n        force_collect();\n        assert!(!eph.has_value());\n        // finalize ran when collecting\n        assert!(val.inner.get());\n    });\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_21", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_21() {\n    let original = r##\"# H1 {.foo{unknown}\n## H2 {.foo{.bar}\n\"##;\n    let expected = r##\"<h1>H1 {.foo</h1>\n<h2 class=\"bar\">H2 {.foo</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::test_create_view_with_no_schema_binding", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_create_view_with_no_schema_binding() {\n    redshift_and_generic()\n        .verified_stmt(\"CREATE VIEW myevent AS SELECT eventname FROM event WITH NO SCHEMA BINDING\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::strict_mode_dup_func_parameters", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn strict_mode_dup_func_parameters() {\n    // Checks that a function cannot contain duplicate parameter\n    // names in strict mode code as per https://tc39.es/ecma262/#sec-function-definitions-static-semantics-early-errors.\n    run_test_actions([TestAction::assert_native_error(\n        indoc! {r#\"\n            'use strict';\n            function f(a, b, b) {}\n        \"#},\n        JsNativeErrorKind::Syntax,\n        \"Duplicate parameter name not allowed in this context at line 2, col 12\",\n    )]);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_lint_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_lint_error() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::wasm_fault_address_reported_by_default", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn wasm_fault_address_reported_by_default() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (func $start\n                    i32.const 0xdeadbeef\n                    i32.load\n                    drop)\n                (start $start)\n            )\n        \"#,\n    )?;\n    let err = Instance::new(&mut store, &module, &[]).unwrap_err();\n\n    // NB: at this time there's no programmatic access to the fault address\n    // because it's not always available for load/store traps. Only static\n    // memories on 32-bit have this information, but bounds-checked memories\n    // use manual trapping instructions and otherwise don't have a means of\n    // communicating the faulting address at this time.\n    //\n    // It looks like the exact reported fault address may not be deterministic,\n    // so assert that we have the right error message, but not the exact address.\n    let err = format!(\"{err:?}\");\n    assert!(\n        err.contains(\"memory fault at wasm address \")\n            && err.contains(\" in linear memory of size 0x10000\"),\n        \"bad error: {err}\"\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_mix", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_mix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"13\", \"%25%\", \"/0$/\"])\n        .succeeds()\n        .stdout_only(\"27\\n15\\n63\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 3);\n    assert_eq!(at.read(\"xx00\"), generate(1, 13));\n    assert_eq!(at.read(\"xx01\"), generate(25, 30));\n    assert_eq!(at.read(\"xx02\"), generate(30, 51));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_multiple_snapshots_together", "code": "fn test_node_merge_multiple_snapshots(together: bool) {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    ignore_merge_target_integrity(&mut cluster.cfg, &cluster.pd_client);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    // make it gc quickly to trigger snapshot easily\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(20);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(10);\n    cluster.cfg.raft_store.merge_max_log_gap = 9;\n    cluster.run();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k3\").unwrap();\n\n    let target_leader = right\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() == 1)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(right.get_id(), target_leader);\n    let target_leader = left\n        .get_peers()\n        .iter()\n        .find(|p| p.get_store_id() == 2)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(left.get_id(), target_leader);\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n\n    // So cluster becomes:\n    //  left region: 1         2(leader) I 3\n    // right region: 1(leader) 2         I 3\n    // I means isolation.(here just means 3 can not receive append log)\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(right.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n\n    // Add a collect snapshot filter, it will delay snapshots until have collected\n    // multiple snapshots from different peers\n    cluster.sim.wl().add_recv_filter(\n        3,\n        Box::new(LeadingDuplicatedSnapshotFilter::new(\n            Arc::new(AtomicBool::new(false)),\n            together,\n        )),\n    );\n    // Write some data to trigger a snapshot of right region.\n    for i in 200..210 {\n        let key = format!(\"k{}\", i);\n        let value = format!(\"v{}\", i);\n        cluster.must_put(key.as_bytes(), value.as_bytes());\n    }\n    // Wait for snapshot to generate and send\n    thread::sleep(Duration::from_millis(100));\n\n    // Merge left and right region, due to isolation, the regions on store 3 are not\n    // merged yet.\n    pd_client.must_merge(left.get_id(), right.get_id());\n    thread::sleep(Duration::from_millis(200));\n\n    // Let peer of right region on store 3 to make append response to trigger a new\n    // snapshot one is snapshot before merge, the other is snapshot after merge.\n    // Here blocks raftstore for a while to make it not to apply snapshot and\n    // receive new log now.\n    fail::cfg(\"on_raft_ready\", \"sleep(100)\").unwrap();\n    cluster.clear_send_filters();\n    thread::sleep(Duration::from_millis(200));\n    // Filter message again to make sure peer on store 3 can not catch up\n    // CommitMerge log\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(left.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(right.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    ));\n    // Cause filter is added again, no need to block raftstore anymore\n    fail::cfg(\"on_raft_ready\", \"off\").unwrap();\n\n    // Wait some time to let already merged peer on store 1 or store 2 to notify\n    // the peer of left region on store 3 is stale.\n    thread::sleep(Duration::from_millis(300));\n\n    cluster.must_put(b\"k9\", b\"v9\");\n    // let follower can reach the new log, then commit merge\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(3), b\"k9\", b\"v9\");\n}", "test": "fn test_node_merge_multiple_snapshots_together() {\n    test_node_merge_multiple_snapshots(true)\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pathchk.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transfer_leader.rs::test_when_warmup_range_start_is_larger_than_last_index", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_when_warmup_range_start_is_larger_than_last_index() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_entry_cache_life_time = ReadableDuration::secs(1000);\n    prevent_from_gc_raft_log(&mut cluster);\n    run_cluster_for_test_warmup_entry_cache(&mut cluster);\n    cluster.pd_client.disable_default_operator();\n\n    let s4 = cluster.add_new_engine();\n\n    // Prevent peer 4 from appending logs, so it's last index should\n    // be really small.\n    let recv_filter_s4 = Box::new(\n        RegionPacketFilter::new(1, s4)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend),\n    );\n    cluster.sim.wl().add_recv_filter(s4, recv_filter_s4);\n\n    let (sx, rx) = channel::unbounded();\n    let recv_filter_1 = Box::new(\n        RegionPacketFilter::new(1, 1)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgTransferLeader)\n            .set_msg_callback(Arc::new(move |m| {\n                sx.send(m.get_message().get_from()).unwrap();\n            })),\n    );\n    cluster.sim.wl().add_recv_filter(1, recv_filter_1);\n\n    cluster.pd_client.must_add_peer(1, new_peer(s4, s4));\n    cluster.transfer_leader(1, new_peer(s4, s4));\n    // Store(s4) should ack the transfer leader msg immediately.\n    assert_eq!(rx.recv_timeout(Duration::from_millis(500)).unwrap(), s4);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_values_scientific_notation", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_values_scientific_notation() {\n    let mut env = Environment::new();\n    env.add_template(\"sci1\", \"VALUE = {{ value or -12.4E-4 }}\")\n        .unwrap();\n    let tmpl = env.get_template(\"sci1\").unwrap();\n    let rv = tmpl.render(context!(value => -12.4E-3)).unwrap();\n    assert_eq!(rv, \"VALUE = -0.0124\");\n    let rv = tmpl.render(context!());\n    // assert_eq!(rv, \"VALUE = -0.00124\");\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci2\", \"VALUE = {{ value or 1.4E4 }}\")\n        .unwrap();\n    let tmpl = env.get_template(\"sci2\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci3\", \"VALUE = {{ value or 1.4e+4}}\")\n        .unwrap();\n    let tmpl = env.get_template(\"sci3\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci4\", \"VALUE = {{ 1.4+4}}\").unwrap();\n    let tmpl = env.get_template(\"sci4\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci5\", \"VALUE = {{ 1.4+1E-1}}\").unwrap();\n    let tmpl = env.get_template(\"sci5\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n\n    env.add_template(\"sci6\", \"VALUE = {{ 1.0E0+1.0}}\").unwrap();\n    let tmpl = env.get_template(\"sci6\").unwrap();\n    let rv = tmpl.render(context!());\n    assert!(rv.is_ok());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_on_array_literal_works", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn filter_on_array_literal_works() {\n    let mut context = Context::new();\n    let i: Option<usize> = None;\n    context.insert(\"existing\", \"hello\");\n    context.insert(\"null\", &i);\n\n    let inputs = vec![\n        (r#\"{{ [1, 2, 3] | length }}\"#, \"3\"),\n        (r#\"{% set a = [1, 2, 3] | length %}{{ a }}\"#, \"3\"),\n        (r#\"{% for a in [1, 2, 3] | slice(start=1) %}{{ a }}{% endfor %}\"#, \"23\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_eq", "code": "pub(super) fn prerelease(text: &str) -> Prerelease {\n    Prerelease::new(text).unwrap()\n}", "test": "fn test_eq() {\n    assert_eq!(prerelease(\"-\"), prerelease(\"-\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aa\"));\n    assert_ne!(prerelease(\"aa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aaaaaaaaa\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"bbbbbbbbb\"));\n    assert_ne!(build_metadata(\"1\"), build_metadata(\"001\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_cli_args", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_cli_args() {\n    // Make sure that factor works with CLI arguments as well.\n    new_ucmd!().args(&[\"3\"]).succeeds().stdout_contains(\"3: 3\");\n\n    new_ucmd!()\n        .args(&[\"3\", \"6\", \" +9\"])\n        .succeeds()\n        .stdout_contains(\"3: 3\")\n        .stdout_contains(\"9: 3 3\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_window_rank_function", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_window_rank_function() {\n    let supported_dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(HiveDialect {}),\n            Box::new(SnowflakeDialect {}),\n        ],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT column1, column2, FIRST_VALUE(column2) OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT column1, column2, FIRST_VALUE(column2) OVER (ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT col_1, col_2, LAG(col_2) OVER (ORDER BY col_1) FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) OVER (ORDER BY col_1) FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) OVER (PARTITION BY col_3 ORDER BY col_1)\",\n    ] {\n        supported_dialects.verified_stmt(sql);\n    }\n\n    let supported_dialects_nulls = TestedDialects {\n        dialects: vec![Box::new(MsSqlDialect {}), Box::new(SnowflakeDialect {})],\n        options: None,\n    };\n\n    for sql in [\n        \"SELECT column1, column2, FIRST_VALUE(column2) IGNORE NULLS OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT column1, column2, FIRST_VALUE(column2) RESPECT NULLS OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) IGNORE NULLS OVER (ORDER BY col_1) FROM t1\",\n        \"SELECT LAG(col_2, 1, 0) RESPECT NULLS OVER (ORDER BY col_1) FROM t1\",\n    ] {\n        supported_dialects_nulls.verified_stmt(sql);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_interactive_error", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_cp_arg_update_interactive_error() {\n    new_ucmd!()\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"-i\")\n        .fails()\n        .no_stdout();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::plain_context", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn plain_context() {\n    let ctx = \"unconfined_u:unconfined_r:unconfined_t:s0-s0\";\n    new_ucmd!().args(&[ctx, \"/bin/true\"]).succeeds();\n    new_ucmd!().args(&[ctx, \"/bin/false\"]).fails().code_is(1);\n\n    let output = new_ucmd!().args(&[ctx, \"sestatus\", \"-v\"]).succeeds();\n    let r = get_sestatus_context(output.stdout());\n    assert_eq!(r, \"unconfined_u:unconfined_r:unconfined_t:s0\");\n\n    let ctx = \"system_u:unconfined_r:unconfined_t:s0-s0\";\n    new_ucmd!().args(&[ctx, \"/bin/true\"]).succeeds();\n\n    let ctx = \"system_u:system_r:unconfined_t:s0\";\n    let output = new_ucmd!().args(&[ctx, \"sestatus\", \"-v\"]).succeeds();\n    assert_eq!(get_sestatus_context(output.stdout()), ctx);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_server.rs::test_serving_status", "code": "fn check(&mut self, ctx: &RpcContext<'_>) -> CheckResult {\n        match check_common_name(&self.allowed_cn, ctx) {\n            Ok(()) => CheckResult::Continue,\n            Err(reason) => CheckResult::Abort(RpcStatus::with_message(\n                RpcStatusCode::UNAUTHENTICATED,\n                format!(\n                    \"Common name check fail, reason: {}, cert_allowed_cn: {:?}\",\n                    reason, self.allowed_cn\n                ),\n            )),\n        }\n    }", "test": "fn test_serving_status() {\n    let mut cluster = new_server_cluster(0, 3);\n    // A round is 30 ticks, set inspect interval to 20ms, so one round is 0.3s.\n    cluster.cfg.raft_store.inspect_interval = ReadableDuration::millis(10);\n    cluster.run();\n\n    let service = cluster.sim.rl().health_services.get(&1).unwrap().clone();\n    let builder =\n        ServerBuilder::new(Arc::new(Environment::new(1))).register_service(create_health(service));\n    let mut server = builder.bind(\"127.0.0.1\", 0).build().unwrap();\n    server.start();\n\n    let (addr, port) = server.bind_addrs().next().unwrap();\n    let ch =\n        ChannelBuilder::new(Arc::new(Environment::new(1))).connect(&format!(\"{}:{}\", addr, port));\n    let client = HealthClient::new(ch);\n\n    let check = || {\n        let req = HealthCheckRequest {\n            service: \"\".to_string(),\n            ..Default::default()\n        };\n        let resp = client.check(&req).unwrap();\n        resp.status\n    };\n\n    thread::sleep(Duration::from_millis(500));\n    assert_eq!(check(), ServingStatus::Serving);\n\n    fail::cfg(\"pause_on_peer_collect_message\", \"pause\").unwrap();\n\n    thread::sleep(Duration::from_secs(1));\n    assert_eq!(check(), ServingStatus::ServiceUnknown);\n\n    fail::remove(\"pause_on_peer_collect_message\");\n\n    // It should recover within one round.\n    thread::sleep(Duration::from_millis(200));\n    assert_eq!(check(), ServingStatus::Serving);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/inscribe.rs::batch_inscribe_with_multiple_inscriptions_with_parent", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn batch_inscribe_with_multiple_inscriptions_with_parent() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 0);\n\n  create_wallet(&rpc_server);\n\n  let parent_output = CommandBuilder::new(\"wallet inscribe --fee-rate 5.0 --file parent.png\")\n    .write(\"parent.png\", [1; 520])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  assert_eq!(rpc_server.descriptors().len(), 3);\n\n  let parent_id = parent_output.inscriptions[0].id;\n\n  let output = CommandBuilder::new(\"wallet inscribe --fee-rate 1 --batch batch.yaml\")\n    .write(\"inscription.txt\", \"Hello World\")\n    .write(\"tulip.png\", [0; 555])\n    .write(\"meow.wav\", [0; 2048])\n    .write(\n      \"batch.yaml\",\n      format!(\"parent: {parent_id}\\nmode: shared-output\\ninscriptions:\\n- file: inscription.txt\\n- file: tulip.png\\n- file: meow.wav\\n\")\n    )\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Inscribe>();\n\n  rpc_server.mine_blocks(1);\n\n  let ord_server = TestServer::spawn_with_args(&rpc_server, &[]);\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[0].id),\n    r\".*<dt>parent</dt>\\s*<dd>.*</dd>.*\",\n  );\n\n  ord_server.assert_response_regex(\n    format!(\"/inscription/{}\", output.inscriptions[1].id),\n    r\".*<dt>parent</dt>\\s*<dd>.*</dd>.*\",\n  );\n\n  let request = TestServer::spawn_with_args(&rpc_server, &[])\n    .request(format!(\"/content/{}\", output.inscriptions[2].id));\n  assert_eq!(request.status(), 200);\n  assert_eq!(request.headers().get(\"content-type\").unwrap(), \"audio/wav\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_transport.rs::test_node_partition_write", "code": "fn test_partition_write<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    must_get_equal(&cluster.get_engine(1), key, value);\n\n    let region_id = cluster.get_region_id(key);\n\n    // transfer leader to (1, 1)\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n\n    // leader in majority, partition doesn't affect write/read\n    cluster.partition(vec![1, 2, 3], vec![4, 5]);\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n    cluster.clear_send_filters();\n\n    // leader in minority, new leader should be elected\n    cluster.partition(vec![1, 2], vec![3, 4, 5]);\n    assert_eq!(cluster.must_get(key), Some(value.to_vec()));\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 1);\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 2);\n    cluster.must_put(key, b\"changed\");\n    cluster.clear_send_filters();\n\n    // when network recover, old leader should sync data\n    cluster.reset_leader_of_region(region_id);\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), key, b\"changed\");\n}", "test": "fn test_node_partition_write() {\n    let mut cluster = new_node_cluster(0, 5);\n    test_partition_write(&mut cluster);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/fallback.rs::requires_setting", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn requires_setting() {\n  Test::new()\n    .tree(tree! {\n      bar: {\n        justfile: \"\n          baz:\n            echo subdir\n        \"\n      }\n    })\n    .justfile(\n      \"\n      foo:\n        echo root\n    \",\n    )\n    .args([\"foo\"])\n    .current_dir(\"bar\")\n    .status(EXIT_FAILURE)\n    .stderr(\"error: Justfile does not contain recipe `foo`.\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_help_ref", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_help_ref() {\n    new_ucmd!()\n        .arg(\"--help\")\n        .arg(\"--reference=ref_file\")\n        .succeeds()\n        .stdout_contains(\"Arguments:\");\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/123_enum_representation.rs::test_internally_b_de", "code": "fn test_de<T>(s: &str, expected: T)\nwhere\n    T: for<'a> Deserialize<'a> + Debug + PartialEq,\n{\n    let actual: Result<T, _> = from_str(s);\n    assert_eq!(actual, Ok(expected));\n}", "test": "fn test_internally_b_de() {\n    let s = \"(type:\\\"VariantB\\\",foo:1,bar:2)\";\n    let e = EnumStructInternally::VariantB { foo: 1, bar: 2 };\n    test_de(s, e);\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_int_max_i64", "code": "fn test_serde<T>(thing: &T, yaml: &str)\nwhere\n    T: serde::Serialize + serde::de::DeserializeOwned + PartialEq + Debug,\n{\n    let serialized = serde_yaml::to_string(&thing).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let value = serde_yaml::to_value(thing).unwrap();\n    let serialized = serde_yaml::to_string(&value).unwrap();\n    assert_eq!(yaml, serialized);\n\n    let deserialized: T = serde_yaml::from_str(yaml).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let value: Value = serde_yaml::from_str(yaml).unwrap();\n    let deserialized = T::deserialize(&value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    let deserialized: T = serde_yaml::from_value(value).unwrap();\n    assert_eq!(*thing, deserialized);\n\n    serde_yaml::from_str::<serde::de::IgnoredAny>(yaml).unwrap();\n}", "test": "fn test_int_max_i64() {\n    let thing = i64::MAX;\n    let yaml = indoc! {\"\n        9223372036854775807\n    \"};\n    test_serde(&thing, yaml);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/regression.rs::regression_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn regression_test_2() {\n    let original = r##\"see the [many] [articles] [on] [QuickCheck].\n\n[many]: https://medium.com/@jlouis666/quickcheck-advice-c357efb4e7e6\n[articles]: http://www.quviq.com/products/erlang-quickcheck/\n[on]: https://wiki.haskell.org/Introduction_to_QuickCheck1\n[QuickCheck]: https://hackage.haskell.org/package/QuickCheck\n\"##;\n    let expected = r##\"<p>see the \n  <a href=\"https://medium.com/@jlouis666/quickcheck-advice-c357efb4e7e6\">many</a> \n  <a href=\"http://www.quviq.com/products/erlang-quickcheck/\">articles</a> \n  <a href=\"https://wiki.haskell.org/Introduction_to_QuickCheck1\">on</a> \n  <a href=\"https://hackage.haskell.org/package/QuickCheck\">QuickCheck</a>.\n</p>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/oxc/precedence.rs::arrow", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn arrow() {\n    test(\"x => a, b\", \"x=>a,b;\");\n    test(\"x => (a, b)\", \"x=>(a,b);\");\n    test(\"x => (a => b)\", \"x=>a=>b;\");\n    test(\"x => y => a, b\", \"x=>y=>a,b;\");\n    test(\"x => y => (a = b)\", \"x=>y=>a=b;\");\n    test(\"x => y => z => a = b, c\", \"x=>y=>z=>a=b,c;\");\n    test(\"x => y => z => a = (b, c)\", \"x=>y=>z=>a=(b,c);\");\n    test(\"x => ({} + 0)\", \"x=>({})+0;\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_readlink.rs::test_canonicalize_trailing_slash_subdir", "code": "pub fn no_stdout(&self) -> &Self {\n        assert!(\n            self.stdout.is_empty(),\n            \"Expected stdout to be empty, but it's:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_canonicalize_trailing_slash_subdir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.mkdir(\"subdir\");\n    at.relative_symlink_dir(\"subdir\", \"link2\");\n    for name in [\"subdir\", \"link2\"] {\n        scene\n            .ucmd()\n            .args(&[\"-f\", name])\n            .succeeds()\n            .stdout_contains(\"subdir\");\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"./{name}/\")])\n            .succeeds()\n            .stdout_contains(\"subdir\");\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"{name}/more\")])\n            .succeeds()\n            .stdout_contains(path_concat!(\"subdir\", \"more\"));\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"./{name}/more/\")])\n            .succeeds()\n            .stdout_contains(path_concat!(\"subdir\", \"more\"));\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"{name}/more/more2\")])\n            .fails()\n            .code_is(1)\n            .no_stdout();\n        scene\n            .ucmd()\n            .args(&[\"-f\", &format!(\"./{name}/more/more2/\")])\n            .fails()\n            .code_is(1)\n            .no_stdout();\n    }\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::function_type_parameters", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn function_type_parameters() {\n    let source = r#\"def X[T: str, U, *Ts, **P](): ...\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_verbose", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_mv_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_verbose_dir\";\n    let file_a = \"test_mv_verbose_file_a\";\n    let file_b = \"test_mv_verbose_file_b\";\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n        .ucmd()\n        .arg(\"-v\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .stdout_only(format!(\"renamed '{file_a}' -> '{file_b}'\\n\"));\n\n    at.touch(file_a);\n    scene\n        .ucmd()\n        .arg(\"-vb\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .stdout_only(format!(\n            \"renamed '{file_a}' -> '{file_b}' (backup: '{file_b}~')\\n\"\n        ));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_config_is_clone", "code": "fn make_client_config(\n    params: &BenchmarkParam,\n    clientauth: ClientAuth,\n    resume: ResumptionParam,\n) -> ClientConfig {\n    let mut root_store = RootCertStore::empty();\n    let mut rootbuf =\n        io::BufReader::new(fs::File::open(params.key_type.path_for(\"ca.cert\")).unwrap());\n    root_store.add_parsable_certificates(&rustls_pemfile::certs(&mut rootbuf).unwrap());\n\n    let cfg = ClientConfig::builder()\n        .with_cipher_suites(&[params.ciphersuite])\n        .with_safe_default_kx_groups()\n        .with_protocol_versions(&[params.version])\n        .unwrap()\n        .with_root_certificates(root_store);\n\n    let mut cfg = if clientauth == ClientAuth::Yes {\n        cfg.with_client_auth_cert(\n            params.key_type.get_client_chain(),\n            params.key_type.get_client_key(),\n        )\n        .unwrap()\n    } else {\n        cfg.with_no_client_auth()\n    };\n\n    if resume != ResumptionParam::No {\n        cfg.resumption = Resumption::in_memory_sessions(128);\n    } else {\n        cfg.resumption = Resumption::disabled();\n    }\n\n    cfg\n}", "test": "fn client_config_is_clone() {\n    let _ = make_client_config(KeyType::Rsa);\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_end_element", "code": "pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    }", "test": "fn test_offset_err_end_element() {\n    let mut r = Reader::from_str(\"</a>\");\n    r.trim_text(true);\n\n    match r.read_event() {\n        Err(_) if r.buffer_position() == 2 => (), // error at char 2: no opening tag\n        Err(e) => panic!(\n            \"expecting buf_pos = 2, found {}, err: {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_all_symlinks", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "test": "fn valid_context_directory_recursive_follow_all_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let c_path = Path::new(\"a\").join(\"c\");\n    dir.touch(c_path.to_str().unwrap());\n\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(c_path.to_str().unwrap(), lc_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let lc_context = get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    // -L: traverse every symbolic link to a directory encountered.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-L\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap(),\n        lc_context\n    );\n    assert_eq!(\n        get_file_context(dir.plus(c_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_transport.rs::test_server_partition_write", "code": "fn test_partition_write<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.run();\n\n    let (key, value) = (b\"k1\", b\"v1\");\n    cluster.must_put(key, value);\n    must_get_equal(&cluster.get_engine(1), key, value);\n\n    let region_id = cluster.get_region_id(key);\n\n    // transfer leader to (1, 1)\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n\n    // leader in majority, partition doesn't affect write/read\n    cluster.partition(vec![1, 2, 3], vec![4, 5]);\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n    cluster.must_transfer_leader(region_id, new_peer(1, 1));\n    cluster.clear_send_filters();\n\n    // leader in minority, new leader should be elected\n    cluster.partition(vec![1, 2], vec![3, 4, 5]);\n    assert_eq!(cluster.must_get(key), Some(value.to_vec()));\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 1);\n    assert_ne!(cluster.leader_of_region(region_id).unwrap().get_id(), 2);\n    cluster.must_put(key, b\"changed\");\n    cluster.clear_send_filters();\n\n    // when network recover, old leader should sync data\n    cluster.reset_leader_of_region(region_id);\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), key, b\"changed\");\n}", "test": "fn test_server_partition_write() {\n    let mut cluster = new_server_cluster(0, 5);\n    test_partition_write(&mut cluster);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_txout", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_txout() {\n    let txout = TxOut {\n        value: Amount::from_sat(0xDEADBEEFCAFEBABE),\n        script_pubkey: ScriptBuf::from(vec![0u8, 1u8, 2u8]),\n    };\n    let got = serialize(&txout).unwrap();\n    let want = include_bytes!(\"data/serde/txout_bincode\") as &[_];\n    assert_eq!(got, want)\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_destroy_clean_up_logs_with_log_gc", "code": "pub fn is_empty(&self) -> bool {\n        self.entries.len() == 0\n    }", "test": "fn test_destroy_clean_up_logs_with_log_gc() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(50);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 50;\n    let pd_client = cluster.pd_client.clone();\n\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    let raft_engine = cluster.engines[&3].raft.clone();\n    let mut dest = vec![];\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(!dest.is_empty());\n\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    dest.clear();\n    // Normally destroy peer should cleanup all logs.\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(dest.is_empty(), \"{:?}\", dest);\n\n    pd_client.must_add_peer(1, new_peer(3, 4));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n    must_get_equal(&cluster.get_engine(3), b\"k3\", b\"v3\");\n    dest.clear();\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(!dest.is_empty());\n\n    pd_client.must_remove_peer(1, new_peer(3, 4));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    dest.clear();\n    // Peer created by snapshot should also cleanup all logs.\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(dest.is_empty(), \"{:?}\", dest);\n\n    pd_client.must_add_peer(1, new_peer(3, 5));\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    cluster.must_put(b\"k4\", b\"v4\");\n    must_get_equal(&cluster.get_engine(3), b\"k4\", b\"v4\");\n    dest.clear();\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(!dest.is_empty());\n\n    let state = cluster.truncated_state(1, 3);\n    for _ in 0..50 {\n        cluster.must_put(b\"k5\", b\"v5\");\n    }\n    cluster.wait_log_truncated(1, 3, state.get_index() + 1);\n\n    pd_client.must_remove_peer(1, new_peer(3, 5));\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    dest.clear();\n    // Peer destroy after log gc should also cleanup all logs.\n    raft_engine.get_all_entries_to(1, &mut dest).unwrap();\n    assert!(dest.is_empty(), \"{:?}\", dest);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/functions.rs::test_absolute_path_resolves_parent", "code": "pub(crate) fn parent(&self) -> Option<&'run Scope<'src, 'run>> {\n    self.parent\n  }", "test": "fn test_absolute_path_resolves_parent() {\n  let test_object = Test::new()\n    .justfile(\"path := absolute_path('../test_file')\")\n    .args([\"--evaluate\", \"path\"]);\n\n  let mut tempdir = test_object.tempdir.path().to_owned();\n\n  // Just retrieves the current directory via env::current_dir(), which\n  // does the moral equivalent of canonicalize, which will remove symlinks.\n  // So, we have to canonicalize here, so that we can match it.\n  if cfg!(unix) {\n    tempdir = tempdir.canonicalize().unwrap();\n  }\n\n  test_object\n    .stdout(\n      tempdir\n        .parent()\n        .unwrap()\n        .join(\"test_file\")\n        .to_str()\n        .unwrap()\n        .to_owned(),\n    )\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pr.rs::test_with_valid_page_ranges", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_with_valid_page_ranges() {\n    let test_file_path = \"test_num_page.log\";\n    let mut scenario = new_ucmd!();\n    scenario\n        .args(&[\"--pages=20:5\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: invalid --pages argument '20:5'\\n\")\n        .stdout_is(\"\");\n    new_ucmd!()\n        .args(&[\"--pages=1:5\", test_file_path])\n        .succeeds();\n    new_ucmd!().args(&[\"--pages=1\", test_file_path]).succeeds();\n    new_ucmd!()\n        .args(&[\"--pages=-1:5\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: invalid --pages argument '-1:5'\\n\")\n        .stdout_is(\"\");\n    new_ucmd!()\n        .args(&[\"--pages=1:-5\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: invalid --pages argument '1:-5'\\n\")\n        .stdout_is(\"\");\n    new_ucmd!()\n        .args(&[\"--pages=5:1\", test_file_path])\n        .fails()\n        .stderr_is(\"pr: invalid --pages argument '5:1'\\n\")\n        .stdout_is(\"\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_snap.rs::test_server_snapshot_on_resolve_failure", "code": "pub fn recv_timeout(&mut self, dur: Duration) -> Result<T, RecvTimeoutError> {\n        let fut = self.next();\n        match block_on_timeout(fut, dur) {\n            Ok(Some(v)) => Ok(v),\n            Ok(None) => Err(RecvTimeoutError::Disconnected),\n            Err(_) => Err(RecvTimeoutError::Timeout),\n        }\n    }", "test": "fn test_server_snapshot_on_resolve_failure() {\n    let mut cluster = new_server_cluster(1, 2);\n    configure_for_snapshot(&mut cluster.cfg);\n\n    let on_send_store_fp = \"transport_on_send_snapshot\";\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n    cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let ready_notify = Arc::default();\n    let (notify_tx, notify_rx) = mpsc::channel();\n    cluster.sim.write().unwrap().add_send_filter(\n        1,\n        Box::new(MessageTypeNotifier::new(\n            MessageType::MsgSnapshot,\n            notify_tx,\n            Arc::clone(&ready_notify),\n        )),\n    );\n\n    // \"return(2)\" those failure occurs if TiKV resolves or sends to store 2.\n    fail::cfg(on_send_store_fp, \"return(2)\").unwrap();\n    pd_client.add_peer(1, new_learner_peer(2, 2));\n\n    // We are ready to recv notify.\n    ready_notify.store(true, Ordering::SeqCst);\n    notify_rx.recv_timeout(Duration::from_secs(3)).unwrap();\n\n    let engine2 = cluster.get_engine(2);\n    must_get_none(&engine2, b\"k1\");\n\n    // If snapshot status is reported correctly, sending snapshot should be retried.\n    notify_rx.recv_timeout(Duration::from_secs(3)).unwrap();\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/gen_c_header.rs::gen_c_header_works", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "test": "fn gen_c_header_works() -> anyhow::Result<()> {\n    let temp_dir = tempfile::tempdir()?;\n    let operating_dir: PathBuf = temp_dir.path().to_owned();\n\n    let wasm_path = operating_dir.join(fixtures::qjs());\n    let out_path = temp_dir.path().join(\"header.h\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(file.contains(\"wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0\"), \"no wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0 in file\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .arg(\"--prefix\")\n        .arg(\"abc123\")\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(\n        file.contains(\"wasmer_function_abc123_0\"),\n        \"no wasmer_function_abc123_0 in file\"\n    );\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_node_split_epoch_not_match_left_derive", "code": "fn test_split_epoch_not_match<T: Simulator>(cluster: &mut Cluster<T>, right_derive: bool) {\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    cluster.run();\n    let pd_client = Arc::clone(&cluster.pd_client);\n    let old = pd_client.get_region(b\"k1\").unwrap();\n    // Construct a get command using old region meta.\n    let get_old = new_request(\n        old.get_id(),\n        old.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k1\")],\n        false,\n    );\n    cluster.must_split(&old, b\"k2\");\n    let r = pd_client.get_region(b\"k3\").unwrap();\n    let get_middle = new_request(\n        r.get_id(),\n        r.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k3\")],\n        false,\n    );\n    cluster.must_split(&r, b\"k3\");\n    let r = pd_client.get_region(b\"k4\").unwrap();\n    cluster.must_split(&r, b\"k4\");\n    let regions: Vec<_> = [b\"k0\", b\"k2\", b\"k3\", b\"k4\"]\n        .iter()\n        .map(|&k| pd_client.get_region(k).unwrap())\n        .collect();\n\n    let new = regions[3].clone();\n    // Newer epoch also triggers the EpochNotMatch error.\n    let mut latest_epoch = new.get_region_epoch().clone();\n    let latest_version = latest_epoch.get_version() + 1;\n    latest_epoch.set_version(latest_version);\n    let get_new = new_request(new.get_id(), latest_epoch, vec![new_get_cmd(b\"k1\")], false);\n\n    let mut cases = vec![\n        // All regions should be returned as request uses an oldest epoch.\n        (get_old, regions.clone()),\n        // Only new split regions should be returned.\n        (get_middle, regions[1..].to_vec()),\n        // Epoch is too new that TiKV can't offer any useful hint.\n        (get_new, vec![regions[3].clone()]),\n    ];\n    if right_derive {\n        // TiKV search backward when right derive.\n        cases[0].1.reverse();\n        cases[1].1.reverse();\n    }\n    for (get, exp) in cases {\n        let resp = cluster\n            .call_command_on_leader(get.clone(), Duration::from_secs(5))\n            .unwrap();\n        assert!(resp.get_header().has_error(), \"{:?}\", get);\n        assert!(\n            resp.get_header().get_error().has_epoch_not_match(),\n            \"{:?}\",\n            get\n        );\n        assert_eq!(\n            resp.get_header()\n                .get_error()\n                .get_epoch_not_match()\n                .get_current_regions(),\n            &*exp,\n            \"{:?}\",\n            get\n        );\n    }\n}", "test": "fn test_node_split_epoch_not_match_left_derive() {\n    let mut cluster = new_node_cluster(0, 3);\n    test_split_epoch_not_match(&mut cluster, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none_then_all", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_none_then_all() {\n    // take last if multiple update args are supplied,\n    // update=all wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_then_all_file1\";\n    let new = \"test_mv_arg_update_none_then_all_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=none\")\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"old content\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_region_heartbeat.rs::test_server_down_peers_without_hibernate_regions", "code": "fn test_down_peers<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.max_peer_down_duration = ReadableDuration::secs(1);\n    cluster.run();\n\n    // Kill 1, 2\n    for len in 1..3 {\n        let id = len;\n        cluster.stop_node(id);\n        wait_down_peers(cluster, len, Some(id));\n    }\n\n    // Restart 1, 2\n    cluster.run_node(1).unwrap();\n    cluster.run_node(2).unwrap();\n    wait_down_peers(cluster, 0, None);\n\n    cluster.stop_node(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    // max peer down duration is 500 millis, but we only report down time in\n    // seconds, so sleep 1 second to make the old down second is always larger\n    // than new down second by at lease 1 second.\n    sleep_ms(1000);\n\n    wait_down_peers(cluster, 1, Some(1));\n    let down_secs = cluster.get_down_peers()[&1].get_down_seconds();\n    let timer = Instant::now();\n    let leader = cluster.leader_of_region(1).unwrap();\n    let new_leader = if leader.get_id() == 2 {\n        new_peer(3, 3)\n    } else {\n        new_peer(2, 2)\n    };\n\n    cluster.must_transfer_leader(1, new_leader);\n    // new leader should reset all down peer list.\n    wait_down_peers(cluster, 0, None);\n    wait_down_peers(cluster, 1, Some(1));\n    assert!(\n        cluster.get_down_peers()[&1].get_down_seconds()\n            < down_secs + timer.saturating_elapsed().as_secs()\n    );\n\n    // Ensure that node will not reuse the previous peer heartbeats.\n    cluster.must_transfer_leader(1, leader);\n    wait_down_peers(cluster, 0, None);\n    wait_down_peers(cluster, 1, Some(1));\n    assert!(\n        cluster.get_down_peers()[&1].get_down_seconds() < timer.saturating_elapsed().as_secs() + 1\n    );\n}", "test": "fn test_server_down_peers_without_hibernate_regions() {\n    let mut cluster = new_server_cluster(0, 5);\n    cluster.cfg.raft_store.hibernate_regions = false;\n    test_down_peers(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_format_day", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_format_day() {\n    let scene = TestScenario::new(util_name!());\n\n    let mut re = Regex::new(r\"\\S+\").unwrap();\n    scene.ucmd().arg(\"+%a\").succeeds().stdout_matches(&re);\n\n    re = Regex::new(r\"\\S+\").unwrap();\n    scene.ucmd().arg(\"+%A\").succeeds().stdout_matches(&re);\n\n    re = Regex::new(r\"^\\d{1}\\n$\").unwrap();\n    scene.ucmd().arg(\"+%u\").succeeds().stdout_matches(&re);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::into_header_name", "code": "pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri> {\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3] != b\"//\" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invald scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }", "test": "fn into_header_name() {\n    let mut m = HeaderMap::new();\n    m.insert(HOST, \"localhost\".parse().unwrap());\n    m.insert(&ACCEPT, \"*/*\".parse().unwrap());\n    m.insert(\"connection\", \"keep-alive\".parse().unwrap());\n\n    m.append(LOCATION, \"/\".parse().unwrap());\n    m.append(&VIA, \"bob\".parse().unwrap());\n    m.append(\"transfer-encoding\", \"chunked\".parse().unwrap());\n\n    assert_eq!(m.len(), 6);\n}"}
{"test_id": "image-rs-jpeg-decoder/image-rs-jpeg-decoder-cacc433/tests/reftest/mod.rs::reftest", "code": "fn reftest_file(path: &Path) {\n    let file = File::open(path).unwrap();\n    let decoder = jpeg::Decoder::new(file);\n    reftest_decoder(decoder, path, &path.with_extension(\"png\"));\n}", "test": "fn reftest() {\n    let files = common::test_files(&Path::new(\"tests\").join(\"reftest\").join(\"images\"));\n\n    for path in &files {\n        reftest_file(path);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_no_args", "code": "fn expect_error(input: &[&str]) {\n    assert!(!new_ucmd!()\n        .args(input)\n        .fails()\n        .no_stdout()\n        .stderr_str()\n        .is_empty());\n}", "test": "fn test_no_args() {\n    expect_error(&[]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_multiple_of_input_chunk", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_multiple_of_input_chunk() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"multiple_of_input_chunk\";\n    RandomFile::new(&at, name).add_bytes(16 * 1024);\n    ucmd.args(&[\"-b\", \"8K\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 8 * 1024);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::lower_n_halfway_test", "code": "pub(crate) fn lower_n_halfway(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n <= bits, \"lower_n_halfway() overflow in shl.\");\n\n    if n == 0 {\n        0\n    } else {\n        nth_bit(n - 1)\n    }\n}", "test": "fn lower_n_halfway_test() {\n    assert_eq!(lower_n_halfway(0u64), 0b0);\n    assert_eq!(lower_n_halfway(1u64), 0b1);\n    assert_eq!(lower_n_halfway(2u64), 0b10);\n    assert_eq!(lower_n_halfway(10u64), 0b1000000000);\n    assert_eq!(lower_n_halfway(32u64), 0b10000000000000000000000000000000);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::s_iseek_skip_not_additive() {\n    ", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "ytes_iseek_skip_not_additive() {\n    new_ucmd!()\n        .args(&[\"iseek=4\", \"skip=4\", \"iflag=skip_bytes\", \"bs=2\"])\n        .pipe_in(\"0123456789abcdefghijklm\")\n        .succeeds()\n        .stdout_is(\"456789abcdefghijklm\");\n}\n\n#[test]"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_wc.rs::test_files0_progressive_stream", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_files0_progressive_stream() {\n    use std::process::Stdio;\n    // You should be able to run wc and have a back-and-forth exchange with wc...\n    let mut child = new_ucmd!()\n        .args(&[\"--files0-from=-\"])\n        .set_stdin(Stdio::piped())\n        .set_stdout(Stdio::piped())\n        .set_stderr(Stdio::piped())\n        .run_no_wait();\n\n    macro_rules! chk {\n        ($fn:ident, $exp:literal) => {\n            assert_eq!(child.$fn($exp.len()), $exp.as_bytes());\n        };\n    }\n\n    // File in, count out...\n    child.write_in(\"moby_dick.txt\\0\");\n    chk!(stdout_exact_bytes, \"18 204 1115 moby_dick.txt\\n\");\n    child.write_in(\"lorem_ipsum.txt\\0\");\n    chk!(stdout_exact_bytes, \"13 109 772 lorem_ipsum.txt\\n\");\n\n    // Introduce an error!\n    child.write_in(\"\\0\");\n    chk!(\n        stderr_exact_bytes,\n        \"wc: -:3: invalid zero-length file name\\n\"\n    );\n\n    // wc is quick to forgive, let's move on...\n    child.write_in(\"alice_in_wonderland.txt\\0\");\n    chk!(stdout_exact_bytes, \"5 57 302 alice_in_wonderland.txt\\n\");\n\n    // Fin.\n    child\n        .wait()\n        .expect(\"wc should finish\")\n        .failure()\n        .stdout_only(\"36 370 2189 total\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_cymdhms_time", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_cymdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_cymdhms_time\";\n\n    ucmd.args(&[\"-t\", \"201501011234.56\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M.%S\", \"201501010000.00\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_ipv4_like_fall_through", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_lookup_ipv4_like_fall_through() {\n    let authority = create_ip_like_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"198.51.100.35.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(Hosts::default())),\n        Some(RData::A(A::new(198, 51, 100, 35))),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        lookup.iter().next().unwrap(),\n        Ipv4Addr::new(198, 51, 100, 35)\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_multiple_files_into_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_multiple_files_into_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_multiple_files_into_file1\";\n    let file2 = \"test_mv_move_multiple_files_into_file2\";\n    let file3 = \"test_mv_move_multiple_files_into_file3\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(file3)\n        .fails()\n        .stderr_is(format!(\"mv: target '{file3}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_tombstone.rs::test_server_stale_meta", "code": "pub fn must_get_equal<EK: KvEngine>(engine: &impl RawEngine<EK>, key: &[u8], value: &[u8]) {\n    must_get(engine, \"default\", key, Some(value));\n}", "test": "fn test_server_stale_meta() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    // Disable default max peer number check.\n    pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    pd_client.must_remove_peer(1, new_peer(3, 3));\n    pd_client.must_add_peer(1, new_peer(3, 4));\n    cluster.shutdown();\n\n    let engine_3 = cluster.get_engine(3);\n    let mut state: RegionLocalState = engine_3\n        .get_msg_cf(CF_RAFT, &keys::region_state_key(1))\n        .unwrap()\n        .unwrap();\n    state.set_state(PeerState::Tombstone);\n\n    engine_3\n        .put_msg_cf(CF_RAFT, &keys::region_state_key(1), &state)\n        .unwrap();\n    cluster.clear_send_filters();\n\n    // avoid TIMEWAIT\n    sleep_ms(500);\n    cluster.start().unwrap();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&engine_3, b\"k1\", b\"v1\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_reboot", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_reboot() {\n    let eps_count = 1;\n    let server = MockServer::with_case(eps_count, Arc::new(AlreadyBootstrapped));\n    let eps = server.bind_addrs();\n    let mut client = new_client_v2(eps, None);\n\n    assert!(!client.is_cluster_bootstrapped().unwrap());\n\n    match client.bootstrap_cluster(metapb::Store::default(), metapb::Region::default()) {\n        Err(PdError::ClusterBootstrapped(_)) => (),\n        _ => {\n            panic!(\"failed, should return ClusterBootstrapped\");\n        }\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_basic", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_basic() {\n    let mut env = Environment::new();\n    env.add_template(\"test\", \"{% for x in seq %}[{{ x }}]{% endfor %}\")\n        .unwrap();\n    let t = env.get_template(\"test\").unwrap();\n    let mut ctx = BTreeMap::new();\n    ctx.insert(\"seq\", Value::from((0..3).collect::<Vec<_>>()));\n    let rv = t.render(ctx).unwrap();\n    assert_eq!(rv, \"[0][1][2]\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nl.rs::test_no_renumber", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_no_renumber() {\n    for arg in [\"-p\", \"--no-renumber\"] {\n        new_ucmd!()\n            .arg(arg)\n            .pipe_in(\"a\\n\\\\:\\\\:\\nb\")\n            .succeeds()\n            .stdout_is(\"     1\\ta\\n\\n     2\\tb\\n\");\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_drop_sequence", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_drop_sequence() {\n    // SimpleLogger::new().init().unwrap();\n    let sql1 = \"DROP SEQUENCE IF EXISTS  name0 CASCADE\";\n    pg().one_statement_parses_to(sql1, \"DROP SEQUENCE IF EXISTS name0 CASCADE\");\n    let sql2 = \"DROP SEQUENCE IF EXISTS  name1 RESTRICT\";\n    pg().one_statement_parses_to(sql2, \"DROP SEQUENCE IF EXISTS name1 RESTRICT\");\n    let sql3 = \"DROP SEQUENCE  name2 CASCADE\";\n    pg().one_statement_parses_to(sql3, \"DROP SEQUENCE name2 CASCADE\");\n    let sql4 = \"DROP SEQUENCE  name2\";\n    pg().one_statement_parses_to(sql4, \"DROP SEQUENCE name2\");\n    let sql5 = \"DROP SEQUENCE  name0 CASCADE\";\n    pg().one_statement_parses_to(sql5, \"DROP SEQUENCE name0 CASCADE\");\n    let sql6 = \"DROP SEQUENCE  name1 RESTRICT\";\n    pg().one_statement_parses_to(sql6, \"DROP SEQUENCE name1 RESTRICT\");\n    let sql7 = \"DROP SEQUENCE  name1, name2, name3\";\n    pg().one_statement_parses_to(sql7, \"DROP SEQUENCE name1, name2, name3\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_head.rs::test_zero_terminated_syntax_2", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_zero_terminated_syntax_2() {\n    new_ucmd!()\n        .args(&[\"-z\", \"-n\", \"2\"])\n        .pipe_in(\"x\\0y\")\n        .run()\n        .stdout_is(\"x\\0y\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_read_from_two_file", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn unexpand_read_from_two_file() {\n    new_ucmd!()\n        .arg(\"with_spaces.txt\")\n        .arg(\"with_spaces.txt\")\n        .arg(\"-t4\")\n        .run()\n        .success();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_rfc_8601", "code": "pub fn stdout_matches(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            regex.is_match(self.stdout_str()),\n            \"Stdout does not match regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_date_rfc_8601() {\n    let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2},\\d{9}[+-]\\d{2}:\\d{2}\\n$\").unwrap();\n    for param in [\"--iso-8601\", \"--i\"] {\n        new_ucmd!()\n            .arg(format!(\"{param}=ns\"))\n            .succeeds()\n            .stdout_matches(&re);\n    }\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/truncate_images.rs::truncate_bmp", "code": "fn truncate_images(decoder: &str) {\n    process_images(IMAGE_DIR, Some(decoder), |path| {\n        println!(\"{:?}\", path);\n        let fin = fs::File::open(&path).unwrap();\n        let max_length = 1000;\n        let mut buf = Vec::with_capacity(max_length);\n        fin.take(max_length as u64).read_to_end(&mut buf).unwrap();\n        for i in 0..buf.len() {\n            image::load_from_memory(&buf[..i + 1]).ok();\n        }\n    })\n}", "test": "fn truncate_bmp() {\n    truncate_images(\"bmp\")\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_a = \"test_mv_interactive_file_a\";\n    let file_b = \"test_mv_interactive_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"n\")\n        .fails()\n        .no_stdout();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"Yesh\") // spell-checker:disable-line\n        .succeeds()\n        .no_stdout();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chgrp.rs::test_no_change", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_no_change() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"file\");\n    ucmd.arg(\"\").arg(at.plus(\"file\")).succeeds();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/function/mod.rs::function", "code": "fn log(\n        _: &JsValue,\n        args: &[JsValue],\n        console: &Self,\n        context: &mut Context<'_>,\n    ) -> JsResult<JsValue> {\n        logger(LogMessage::Log(formatter(args, context)?), console);\n        Ok(JsValue::undefined())\n    }", "test": "fn function() {\n    test_formatting(\n        r#\"\n        function func(a, b) {\n            console.log(a);\n        }\n        function func_2(a, b) {}\n        pass_func(function(a, b) {\n            console.log(\"in callback\", a);\n        });\n        pass_func(function(a, b) {});\n        \"#,\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_scale_scheduler_pool", "code": "fn get_pool_size(&self, priority_level: CommandPri) -> usize {\n        if priority_level == CommandPri::High {\n            self.high_worker_pool.get_pool_size()\n        } else {\n            self.worker_pool.get_pool_size()\n        }\n    }", "test": "fn test_scale_scheduler_pool() {\n    let snapshot_fp = \"scheduler_start_execute\";\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    let origin_pool_size = cluster.cfg.storage.scheduler_worker_pool_size;\n\n    let engine = cluster\n        .sim\n        .read()\n        .unwrap()\n        .storages\n        .get(&1)\n        .unwrap()\n        .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .config(cluster.cfg.tikv.storage.clone())\n        .build()\n        .unwrap();\n\n    let cfg = new_tikv_config(1);\n    let kv_engine = storage.get_engine().kv_engine().unwrap();\n    let (_tx, rx) = std::sync::mpsc::channel();\n    let flow_controller = Arc::new(FlowController::Singleton(EngineFlowController::new(\n        &cfg.storage.flow_control,\n        kv_engine.clone(),\n        rx,\n    )));\n\n    let cfg_controller = ConfigController::new(cfg);\n    let (scheduler, _receiver) = dummy_scheduler();\n    cfg_controller.register(\n        Module::Storage,\n        Box::new(StorageConfigManger::new(\n            kv_engine,\n            scheduler,\n            flow_controller,\n            storage.get_scheduler(),\n        )),\n    );\n    let scheduler = storage.get_scheduler();\n\n    let region = cluster.get_region(b\"k1\");\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.id);\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(cluster.leader_of_region(region.id).unwrap());\n    let do_prewrite = |key: &[u8], val: &[u8]| {\n        // prewrite\n        let (prewrite_tx, prewrite_rx) = channel();\n        storage\n            .sched_txn_command(\n                commands::Prewrite::new(\n                    vec![Mutation::make_put(Key::from_raw(key), val.to_vec())],\n                    key.to_vec(),\n                    10.into(),\n                    100,\n                    false,\n                    2,\n                    TimeStamp::default(),\n                    TimeStamp::default(),\n                    None,\n                    false,\n                    AssertionLevel::Off,\n                    ctx.clone(),\n                ),\n                Box::new(move |res: storage::Result<_>| {\n                    let _ = prewrite_tx.send(res);\n                }),\n            )\n            .unwrap();\n        prewrite_rx.recv_timeout(Duration::from_secs(2))\n    };\n\n    let scale_pool = |size: usize| {\n        cfg_controller\n            .update_config(\"storage.scheduler-worker-pool-size\", &format!(\"{}\", size))\n            .unwrap();\n        assert_eq!(\n            scheduler.get_sched_pool().get_pool_size(CommandPri::Normal),\n            size\n        );\n    };\n\n    scale_pool(1);\n    fail::cfg(snapshot_fp, \"1*pause\").unwrap();\n    // propose one prewrite to block the only worker\n    do_prewrite(b\"k1\", b\"v1\").unwrap_err();\n\n    scale_pool(2);\n\n    // do prewrite again, as we scale another worker, this request should success\n    do_prewrite(b\"k2\", b\"v2\").unwrap().unwrap();\n\n    // restore to original config.\n    scale_pool(origin_pool_size);\n    fail::remove(snapshot_fp);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::i128_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn i128_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n\n    let definition: TableDefinition<i128, i128> = TableDefinition::new(\"x\");\n\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in -10..=10 {\n            table.insert(&i, &(i - 1)).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(-2, table.get(&-1).unwrap().unwrap().value());\n    let mut iter: Range<i128, i128> = table.range::<i128>(..).unwrap();\n    for i in -11..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i);\n    }\n    assert!(iter.next().is_none());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_replica_read.rs::test_read_after_cleanup_range_for_snap", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_read_after_cleanup_range_for_snap() {\n    let mut cluster = new_server_cluster(1, 3);\n    configure_for_snapshot(&mut cluster.cfg);\n    configure_for_lease_read(&mut cluster.cfg, Some(100), Some(10));\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    // Set region and peers\n    let r1 = cluster.run_conf_change();\n    let p1 = new_peer(1, 1);\n    let p2 = new_peer(2, 2);\n    cluster.pd_client.must_add_peer(r1, p2.clone());\n    let p3 = new_peer(3, 3);\n    cluster.pd_client.must_add_peer(r1, p3.clone());\n    cluster.must_put(b\"k0\", b\"v0\");\n    cluster.pd_client.must_none_pending_peer(p2);\n    cluster.pd_client.must_none_pending_peer(p3.clone());\n    let region = cluster.get_region(b\"k0\");\n    assert_eq!(cluster.leader_of_region(region.get_id()).unwrap(), p1);\n    must_get_equal(&cluster.get_engine(3), b\"k0\", b\"v0\");\n    cluster.stop_node(3);\n    let last_index = cluster.raft_local_state(r1, 1).last_index;\n    (0..10).for_each(|_| cluster.must_put(b\"k1\", b\"v1\"));\n    // Ensure logs are compacted, then node 1 will send a snapshot to node 3 later\n    cluster.wait_log_truncated(r1, 1, last_index + 1);\n\n    fail::cfg(\"send_snapshot\", \"pause\").unwrap();\n    cluster.run_node(3).unwrap();\n    // Sleep for a while to ensure peer 3 receives a HeartBeat\n    thread::sleep(Duration::from_millis(500));\n\n    // Add filter for delaying ReadIndexResp and MsgSnapshot\n    let (read_index_sx, read_index_rx) = channel::unbounded::<RaftMessage>();\n    let (snap_sx, snap_rx) = channel::unbounded::<RaftMessage>();\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 3)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgSnapshot)\n            .set_msg_callback(Arc::new(move |msg: &RaftMessage| {\n                snap_sx.send(msg.clone()).unwrap();\n            })),\n    );\n    let send_read_index_filter = RegionPacketFilter::new(region.get_id(), 3)\n        .direction(Direction::Recv)\n        .msg_type(MessageType::MsgReadIndexResp)\n        .set_msg_callback(Arc::new(move |msg: &RaftMessage| {\n            read_index_sx.send(msg.clone()).unwrap();\n        }));\n    cluster.sim.wl().add_recv_filter(3, recv_filter);\n    cluster.add_send_filter(CloneFilterFactory(send_read_index_filter));\n    fail::remove(\"send_snapshot\");\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_get_cf_cmd(\"default\", b\"k0\")],\n        false,\n    );\n    request.mut_header().set_peer(p3);\n    request.mut_header().set_replica_read(true);\n    // Send follower read request to peer 3\n    let (cb1, mut rx1) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(3, request, cb1)\n        .unwrap();\n    let read_index_msg = read_index_rx.recv_timeout(Duration::from_secs(5)).unwrap();\n    let snap_msg = snap_rx.recv_timeout(Duration::from_secs(5)).unwrap();\n\n    fail::cfg(\"apply_snap_cleanup_range\", \"pause\").unwrap();\n\n    let router = cluster.sim.wl().get_router(3).unwrap();\n    fail::cfg(\"pause_on_peer_collect_message\", \"pause\").unwrap();\n    cluster.sim.wl().clear_recv_filters(3);\n    cluster.clear_send_filters();\n    router.send_raft_message(snap_msg).unwrap();\n    router.send_raft_message(read_index_msg).unwrap();\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    fail::remove(\"pause_on_peer_collect_message\");\n    must_get_none(&cluster.get_engine(3), b\"k0\");\n    // Should not receive resp\n    rx1.recv_timeout(Duration::from_millis(500)).unwrap_err();\n    fail::remove(\"apply_snap_cleanup_range\");\n    rx1.recv_timeout(Duration::from_secs(5)).unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_seq.rs::test_big_numbers", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_big_numbers() {\n    new_ucmd!()\n        .args(&[\n            \"1000000000000000000000000000\",\n            \"1000000000000000000000000001\",\n        ])\n        .succeeds()\n        .stdout_only(\"1000000000000000000000000000\\n1000000000000000000000000001\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_nonempty_directory_with_parents", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rmdir_nonempty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(NESTED_DIR_FILE);\n\n    ucmd.arg(\"-p\").arg(NESTED_DIR).fails().stderr_is(format!(\n        \"rmdir: failed to remove 'dir/ect/ory': {NOT_EMPTY}\\n\"\n    ));\n\n    assert!(at.dir_exists(NESTED_DIR));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/resolved_ts/tests/integrations/mod.rs::test_store_partitioned", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_store_partitioned() {\n    let mut suite = TestSuite::new(3);\n    let r = suite.cluster.get_region(&[]);\n    suite.cluster.must_transfer_leader(r.id, new_peer(1, 1));\n    suite.must_get_rts_ge(r.id, block_on(suite.cluster.pd_client.get_tso()).unwrap());\n\n    suite\n        .cluster\n        .add_send_filter(IsolationFilterFactory::new(3));\n    let tso = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    for _ in 0..50 {\n        let rts = suite.region_resolved_ts(r.id).unwrap();\n        if rts > tso {\n            if rts.physical() - tso.physical() < 3000 {\n                break;\n            } else {\n                panic!(\"resolved ts doesn't advance in time\")\n            }\n        }\n        sleep_ms(100);\n    }\n\n    suite.stop();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::empty_type", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "test": "fn empty_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, ()> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(&0, &()).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert!(!table.is_empty().unwrap());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_node_stale_read_during_splitting_left_derive", "code": "fn stale_read_during_splitting(right_derive: bool) {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, None, None);\n    cluster.run();\n\n    // Write the initial values.\n    let key1 = b\"k1\";\n    let v1 = b\"v1\";\n    cluster.must_put(key1, v1);\n    let key2 = b\"k2\";\n    let v2 = b\"v2\";\n    cluster.must_put(key2, v2);\n\n    // Get the first region.\n    let region_left = cluster.get_region(key1);\n    let region_right = cluster.get_region(key2);\n    assert_eq!(region_left, region_right);\n    let region1 = region_left;\n    assert_eq!(region1.get_id(), 1);\n    let peer3 = region1\n        .get_peers()\n        .iter()\n        .find(|p| p.get_id() == 3)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(region1.get_id(), peer3.clone());\n\n    // Get the current leader.\n    let leader1 = peer3;\n\n    // Pause the apply worker of peer 3.\n    let apply_split = \"apply_before_split_1_3\";\n    fail::cfg(apply_split, \"pause\").unwrap();\n\n    // Split the first region.\n    cluster.split_region(&region1, key2, Callback::write(Box::new(move |_| {})));\n\n    // Sleep for a while.\n    // The TiKVs that have followers of the old region will elected a leader\n    // of the new region.\n    //           TiKV A  TiKV B  TiKV C\n    // Region 1    L       F       F\n    // Region 2    X       L       F\n    // Note: A has the peer 3,\n    //       L: leader, F: follower, X: peer is not ready.\n    thread::sleep(election_timeout);\n\n    // A key that is covered by the old region and the new region.\n    let stale_key = if right_derive { key1 } else { key2 };\n    // Get the new region.\n    let region2 = cluster.get_region_with(stale_key, |region| region != &region1);\n\n    // Get the leader of the new region.\n    let leader2 = cluster.leader_of_region(region2.get_id()).unwrap();\n    assert_ne!(leader1.get_store_id(), leader2.get_store_id());\n\n    must_not_stale_read(\n        &mut cluster,\n        stale_key,\n        &region1,\n        &leader1,\n        &region2,\n        &leader2,\n        apply_split,\n    );\n}", "test": "fn test_node_stale_read_during_splitting_left_derive() {\n    stale_read_during_splitting(false);\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_addresses_must_be_valid_for_network", "code": "pub(crate) fn run_and_extract_stdout(self) -> String {\n    self.run().1\n  }", "test": "fn send_addresses_must_be_valid_for_network() {\n  let rpc_server = test_bitcoincore_rpc::builder().build();\n  let txid = rpc_server.mine_blocks_with_subsidy(1, 1_000)[0].txdata[0].txid();\n  create_wallet(&rpc_server);\n\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 tb1q6en7qjxgw4ev8xwx94pzdry6a6ky7wlfeqzunz {txid}:0:0\"\n  ))\n  .rpc_server(&rpc_server)\n  .expected_stderr(\n    \"error: address tb1q6en7qjxgw4ev8xwx94pzdry6a6ky7wlfeqzunz belongs to network testnet which is different from required bitcoin\\n\",\n  )\n  .expected_exit_code(1)\n  .run_and_extract_stdout();\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::three_case_partial_fallthrough", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn three_case_partial_fallthrough() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            let b = 10;\n\n            switch (a) {\n                case 10:\n                    a = 150;\n                case 20:\n                    b = 150;\n                    break;\n                case 15:\n                    b = 1000;\n                    break;\n            }\n\n            a + b;\n        \"#},\n        300,\n    )]);\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::internal_n_mask_test", "code": "pub(crate) fn internal_n_mask(bit: u64, n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(bit <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(n <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(bit >= n, \"internal_n_halfway() overflow in sub.\");\n\n    lower_n_mask(bit) ^ lower_n_mask(bit - n)\n}", "test": "fn internal_n_mask_test() {\n    assert_eq!(internal_n_mask(1u64, 0u64), 0b0);\n    assert_eq!(internal_n_mask(1u64, 1u64), 0b1);\n    assert_eq!(internal_n_mask(2u64, 1u64), 0b10);\n    assert_eq!(internal_n_mask(4u64, 2u64), 0b1100);\n    assert_eq!(internal_n_mask(10u64, 2u64), 0b1100000000);\n    assert_eq!(internal_n_mask(10u64, 4u64), 0b1111000000);\n    assert_eq!(\n        internal_n_mask(32u64, 4u64),\n        0b11110000000000000000000000000000\n    );\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::compare", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn compare() {\n    let source = r#\"4 < x < 5\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_ident.rs::ident_parse_empty", "code": "pub fn parse() -> Result<types::Definitions> {\n    let tokens = load_token_file(TOKEN_SRC)?;\n\n    let mut lookup = Lookup {\n        items: BTreeMap::new(),\n        tokens,\n        aliases: BTreeMap::new(),\n    };\n\n    load_file(SYN_CRATE_ROOT, &[], &mut lookup)?;\n\n    let version = version::get()?;\n\n    let types = lookup\n        .items\n        .values()\n        .map(|item| introspect_item(item, &lookup))\n        .collect();\n\n    let tokens = lookup\n        .tokens\n        .into_iter()\n        .map(|(name, ty)| (ty, name))\n        .collect();\n\n    Ok(types::Definitions {\n        version,\n        types,\n        tokens,\n    })\n}", "test": "fn ident_parse_empty() {\n    parse(\"\").unwrap_err();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::write_digits_f32_test", "code": "fn write_digits_f32(buffer: &mut [u8], value: u64, expected: &str) {\n    let count = unsafe { f32::write_digits(buffer, value) };\n    let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n    assert_eq!(actual, expected);\n}", "test": "fn write_digits_f32_test() {\n    let mut buffer = [b'\\x00'; 32];\n    write_digits_f32(&mut buffer, 0, \"0\");\n    write_digits_f32(&mut buffer, 1, \"1\");\n    write_digits_f32(&mut buffer, 11, \"11\");\n    write_digits_f32(&mut buffer, 23, \"23\");\n    write_digits_f32(&mut buffer, 23786281, \"23786281\");\n    write_digits_f32(&mut buffer, 4294967295, \"4294967295\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_sort.rs::test_check_zero_terminated_success", "code": "pub fn succeeds(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.success();\n        cmd_result\n    }", "test": "fn test_check_zero_terminated_success() {\n    new_ucmd!()\n        .arg(\"-z\")\n        .arg(\"-c\")\n        .arg(\"zero-terminated.expected\")\n        .succeeds();\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_with_table_alias_as", "code": "pub fn one_statement_parses_to(&self, sql: &str, canonical: &str) -> Statement {\n        let mut statements = self.parse_sql_statements(sql).expect(sql);\n        assert_eq!(statements.len(), 1);\n\n        if !canonical.is_empty() && sql != canonical {\n            assert_eq!(self.parse_sql_statements(canonical).unwrap(), statements);\n        }\n\n        let only_statement = statements.pop().unwrap();\n        if !canonical.is_empty() {\n            assert_eq!(canonical, only_statement.to_string())\n        }\n        only_statement\n    }", "test": "fn parse_select_with_table_alias_as() {\n    // AS is optional\n    one_statement_parses_to(\n        \"SELECT a, b, c FROM lineitem l (A, B, C)\",\n        \"SELECT a, b, c FROM lineitem AS l (A, B, C)\",\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_backspace_should_be_preserved", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_backspace_should_be_preserved() {\n    new_ucmd!().pipe_in(\"\\x08\").succeeds().stdout_is(\"\\x08\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_const", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_const() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                var result = 0;\n                for (let i of [1, 2, 3]) {\n                    result = i;\n                }\n            \"#}),\n        TestAction::assert_eq(\"result\", 3),\n        TestAction::assert_native_error(\"i\", JsNativeErrorKind::Reference, \"i is not defined\"),\n    ]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_comma_with_plus_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_comma_with_plus_1() {\n    new_ucmd!()\n        .args(&[\"--tabs=3,+6\"])\n        .pipe_in(\"\\t111\\t222\\t333\")\n        .succeeds()\n        //          01234567890\n        .stdout_is(\"   111   222   333\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/failpoints/test_endpoint.rs::test_cdc_observed_before_incremental_scan_snapshot", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_cdc_observed_before_incremental_scan_snapshot() {\n    let cluster = new_server_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n    let region = suite.cluster.get_region(b\"\");\n    let lead_client = PeerClient::new(&suite.cluster, region.id, new_peer(1, 1));\n\n    // So that the second changefeed can get some delta changes elder than its\n    // snapshot.\n    let (mut req_tx_0, event_feed_0, _) = new_event_feed(suite.get_region_cdc_client(region.id));\n    let req_0 = suite.new_changedata_request(region.id);\n    block_on(req_tx_0.send((req_0, WriteFlags::default()))).unwrap();\n\n    fail::cfg(\"cdc_before_handle_multi_batch\", \"pause\").unwrap();\n    fail::cfg(\"cdc_sleep_before_drain_change_event\", \"return\").unwrap();\n    let (mut req_tx, event_feed, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.id));\n    let req = suite.new_changedata_request(region.id);\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    thread::sleep(Duration::from_secs(1));\n\n    for version in 0..10 {\n        let key = format!(\"key-{:0>6}\", version);\n        let start_ts = get_tso(&suite.cluster.pd_client);\n        lead_client.must_kv_prewrite(\n            vec![new_mutation(Op::Put, key.as_bytes(), b\"value\")],\n            key.as_bytes().to_owned(),\n            start_ts,\n        );\n        let commit_ts = get_tso(&suite.cluster.pd_client);\n        lead_client.must_kv_commit(vec![key.into_bytes()], start_ts, commit_ts);\n    }\n\n    fail::cfg(\"cdc_before_handle_multi_batch\", \"off\").unwrap();\n    fail::cfg(\"cdc_before_drain_change_event\", \"off\").unwrap();\n    // Wait the client wake up from `cdc_sleep_before_drain_change_event`.\n    thread::sleep(Duration::from_secs(5));\n\n    // `Initialized` should be the last event.\n    let (mut initialized_pos, mut row_count) = (0, 0);\n    while initialized_pos == 0 {\n        for event in receive_event(false).get_events() {\n            if let Some(Event_oneof_event::Entries(ref entries)) = event.event {\n                for row in entries.get_entries() {\n                    row_count += 1;\n                    if row.r_type == EventLogType::Initialized {\n                        initialized_pos = row_count;\n                    }\n                }\n            }\n        }\n    }\n    assert!(initialized_pos > 0);\n    assert_eq!(initialized_pos, row_count);\n    let mut rx = event_feed.replace(None).unwrap();\n    if let Ok(Some(Ok(event))) = recv_timeout(&mut rx, Duration::from_secs(1)) {\n        assert!(event.get_events().is_empty());\n    }\n\n    drop(event_feed_0);\n    drop(event_feed);\n    suite.stop();\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_push_promise", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_push_promise() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0x5,\n            0x5, 0x4,\n            0, 0, 0, 0x1, // stream id\n            0, 0, 0, 0x2, // promised id\n            0x82, // HPACK :method=\"GET\"\n        ];\n    };\n\n    let pp = poll_frame!(PushPromise, codec);\n    assert_eq!(pp.stream_id(), 1);\n    assert_eq!(pp.promised_id(), 2);\n    assert_eq!(pp.into_parts().0.method, Some(Method::GET));\n\n    assert_closed!(codec);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_coprocessor.rs::test_readpool_full", "code": "pub fn has_server_is_busy(&self) -> bool {\n        self.server_is_busy.is_some()\n    }", "test": "fn test_readpool_full() {\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &[]);\n    let req = DagSelect::from(&product).build();\n\n    fail::cfg(\"future_pool_spawn_full\", \"return()\").unwrap();\n    let resp = handle_request(&endpoint, req);\n\n    assert!(resp.get_region_error().has_server_is_busy());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::break_labelled_if_statement", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn break_labelled_if_statement() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let result = \"\";\n            bar: if(true) {\n                result = \"foo\";\n                break bar;\n                result = 'this will not be executed';\n            }\n            result\n        \"#},\n        \"foo\",\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_init_list_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_init_list_1() {\n    // Once the list is exhausted, spaces are not converted anymore\n    new_ucmd!()\n        .args(&[\"-t2,4\"])\n        .pipe_in(\"     5\\n      6\\n       7\\n        8\\n\")\n        .run()\n        .stdout_is(\"\\t\\t 5\\n\\t\\t  6\\n\\t\\t   7\\n\\t\\t    8\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_shell_syntax", "code": "pub fn guess_syntax() -> OutputFmt {\n    match env::var(\"SHELL\") {\n        Ok(ref s) if !s.is_empty() => {\n            let shell_path: &Path = s.as_ref();\n            if let Some(name) = shell_path.file_name() {\n                if name == \"csh\" || name == \"tcsh\" {\n                    OutputFmt::CShell\n                } else {\n                    OutputFmt::Shell\n                }\n            } else {\n                OutputFmt::Shell\n            }\n        }\n        _ => OutputFmt::Unknown,\n    }\n}", "test": "fn test_shell_syntax() {\n    use std::env;\n    let last = env::var(\"SHELL\");\n    env::set_var(\"SHELL\", \"/path/csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"/path/bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"/asd/bar\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"foo\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n    env::remove_var(\"SHELL\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n\n    if let Ok(s) = last {\n        env::set_var(\"SHELL\", s);\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter", "code": "fn abort() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"aborted\").unwrap();\n        assert_eq!(\"aborted\", table.get(\"hello\").unwrap().unwrap().value());\n    }\n    write_txn.abort().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE);\n    assert!(table.is_err());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 1);\n}", "test": "fn drain_filter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n        // Test draining uncommitted data\n        drop(table.drain_filter(0..10, |k, _| k < 5).unwrap());\n        for i in 0..5 {\n            table.insert(&i, &i).unwrap();\n        }\n        assert_eq!(table.len().unwrap(), 10);\n\n        // Test matching on the value\n        drop(table.drain_filter(0..10, |_, v| v < 5).unwrap());\n        for i in 0..5 {\n            table.insert(&i, &i).unwrap();\n        }\n        assert_eq!(table.len().unwrap(), 10);\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        for (i, item) in table.drain_filter(0.., |x, _| x < 5).unwrap().enumerate() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i as u64, k.value());\n            assert_eq!(i as u64, v.value());\n        }\n        assert_eq!(table.len().unwrap(), 5);\n        let mut i = 5u64;\n        for item in table.range(0..10).unwrap() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i, k.value());\n            assert_eq!(i, v.value());\n            i += 1;\n        }\n    }\n    write_txn.abort().unwrap();\n\n    // Check that dropping the iter early works too\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        drop(table.drain_filter(0.., |x, _| x < 5).unwrap());\n        assert_eq!(table.len().unwrap(), 5);\n    }\n    write_txn.abort().unwrap();\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_qualified_identifier", "code": "fn parse_and_match_cpp(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, true).len()\n}", "test": "fn test_qualified_identifier() {\n    let needle = r#\"_::var = 10\"#;\n\n    let source = r#\"\n    void foo::bar(foo *this){\n        foo::var = 10;\n    }\"#;\n\n    let matches = parse_and_match_cpp(needle, source);\n    assert_eq!(matches, 1);\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/mod.rs::multiline_str_concat", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn multiline_str_concat() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 'hello ' +\n                    'world';\n            a\n        \"#},\n        \"hello world\",\n    )]);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_all", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_delete_all() {\n    use hickory_proto::rr::rdata::AAAA;\n\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .delete_all(record.name().clone(), origin.clone(), DNSClass::IN)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_rr_type(RecordType::AAAA);\n    record.set_data(Some(RData::AAAA(AAAA::new(1, 2, 3, 4, 5, 6, 7, 8))));\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .delete_all(record.name().clone(), origin, DNSClass::IN)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), RecordType::A)\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n\n    let result = client\n        .query(record.name(), record.dns_class(), RecordType::AAAA)\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge_custom", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_context_merge_custom() {\n    struct X;\n    impl StructObject for X {\n        fn get_field(&self, name: &str) -> Option<Value> {\n            match name {\n                \"a\" => Some(Value::from(1)),\n                \"b\" => Some(Value::from(2)),\n                _ => None,\n            }\n        }\n    }\n\n    let x = Value::from_struct_object(X);\n    let ctx = context! { a => 42, ..x };\n\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(42));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_char", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "test": "fn test_serialize_char() {\n    let value = json!(\n        ({\n            let mut map = BTreeMap::new();\n            map.insert('c', ());\n            map\n        })\n    );\n    assert_eq!(&Value::Null, value.get(\"c\").unwrap());\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_cert_resolve_reduces_sigalgs_for_rsa_ciphersuite", "code": "fn check_sigalgs_reduced_by_ciphersuite(\n    kt: KeyType,\n    suite: CipherSuite,\n    expected_sigalgs: Vec<SignatureScheme>,\n) {\n    let client_config = finish_client_config(\n        kt,\n        ClientConfig::builder()\n            .with_cipher_suites(&[find_suite(suite)])\n            .with_safe_default_kx_groups()\n            .with_safe_default_protocol_versions()\n            .unwrap(),\n    );\n\n    let mut server_config = make_server_config(kt);\n\n    server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n        expected_sigalgs: Some(expected_sigalgs),\n        expected_cipher_suites: Some(vec![suite, CipherSuite::TLS_EMPTY_RENEGOTIATION_INFO_SCSV]),\n        ..Default::default()\n    });\n\n    let mut client = ClientConnection::new(Arc::new(client_config), dns_name(\"localhost\")).unwrap();\n    let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n    let err = do_handshake_until_error(&mut client, &mut server);\n    assert!(err.is_err());\n}", "test": "fn server_cert_resolve_reduces_sigalgs_for_rsa_ciphersuite() {\n    check_sigalgs_reduced_by_ciphersuite(\n        KeyType::Rsa,\n        CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        vec![\n            SignatureScheme::RSA_PSS_SHA512,\n            SignatureScheme::RSA_PSS_SHA384,\n            SignatureScheme::RSA_PSS_SHA256,\n            SignatureScheme::RSA_PKCS1_SHA512,\n            SignatureScheme::RSA_PKCS1_SHA384,\n            SignatureScheme::RSA_PKCS1_SHA256,\n        ],\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_read.rs::test_node_stale_read_during_splitting_right_derive", "code": "fn stale_read_during_splitting(right_derive: bool) {\n    let count = 3;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.cfg.raft_store.right_derive_when_split = right_derive;\n    let election_timeout = configure_for_lease_read(&mut cluster.cfg, None, None);\n    cluster.run();\n\n    // Write the initial values.\n    let key1 = b\"k1\";\n    let v1 = b\"v1\";\n    cluster.must_put(key1, v1);\n    let key2 = b\"k2\";\n    let v2 = b\"v2\";\n    cluster.must_put(key2, v2);\n\n    // Get the first region.\n    let region_left = cluster.get_region(key1);\n    let region_right = cluster.get_region(key2);\n    assert_eq!(region_left, region_right);\n    let region1 = region_left;\n    assert_eq!(region1.get_id(), 1);\n    let peer3 = region1\n        .get_peers()\n        .iter()\n        .find(|p| p.get_id() == 3)\n        .unwrap()\n        .clone();\n    cluster.must_transfer_leader(region1.get_id(), peer3.clone());\n\n    // Get the current leader.\n    let leader1 = peer3;\n\n    // Pause the apply worker of peer 3.\n    let apply_split = \"apply_before_split_1_3\";\n    fail::cfg(apply_split, \"pause\").unwrap();\n\n    // Split the first region.\n    cluster.split_region(&region1, key2, Callback::write(Box::new(move |_| {})));\n\n    // Sleep for a while.\n    // The TiKVs that have followers of the old region will elected a leader\n    // of the new region.\n    //           TiKV A  TiKV B  TiKV C\n    // Region 1    L       F       F\n    // Region 2    X       L       F\n    // Note: A has the peer 3,\n    //       L: leader, F: follower, X: peer is not ready.\n    thread::sleep(election_timeout);\n\n    // A key that is covered by the old region and the new region.\n    let stale_key = if right_derive { key1 } else { key2 };\n    // Get the new region.\n    let region2 = cluster.get_region_with(stale_key, |region| region != &region1);\n\n    // Get the leader of the new region.\n    let leader2 = cluster.leader_of_region(region2.get_id()).unwrap();\n    assert_ne!(leader1.get_store_id(), leader2.get_store_id());\n\n    must_not_stale_read(\n        &mut cluster,\n        stale_key,\n        &region1,\n        &leader1,\n        &region2,\n        &leader2,\n        apply_split,\n    );\n}", "test": "fn test_node_stale_read_during_splitting_right_derive() {\n    stale_read_during_splitting(true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_stdin_default", "code": "pub fn no_stderr(&self) -> &Self {\n        assert!(\n            self.stderr.is_empty(),\n            \"Expected stderr to be empty, but it's:\\n{}\",\n            self.stderr_str()\n        );\n        self\n    }", "test": "fn test_stdin_default() {\n    new_ucmd!()\n        .pipe_in_fixture(FOOBAR_TXT)\n        .run()\n        .stdout_is_fixture(\"foobar_stdin_default.expected\")\n        .no_stderr();\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_args", "code": "fn clone(&self) -> Self {\n        *self\n    }", "test": "fn test_args() {\n    fn type_name_of_val<T: ?Sized>(_val: &T) -> &str {\n        std::any::type_name::<T>()\n    }\n\n    let args = args!();\n    assert_eq!(args.len(), 0);\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n\n    let args = args!(1, 2, foo => 42, bar => 23);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n\n    let args = args!(1, 2, foo => 42, bar => 23,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/raft_client.rs::test_batch_size_edge_limit", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_batch_size_edge_limit() {\n    let msg_count = Arc::new(AtomicUsize::new(0));\n    let batch_msg_count = Arc::new(AtomicUsize::new(0));\n    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), true);\n    let (mock_server, port) = create_mock_server(service, 60200, 60300).unwrap();\n\n    let mut raft_client = get_raft_client_by_port(port);\n\n    // Put them in buffer so sibling messages will be likely be batched during\n    // sending.\n    let mut msgs = Vec::with_capacity(5);\n    for _ in 0..5 {\n        let mut raft_m = RaftMessage::default();\n        // Magic number, this can make estimated size about 4940000, hence two messages\n        // will be batched together, but the total size will be way larger than\n        // 10MiB as there are many indexes and terms.\n        for _ in 0..38000 {\n            let mut e = Entry::default();\n            e.set_term(1);\n            e.set_index(256);\n            e.set_data(vec![b'a'; 130].into());\n            raft_m.mut_message().mut_entries().push(e);\n        }\n        msgs.push(raft_m);\n    }\n    for m in msgs {\n        raft_client.send(m).unwrap();\n    }\n    raft_client.flush();\n\n    check_msg_count(10000, &msg_count, 5);\n    // The final received message count should be 5 exactly.\n    drop(raft_client);\n    drop(mock_server);\n    assert_eq!(msg_count.load(Ordering::SeqCst), 5);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_mock_lookup", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "test": "fn test_mock_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let v4_record = v4_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(resp_query, vec![v4_record], vec![], vec![]);\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::delete", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn delete() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello2\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 2);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert_eq!(\"world\", table.remove(\"hello\").unwrap().unwrap().value());\n        assert!(table.remove(\"hello\").unwrap().is_none());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert!(table.get(\"hello\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_factor.rs::test_valid_arg_exponents", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_valid_arg_exponents() {\n    new_ucmd!().arg(\"-h\").succeeds().code_is(0);\n    new_ucmd!().arg(\"--exponents\").succeeds().code_is(0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_mv_arg_update_none_file1\";\n    let file2 = \"test_mv_arg_update_none_file2\";\n    let file1_content = \"file1 content\\n\";\n    let file2_content = \"file2 content\\n\";\n\n    at.write(file1, file1_content);\n    at.write(file2, file2_content);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(file2), file2_content);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_write", "code": "pub fn reader(&mut self) -> Reader {\n        match self {\n            Self::Client(conn) => conn.reader(),\n            Self::Server(conn) => conn.reader(),\n        }\n    }", "test": "fn client_complete_io_for_write() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        do_handshake(&mut client, &mut server);\n\n        client\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        client\n            .writer()\n            .write_all(b\"01234567890123456789\")\n            .unwrap();\n        {\n            let mut pipe = OtherSession::new(&mut server);\n            let (rdlen, wrlen) = client.complete_io(&mut pipe).unwrap();\n            assert!(rdlen == 0 && wrlen > 0);\n            println!(\"{:?}\", pipe.writevs);\n            assert_eq!(pipe.writevs, vec![vec![42, 42]]);\n        }\n        check_read(\n            &mut server.reader(),\n            b\"0123456789012345678901234567890123456789\",\n        );\n    }\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/regexes.rs::match_fails_evaluates_to_second_branch", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn match_fails_evaluates_to_second_branch() {\n  Test::new()\n    .justfile(\n      \"\n      foo := if 'abbbc' =~ 'ab{4}c' {\n        'yes'\n      } else {\n        'no'\n      }\n\n      default:\n        echo {{ foo }}\n    \",\n    )\n    .stderr(\"echo no\\n\")\n    .stdout(\"no\\n\")\n    .run();\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/closure/fold_constants.rs::test_fold_void", "code": "pub(crate) fn test_same(source_text: &str) {\n    test(source_text, source_text);\n}", "test": "fn test_fold_void() {\n    test_same(\"void 0;\");\n    test(\"void 1\", \"void 0;\");\n    test(\"void x\", \"void 0;\");\n    test_same(\"void x();\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/gfm_table.rs::gfm_table_test_4", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn gfm_table_test_4() {\n    let original = r##\"| abc | def |\n| --- | --- |\n| bar | baz |\n> bar\n\"##;\n    let expected = r##\"<table>\n<thead>\n<tr>\n<th>abc</th>\n<th>def</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bar</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>bar</p>\n</blockquote>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_mode_directories_with_file", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_ancestors_mode_directories_with_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_file = \"ancestor1/ancestor2/target_file\";\n    let directories_arg = \"-D\";\n    let mode_arg = \"--mode=200\";\n    let file = \"file\";\n    let probe = \"probe\";\n\n    at.mkdir(probe);\n    let default_perms = at.metadata(probe).permissions().mode();\n\n    at.touch(file);\n\n    ucmd.args(&[mode_arg, directories_arg, file, target_file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.file_exists(target_file));\n\n    assert_eq!(default_perms, at.metadata(ancestor1).permissions().mode());\n    assert_eq!(default_perms, at.metadata(ancestor2).permissions().mode());\n\n    // Expected mode only on the target_file.\n    assert_eq!(0o100_200_u32, at.metadata(target_file).permissions().mode());\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_rrset", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_delete_rrset() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_rrset(record.clone(), origin.clone()))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_rrset(record.clone(), origin))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_import_macros_missing_namespace", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_import_macros_missing_namespace() {\n    assert_err_msg(\n        r#\"{% import \"hello\" as %}\"#,\n        &[\"1:22\", \"expected an identifier (must start with a-z)\"],\n    );\n}"}
{"test_id": "tafia-calamine/tafia-calamine-5a5804d/tests/test.rs::special_chrs_xlsx", "code": "fn worksheet_range(&mut self, name: &str) -> Option<Result<Range<DataType>, XlsError>> {\n        self.sheets.get(name).map(|r| Ok(r.0.clone()))\n    }", "test": "fn special_chrs_xlsx() {\n    setup();\n\n    let path = format!(\"{}/tests/issues.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(&path).unwrap();\n\n    let range = excel.worksheet_range(\"spc_chrs\").unwrap().unwrap();\n    range_eq!(\n        range,\n        [\n            [String(\"&\".to_string())],\n            [String(\"<\".to_string())],\n            [String(\">\".to_string())],\n            [String(\"aaa ' aaa\".to_string())],\n            [String(\"\\\"\".to_string())],\n            [String(\"\u263a\".to_string())],\n            [String(\"\u058d\".to_string())],\n            [String(\"\u00e0\u00e2\u00e9\u00ea\u00e8\u00e7\u00f6\u00ef\u00ee\u00ab\u00bb\".to_string())]\n        ]\n    );\n}\n\n#[test]\nfn s"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_exclude_all_types", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_exclude_all_types() {\n    let fs_types = new_ucmd!()\n        .arg(\"--output=fstype\")\n        .succeeds()\n        .stdout_move_str();\n    let fs_types: HashSet<_> = fs_types.lines().skip(1).collect();\n\n    let mut args = Vec::new();\n\n    for fs_type in fs_types {\n        args.push(\"-x\");\n        args.push(fs_type.trim_end());\n    }\n\n    new_ucmd!()\n        .args(&args)\n        .fails()\n        .stderr_contains(\"no file systems processed\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_nonexistent_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_link_nonexistent_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_nonexistent_file\";\n    let link = \"test_link_nonexistent_file_link\";\n\n    ucmd.args(&[file, link])\n        .fails()\n        .stderr_only(\"link: cannot create link 'test_link_nonexistent_file_link' to 'test_link_nonexistent_file': No such file or directory\\n\");\n    assert!(!at.file_exists(file));\n    assert!(!at.file_exists(link));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_var_width_value_type", "code": "fn get<'a>(&self, key: impl Borrow<K::SelfType<'a>>) -> Result<MultimapValue<V>>\n    where\n        K: 'a,\n    {\n        let iter = if let Some(collection) = self.tree.get(key.borrow())? {\n            DynamicCollection::iter(collection, self.mem)?\n        } else {\n            MultimapValue::new_subtree(BtreeRangeIter::new::<RangeFull, &V::SelfType<'_>>(\n                &(..),\n                None,\n                self.mem,\n            )?)\n        };\n\n        Ok(iter)\n    }", "test": "fn vec_var_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<&str>> = TableDefinition::new(\"x\");\n\n    let value = vec![\"hello\", \"world\"];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_numbered", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_numbered() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=numbered\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::lifecycle", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn lifecycle() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(\n                        ApplicationClose { error_code: VarInt(42), ref reason }\n                    )}) if reason == REASON);\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client.known_connections(), 0);\n    assert_eq!(pair.client.known_cids(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_cpu.rs::test_reschedule_coprocessor", "code": "fn is_empty(&self) -> bool {\n        self.heap.is_empty()\n    }", "test": "pub fn test_reschedule_coprocessor() {\n    let tag = \"tag_coprocessor\";\n\n    let (test_suite, mut store, endpoint) = setup_test_suite();\n    fail::cfg(\"copr_reschedule\", \"return\").unwrap();\n    fail::cfg_callback(\"scanner_next\", || cpu_load(Duration::from_millis(100))).unwrap();\n    defer!({\n        fail::remove(\"scanner_next\");\n        fail::remove(\"copr_reschedule\");\n    });\n\n    let jh = test_suite\n        .rt\n        .spawn(require_cpu_time_not_zero(&test_suite, tag));\n\n    let table = ProductTable::new();\n    let insert = prepare_insert(&mut store, &table);\n    insert.execute();\n    store.commit();\n\n    let mut req = DagSelect::from(&table).build();\n    let mut ctx = Context::default();\n    ctx.set_resource_group_tag(tag.as_bytes().to_vec());\n    req.set_context(ctx);\n    assert!(\n        !block_on(endpoint.parse_and_handle_unary_request(req, None))\n            .consume()\n            .get_data()\n            .is_empty()\n    );\n\n    assert!(block_on(jh).unwrap());\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/function.rs::function_declaration_returns_undefined", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn function_declaration_returns_undefined() {\n    run_test_actions([TestAction::assert_eq(\n        \"function abc() {}\",\n        JsValue::undefined(),\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_target_directory", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_cp_arg_no_target_directory() {\n    new_ucmd!()\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"-v\")\n        .arg(\"-T\")\n        .arg(TEST_COPY_TO_FOLDER)\n        .fails()\n        .stderr_contains(\"cannot overwrite directory\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u64_pow10_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        100000000000000,\n        100000000000001,\n        100000000000005,\n        999999999999999,\n        1000000000000000,\n        1000000000000001,\n        1000000000000005,\n        9999999999999999,\n        10000000000000000,\n        10000000000000001,\n        10000000000000005,\n        99999999999999999,\n        100000000000000000,\n        100000000000000001,\n        100000000000000005,\n        999999999999999999,\n        1000000000000000000,\n        1000000000000000001,\n        1000000000000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_lines_file", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_positive_lines_file() {\n    new_ucmd!()\n        .args(&[\"-n\", \"+7\", \"foobar.txt\"])\n        .succeeds()\n        .stdout_is(\n            \"siette\nocho\nnueve\ndiez\nonce\n\",\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_positive_bytes_file", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_positive_bytes_file() {\n    new_ucmd!()\n        .args(&[\"-c\", \"+42\", \"foobar.txt\"])\n        .succeeds()\n        .stdout_is(\n            \"ho\nnueve\ndiez\nonce\n\",\n        );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix_hyphen_value", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_custom_backup_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::test_commutative", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn test_commutative() {\n    let needle = \"{if ($x + size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size + offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n\n    let needle = \"{while (_(C_INUSE & _($psize))){k == $psize;}}\";\n    let source = r\"\n    static int alloc_rev(struct chunk *c)\n    {\n    int i;\n    size_t k;\n    while (!((k=c->psize) & C_INUSE)) {\n        i = bin_index(k);\n        lock_bin(i);\n        if (c->psize == k) {\n            unbin(PREV_CHUNK(c), i);\n            unlock_bin(i);\n            return 1;\n        }\n        unlock_bin(i);\n    }\n    return 0;\n    }\n    \";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n\n    let needle = \"{if ($x - size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size - offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 0);\n\n    let needle = \"{if ($x / size > 0){}}\";\n    let source = r\"\n    void func(){\n    if (size / offset > 0) {\n        func2();\n    }}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 0);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter_all_elements_next_back", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn drain_filter_all_elements_next_back() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let mut table = write_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.drain_filter(0..10, |_, _| true).unwrap();\n    for i in (0..10).rev() {\n        let (k, v) = iter.next_back().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_of_loop_return", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_of_loop_return() {\n    run_test_actions([\n        TestAction::run(indoc! {r#\"\n                function foo() {\n                    for (i of [1, 2, 3]) {\n                        if (i > 1)\n                            return i;\n                    }\n                }\n            \"#}),\n        TestAction::assert_eq(\"foo()\", 2),\n    ]);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_host_twice", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn drop_host_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let dtor = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"dtor\")?;\n\n    let t = Resource::new_own(100);\n    dtor.call(&mut store, (&t,))?;\n    dtor.post_return(&mut store)?;\n\n    assert_eq!(\n        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),\n        \"host resource already consumed\"\n    );\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_number_with_io_blksize", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_number_with_io_blksize() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n    ucmd.args(&[\"-n\", \"5\", \"asciilowercase.txt\", \"---io-blksize\", \"1024\"])\n        .succeeds();\n    assert_eq!(file_read(\"xaa\"), \"abcde\");\n    assert_eq!(file_read(\"xab\"), \"fghij\");\n    assert_eq!(file_read(\"xac\"), \"klmno\");\n    assert_eq!(file_read(\"xad\"), \"pqrst\");\n    assert_eq!(file_read(\"xae\"), \"uvwxyz\\n\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_iterators.rs::may_dangle", "code": "fn drop(&mut self) {}", "test": "fn may_dangle() {\n    let p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n    for element in &p {\n        if *element == 2 {\n            drop(p);\n            break;\n        }\n    }\n\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n    for element in &mut p {\n        if *element == 2 {\n            drop(p);\n            break;\n        }\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_runs_linter_not_formatter_issue_3495", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_runs_linter_not_formatter_issue_3495() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_DISABLED_FORMATTER.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), INCORRECT_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"ci target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_runs_linter_not_formatter_issue_3495\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "test": "fn server_exposes_offered_sni() {\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"second.testserver.com\"))\n                .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_true.rs::test_short_options", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_short_options() {\n    for option in [\"-h\", \"-V\"] {\n        new_ucmd!().arg(option).succeeds().stdout_is(\"\");\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/format/expression.rs::assign", "code": "fn test_formatting(source: &'static str) {\n    // Remove preceding newline.\n\n    use crate::{Parser, Source};\n    use boa_interner::{Interner, ToInternedString};\n    let source = &source[1..];\n\n    // Find out how much the code is indented\n    let first_line = &source[..source.find('\\n').unwrap()];\n    let trimmed_first_line = first_line.trim();\n    let characters_to_remove = first_line.len() - trimmed_first_line.len();\n\n    let scenario = source\n        .lines()\n        .map(|l| &l[characters_to_remove..]) // Remove preceding whitespace from each line\n        .collect::<Vec<&'static str>>()\n        .join(\"\\n\");\n    let source = Source::from_bytes(source);\n    let interner = &mut Interner::default();\n    let result = Parser::new(source)\n        .parse_script(interner)\n        .expect(\"parsing failed\")\n        .to_interned_string(interner);\n    if scenario != result {\n        eprint!(\"========= Expected:\\n{scenario}\");\n        eprint!(\"========= Got:\\n{result}\");\n        // Might be helpful to find differing whitespace\n        eprintln!(\"========= Expected: {scenario:?}\");\n        eprintln!(\"========= Got:      {result:?}\");\n        panic!(\"parsing test did not give the correct result (see above)\");\n    }\n}", "test": "fn assign() {\n    test_formatting(\n        r#\"\n        let a = 20;\n        a += 10;\n        a -= 10;\n        a *= 10;\n        a **= 10;\n        a /= 10;\n        a %= 10;\n        a &= 10;\n        a |= 10;\n        a ^= 10;\n        a <<= 10;\n        a >>= 10;\n        a >>>= 10;\n        a &&= 10;\n        a ||= 10;\n        a ??= 10;\n        a;\n        \"#,\n    );\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i32_min", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_i32_min() {\n    assert_eq!(\n        std::i32::MIN,\n        from_str(&to_string(&std::i32::MIN).unwrap()).unwrap()\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_coredump_smoketest", "code": "pub fn display<'a>(&'a self, params: Option<&'a FunctionParameters>) -> String {\n        match self {\n            FinalizedRelocTarget::ExternalName(name) => format!(\"{}\", name.display(params)),\n            FinalizedRelocTarget::Func(offset) => format!(\"func+{offset}\"),\n        }\n    }", "test": "fn run_coredump_smoketest() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/coredump_smoketest.wat\")?;\n    let coredump_file = NamedTempFile::new()?;\n    let coredump_arg = format!(\"-Dcoredump={}\", coredump_file.path().display());\n    let err = run_wasmtime(&[\n        \"run\",\n        \"--invoke\",\n        \"a\",\n        \"-Ccache=n\",\n        &coredump_arg,\n        wasm.path().to_str().unwrap(),\n    ])\n    .unwrap_err();\n    assert!(err.to_string().contains(&format!(\n        \"core dumped at {}\",\n        coredump_file.path().display()\n    )));\n    Ok(())\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/loops.rs::for_loop_break", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn for_loop_break() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 1;\n            for (; a < 5; a++) {\n                if (a == 3) {\n                    break;\n                }\n            }\n            a;\n        \"#},\n        3,\n    )]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_index", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_index() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n        (6, Some(\"name:1\"), 1),\n        (7, Some(\"name:1\"), 1),\n        (8, Some(\"name:1\"), 1),\n        (9, Some(\"name:2\"), 1),\n        (10, Some(\"name:2\"), 1),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    let req = new_analyze_index_req(&product, 3, product[\"name\"].index, 4, 32, 2, 2);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeIndexResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let hist = analyze_resp.get_hist();\n    assert_eq!(hist.get_ndv(), 6);\n    assert_eq!(hist.get_buckets().len(), 2);\n    assert_eq!(hist.get_buckets()[0].get_count(), 5);\n    assert_eq!(hist.get_buckets()[0].get_ndv(), 3);\n    assert_eq!(hist.get_buckets()[1].get_count(), 9);\n    assert_eq!(hist.get_buckets()[1].get_ndv(), 3);\n    let rows = analyze_resp.get_cms().get_rows();\n    assert_eq!(rows.len(), 4);\n    let sum: u32 = rows.first().unwrap().get_counters().iter().sum();\n    assert_eq!(sum, 13);\n    let top_n = analyze_resp.get_cms().get_top_n();\n    let mut top_n_count = top_n\n        .iter()\n        .map(|data| data.get_count())\n        .collect::<Vec<_>>();\n    top_n_count.sort_unstable();\n    assert_eq!(top_n_count, vec![2, 3]);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_test", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_test() {\n    assert_err_msg(\n        r#\"{% if a is odd( %}\"#,\n        &[\"1:17\", \"a test argument (any expressions including arrays)\"],\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_first_only_0", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_first_only_0() {\n    new_ucmd!()\n        .args(&[\"-t3\"])\n        .pipe_in(\"        A     B\")\n        .run()\n        .stdout_is(\"\\t\\t  A\\t  B\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_join.rs::empty_intersection", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn empty_intersection() {\n    new_ucmd!()\n        .arg(\"fields_1.txt\")\n        .arg(\"fields_2.txt\")\n        .arg(\"-2\")\n        .arg(\"2\")\n        .succeeds()\n        .stdout_only(\"\");\n}"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_matching_hostnames", "code": "pub fn check_network_request(&self, request: &Request) -> BlockerResult {\n        self.blocker.check(request, &self.resources)\n    }", "test": "fn check_matching_hostnames() {\n    // Makes sure that reuqests are handled with the same result whether parsed form full url or from pre-parsed hostname\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    let engine = get_blocker_engine();\n\n    for req in requests {\n        let url_host = adblock::url_parser::parse_url(&req.url).unwrap();\n        let source_host = adblock::url_parser::parse_url(&req.sourceUrl).unwrap();\n        let domain = url_host.domain();\n        let source_domain = source_host.domain();\n        let third_party = source_domain != domain;\n\n        let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n        let preparsed_request = Request::preparsed(&req.url, url_host.hostname(), source_host.hostname(), &req.r#type, third_party);\n\n        let checked = engine.check_network_request(&request);\n        let checked_hostnames = engine.check_network_request(&preparsed_request);\n\n        assert_eq!(checked.matched, checked_hostnames.matched);\n        assert_eq!(checked.filter, checked_hostnames.filter);\n        assert_eq!(checked.exception, checked_hostnames.exception);\n        assert_eq!(checked.redirect, checked_hostnames.redirect);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_v1_v2_mixed.rs::test_v1_simple_write", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_v1_simple_write() {\n    let mut cluster_v2 = test_raftstore_v2::new_node_cluster(1, 2);\n    let mut cluster_v1 = test_raftstore::new_node_cluster(1, 2);\n    cluster_v1.cfg.tikv.raft_store.enable_v2_compatible_learner = true;\n    cluster_v1.pd_client.disable_default_operator();\n    cluster_v2.pd_client.disable_default_operator();\n    let r11 = cluster_v1.run_conf_change();\n    let r21 = cluster_v2.run_conf_change();\n\n    cluster_v1.must_put(b\"k0\", b\"v0\");\n    cluster_v2.must_put(b\"k0\", b\"v0\");\n    cluster_v1\n        .pd_client\n        .must_add_peer(r11, new_learner_peer(2, 10));\n    cluster_v2\n        .pd_client\n        .must_add_peer(r21, new_learner_peer(2, 10));\n    check_key_in_engine(&cluster_v1.get_engine(2), b\"zk0\", b\"v0\");\n    check_key_in_engine(&cluster_v2.get_engine(2), b\"zk0\", b\"v0\");\n    let trans1 = Mutex::new(cluster_v1.sim.read().unwrap().get_router(2).unwrap());\n    let trans2 = Mutex::new(cluster_v2.sim.read().unwrap().get_router(1).unwrap());\n\n    let factory1 = ForwardFactory {\n        node_id: 1,\n        chain_send: Arc::new(move |m| {\n            info!(\"send to trans2\"; \"msg\" => ?m);\n            let _ = trans2.lock().unwrap().send_raft_message(Box::new(m));\n        }),\n    };\n    cluster_v1.add_send_filter(factory1);\n    let factory2 = ForwardFactory {\n        node_id: 2,\n        chain_send: Arc::new(move |m| {\n            info!(\"send to trans1\"; \"msg\" => ?m);\n            let _ = trans1.lock().unwrap().send_raft_message(m);\n        }),\n    };\n    cluster_v2.add_send_filter(factory2);\n    let filter11 = Box::new(\n        RegionPacketFilter::new(r11, 2)\n            .direction(Direction::Recv)\n            .msg_type(MessageType::MsgAppend)\n            .msg_type(MessageType::MsgAppendResponse)\n            .msg_type(MessageType::MsgSnapshot)\n            .msg_type(MessageType::MsgHeartbeat)\n            .msg_type(MessageType::MsgHeartbeatResponse),\n    );\n    cluster_v1.add_recv_filter_on_node(2, filter11);\n\n    cluster_v2.must_put(b\"k1\", b\"v1\");\n    assert_eq!(\n        cluster_v2.must_get(b\"k1\").unwrap(),\n        \"v1\".as_bytes().to_vec()\n    );\n    check_key_in_engine(&cluster_v1.get_engine(2), b\"zk1\", b\"v1\");\n\n    cluster_v1.shutdown();\n    cluster_v2.shutdown();\n}"}
{"test_id": "gfx-rs-naga/gfx-rs-naga-92e41b4/tests/spirv-capabilities.rs::sample_rate_shading", "code": "fn require(capabilities: &[Ca], source: &str) {\n    require_and_forbid(capabilities, &[], source);\n}", "test": "fn sample_rate_shading() {\n    require(\n        &[Ca::SampleRateShading],\n        r#\"\n        @fragment\n        fn f(@location(0) @interpolate(perspective, sample) x: f32) { }\n    \"#,\n    );\n\n    require(\n        &[Ca::SampleRateShading],\n        r#\"\n        @fragment\n        fn f(@builtin(sample_index) x: u32) { }\n    \"#,\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_hibernate.rs::test_transfer_leader_delay", "code": "pub async fn lock(self: Arc<Self>) -> KeyHandleGuard {\n        // Safety: `_mutex_guard` is declared before `handle_ref` in `KeyHandleGuard`.\n        // So the mutex guard will be released earlier than the `Arc<KeyHandle>`.\n        // Then we can make sure the mutex guard doesn't point to released memory.\n        let mutex_guard = unsafe { mem::transmute(self.mutex.lock().await) };\n        KeyHandleGuard {\n            _mutex_guard: mutex_guard,\n            handle: self,\n        }\n    }", "test": "fn test_transfer_leader_delay() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_hibernate(&mut cluster.cfg);\n    cluster.run();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    let messages = Arc::new(Mutex::new(vec![]));\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3)\n            .direction(Direction::Send)\n            .msg_type(MessageType::MsgTransferLeader)\n            .reserve_dropped(messages.clone()),\n    ));\n\n    cluster.transfer_leader(1, new_peer(3, 3));\n    let timer = Instant::now();\n    while timer.saturating_elapsed() < Duration::from_secs(3) && messages.lock().unwrap().is_empty()\n    {\n        thread::sleep(Duration::from_millis(10));\n    }\n    assert_eq!(messages.lock().unwrap().len(), 1);\n\n    // Wait till leader peer goes to sleep again.\n    thread::sleep(\n        cluster.cfg.raft_store.raft_base_tick_interval.0\n            * 2\n            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32,\n    );\n\n    cluster.clear_send_filters();\n    cluster.add_send_filter(CloneFilterFactory(DropMessageFilter::new(Arc::new(|m| {\n        m.get_message().get_msg_type() != MessageType::MsgTimeoutNow\n    }))));\n    let router = cluster.sim.wl().get_router(1).unwrap();\n    router\n        .send_raft_message(messages.lock().unwrap().pop().unwrap())\n        .unwrap();\n\n    let timer = Instant::now();\n    while timer.saturating_elapsed() < Duration::from_secs(3) {\n        let resp = cluster.request(\n            b\"k2\",\n            vec![new_put_cmd(b\"k2\", b\"v2\")],\n            false,\n            Duration::from_secs(5),\n        );\n        let header = resp.get_header();\n        if !header.has_error() {\n            return;\n        }\n        if !header\n            .get_error()\n            .get_message()\n            .contains(\"proposal dropped\")\n        {\n            panic!(\"response {:?} has error\", resp);\n        }\n        thread::sleep(Duration::from_millis(10));\n    }\n    panic!(\"failed to request after 3 seconds\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_file_with_target_arg", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_file_into_file_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_file_into_file_with_target_arg_file1\";\n    let file2 = \"test_mv_move_file_into_file_with_target_arg_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--target\")\n        .arg(file1)\n        .arg(file2)\n        .fails()\n        .stderr_is(format!(\"mv: target directory '{file1}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_custom_filter", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_custom_filter() {\n    fn test_filter(_: &State, value: String) -> Result<String, Error> {\n        Ok(format!(\"[{value}]\"))\n    }\n\n    let mut ctx = BTreeMap::new();\n    ctx.insert(\"var\", 42);\n\n    let mut env = Environment::new();\n    env.add_filter(\"test\", test_filter);\n    env.add_template(\"test\", \"{{ var|test }}\").unwrap();\n    let tmpl = env.get_template(\"test\").unwrap();\n    let rv = tmpl.render(&ctx).unwrap();\n    assert_eq!(rv, \"[42]\");\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/spec.rs::spec_test_2", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn spec_test_2() {\n    let original = r##\"      foo    baz        bim\n\"##;\n    let expected = r##\"<pre><code>foo    baz        bim\n</code></pre>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_create_procedure", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_mssql_create_procedure() {\n    let _ = ms_and_generic().verified_stmt(\"CREATE OR ALTER PROCEDURE foo AS BEGIN SELECT 1 END\");\n    let _ = ms_and_generic().verified_stmt(\"CREATE PROCEDURE foo AS BEGIN SELECT 1 END\");\n    let _ = ms().verified_stmt(\n        \"CREATE PROCEDURE foo AS BEGIN SELECT [myColumn] FROM [myschema].[mytable] END\",\n    );\n    let _ = ms_and_generic().verified_stmt(\n        \"CREATE PROCEDURE foo (@CustomerName NVARCHAR(50)) AS BEGIN SELECT * FROM DEV END\",\n    );\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN UPDATE bar SET col = 'test' END\");\n    // Test a statement with END in it\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN SELECT [foo], CASE WHEN [foo] IS NULL THEN 'empty' ELSE 'notempty' END AS [foo] END\");\n    // Multiple statements\n    let _ = ms().verified_stmt(\"CREATE PROCEDURE [foo] AS BEGIN UPDATE bar SET col = 'test'; SELECT [foo] FROM BAR WHERE [FOO] > 10 END\");\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/visitor.rs::type_aliases", "code": "fn trace_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    walk_module(&mut visitor, &parsed);\n\n    visitor.output\n}", "test": "fn type_aliases() {\n    let source = r#\"type X[T: str, U, *Ts, **P] = list[T]\"#;\n\n    let trace = trace_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::export_keying_material", "code": "fn export_keying_material(\n        &self,\n        output: &mut [u8],\n        label: &[u8],\n        context: &[u8],\n    ) -> Result<(), crypto::ExportKeyingMaterialError> {\n        self.inner.export_keying_material(output, label, context)\n    }", "test": "fn export_keying_material() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    const LABEL: &[u8] = b\"test_label\";\n    const CONTEXT: &[u8] = b\"test_context\";\n\n    // client keying material\n    let mut client_buf = [0u8; 64];\n    pair.client_conn_mut(client_ch)\n        .crypto_session()\n        .export_keying_material(&mut client_buf, LABEL, CONTEXT)\n        .unwrap();\n\n    // server keying material\n    let mut server_buf = [0u8; 64];\n    pair.server_conn_mut(server_ch)\n        .crypto_session()\n        .export_keying_material(&mut server_buf, LABEL, CONTEXT)\n        .unwrap();\n\n    assert_eq!(&client_buf[..], &server_buf[..]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_kth_l", "code": "pub fn stdout_only<T: AsRef<str>>(&self, msg: T) -> &Self {\n        self.no_stderr().stdout_is(msg)\n    }", "test": "fn test_split_separator_semicolon_number_kth_l() {\n    new_ucmd!()\n        .args(&[\n            \"--number=l/1/3\",\n            \"--separator\",\n            \";\",\n            \"separator_semicolon.txt\",\n        ])\n        .succeeds()\n        .stdout_only(\"1;2;\");\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/regression.rs::check_regressions", "code": "fn process_images<F>(dir: &str, input_decoder: Option<&str>, func: F)\nwhere\n    F: Fn(&PathBuf, PathBuf, &str),\n{\n    let base: PathBuf = BASE_PATH.iter().collect();\n    let decoders = &[\n        \"tga\", \"tiff\", \"png\", \"gif\", \"bmp\", \"ico\", \"jpg\", \"hdr\", \"pbm\", \"webp\",\n    ];\n    for decoder in decoders {\n        let mut path = base.clone();\n        path.push(dir);\n        path.push(decoder);\n        path.push(\"**\");\n        path.push(\n            \"*.\".to_string()\n                + match input_decoder {\n                    Some(val) => val,\n                    None => decoder,\n                },\n        );\n        let pattern = &*format!(\"{}\", path.display());\n        for path in glob::glob(pattern).unwrap().filter_map(Result::ok) {\n            func(&base, path, decoder)\n        }\n    }\n}", "test": "fn check_regressions() {\n    process_images(REGRESSION_DIR, None, |path| {\n        let _ = image::open(path);\n    })\n}"}
{"test_id": "unicode-rs-unicode-normalization/unicode-rs-unicode-normalization-22675c1/tests/public_assigned.rs::test_public_assigned", "code": "pub fn is_public_assigned(c: char) -> bool {\n    match c {\n        '\\u{0000}'..='\\u{0377}'\n        | '\\u{037A}'..='\\u{037F}'\n        | '\\u{0384}'..='\\u{038A}'\n        | '\\u{038C}'\n        | '\\u{038E}'..='\\u{03A1}'\n        | '\\u{03A3}'..='\\u{052F}'\n        | '\\u{0531}'..='\\u{0556}'\n        | '\\u{0559}'..='\\u{058A}'\n        | '\\u{058D}'..='\\u{058F}'\n        | '\\u{0591}'..='\\u{05C7}'\n        | '\\u{05D0}'..='\\u{05EA}'\n        | '\\u{05EF}'..='\\u{05F4}'\n        | '\\u{0600}'..='\\u{070D}'\n        | '\\u{070F}'..='\\u{074A}'\n        | '\\u{074D}'..='\\u{07B1}'\n        | '\\u{07C0}'..='\\u{07FA}'\n        | '\\u{07FD}'..='\\u{082D}'\n        | '\\u{0830}'..='\\u{083E}'\n        | '\\u{0840}'..='\\u{085B}'\n        | '\\u{085E}'\n        | '\\u{0860}'..='\\u{086A}'\n        | '\\u{0870}'..='\\u{088E}'\n        | '\\u{0890}'..='\\u{0891}'\n        | '\\u{0898}'..='\\u{0983}'\n        | '\\u{0985}'..='\\u{098C}'\n        | '\\u{098F}'..='\\u{0990}'\n        | '\\u{0993}'..='\\u{09A8}'\n        | '\\u{09AA}'..='\\u{09B0}'\n        | '\\u{09B2}'\n        | '\\u{09B6}'..='\\u{09B9}'\n        | '\\u{09BC}'..='\\u{09C4}'\n        | '\\u{09C7}'..='\\u{09C8}'\n        | '\\u{09CB}'..='\\u{09CE}'\n        | '\\u{09D7}'\n        | '\\u{09DC}'..='\\u{09DD}'\n        | '\\u{09DF}'..='\\u{09E3}'\n        | '\\u{09E6}'..='\\u{09FE}'\n        | '\\u{0A01}'..='\\u{0A03}'\n        | '\\u{0A05}'..='\\u{0A0A}'\n        | '\\u{0A0F}'..='\\u{0A10}'\n        | '\\u{0A13}'..='\\u{0A28}'\n        | '\\u{0A2A}'..='\\u{0A30}'\n        | '\\u{0A32}'..='\\u{0A33}'\n        | '\\u{0A35}'..='\\u{0A36}'\n        | '\\u{0A38}'..='\\u{0A39}'\n        | '\\u{0A3C}'\n        | '\\u{0A3E}'..='\\u{0A42}'\n        | '\\u{0A47}'..='\\u{0A48}'\n        | '\\u{0A4B}'..='\\u{0A4D}'\n        | '\\u{0A51}'\n        | '\\u{0A59}'..='\\u{0A5C}'\n        | '\\u{0A5E}'\n        | '\\u{0A66}'..='\\u{0A76}'\n        | '\\u{0A81}'..='\\u{0A83}'\n        | '\\u{0A85}'..='\\u{0A8D}'\n        | '\\u{0A8F}'..='\\u{0A91}'\n        | '\\u{0A93}'..='\\u{0AA8}'\n        | '\\u{0AAA}'..='\\u{0AB0}'\n        | '\\u{0AB2}'..='\\u{0AB3}'\n        | '\\u{0AB5}'..='\\u{0AB9}'\n        | '\\u{0ABC}'..='\\u{0AC5}'\n        | '\\u{0AC7}'..='\\u{0AC9}'\n        | '\\u{0ACB}'..='\\u{0ACD}'\n        | '\\u{0AD0}'\n        | '\\u{0AE0}'..='\\u{0AE3}'\n        | '\\u{0AE6}'..='\\u{0AF1}'\n        | '\\u{0AF9}'..='\\u{0AFF}'\n        | '\\u{0B01}'..='\\u{0B03}'\n        | '\\u{0B05}'..='\\u{0B0C}'\n        | '\\u{0B0F}'..='\\u{0B10}'\n        | '\\u{0B13}'..='\\u{0B28}'\n        | '\\u{0B2A}'..='\\u{0B30}'\n        | '\\u{0B32}'..='\\u{0B33}'\n        | '\\u{0B35}'..='\\u{0B39}'\n        | '\\u{0B3C}'..='\\u{0B44}'\n        | '\\u{0B47}'..='\\u{0B48}'\n        | '\\u{0B4B}'..='\\u{0B4D}'\n        | '\\u{0B55}'..='\\u{0B57}'\n        | '\\u{0B5C}'..='\\u{0B5D}'\n        | '\\u{0B5F}'..='\\u{0B63}'\n        | '\\u{0B66}'..='\\u{0B77}'\n        | '\\u{0B82}'..='\\u{0B83}'\n        | '\\u{0B85}'..='\\u{0B8A}'\n        | '\\u{0B8E}'..='\\u{0B90}'\n        | '\\u{0B92}'..='\\u{0B95}'\n        | '\\u{0B99}'..='\\u{0B9A}'\n        | '\\u{0B9C}'\n        | '\\u{0B9E}'..='\\u{0B9F}'\n        | '\\u{0BA3}'..='\\u{0BA4}'\n        | '\\u{0BA8}'..='\\u{0BAA}'\n        | '\\u{0BAE}'..='\\u{0BB9}'\n        | '\\u{0BBE}'..='\\u{0BC2}'\n        | '\\u{0BC6}'..='\\u{0BC8}'\n        | '\\u{0BCA}'..='\\u{0BCD}'\n        | '\\u{0BD0}'\n        | '\\u{0BD7}'\n        | '\\u{0BE6}'..='\\u{0BFA}'\n        | '\\u{0C00}'..='\\u{0C0C}'\n        | '\\u{0C0E}'..='\\u{0C10}'\n        | '\\u{0C12}'..='\\u{0C28}'\n        | '\\u{0C2A}'..='\\u{0C39}'\n        | '\\u{0C3C}'..='\\u{0C44}'\n        | '\\u{0C46}'..='\\u{0C48}'\n        | '\\u{0C4A}'..='\\u{0C4D}'\n        | '\\u{0C55}'..='\\u{0C56}'\n        | '\\u{0C58}'..='\\u{0C5A}'\n        | '\\u{0C5D}'\n        | '\\u{0C60}'..='\\u{0C63}'\n        | '\\u{0C66}'..='\\u{0C6F}'\n        | '\\u{0C77}'..='\\u{0C8C}'\n        | '\\u{0C8E}'..='\\u{0C90}'\n        | '\\u{0C92}'..='\\u{0CA8}'\n        | '\\u{0CAA}'..='\\u{0CB3}'\n        | '\\u{0CB5}'..='\\u{0CB9}'\n        | '\\u{0CBC}'..='\\u{0CC4}'\n        | '\\u{0CC6}'..='\\u{0CC8}'\n        | '\\u{0CCA}'..='\\u{0CCD}'\n        | '\\u{0CD5}'..='\\u{0CD6}'\n        | '\\u{0CDD}'..='\\u{0CDE}'\n        | '\\u{0CE0}'..='\\u{0CE3}'\n        | '\\u{0CE6}'..='\\u{0CEF}'\n        | '\\u{0CF1}'..='\\u{0CF3}'\n        | '\\u{0D00}'..='\\u{0D0C}'\n        | '\\u{0D0E}'..='\\u{0D10}'\n        | '\\u{0D12}'..='\\u{0D44}'\n        | '\\u{0D46}'..='\\u{0D48}'\n        | '\\u{0D4A}'..='\\u{0D4F}'\n        | '\\u{0D54}'..='\\u{0D63}'\n        | '\\u{0D66}'..='\\u{0D7F}'\n        | '\\u{0D81}'..='\\u{0D83}'\n        | '\\u{0D85}'..='\\u{0D96}'\n        | '\\u{0D9A}'..='\\u{0DB1}'\n        | '\\u{0DB3}'..='\\u{0DBB}'\n        | '\\u{0DBD}'\n        | '\\u{0DC0}'..='\\u{0DC6}'\n        | '\\u{0DCA}'\n        | '\\u{0DCF}'..='\\u{0DD4}'\n        | '\\u{0DD6}'\n        | '\\u{0DD8}'..='\\u{0DDF}'\n        | '\\u{0DE6}'..='\\u{0DEF}'\n        | '\\u{0DF2}'..='\\u{0DF4}'\n        | '\\u{0E01}'..='\\u{0E3A}'\n        | '\\u{0E3F}'..='\\u{0E5B}'\n        | '\\u{0E81}'..='\\u{0E82}'\n        | '\\u{0E84}'\n        | '\\u{0E86}'..='\\u{0E8A}'\n        | '\\u{0E8C}'..='\\u{0EA3}'\n        | '\\u{0EA5}'\n        | '\\u{0EA7}'..='\\u{0EBD}'\n        | '\\u{0EC0}'..='\\u{0EC4}'\n        | '\\u{0EC6}'\n        | '\\u{0EC8}'..='\\u{0ECE}'\n        | '\\u{0ED0}'..='\\u{0ED9}'\n        | '\\u{0EDC}'..='\\u{0EDF}'\n        | '\\u{0F00}'..='\\u{0F47}'\n        | '\\u{0F49}'..='\\u{0F6C}'\n        | '\\u{0F71}'..='\\u{0F97}'\n        | '\\u{0F99}'..='\\u{0FBC}'\n        | '\\u{0FBE}'..='\\u{0FCC}'\n        | '\\u{0FCE}'..='\\u{0FDA}'\n        | '\\u{1000}'..='\\u{10C5}'\n        | '\\u{10C7}'\n        | '\\u{10CD}'\n        | '\\u{10D0}'..='\\u{1248}'\n        | '\\u{124A}'..='\\u{124D}'\n        | '\\u{1250}'..='\\u{1256}'\n        | '\\u{1258}'\n        | '\\u{125A}'..='\\u{125D}'\n        | '\\u{1260}'..='\\u{1288}'\n        | '\\u{128A}'..='\\u{128D}'\n        | '\\u{1290}'..='\\u{12B0}'\n        | '\\u{12B2}'..='\\u{12B5}'\n        | '\\u{12B8}'..='\\u{12BE}'\n        | '\\u{12C0}'\n        | '\\u{12C2}'..='\\u{12C5}'\n        | '\\u{12C8}'..='\\u{12D6}'\n        | '\\u{12D8}'..='\\u{1310}'\n        | '\\u{1312}'..='\\u{1315}'\n        | '\\u{1318}'..='\\u{135A}'\n        | '\\u{135D}'..='\\u{137C}'\n        | '\\u{1380}'..='\\u{1399}'\n        | '\\u{13A0}'..='\\u{13F5}'\n        | '\\u{13F8}'..='\\u{13FD}'\n        | '\\u{1400}'..='\\u{169C}'\n        | '\\u{16A0}'..='\\u{16F8}'\n        | '\\u{1700}'..='\\u{1715}'\n        | '\\u{171F}'..='\\u{1736}'\n        | '\\u{1740}'..='\\u{1753}'\n        | '\\u{1760}'..='\\u{176C}'\n        | '\\u{176E}'..='\\u{1770}'\n        | '\\u{1772}'..='\\u{1773}'\n        | '\\u{1780}'..='\\u{17DD}'\n        | '\\u{17E0}'..='\\u{17E9}'\n        | '\\u{17F0}'..='\\u{17F9}'\n        | '\\u{1800}'..='\\u{1819}'\n        | '\\u{1820}'..='\\u{1878}'\n        | '\\u{1880}'..='\\u{18AA}'\n        | '\\u{18B0}'..='\\u{18F5}'\n        | '\\u{1900}'..='\\u{191E}'\n        | '\\u{1920}'..='\\u{192B}'\n        | '\\u{1930}'..='\\u{193B}'\n        | '\\u{1940}'\n        | '\\u{1944}'..='\\u{196D}'\n        | '\\u{1970}'..='\\u{1974}'\n        | '\\u{1980}'..='\\u{19AB}'\n        | '\\u{19B0}'..='\\u{19C9}'\n        | '\\u{19D0}'..='\\u{19DA}'\n        | '\\u{19DE}'..='\\u{1A1B}'\n        | '\\u{1A1E}'..='\\u{1A5E}'\n        | '\\u{1A60}'..='\\u{1A7C}'\n        | '\\u{1A7F}'..='\\u{1A89}'\n        | '\\u{1A90}'..='\\u{1A99}'\n        | '\\u{1AA0}'..='\\u{1AAD}'\n        | '\\u{1AB0}'..='\\u{1ACE}'\n        | '\\u{1B00}'..='\\u{1B4C}'\n        | '\\u{1B50}'..='\\u{1B7E}'\n        | '\\u{1B80}'..='\\u{1BF3}'\n        | '\\u{1BFC}'..='\\u{1C37}'\n        | '\\u{1C3B}'..='\\u{1C49}'\n        | '\\u{1C4D}'..='\\u{1C88}'\n        | '\\u{1C90}'..='\\u{1CBA}'\n        | '\\u{1CBD}'..='\\u{1CC7}'\n        | '\\u{1CD0}'..='\\u{1CFA}'\n        | '\\u{1D00}'..='\\u{1F15}'\n        | '\\u{1F18}'..='\\u{1F1D}'\n        | '\\u{1F20}'..='\\u{1F45}'\n        | '\\u{1F48}'..='\\u{1F4D}'\n        | '\\u{1F50}'..='\\u{1F57}'\n        | '\\u{1F59}'\n        | '\\u{1F5B}'\n        | '\\u{1F5D}'\n        | '\\u{1F5F}'..='\\u{1F7D}'\n        | '\\u{1F80}'..='\\u{1FB4}'\n        | '\\u{1FB6}'..='\\u{1FC4}'\n        | '\\u{1FC6}'..='\\u{1FD3}'\n        | '\\u{1FD6}'..='\\u{1FDB}'\n        | '\\u{1FDD}'..='\\u{1FEF}'\n        | '\\u{1FF2}'..='\\u{1FF4}'\n        | '\\u{1FF6}'..='\\u{1FFE}'\n        | '\\u{2000}'..='\\u{2064}'\n        | '\\u{2066}'..='\\u{2071}'\n        | '\\u{2074}'..='\\u{208E}'\n        | '\\u{2090}'..='\\u{209C}'\n        | '\\u{20A0}'..='\\u{20C0}'\n        | '\\u{20D0}'..='\\u{20F0}'\n        | '\\u{2100}'..='\\u{218B}'\n        | '\\u{2190}'..='\\u{2426}'\n        | '\\u{2440}'..='\\u{244A}'\n        | '\\u{2460}'..='\\u{2B73}'\n        | '\\u{2B76}'..='\\u{2B95}'\n        | '\\u{2B97}'..='\\u{2CF3}'\n        | '\\u{2CF9}'..='\\u{2D25}'\n        | '\\u{2D27}'\n        | '\\u{2D2D}'\n        | '\\u{2D30}'..='\\u{2D67}'\n        | '\\u{2D6F}'..='\\u{2D70}'\n        | '\\u{2D7F}'..='\\u{2D96}'\n        | '\\u{2DA0}'..='\\u{2DA6}'\n        | '\\u{2DA8}'..='\\u{2DAE}'\n        | '\\u{2DB0}'..='\\u{2DB6}'\n        | '\\u{2DB8}'..='\\u{2DBE}'\n        | '\\u{2DC0}'..='\\u{2DC6}'\n        | '\\u{2DC8}'..='\\u{2DCE}'\n        | '\\u{2DD0}'..='\\u{2DD6}'\n        | '\\u{2DD8}'..='\\u{2DDE}'\n        | '\\u{2DE0}'..='\\u{2E5D}'\n        | '\\u{2E80}'..='\\u{2E99}'\n        | '\\u{2E9B}'..='\\u{2EF3}'\n        | '\\u{2F00}'..='\\u{2FD5}'\n        | '\\u{2FF0}'..='\\u{2FFB}'\n        | '\\u{3000}'..='\\u{303F}'\n        | '\\u{3041}'..='\\u{3096}'\n        | '\\u{3099}'..='\\u{30FF}'\n        | '\\u{3105}'..='\\u{312F}'\n        | '\\u{3131}'..='\\u{318E}'\n        | '\\u{3190}'..='\\u{31E3}'\n        | '\\u{31F0}'..='\\u{321E}'\n        | '\\u{3220}'..='\\u{A48C}'\n        | '\\u{A490}'..='\\u{A4C6}'\n        | '\\u{A4D0}'..='\\u{A62B}'\n        | '\\u{A640}'..='\\u{A6F7}'\n        | '\\u{A700}'..='\\u{A7CA}'\n        | '\\u{A7D0}'..='\\u{A7D1}'\n        | '\\u{A7D3}'\n        | '\\u{A7D5}'..='\\u{A7D9}'\n        | '\\u{A7F2}'..='\\u{A82C}'\n        | '\\u{A830}'..='\\u{A839}'\n        | '\\u{A840}'..='\\u{A877}'\n        | '\\u{A880}'..='\\u{A8C5}'\n        | '\\u{A8CE}'..='\\u{A8D9}'\n        | '\\u{A8E0}'..='\\u{A953}'\n        | '\\u{A95F}'..='\\u{A97C}'\n        | '\\u{A980}'..='\\u{A9CD}'\n        | '\\u{A9CF}'..='\\u{A9D9}'\n        | '\\u{A9DE}'..='\\u{A9FE}'\n        | '\\u{AA00}'..='\\u{AA36}'\n        | '\\u{AA40}'..='\\u{AA4D}'\n        | '\\u{AA50}'..='\\u{AA59}'\n        | '\\u{AA5C}'..='\\u{AAC2}'\n        | '\\u{AADB}'..='\\u{AAF6}'\n        | '\\u{AB01}'..='\\u{AB06}'\n        | '\\u{AB09}'..='\\u{AB0E}'\n        | '\\u{AB11}'..='\\u{AB16}'\n        | '\\u{AB20}'..='\\u{AB26}'\n        | '\\u{AB28}'..='\\u{AB2E}'\n        | '\\u{AB30}'..='\\u{AB6B}'\n        | '\\u{AB70}'..='\\u{ABED}'\n        | '\\u{ABF0}'..='\\u{ABF9}'\n        | '\\u{AC00}'..='\\u{D7A3}'\n        | '\\u{D7B0}'..='\\u{D7C6}'\n        | '\\u{D7CB}'..='\\u{D7FB}'\n        | '\\u{F900}'..='\\u{FA6D}'\n        | '\\u{FA70}'..='\\u{FAD9}'\n        | '\\u{FB00}'..='\\u{FB06}'\n        | '\\u{FB13}'..='\\u{FB17}'\n        | '\\u{FB1D}'..='\\u{FB36}'\n        | '\\u{FB38}'..='\\u{FB3C}'\n        | '\\u{FB3E}'\n        | '\\u{FB40}'..='\\u{FB41}'\n        | '\\u{FB43}'..='\\u{FB44}'\n        | '\\u{FB46}'..='\\u{FBC2}'\n        | '\\u{FBD3}'..='\\u{FD8F}'\n        | '\\u{FD92}'..='\\u{FDC7}'\n        | '\\u{FDCF}'\n        | '\\u{FDF0}'..='\\u{FE19}'\n        | '\\u{FE20}'..='\\u{FE52}'\n        | '\\u{FE54}'..='\\u{FE66}'\n        | '\\u{FE68}'..='\\u{FE6B}'\n        | '\\u{FE70}'..='\\u{FE74}'\n        | '\\u{FE76}'..='\\u{FEFC}'\n        | '\\u{FEFF}'\n        | '\\u{FF01}'..='\\u{FFBE}'\n        | '\\u{FFC2}'..='\\u{FFC7}'\n        | '\\u{FFCA}'..='\\u{FFCF}'\n        | '\\u{FFD2}'..='\\u{FFD7}'\n        | '\\u{FFDA}'..='\\u{FFDC}'\n        | '\\u{FFE0}'..='\\u{FFE6}'\n        | '\\u{FFE8}'..='\\u{FFEE}'\n        | '\\u{FFF9}'..='\\u{FFFD}'\n        | '\\u{10000}'..='\\u{1000B}'\n        | '\\u{1000D}'..='\\u{10026}'\n        | '\\u{10028}'..='\\u{1003A}'\n        | '\\u{1003C}'..='\\u{1003D}'\n        | '\\u{1003F}'..='\\u{1004D}'\n        | '\\u{10050}'..='\\u{1005D}'\n        | '\\u{10080}'..='\\u{100FA}'\n        | '\\u{10100}'..='\\u{10102}'\n        | '\\u{10107}'..='\\u{10133}'\n        | '\\u{10137}'..='\\u{1018E}'\n        | '\\u{10190}'..='\\u{1019C}'\n        | '\\u{101A0}'\n        | '\\u{101D0}'..='\\u{101FD}'\n        | '\\u{10280}'..='\\u{1029C}'\n        | '\\u{102A0}'..='\\u{102D0}'\n        | '\\u{102E0}'..='\\u{102FB}'\n        | '\\u{10300}'..='\\u{10323}'\n        | '\\u{1032D}'..='\\u{1034A}'\n        | '\\u{10350}'..='\\u{1037A}'\n        | '\\u{10380}'..='\\u{1039D}'\n        | '\\u{1039F}'..='\\u{103C3}'\n        | '\\u{103C8}'..='\\u{103D5}'\n        | '\\u{10400}'..='\\u{1049D}'\n        | '\\u{104A0}'..='\\u{104A9}'\n        | '\\u{104B0}'..='\\u{104D3}'\n        | '\\u{104D8}'..='\\u{104FB}'\n        | '\\u{10500}'..='\\u{10527}'\n        | '\\u{10530}'..='\\u{10563}'\n        | '\\u{1056F}'..='\\u{1057A}'\n        | '\\u{1057C}'..='\\u{1058A}'\n        | '\\u{1058C}'..='\\u{10592}'\n        | '\\u{10594}'..='\\u{10595}'\n        | '\\u{10597}'..='\\u{105A1}'\n        | '\\u{105A3}'..='\\u{105B1}'\n        | '\\u{105B3}'..='\\u{105B9}'\n        | '\\u{105BB}'..='\\u{105BC}'\n        | '\\u{10600}'..='\\u{10736}'\n        | '\\u{10740}'..='\\u{10755}'\n        | '\\u{10760}'..='\\u{10767}'\n        | '\\u{10780}'..='\\u{10785}'\n        | '\\u{10787}'..='\\u{107B0}'\n        | '\\u{107B2}'..='\\u{107BA}'\n        | '\\u{10800}'..='\\u{10805}'\n        | '\\u{10808}'\n        | '\\u{1080A}'..='\\u{10835}'\n        | '\\u{10837}'..='\\u{10838}'\n        | '\\u{1083C}'\n        | '\\u{1083F}'..='\\u{10855}'\n        | '\\u{10857}'..='\\u{1089E}'\n        | '\\u{108A7}'..='\\u{108AF}'\n        | '\\u{108E0}'..='\\u{108F2}'\n        | '\\u{108F4}'..='\\u{108F5}'\n        | '\\u{108FB}'..='\\u{1091B}'\n        | '\\u{1091F}'..='\\u{10939}'\n        | '\\u{1093F}'\n        | '\\u{10980}'..='\\u{109B7}'\n        | '\\u{109BC}'..='\\u{109CF}'\n        | '\\u{109D2}'..='\\u{10A03}'\n        | '\\u{10A05}'..='\\u{10A06}'\n        | '\\u{10A0C}'..='\\u{10A13}'\n        | '\\u{10A15}'..='\\u{10A17}'\n        | '\\u{10A19}'..='\\u{10A35}'\n        | '\\u{10A38}'..='\\u{10A3A}'\n        | '\\u{10A3F}'..='\\u{10A48}'\n        | '\\u{10A50}'..='\\u{10A58}'\n        | '\\u{10A60}'..='\\u{10A9F}'\n        | '\\u{10AC0}'..='\\u{10AE6}'\n        | '\\u{10AEB}'..='\\u{10AF6}'\n        | '\\u{10B00}'..='\\u{10B35}'\n        | '\\u{10B39}'..='\\u{10B55}'\n        | '\\u{10B58}'..='\\u{10B72}'\n        | '\\u{10B78}'..='\\u{10B91}'\n        | '\\u{10B99}'..='\\u{10B9C}'\n        | '\\u{10BA9}'..='\\u{10BAF}'\n        | '\\u{10C00}'..='\\u{10C48}'\n        | '\\u{10C80}'..='\\u{10CB2}'\n        | '\\u{10CC0}'..='\\u{10CF2}'\n        | '\\u{10CFA}'..='\\u{10D27}'\n        | '\\u{10D30}'..='\\u{10D39}'\n        | '\\u{10E60}'..='\\u{10E7E}'\n        | '\\u{10E80}'..='\\u{10EA9}'\n        | '\\u{10EAB}'..='\\u{10EAD}'\n        | '\\u{10EB0}'..='\\u{10EB1}'\n        | '\\u{10EFD}'..='\\u{10F27}'\n        | '\\u{10F30}'..='\\u{10F59}'\n        | '\\u{10F70}'..='\\u{10F89}'\n        | '\\u{10FB0}'..='\\u{10FCB}'\n        | '\\u{10FE0}'..='\\u{10FF6}'\n        | '\\u{11000}'..='\\u{1104D}'\n        | '\\u{11052}'..='\\u{11075}'\n        | '\\u{1107F}'..='\\u{110C2}'\n        | '\\u{110CD}'\n        | '\\u{110D0}'..='\\u{110E8}'\n        | '\\u{110F0}'..='\\u{110F9}'\n        | '\\u{11100}'..='\\u{11134}'\n        | '\\u{11136}'..='\\u{11147}'\n        | '\\u{11150}'..='\\u{11176}'\n        | '\\u{11180}'..='\\u{111DF}'\n        | '\\u{111E1}'..='\\u{111F4}'\n        | '\\u{11200}'..='\\u{11211}'\n        | '\\u{11213}'..='\\u{11241}'\n        | '\\u{11280}'..='\\u{11286}'\n        | '\\u{11288}'\n        | '\\u{1128A}'..='\\u{1128D}'\n        | '\\u{1128F}'..='\\u{1129D}'\n        | '\\u{1129F}'..='\\u{112A9}'\n        | '\\u{112B0}'..='\\u{112EA}'\n        | '\\u{112F0}'..='\\u{112F9}'\n        | '\\u{11300}'..='\\u{11303}'\n        | '\\u{11305}'..='\\u{1130C}'\n        | '\\u{1130F}'..='\\u{11310}'\n        | '\\u{11313}'..='\\u{11328}'\n        | '\\u{1132A}'..='\\u{11330}'\n        | '\\u{11332}'..='\\u{11333}'\n        | '\\u{11335}'..='\\u{11339}'\n        | '\\u{1133B}'..='\\u{11344}'\n        | '\\u{11347}'..='\\u{11348}'\n        | '\\u{1134B}'..='\\u{1134D}'\n        | '\\u{11350}'\n        | '\\u{11357}'\n        | '\\u{1135D}'..='\\u{11363}'\n        | '\\u{11366}'..='\\u{1136C}'\n        | '\\u{11370}'..='\\u{11374}'\n        | '\\u{11400}'..='\\u{1145B}'\n        | '\\u{1145D}'..='\\u{11461}'\n        | '\\u{11480}'..='\\u{114C7}'\n        | '\\u{114D0}'..='\\u{114D9}'\n        | '\\u{11580}'..='\\u{115B5}'\n        | '\\u{115B8}'..='\\u{115DD}'\n        | '\\u{11600}'..='\\u{11644}'\n        | '\\u{11650}'..='\\u{11659}'\n        | '\\u{11660}'..='\\u{1166C}'\n        | '\\u{11680}'..='\\u{116B9}'\n        | '\\u{116C0}'..='\\u{116C9}'\n        | '\\u{11700}'..='\\u{1171A}'\n        | '\\u{1171D}'..='\\u{1172B}'\n        | '\\u{11730}'..='\\u{11746}'\n        | '\\u{11800}'..='\\u{1183B}'\n        | '\\u{118A0}'..='\\u{118F2}'\n        | '\\u{118FF}'..='\\u{11906}'\n        | '\\u{11909}'\n        | '\\u{1190C}'..='\\u{11913}'\n        | '\\u{11915}'..='\\u{11916}'\n        | '\\u{11918}'..='\\u{11935}'\n        | '\\u{11937}'..='\\u{11938}'\n        | '\\u{1193B}'..='\\u{11946}'\n        | '\\u{11950}'..='\\u{11959}'\n        | '\\u{119A0}'..='\\u{119A7}'\n        | '\\u{119AA}'..='\\u{119D7}'\n        | '\\u{119DA}'..='\\u{119E4}'\n        | '\\u{11A00}'..='\\u{11A47}'\n        | '\\u{11A50}'..='\\u{11AA2}'\n        | '\\u{11AB0}'..='\\u{11AF8}'\n        | '\\u{11B00}'..='\\u{11B09}'\n        | '\\u{11C00}'..='\\u{11C08}'\n        | '\\u{11C0A}'..='\\u{11C36}'\n        | '\\u{11C38}'..='\\u{11C45}'\n        | '\\u{11C50}'..='\\u{11C6C}'\n        | '\\u{11C70}'..='\\u{11C8F}'\n        | '\\u{11C92}'..='\\u{11CA7}'\n        | '\\u{11CA9}'..='\\u{11CB6}'\n        | '\\u{11D00}'..='\\u{11D06}'\n        | '\\u{11D08}'..='\\u{11D09}'\n        | '\\u{11D0B}'..='\\u{11D36}'\n        | '\\u{11D3A}'\n        | '\\u{11D3C}'..='\\u{11D3D}'\n        | '\\u{11D3F}'..='\\u{11D47}'\n        | '\\u{11D50}'..='\\u{11D59}'\n        | '\\u{11D60}'..='\\u{11D65}'\n        | '\\u{11D67}'..='\\u{11D68}'\n        | '\\u{11D6A}'..='\\u{11D8E}'\n        | '\\u{11D90}'..='\\u{11D91}'\n        | '\\u{11D93}'..='\\u{11D98}'\n        | '\\u{11DA0}'..='\\u{11DA9}'\n        | '\\u{11EE0}'..='\\u{11EF8}'\n        | '\\u{11F00}'..='\\u{11F10}'\n        | '\\u{11F12}'..='\\u{11F3A}'\n        | '\\u{11F3E}'..='\\u{11F59}'\n        | '\\u{11FB0}'\n        | '\\u{11FC0}'..='\\u{11FF1}'\n        | '\\u{11FFF}'..='\\u{12399}'\n        | '\\u{12400}'..='\\u{1246E}'\n        | '\\u{12470}'..='\\u{12474}'\n        | '\\u{12480}'..='\\u{12543}'\n        | '\\u{12F90}'..='\\u{12FF2}'\n        | '\\u{13000}'..='\\u{13455}'\n        | '\\u{14400}'..='\\u{14646}'\n        | '\\u{16800}'..='\\u{16A38}'\n        | '\\u{16A40}'..='\\u{16A5E}'\n        | '\\u{16A60}'..='\\u{16A69}'\n        | '\\u{16A6E}'..='\\u{16ABE}'\n        | '\\u{16AC0}'..='\\u{16AC9}'\n        | '\\u{16AD0}'..='\\u{16AED}'\n        | '\\u{16AF0}'..='\\u{16AF5}'\n        | '\\u{16B00}'..='\\u{16B45}'\n        | '\\u{16B50}'..='\\u{16B59}'\n        | '\\u{16B5B}'..='\\u{16B61}'\n        | '\\u{16B63}'..='\\u{16B77}'\n        | '\\u{16B7D}'..='\\u{16B8F}'\n        | '\\u{16E40}'..='\\u{16E9A}'\n        | '\\u{16F00}'..='\\u{16F4A}'\n        | '\\u{16F4F}'..='\\u{16F87}'\n        | '\\u{16F8F}'..='\\u{16F9F}'\n        | '\\u{16FE0}'..='\\u{16FE4}'\n        | '\\u{16FF0}'..='\\u{16FF1}'\n        | '\\u{17000}'..='\\u{187F7}'\n        | '\\u{18800}'..='\\u{18CD5}'\n        | '\\u{18D00}'..='\\u{18D08}'\n        | '\\u{1AFF0}'..='\\u{1AFF3}'\n        | '\\u{1AFF5}'..='\\u{1AFFB}'\n        | '\\u{1AFFD}'..='\\u{1AFFE}'\n        | '\\u{1B000}'..='\\u{1B122}'\n        | '\\u{1B132}'\n        | '\\u{1B150}'..='\\u{1B152}'\n        | '\\u{1B155}'\n        | '\\u{1B164}'..='\\u{1B167}'\n        | '\\u{1B170}'..='\\u{1B2FB}'\n        | '\\u{1BC00}'..='\\u{1BC6A}'\n        | '\\u{1BC70}'..='\\u{1BC7C}'\n        | '\\u{1BC80}'..='\\u{1BC88}'\n        | '\\u{1BC90}'..='\\u{1BC99}'\n        | '\\u{1BC9C}'..='\\u{1BCA3}'\n        | '\\u{1CF00}'..='\\u{1CF2D}'\n        | '\\u{1CF30}'..='\\u{1CF46}'\n        | '\\u{1CF50}'..='\\u{1CFC3}'\n        | '\\u{1D000}'..='\\u{1D0F5}'\n        | '\\u{1D100}'..='\\u{1D126}'\n        | '\\u{1D129}'..='\\u{1D1EA}'\n        | '\\u{1D200}'..='\\u{1D245}'\n        | '\\u{1D2C0}'..='\\u{1D2D3}'\n        | '\\u{1D2E0}'..='\\u{1D2F3}'\n        | '\\u{1D300}'..='\\u{1D356}'\n        | '\\u{1D360}'..='\\u{1D378}'\n        | '\\u{1D400}'..='\\u{1D454}'\n        | '\\u{1D456}'..='\\u{1D49C}'\n        | '\\u{1D49E}'..='\\u{1D49F}'\n        | '\\u{1D4A2}'\n        | '\\u{1D4A5}'..='\\u{1D4A6}'\n        | '\\u{1D4A9}'..='\\u{1D4AC}'\n        | '\\u{1D4AE}'..='\\u{1D4B9}'\n        | '\\u{1D4BB}'\n        | '\\u{1D4BD}'..='\\u{1D4C3}'\n        | '\\u{1D4C5}'..='\\u{1D505}'\n        | '\\u{1D507}'..='\\u{1D50A}'\n        | '\\u{1D50D}'..='\\u{1D514}'\n        | '\\u{1D516}'..='\\u{1D51C}'\n        | '\\u{1D51E}'..='\\u{1D539}'\n        | '\\u{1D53B}'..='\\u{1D53E}'\n        | '\\u{1D540}'..='\\u{1D544}'\n        | '\\u{1D546}'\n        | '\\u{1D54A}'..='\\u{1D550}'\n        | '\\u{1D552}'..='\\u{1D6A5}'\n        | '\\u{1D6A8}'..='\\u{1D7CB}'\n        | '\\u{1D7CE}'..='\\u{1DA8B}'\n        | '\\u{1DA9B}'..='\\u{1DA9F}'\n        | '\\u{1DAA1}'..='\\u{1DAAF}'\n        | '\\u{1DF00}'..='\\u{1DF1E}'\n        | '\\u{1DF25}'..='\\u{1DF2A}'\n        | '\\u{1E000}'..='\\u{1E006}'\n        | '\\u{1E008}'..='\\u{1E018}'\n        | '\\u{1E01B}'..='\\u{1E021}'\n        | '\\u{1E023}'..='\\u{1E024}'\n        | '\\u{1E026}'..='\\u{1E02A}'\n        | '\\u{1E030}'..='\\u{1E06D}'\n        | '\\u{1E08F}'\n        | '\\u{1E100}'..='\\u{1E12C}'\n        | '\\u{1E130}'..='\\u{1E13D}'\n        | '\\u{1E140}'..='\\u{1E149}'\n        | '\\u{1E14E}'..='\\u{1E14F}'\n        | '\\u{1E290}'..='\\u{1E2AE}'\n        | '\\u{1E2C0}'..='\\u{1E2F9}'\n        | '\\u{1E2FF}'\n        | '\\u{1E4D0}'..='\\u{1E4F9}'\n        | '\\u{1E7E0}'..='\\u{1E7E6}'\n        | '\\u{1E7E8}'..='\\u{1E7EB}'\n        | '\\u{1E7ED}'..='\\u{1E7EE}'\n        | '\\u{1E7F0}'..='\\u{1E7FE}'\n        | '\\u{1E800}'..='\\u{1E8C4}'\n        | '\\u{1E8C7}'..='\\u{1E8D6}'\n        | '\\u{1E900}'..='\\u{1E94B}'\n        | '\\u{1E950}'..='\\u{1E959}'\n        | '\\u{1E95E}'..='\\u{1E95F}'\n        | '\\u{1EC71}'..='\\u{1ECB4}'\n        | '\\u{1ED01}'..='\\u{1ED3D}'\n        | '\\u{1EE00}'..='\\u{1EE03}'\n        | '\\u{1EE05}'..='\\u{1EE1F}'\n        | '\\u{1EE21}'..='\\u{1EE22}'\n        | '\\u{1EE24}'\n        | '\\u{1EE27}'\n        | '\\u{1EE29}'..='\\u{1EE32}'\n        | '\\u{1EE34}'..='\\u{1EE37}'\n        | '\\u{1EE39}'\n        | '\\u{1EE3B}'\n        | '\\u{1EE42}'\n        | '\\u{1EE47}'\n        | '\\u{1EE49}'\n        | '\\u{1EE4B}'\n        | '\\u{1EE4D}'..='\\u{1EE4F}'\n        | '\\u{1EE51}'..='\\u{1EE52}'\n        | '\\u{1EE54}'\n        | '\\u{1EE57}'\n        | '\\u{1EE59}'\n        | '\\u{1EE5B}'\n        | '\\u{1EE5D}'\n        | '\\u{1EE5F}'\n        | '\\u{1EE61}'..='\\u{1EE62}'\n        | '\\u{1EE64}'\n        | '\\u{1EE67}'..='\\u{1EE6A}'\n        | '\\u{1EE6C}'..='\\u{1EE72}'\n        | '\\u{1EE74}'..='\\u{1EE77}'\n        | '\\u{1EE79}'..='\\u{1EE7C}'\n        | '\\u{1EE7E}'\n        | '\\u{1EE80}'..='\\u{1EE89}'\n        | '\\u{1EE8B}'..='\\u{1EE9B}'\n        | '\\u{1EEA1}'..='\\u{1EEA3}'\n        | '\\u{1EEA5}'..='\\u{1EEA9}'\n        | '\\u{1EEAB}'..='\\u{1EEBB}'\n        | '\\u{1EEF0}'..='\\u{1EEF1}'\n        | '\\u{1F000}'..='\\u{1F02B}'\n        | '\\u{1F030}'..='\\u{1F093}'\n        | '\\u{1F0A0}'..='\\u{1F0AE}'\n        | '\\u{1F0B1}'..='\\u{1F0BF}'\n        | '\\u{1F0C1}'..='\\u{1F0CF}'\n        | '\\u{1F0D1}'..='\\u{1F0F5}'\n        | '\\u{1F100}'..='\\u{1F1AD}'\n        | '\\u{1F1E6}'..='\\u{1F202}'\n        | '\\u{1F210}'..='\\u{1F23B}'\n        | '\\u{1F240}'..='\\u{1F248}'\n        | '\\u{1F250}'..='\\u{1F251}'\n        | '\\u{1F260}'..='\\u{1F265}'\n        | '\\u{1F300}'..='\\u{1F6D7}'\n        | '\\u{1F6DC}'..='\\u{1F6EC}'\n        | '\\u{1F6F0}'..='\\u{1F6FC}'\n        | '\\u{1F700}'..='\\u{1F776}'\n        | '\\u{1F77B}'..='\\u{1F7D9}'\n        | '\\u{1F7E0}'..='\\u{1F7EB}'\n        | '\\u{1F7F0}'\n        | '\\u{1F800}'..='\\u{1F80B}'\n        | '\\u{1F810}'..='\\u{1F847}'\n        | '\\u{1F850}'..='\\u{1F859}'\n        | '\\u{1F860}'..='\\u{1F887}'\n        | '\\u{1F890}'..='\\u{1F8AD}'\n        | '\\u{1F8B0}'..='\\u{1F8B1}'\n        | '\\u{1F900}'..='\\u{1FA53}'\n        | '\\u{1FA60}'..='\\u{1FA6D}'\n        | '\\u{1FA70}'..='\\u{1FA7C}'\n        | '\\u{1FA80}'..='\\u{1FA88}'\n        | '\\u{1FA90}'..='\\u{1FABD}'\n        | '\\u{1FABF}'..='\\u{1FAC5}'\n        | '\\u{1FACE}'..='\\u{1FADB}'\n        | '\\u{1FAE0}'..='\\u{1FAE8}'\n        | '\\u{1FAF0}'..='\\u{1FAF8}'\n        | '\\u{1FB00}'..='\\u{1FB92}'\n        | '\\u{1FB94}'..='\\u{1FBCA}'\n        | '\\u{1FBF0}'..='\\u{1FBF9}'\n        | '\\u{20000}'..='\\u{2A6DF}'\n        | '\\u{2A700}'..='\\u{2B739}'\n        | '\\u{2B740}'..='\\u{2B81D}'\n        | '\\u{2B820}'..='\\u{2CEA1}'\n        | '\\u{2CEB0}'..='\\u{2EBE0}'\n        | '\\u{2F800}'..='\\u{2FA1D}'\n        | '\\u{30000}'..='\\u{3134A}'\n        | '\\u{31350}'..='\\u{323AF}'\n        | '\\u{E0001}'\n        | '\\u{E0020}'..='\\u{E007F}'\n        | '\\u{E0100}'..='\\u{E01EF}'\n        => true,\n        _ => false,\n    }\n}", "test": "fn test_public_assigned() {\n    // Misc assigned.\n    assert!(is_public_assigned('\\0'));\n    assert!(is_public_assigned('a'));\n    assert!(is_public_assigned('\\u{7f}'));\n    assert!(is_public_assigned('\\u{80}'));\n    assert!(!is_public_assigned('\\u{9e4}'));\n\n    // Around the first unassigned non-private-use.\n    assert!(is_public_assigned('\\u{377}'));\n    assert!(!is_public_assigned('\\u{378}'));\n    assert!(!is_public_assigned('\\u{379}'));\n    assert!(is_public_assigned('\\u{37a}'));\n    assert!(is_public_assigned('\\u{37f}'));\n\n    // Around the last assigned non-private-use.\n    assert!(!is_public_assigned('\\u{e00ff}'));\n    assert!(is_public_assigned('\\u{e0100}'));\n    assert!(is_public_assigned('\\u{e01ef}'));\n    assert!(!is_public_assigned('\\u{e01f0}'));\n\n    // Private-Use areas\n    assert!(!is_public_assigned('\\u{e000}'));\n    assert!(!is_public_assigned('\\u{f8ff}'));\n    assert!(!is_public_assigned('\\u{f0000}'));\n    assert!(!is_public_assigned('\\u{ffffd}'));\n    assert!(!is_public_assigned('\\u{100000}'));\n    assert!(!is_public_assigned('\\u{10fffd}'));\n\n    // Noncharacters are considered unassigned.\n    assert!(!is_public_assigned('\\u{fdd0}'));\n    assert!(!is_public_assigned('\\u{fdef}'));\n    assert!(!is_public_assigned('\\u{fffe}'));\n    assert!(!is_public_assigned('\\u{ffff}'));\n    assert!(!is_public_assigned('\\u{1fffe}'));\n    assert!(!is_public_assigned('\\u{1ffff}'));\n    assert!(!is_public_assigned('\\u{2fffe}'));\n    assert!(!is_public_assigned('\\u{2ffff}'));\n    assert!(!is_public_assigned('\\u{3fffe}'));\n    assert!(!is_public_assigned('\\u{3ffff}'));\n    assert!(!is_public_assigned('\\u{4fffe}'));\n    assert!(!is_public_assigned('\\u{4ffff}'));\n    assert!(!is_public_assigned('\\u{5fffe}'));\n    assert!(!is_public_assigned('\\u{5ffff}'));\n    assert!(!is_public_assigned('\\u{6fffe}'));\n    assert!(!is_public_assigned('\\u{6ffff}'));\n    assert!(!is_public_assigned('\\u{7fffe}'));\n    assert!(!is_public_assigned('\\u{7ffff}'));\n    assert!(!is_public_assigned('\\u{8fffe}'));\n    assert!(!is_public_assigned('\\u{8ffff}'));\n    assert!(!is_public_assigned('\\u{9fffe}'));\n    assert!(!is_public_assigned('\\u{9ffff}'));\n    assert!(!is_public_assigned('\\u{afffe}'));\n    assert!(!is_public_assigned('\\u{affff}'));\n    assert!(!is_public_assigned('\\u{bfffe}'));\n    assert!(!is_public_assigned('\\u{bffff}'));\n    assert!(!is_public_assigned('\\u{cfffe}'));\n    assert!(!is_public_assigned('\\u{cffff}'));\n    assert!(!is_public_assigned('\\u{dfffe}'));\n    assert!(!is_public_assigned('\\u{dffff}'));\n    assert!(!is_public_assigned('\\u{efffe}'));\n    assert!(!is_public_assigned('\\u{effff}'));\n    assert!(!is_public_assigned('\\u{ffffe}'));\n    assert!(!is_public_assigned('\\u{fffff}'));\n    assert!(!is_public_assigned('\\u{10fffe}'));\n    assert!(!is_public_assigned('\\u{10ffff}'));\n\n    // Several ranges are defined by \"<..., First>\" and \"<..., Last>\" pairs in\n    // UnicodeData.txt:\n\n    // CJK Ideograph Extension A\n    assert!(is_public_assigned('\\u{3400}'));\n    assert!(is_public_assigned('\\u{4dbf}'));\n\n    // CJK Ideograph\n    assert!(is_public_assigned('\\u{4e00}'));\n    assert!(is_public_assigned('\\u{9ffc}'));\n\n    // Hangul Syllable\n    assert!(is_public_assigned('\\u{ac00}'));\n    assert!(is_public_assigned('\\u{d7a3}'));\n\n    // Tangut Ideograph\n    assert!(is_public_assigned('\\u{17000}'));\n    assert!(is_public_assigned('\\u{187f7}'));\n\n    // Tangut Ideograph Supplement\n    assert!(is_public_assigned('\\u{18d00}'));\n    assert!(is_public_assigned('\\u{18d08}'));\n\n    // CJK Ideograph Extension B\n    assert!(is_public_assigned('\\u{20000}'));\n    assert!(is_public_assigned('\\u{2a6dd}'));\n\n    // CJK Ideograph Extension C\n    assert!(is_public_assigned('\\u{2a700}'));\n    assert!(is_public_assigned('\\u{2b734}'));\n\n    // CJK Ideograph Extension D\n    assert!(is_public_assigned('\\u{2b740}'));\n    assert!(is_public_assigned('\\u{2b81d}'));\n\n    // CJK Ideograph Extension E\n    assert!(is_public_assigned('\\u{2b820}'));\n    assert!(is_public_assigned('\\u{2cea1}'));\n\n    // CJK Ideograph Extension F\n    assert!(is_public_assigned('\\u{2ceb0}'));\n    assert!(is_public_assigned('\\u{2ebe0}'));\n\n    // CJK Ideograph Extension G\n    assert!(is_public_assigned('\\u{30000}'));\n    assert!(is_public_assigned('\\u{3134a}'));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::new_client_returns_initial_io_state", "code": "pub fn plaintext_bytes_to_read(&self) -> usize {\n        self.plaintext_bytes_to_read\n    }", "test": "fn new_client_returns_initial_io_state() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    let io_state = client.process_new_packets().unwrap();\n    println!(\"IoState is Debug {:?}\", io_state);\n    assert_eq!(io_state.plaintext_bytes_to_read(), 0);\n    assert!(!io_state.peer_has_closed());\n    assert!(io_state.tls_bytes_to_write() > 200);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/alias.rs::absolute_path", "code": "pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    }", "test": "fn absolute_path() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        alias: vec![(f.join(\"foo\").to_str().unwrap().to_string(), vec![AliasValue::Ignore])],\n        modules: vec![f.clone().to_str().unwrap().to_string()],\n        ..ResolveOptions::default()\n    });\n    let resolution = resolver.resolve(&f, \"foo/index\");\n    assert_eq!(resolution, Err(ResolveError::Ignored(f.join(\"foo\"))));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_dispatch_change", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_dispatch_change() {\n    use std::{error::Error, result::Result};\n\n    use online_config::ConfigManager;\n\n    #[derive(Clone)]\n    struct CfgManager(Arc<Mutex<RaftstoreConfig>>);\n\n    impl ConfigManager for CfgManager {\n        fn dispatch(&mut self, c: ConfigChange) -> Result<(), Box<dyn Error>> {\n            self.0.lock().unwrap().update(c)\n        }\n    }\n\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n    let mgr = CfgManager(Arc::new(Mutex::new(cfg.raft_store.clone())));\n    cfg_controller.register(Module::Raftstore, Box::new(mgr.clone()));\n\n    cfg_controller\n        .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n        .unwrap();\n\n    // config update\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // config change should also dispatch to raftstore config manager\n    assert_eq!(mgr.0.lock().unwrap().raft_log_gc_threshold, 2000);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_unimplemented_arg", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_unimplemented_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let context_arg = \"--context\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(context_arg)\n        .arg(file)\n        .arg(dir)\n        .fails()\n        .stderr_contains(\"Unimplemented\");\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ls.rs::test_ls_walk_glob", "code": "pub fn stdout_does_not_match(&self, regex: &regex::Regex) -> &Self {\n        assert!(\n            !regex.is_match(self.stdout_str()),\n            \"Stdout matches regex:\\n{}\",\n            self.stdout_str()\n        );\n        self\n    }", "test": "fn test_ls_walk_glob() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(\".test-1\");\n    at.mkdir(\"some-dir\");\n    at.touch(\n        Path::new(\"some-dir\")\n            .join(\"test-2~\")\n            .as_os_str()\n            .to_str()\n            .unwrap(),\n    );\n\n    #[allow(clippy::trivial_regex)]\n    let re_pwd = Regex::new(r\"^\\.\\n\").unwrap();\n\n    scene\n        .ucmd()\n        .arg(\"-1\")\n        .arg(\"--ignore-backups\")\n        .arg(\"some-dir\")\n        .succeeds()\n        .stdout_does_not_contain(\"test-2~\")\n        .stdout_does_not_contain(\"..\")\n        .stdout_does_not_match(&re_pwd);\n}"}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/multiline.rs::read_lines_test", "code": "pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n}", "test": "fn read_lines_test() {\n    let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_identifier", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_identifier() {\n    let between = \"SELECT a AS 3_barrr_asdf FROM db.table_name\";\n    hive().verified_stmt(between);\n}"}
{"test_id": "rust-bitcoin-rust-bitcoin/rust-bitcoin-rust-bitcoin-5ee33ea/bitcoin/tests/serde.rs::serde_regression_absolute_lock_time_time", "code": "pub fn serialize(&self) -> Vec<u8> {\n        let mut buf: Vec<u8> = Vec::new();\n\n        //  <magic>\n        buf.extend_from_slice(b\"psbt\");\n\n        buf.push(0xff_u8);\n\n        buf.extend(self.serialize_map());\n\n        for i in &self.inputs {\n            buf.extend(i.serialize_map());\n        }\n\n        for i in &self.outputs {\n            buf.extend(i.serialize_map());\n        }\n\n        buf\n    }", "test": "fn serde_regression_absolute_lock_time_time() {\n    let seconds: u32 = 1653195600; // May 22nd, 5am UTC.\n    let t = absolute::LockTime::from_time(seconds).expect(\"valid time\");\n    let got = serialize(&t).unwrap();\n\n    let want = include_bytes!(\"data/serde/absolute_lock_time_seconds_bincode\") as &[_];\n    assert_eq!(got, want);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_line_bytes", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nl_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \"\\n\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n\")\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_expand.rs::test_tabs_slash", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_tabs_slash() {\n    new_ucmd!()\n        .args(&[\"--tabs\", \"/\"])\n        .pipe_in(\"a\\tb\\tc\")\n        .succeeds()\n        .stdout_is(\"a       b       c\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_none", "code": "async fn write(\n            &self,\n            name: &str,\n            reader: UnpinReader,\n            content_length: u64,\n        ) -> io::Result<()> {\n            (self.error_on_write)()?;\n            self.inner.write(name, reader, content_length).await\n        }", "test": "fn write_batch_none() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n    wb.write().unwrap();\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    wb.write().unwrap();\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/regression.rs::regression_captures_rep", "code": "pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        let mut locs = self.locations();\n        self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n            text: text,\n            locs: locs,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }", "test": "fn regression_captures_rep() {\n    let re = regex!(r\"([a-f]){2}(?P<foo>[x-z])\");\n    let caps = re.captures(text!(\"abx\")).unwrap();\n    assert_eq!(match_text!(caps.name(\"foo\").unwrap()), text!(\"x\"));\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_11", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_11() {\n    let original = r##\"# H1 {#id1.class1.class2 .class3}\n## H2 {.class1#id2.class2}\n\"##;\n    let expected = r##\"<h1 id=\"id1.class1.class2\" class=\"class3\">H1</h1>\n<h2 class=\"class1#id2.class2\">H2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date6", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_date6() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2000-01-01 00:00\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(946_684_800, 0);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unexpand.rs::unexpand_init_1", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn unexpand_init_1() {\n    new_ucmd!()\n        .args(&[\"-t4\"])\n        .pipe_in(\"     5\\n      6\\n       7\\n        8\\n\")\n        .run()\n        .stdout_is(\"\\t 5\\n\\t  6\\n\\t   7\\n\\t\\t8\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_obsolete_syntax", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_obsolete_syntax() {\n    new_ucmd!()\n        .arg(\"-5\")\n        .arg(\"-s\")\n        .arg(\"space_separated_words.txt\")\n        .succeeds()\n        .stdout_is(\"test1\\n \\ntest2\\n \\ntest3\\n \\ntest4\\n \\ntest5\\n \\ntest6\\n \");\n}"}
{"test_id": "ibraheemdev-matchit/ibraheemdev-matchit-64af4bd/tests/tree.rs::issue_22", "code": "pub fn at<'m, 'p>(&'m self, path: &'p str) -> Result<Match<'m, 'p, &'m T>, MatchError> {\n        match self.root.at(path.as_bytes()) {\n            Ok((value, params)) => Ok(Match {\n                // SAFETY: We only expose &mut T through &mut self\n                value: unsafe { &*value.get() },\n                params,\n            }),\n            Err(e) => Err(e),\n        }\n    }", "test": "fn issue_22() {\n    let mut x = Router::new();\n    x.insert(\"/foo_bar\", \"Welcome!\").unwrap();\n    x.insert(\"/foo/bar\", \"Welcome!\").unwrap();\n    assert_eq!(x.at(\"/foo/\").unwrap_err(), MatchError::NotFound);\n\n    let mut x = Router::new();\n    x.insert(\"/foo\", \"Welcome!\").unwrap();\n    x.insert(\"/foo/bar\", \"Welcome!\").unwrap();\n    assert_eq!(x.at(\"/foo/\").unwrap_err(), MatchError::ExtraTrailingSlash);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    // Split into two files without splitting up lines.\n    ucmd.args(&[\"-n\", \"l/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n2\\n3\\n\");\n    assert_eq!(file_read(\"xab\"), \"4\\n5\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_csplit.rs::test_up_to_match_negative_offset", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_up_to_match_negative_offset() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"numbers50.txt\", \"/9$/-3\"])\n        .succeeds()\n        .stdout_only(\"10\\n131\\n\");\n\n    let count = glob(&at.plus_as_string(\"xx*\"))\n        .expect(\"there should be splits created\")\n        .count();\n    assert_eq!(count, 2);\n    assert_eq!(at.read(\"xx00\"), generate(1, 6));\n    assert_eq!(at.read(\"xx01\"), generate(6, 51));\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/fnmut.rs::parse", "code": "fn parser(i: &[u8]) -> nom::IResult<&[u8], u64> {\n  complete::be_u64(i)\n}", "test": "fn parse() {\n  let mut counter = 0;\n\n  let res = {\n    let mut parser = many0::<_, _, (), _>(|i| {\n      counter += 1;\n      tag(\"abc\")(i)\n    });\n\n    parser(\"abcabcabcabc\").unwrap()\n  };\n\n  println!(\"res: {:?}\", res);\n  assert_eq!(counter, 5);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_iuse_percentage", "code": "fn ceil(x: BigDecimal) -> BigInt {\n    if x.is_integer() {\n        // Unwrapping the Option because it always returns Some\n        x.to_bigint().unwrap()\n    } else {\n        (x + BigDecimal::one().half()).round(0).to_bigint().unwrap()\n    }\n}", "test": "fn test_iuse_percentage() {\n    let output = new_ucmd!()\n        .args(&[\"--total\", \"--output=itotal,iused,ipcent\"])\n        .succeeds()\n        .stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    for line in lines {\n        let mut iter = line.split_whitespace();\n        let reported_inodes = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_iused = iter.next().unwrap().parse::<f64>().unwrap();\n        let reported_percentage = iter.next().unwrap();\n\n        if reported_percentage == \"-\" {\n            assert_eq!(0.0, reported_inodes);\n            assert_eq!(0.0, reported_iused);\n        } else {\n            let reported_percentage = reported_percentage[..reported_percentage.len() - 1]\n                .parse::<u8>()\n                .unwrap();\n            let computed_percentage = (100.0 * (reported_iused / reported_inodes)).ceil() as u8;\n\n            assert_eq!(computed_percentage, reported_percentage);\n        }\n    }\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_array_agg_func", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn parse_array_agg_func() {\n    for sql in [\n        \"SELECT ARRAY_AGG(x ORDER BY x) AS a FROM T\",\n        \"SELECT ARRAY_AGG(x ORDER BY x LIMIT 2) FROM tbl\",\n        \"SELECT ARRAY_AGG(DISTINCT x ORDER BY x LIMIT 2) FROM tbl\",\n    ] {\n        bigquery().verified_stmt(sql);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_timeout.rs::test_command_empty_args", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_command_empty_args() {\n    new_ucmd!()\n        .args(&[\"\", \"\"])\n        .fails()\n        .stderr_contains(\"timeout: empty string\");\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::drain", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next_unsafe()\n            .map(|(key, ptr)| (key, unsafe { &*ptr }))\n    }", "test": "fn drain() {\n    let mut headers = HeaderMap::new();\n\n    // Insert a single value\n    let name: HeaderName = \"hello\".parse().unwrap();\n    headers.insert(name, \"world\".parse().unwrap());\n\n    {\n        let mut iter = headers.drain();\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"hello\");\n\n        assert_eq!(value, \"world\");\n\n        assert!(iter.next().is_none());\n    }\n\n    assert!(headers.is_empty());\n\n    // Insert two sequential values\n    headers.insert(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world\".parse().unwrap(),\n    );\n    headers.insert(\n        \"zomg\".parse::<HeaderName>().unwrap(),\n        \"bar\".parse().unwrap(),\n    );\n    headers.append(\n        \"hello\".parse::<HeaderName>().unwrap(),\n        \"world2\".parse().unwrap(),\n    );\n\n    // Drain...\n    {\n        let mut iter = headers.drain();\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"hello\");\n        assert_eq!(value, \"world\");\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name, None);\n        assert_eq!(value, \"world2\");\n\n        let (name, value) = iter.next().unwrap();\n        assert_eq!(name.unwrap().as_str(), \"zomg\");\n        assert_eq!(value, \"bar\");\n\n        assert!(iter.next().is_none());\n    }\n}"}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes128_encrypted_file", "code": "pub fn name(&self) -> &str {\n        &self.data.file_name\n    }", "test": "fn aes128_encrypted_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n        .by_name_decrypt(\"secret_data_128\", PASSWORD)\n        .expect(\"couldn't find file in archive\")\n        .expect(\"invalid password\");\n    assert_eq!(\"secret_data_128\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"couldn't read encrypted file\");\n    assert_eq!(SECRET_CONTENT, content);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/match_directive.rs::test_match_directive", "code": "pub fn match_directive<'a>(comment: &'a str, directive: &str) -> Option<&'a str> {\n    assert!(\n        directive.ends_with(':'),\n        \"Directive must include trailing colon\"\n    );\n    let text = comment.trim_start_matches(';').trim_start();\n    if text.starts_with(directive) {\n        Some(text[directive.len()..].trim())\n    } else {\n        None\n    }\n}", "test": "fn test_match_directive() {\n    assert_eq!(match_directive(\"; foo: bar  \", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\" foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\"foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\";x foo: bar\", \"foo:\"), None);\n    assert_eq!(match_directive(\";;; foo: bar\", \"foo:\"), Some(\"bar\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_selects_columns", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "test": "fn test_output_selects_columns() {\n    let output = new_ucmd!()\n        .args(&[\"--output=source\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(output.lines().next().unwrap(), \"Filesystem\");\n\n    let output = new_ucmd!()\n        .args(&[\"--output=source,target\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\"]\n    );\n\n    let output = new_ucmd!()\n        .args(&[\"--output=source,target,used\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\", \"Used\"]\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::custom_context", "code": "pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    }", "test": "fn custom_context() {\n    let t_ud = \"unconfined_t\";\n    let u_ud = \"unconfined_u\";\n    let r_ud = \"unconfined_r\";\n\n    new_ucmd!().args(&[\"--compute\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"/bin/false\"];\n    new_ucmd!().args(args).fails().code_is(1);\n\n    let args = &[\"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    new_ucmd!().args(&[\"--range=s0\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"--range=s0\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    for (ctx, u, r) in [\n        (\"unconfined_u:unconfined_r:unconfined_t:s0\", u_ud, r_ud),\n        (\"system_u:unconfined_r:unconfined_t:s0\", \"system_u\", r_ud),\n        (\"unconfined_u:system_r:unconfined_t:s0\", u_ud, \"system_r\"),\n        (\"system_u:system_r:unconfined_t:s0\", \"system_u\", \"system_r\"),\n    ] {\n        let args = &[\"-t\", t_ud, \"-u\", u, \"-r\", r, \"-l\", \"s0\", \"sestatus\", \"-v\"];\n\n        let output = new_ucmd!().args(args).succeeds();\n        assert_eq!(get_sestatus_context(output.stdout()), ctx);\n    }\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_remove", "code": "pub fn remove(&mut self, index: usize) -> A::Item {\n    let targets: &mut [A::Item] = &mut self.deref_mut()[index..];\n    let item = take(&mut targets[0]);\n\n    // A previous implementation used rotate_left\n    // rotate_right and rotate_left generate a huge amount of code and fail to\n    // inline; calling them here incurs the cost of all the cases they\n    // handle even though we're rotating a usually-small array by a constant\n    // 1 offset. This swap-based implementation benchmarks much better for\n    // small array lengths in particular.\n\n    for i in 0..targets.len() - 1 {\n      targets.swap(i, i + 1);\n    }\n    self.len -= 1;\n    item\n  }", "test": "fn ArrayVec_remove() {\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n  assert_eq!(av.remove(1), 2);\n  assert_eq!(&av[..], &[1, 3][..]);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_is_send_and_sync", "code": "pub fn make_pair(kt: KeyType) -> (ClientConnection, ServerConnection) {\n    make_pair_for_configs(make_client_config(kt), make_server_config(kt))\n}", "test": "fn server_is_send_and_sync() {\n    let (_, server) = make_pair(KeyType::Rsa);\n    &server as &dyn Send;\n    &server as &dyn Sync;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_existing", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_numbered_if_existing_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_write_i64", "code": "fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\nwhere\n    T: PartialEq + Debug + ser::Serialize,\n{\n    for &(ref value, out) in errors {\n        let out = out.to_string();\n\n        let s = to_string_pretty(value).unwrap();\n        assert_eq!(s, out);\n\n        let v = to_value(value).unwrap();\n        let s = to_string_pretty(&v).unwrap();\n        assert_eq!(s, out);\n    }\n}", "test": "fn test_write_i64() {\n    let tests = &[\n        (3i64, \"3\"),\n        (-2i64, \"-2\"),\n        (-1234i64, \"-1234\"),\n        (i64::MIN, &i64::MIN.to_string()),\n    ];\n    test_encode_ok(tests);\n    test_pretty_encode_ok(tests);\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::unterminated_string", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn unterminated_string() {\n    assert_err_msg(r#\"{{ \"hey }}\"#, &[\"1:4\", \"expected a value that can be negated\"]);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_unnamed_fields_variant", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "test": "fn enum_unnamed_fields_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::UnnamedFields(\"Hello\".to_string(), \"World\".to_string());\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::test_distribute_by", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn test_distribute_by() {\n    let cluster = \"SELECT a FROM db.table DISTRIBUTE BY a, b\";\n    hive().verified_stmt(cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_fold_at_tab_as_word_boundary", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_fold_at_tab_as_word_boundary() {\n    new_ucmd!()\n        .args(&[\"-w8\", \"-s\"])\n        .pipe_in(\"a\\tbbb\\n\")\n        .succeeds()\n        .stdout_is(\"a\\t\\nbbb\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_replication_mode.rs::test_switching_replication_mode", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_switching_replication_mode() {\n    let mut cluster = prepare_cluster();\n    run_cluster(&mut cluster);\n    let region = cluster.get_region(b\"k1\");\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k2\", b\"v2\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n    must_get_none(&cluster.get_engine(1), b\"k2\");\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 1);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::Async, vec![]);\n    rx.recv_timeout(Duration::from_millis(100)).unwrap();\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 2);\n    assert_eq!(state.state, RegionReplicationState::SimpleMajority);\n\n    cluster\n        .pd_client\n        .switch_replication_mode(DrAutoSyncState::SyncRecover, vec![]);\n    thread::sleep(Duration::from_millis(100));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k3\", b\"v3\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    // sync recover should not block write. ref https://github.com/tikv/tikv/issues/14975.\n    assert_eq!(rx.recv_timeout(Duration::from_millis(100)).is_ok(), true);\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 3);\n    assert_eq!(state.state, RegionReplicationState::SimpleMajority);\n\n    cluster.clear_send_filters();\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n    thread::sleep(Duration::from_millis(100));\n    let state = cluster.pd_client.region_replication_status(region.get_id());\n    assert_eq!(state.state_id, 3);\n    assert_eq!(state.state, RegionReplicationState::IntegrityOverLabel);\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_put_cf_cmd(\"default\", b\"k4\", b\"v4\")],\n        false,\n    );\n    request.mut_header().set_peer(new_peer(1, 1));\n    let (cb, mut rx) = make_cb(&request);\n    cluster\n        .sim\n        .rl()\n        .async_command_on_node(1, request, cb)\n        .unwrap();\n    // already enable group commit.\n    assert_eq!(\n        rx.recv_timeout(Duration::from_millis(100)),\n        Err(future::RecvTimeoutError::Timeout)\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_object", "code": "fn test_parse_ok<T>(tests: Vec<(&str, T)>)\nwhere\n    T: Clone + Debug + PartialEq + ser::Serialize + de::DeserializeOwned,\n{\n    for (s, value) in tests {\n        let v: T = from_str(s).unwrap();\n        assert_eq!(v, value.clone());\n\n        let v: T = from_slice(s.as_bytes()).unwrap();\n        assert_eq!(v, value.clone());\n\n        // Make sure we can deserialize into a `Value`.\n        let json_value: Value = from_str(s).unwrap();\n        assert_eq!(json_value, to_value(&value).unwrap());\n\n        // Make sure we can deserialize from a `&Value`.\n        let v = T::deserialize(&json_value).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can deserialize from a `Value`.\n        let v: T = from_value(json_value.clone()).unwrap();\n        assert_eq!(v, value);\n\n        // Make sure we can round trip back to `Value`.\n        let json_value2: Value = from_value(json_value.clone()).unwrap();\n        assert_eq!(json_value2, json_value);\n\n        // Make sure we can fully ignore.\n        let twoline = s.to_owned() + \"\\n3735928559\";\n        let mut de = Deserializer::from_str(&twoline);\n        IgnoredAny::deserialize(&mut de).unwrap();\n        assert_eq!(0xDEAD_BEEF, u64::deserialize(&mut de).unwrap());\n\n        // Make sure every prefix is an EOF error, except that a prefix of a\n        // number may be a valid number.\n        if !json_value.is_number() {\n            for (i, _) in s.trim_end().char_indices() {\n                assert!(from_str::<Value>(&s[..i]).unwrap_err().is_eof());\n                assert!(from_str::<IgnoredAny>(&s[..i]).unwrap_err().is_eof());\n            }\n        }\n    }\n}", "test": "fn test_parse_object() {\n    test_parse_err::<BTreeMap<String, u32>>(&[\n        (\"{\", \"EOF while parsing an object at line 1 column 1\"),\n        (\"{ \", \"EOF while parsing an object at line 1 column 2\"),\n        (\"{1\", \"key must be a string at line 1 column 2\"),\n        (\"{ \\\"a\\\"\", \"EOF while parsing an object at line 1 column 5\"),\n        (\"{\\\"a\\\"\", \"EOF while parsing an object at line 1 column 4\"),\n        (\"{\\\"a\\\" \", \"EOF while parsing an object at line 1 column 5\"),\n        (\"{\\\"a\\\" 1\", \"expected `:` at line 1 column 6\"),\n        (\"{\\\"a\\\":\", \"EOF while parsing a value at line 1 column 5\"),\n        (\"{\\\"a\\\":1\", \"EOF while parsing an object at line 1 column 6\"),\n        (\"{\\\"a\\\":1 1\", \"expected `,` or `}` at line 1 column 8\"),\n        (\"{\\\"a\\\":1,\", \"EOF while parsing a value at line 1 column 7\"),\n        (\"{}a\", \"trailing characters at line 1 column 3\"),\n    ]);\n\n    test_parse_ok(vec![\n        (\"{}\", treemap!()),\n        (\"{ }\", treemap!()),\n        (\"{\\\"a\\\":3}\", treemap!(\"a\".to_string() => 3u64)),\n        (\"{ \\\"a\\\" : 3 }\", treemap!(\"a\".to_string() => 3)),\n        (\n            \"{\\\"a\\\":3,\\\"b\\\":4}\",\n            treemap!(\"a\".to_string() => 3, \"b\".to_string() => 4),\n        ),\n        (\n            \" { \\\"a\\\" : 3 , \\\"b\\\" : 4 } \",\n            treemap!(\"a\".to_string() => 3, \"b\".to_string() => 4),\n        ),\n    ]);\n\n    test_parse_ok(vec![(\n        \"{\\\"a\\\": {\\\"b\\\": 3, \\\"c\\\": 4}}\",\n        treemap!(\n            \"a\".to_string() => treemap!(\n                \"b\".to_string() => 3u64,\n                \"c\".to_string() => 4,\n            ),\n        ),\n    )]);\n\n    test_parse_ok(vec![(\"{\\\"c\\\":null}\", treemap!('c' => ()))]);\n}"}
{"test_id": "casey-just/casey-just-af55be3/tests/newline_escape.rs::newline_escape_deps_linefeed", "code": "pub(crate) fn run(self) -> Output {\n    if let Some(justfile) = &self.justfile {\n      let justfile = unindent(justfile);\n      fs::write(self.justfile_path(), justfile).unwrap();\n    }\n\n    let stdout = if self.unindent_stdout {\n      unindent(&self.stdout)\n    } else {\n      self.stdout\n    };\n    let stderr = unindent(&self.stderr);\n\n    let mut dotenv_path = self.tempdir.path().to_path_buf();\n    dotenv_path.push(\".env\");\n    fs::write(dotenv_path, \"DOTENV_KEY=dotenv-value\").unwrap();\n\n    let mut command = Command::new(executable_path(\"just\"));\n\n    if self.shell {\n      command.args([\"--shell\", \"bash\"]);\n    }\n\n    let mut child = command\n      .args(self.args)\n      .envs(&self.env)\n      .current_dir(self.tempdir.path().join(self.current_dir))\n      .stdin(Stdio::piped())\n      .stdout(Stdio::piped())\n      .stderr(Stdio::piped())\n      .spawn()\n      .expect(\"just invocation failed\");\n\n    {\n      let mut stdin_handle = child.stdin.take().expect(\"failed to unwrap stdin handle\");\n\n      stdin_handle\n        .write_all(self.stdin.as_bytes())\n        .expect(\"failed to write stdin to just process\");\n    }\n\n    let output = child\n      .wait_with_output()\n      .expect(\"failed to wait for just process\");\n\n    fn compare<T: PartialEq + Debug>(name: &str, have: T, want: T) -> bool {\n      let equal = have == want;\n      if !equal {\n        eprintln!(\"Bad {name}: {}\", Comparison::new(&have, &want));\n      }\n      equal\n    }\n\n    let output_stdout = str::from_utf8(&output.stdout).unwrap();\n    let output_stderr = str::from_utf8(&output.stderr).unwrap();\n\n    if let Some(ref stdout_regex) = self.stdout_regex {\n      if !stdout_regex.is_match(output_stdout) {\n        panic!(\"Stdout regex mismatch:\\n{output_stdout:?}\\n!~=\\n/{stdout_regex:?}/\");\n      }\n    }\n\n    if let Some(ref stderr_regex) = self.stderr_regex {\n      if !stderr_regex.is_match(output_stderr) {\n        panic!(\"Stderr regex mismatch:\\n{output_stderr:?}\\n!~=\\n/{stderr_regex:?}/\");\n      }\n    }\n\n    if !compare(\"status\", output.status.code().unwrap(), self.status)\n      | (self.stdout_regex.is_none() && !compare(\"stdout\", output_stdout, &stdout))\n      | (self.stderr_regex.is_none() && !compare(\"stderr\", output_stderr, &stderr))\n    {\n      panic!(\"Output mismatch.\");\n    }\n\n    if self.test_round_trip && self.status == EXIT_SUCCESS {\n      test_round_trip(self.tempdir.path());\n    }\n\n    Output {\n      tempdir: self.tempdir,\n      stdout: output_stdout.into(),\n    }\n  }", "test": "fn newline_escape_deps_linefeed() {\n  Test::new()\n    .justfile(\n      \"\n        default: a\\\\\\r\n                b\n        a:\n          echo a\n        b:\n          echo b\n      \",\n    )\n    .stdout(\"a\\nb\\n\")\n    .stderr(\"echo a\\necho b\\n\")\n    .run();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_invalid_arg", "code": "pub fn code_is(&self, expected_code: i32) -> &Self {\n        assert_eq!(self.code(), expected_code);\n        self\n    }", "test": "fn test_invalid_arg() {\n    new_ucmd!().arg(\"--definitely-invalid\").fails().code_is(1);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_fold.rs::test_bytewise_should_not_add_newline_when_line_longer_than_fold", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_bytewise_should_not_add_newline_when_line_longer_than_fold() {\n    new_ucmd!()\n        .args(&[\"-w2\", \"-b\"])\n        .pipe_in(\"1234\")\n        .succeeds()\n        .stdout_is(\"12\\n34\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_compact_log.rs::test_node_compact_reserve_max_ticks", "code": "fn test_compact_reserve_max_ticks<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100);\n    cluster.cfg.raft_store.raft_log_gc_threshold = 500;\n    cluster.cfg.raft_store.raft_log_gc_size_limit = Some(ReadableSize::mb(20));\n    cluster.cfg.raft_store.raft_log_reserve_max_ticks = 2;\n    cluster.run();\n    let apply_key = keys::apply_state_key(1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let mut before_states = HashMap::default();\n    for (&id, engines) in &cluster.engines {\n        must_get_equal(&engines.kv, b\"k1\", b\"v1\");\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &apply_key);\n        let state = state.take_truncated_state();\n        // compact should not start\n        assert_eq!(RAFT_INIT_LOG_INDEX, state.get_index());\n        assert_eq!(RAFT_INIT_LOG_TERM, state.get_term());\n        before_states.insert(id, state);\n    }\n\n    for i in 1..60 {\n        let k = i.to_string().into_bytes();\n        let v = k.clone();\n        cluster.must_put(&k, &v);\n    }\n\n    // wait log gc.\n    sleep_ms(500);\n\n    // Should GC even if limit has not reached.\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &apply_key);\n        let after_state = state.take_truncated_state();\n        let before_state = &before_states[&id];\n        assert_ne!(after_state.get_index(), before_state.get_index());\n    }\n}", "test": "fn test_node_compact_reserve_max_ticks() {\n    let count = 5;\n    let mut cluster = new_node_cluster(0, count);\n    test_compact_reserve_max_ticks(&mut cluster);\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_single_quote_attr", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn test_closing_bracket_in_single_quote_attr() {\n    let mut r = Reader::from_str(\"<a attr='>' check='2'></a>\");\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\">\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"2\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dirname.rs::test_path_without_trailing_slashes_and_zero", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_path_without_trailing_slashes_and_zero() {\n    new_ucmd!()\n        .arg(\"-z\")\n        .arg(\"/root/alpha/beta/gamma/delta/epsilon/omega\")\n        .succeeds()\n        .stdout_is(\"/root/alpha/beta/gamma/delta/epsilon\\u{0}\");\n\n    new_ucmd!()\n        .arg(\"--zero\")\n        .arg(\"/root/alpha/beta/gamma/delta/epsilon/omega\")\n        .succeeds()\n        .stdout_is(\"/root/alpha/beta/gamma/delta/epsilon\\u{0}\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_storage.rs::test_isolation_inc", "code": "pub fn join(&self, meta: &SstMeta) -> Result<ImportPath> {\n        let file_name = sst_meta_to_path(meta)?;\n        self.get_import_path(file_name.to_str().unwrap())\n    }", "test": "fn test_isolation_inc() {\n    const THREAD_NUM: usize = 4;\n    const INC_PER_THREAD: usize = 100;\n\n    let store = AssertionStorage::default();\n    let oracle = Arc::new(Oracle::new());\n    let punch_card = Arc::new(Mutex::new(vec![false; THREAD_NUM * INC_PER_THREAD]));\n\n    let mut threads = vec![];\n    for _ in 0..THREAD_NUM {\n        let (punch_card, store, oracle) =\n            (Arc::clone(&punch_card), store.clone(), Arc::clone(&oracle));\n        threads.push(thread::spawn(move || {\n            for _ in 0..INC_PER_THREAD {\n                let number = inc(&store.store, &oracle, b\"key\").unwrap() as usize;\n                let mut punch = punch_card.lock().unwrap();\n                assert_eq!(punch[number], false);\n                punch[number] = true;\n            }\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n    assert_eq!(\n        inc(&store.store, &oracle, b\"key\").unwrap() as usize,\n        THREAD_NUM * INC_PER_THREAD\n    );\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::rename_table", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "test": "fn rename_table() {\n    let rename = \"ALTER TABLE db.table_name RENAME TO db.table_2\";\n    hive().verified_stmt(rename);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_delete_range_twice_1", "code": "fn get_value(&self, key: &[u8]) -> Result<Option<Self::DbVector>> {\n        self.get_value_opt(&ReadOptions::default(), key)\n    }", "test": "fn write_batch_delete_range_twice_1() {\n    let db = default_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"b\", b\"\").unwrap();\n    db.engine.put(b\"c\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n    db.engine.put(b\"e\", b\"\").unwrap();\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        db.engine.put(&x, &x).unwrap();\n    }\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(b\"b\", b\"e\").unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.delete_range(&1_usize.to_be_bytes(), &256_usize.to_be_bytes())\n        .unwrap();\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"c\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"d\").unwrap().is_none());\n    assert!(db.engine.get_value(b\"e\").unwrap().is_some());\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    for i in 1..256_usize {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_no_such_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_no_such_file() {\n    new_ucmd!()\n        .arg(\"invalid_file_txt\")\n        .fails()\n        .stderr_contains(\"No such file or directory\");\n}"}
{"test_id": "image-rs-image/image-rs-image-e5580ec/tests/conversions.rs::test_rgbau8_to_rgbau16", "code": "fn convert(&self) -> ImageBuffer<ToType, Vec<ToType::Subpixel>> {\n        let mut buffer: ImageBuffer<ToType, Vec<ToType::Subpixel>> =\n            ImageBuffer::new(self.width, self.height);\n        for (to, from) in buffer.pixels_mut().zip(self.pixels()) {\n            to.from_color(from)\n        }\n        buffer\n    }", "test": "fn test_rgbau8_to_rgbau16() {\n    let image_u16 = ImageBuffer::from_pixel(\n        2,\n        2,\n        image::Rgba::<u16>([u16::MAX, u16::MAX, u16::MAX, u16::MAX]),\n    );\n\n    let image_u8 = ImageBuffer::from_pixel(\n        2,\n        2,\n        image::Rgba::<u8>([u8::MAX, u8::MAX, u8::MAX, u8::MAX]),\n    );\n    let image_converted: ImageBuffer<Rgba<u16>, _> = image_u8.convert();\n\n    assert_eq!(image_u16, image_converted);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_symlink_non_existing_file", "code": "pub fn stderr_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stderr_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stderr_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_chmod_symlink_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let non_existing = \"test_chmod_symlink_non_existing_file\";\n    let test_symlink = \"test_chmod_symlink_non_existing_file_symlink\";\n    let expected_stdout = &format!(\n        \"failed to change mode of '{test_symlink}' from 0000 (---------) to 1500 (r-x-----T)\"\n    );\n    let expected_stderr = &format!(\"cannot operate on dangling symlink '{test_symlink}'\");\n\n    at.symlink_file(non_existing, test_symlink);\n\n    // this cannot succeed since the symbolic link dangles\n    scene\n        .ucmd()\n        .arg(\"755\")\n        .arg(\"-v\")\n        .arg(test_symlink)\n        .fails()\n        .code_is(1)\n        .stdout_contains(expected_stdout)\n        .stderr_contains(expected_stderr);\n\n    // this should be the same than with just '-v' but without stderr\n    scene\n        .ucmd()\n        .arg(\"755\")\n        .arg(\"-v\")\n        .arg(\"-f\")\n        .arg(test_symlink)\n        .run()\n        .code_is(1)\n        .no_stderr()\n        .stdout_contains(expected_stdout);\n\n    // this should only include  the dangling symlink message\n    // NOT the failure to change mode\n    scene\n        .ucmd()\n        .arg(\"755\")\n        .arg(test_symlink)\n        .run()\n        .code_is(1)\n        .no_stdout()\n        .stderr_contains(expected_stderr);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/suite/heading_attrs.rs::heading_attrs_test_20", "code": "pub fn test_markdown_html(input: &str, output: &str, smart_punct: bool) {\n    let mut s = String::new();\n\n    let mut opts = Options::empty();\n    opts.insert(Options::ENABLE_TABLES);\n    opts.insert(Options::ENABLE_FOOTNOTES);\n    opts.insert(Options::ENABLE_STRIKETHROUGH);\n    opts.insert(Options::ENABLE_TASKLISTS);\n    if smart_punct {\n        opts.insert(Options::ENABLE_SMART_PUNCTUATION);\n    }\n    opts.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n    let p = Parser::new_ext(input, opts);\n    pulldown_cmark::html::push_html(&mut s, p);\n\n    assert_eq!(normalize_html(output), normalize_html(&s));\n}", "test": "fn heading_attrs_test_20() {\n    let original = r##\"# H1 {foo}\n## H2 {#myid unknown this#is.ignored attr=value .myclass}\n\"##;\n    let expected = r##\"<h1>H1</h1>\n<h2 id=\"myid\" class=\"myclass\">H2</h2>\n\"##;\n\n    test_markdown_html(original, expected, false);\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/preorder.rs::function_arguments", "code": "fn trace_preorder_visitation(source: &str) -> String {\n    let tokens = lex(source, Mode::Module);\n    let parsed = parse_tokens(tokens, source, Mode::Module, \"test.py\").unwrap();\n\n    let mut visitor = RecordVisitor::default();\n    visitor.visit_mod(&parsed);\n\n    visitor.output\n}", "test": "fn function_arguments() {\n    let source = r#\"def a(b, c,/, d, e = 20, *args, named=5, other=20, **kwargs): pass\"#;\n\n    let trace = trace_preorder_visitation(source);\n\n    assert_snapshot!(trace);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_is_empty", "code": "pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }", "test": "fn write_batch_is_empty() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert!(wb.is_empty());\n    wb.put(b\"a\", b\"\").unwrap();\n    assert!(!wb.is_empty());\n    wb.write().unwrap();\n    assert!(!wb.is_empty());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    assert!(wb.is_empty());\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    assert!(!wb.is_empty());\n    wb.write().unwrap();\n    assert!(!wb.is_empty());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_three_nodes", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_three_nodes() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store3 = find_peer(&region, 3).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store3.clone());\n\n    cluster.stop_node(2);\n    cluster.stop_node(3);\n\n    // quorum is lost, can't propose command successfully.\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![2, 3]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 2).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    // forbid writes in force leader state\n    let put = new_put_cmd(b\"k3\", b\"v3\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, put);\n    // forbid reads in force leader state\n    let get = new_get_cmd(b\"k1\");\n    must_get_error_recovery_in_progress(&mut cluster, &region, get);\n    // forbid read index in force leader state\n    let read_index = new_read_index_cmd();\n    must_get_error_recovery_in_progress(&mut cluster, &region, read_index);\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/login.rs::login_works", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn login_works() {\n    let wasmer_dir = TempDir::new().unwrap();\n\n    // running test locally: should always pass since\n    // developers don't have access to WAPM_DEV_TOKEN\n    if std::env::var(\"GITHUB_TOKEN\").is_err() {\n        return;\n    }\n    let wapm_dev_token = std::env::var(\"WAPM_DEV_TOKEN\").expect(\"WAPM_DEV_TOKEN env var not set\");\n    // Special case: GitHub secrets aren't visible to outside collaborators\n    if wapm_dev_token.is_empty() {\n        return;\n    }\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"login\")\n        .arg(\"--registry=wasmer.wtf\")\n        .arg(wapm_dev_token)\n        .env(\"WASMER_DIR\", wasmer_dir.path())\n        .assert();\n\n    assert\n        .success()\n        .stdout(contains(r#\"Login for Wasmer user \"ciuser\" saved\"#));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_region_split", "code": "pub fn stop(&mut self) {\n        self.mut_store().cancel_applying_snap();\n        self.pending_reads.clear_all(None);\n    }", "test": "fn test_region_split() {\n    let cluster = new_server_cluster(1, 1);\n    cluster.pd_client.disable_default_operator();\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let region = suite.cluster.get_region(&[]);\n    let mut req = suite.new_changedata_request(region.get_id());\n    let (mut req_tx, event_feed_wrap, receive_event) =\n        new_event_feed(suite.get_region_cdc_client(region.get_id()));\n    block_on(req_tx.send((req.clone(), WriteFlags::default()))).unwrap();\n    // Make sure region 1 is registered.\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        // Even if there is no write,\n        // it should always outputs an Initialized event.\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 1, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n    // Split region.\n    suite.cluster.must_split(&region, b\"k0\");\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Error(err) => {\n            assert!(err.has_epoch_not_match(), \"{:?}\", err);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n    // Try to subscribe region again.\n    let region = suite.cluster.get_region(b\"k0\");\n    // Ensure it is the previous region.\n    assert_eq!(req.get_region_id(), region.get_id());\n    req.set_region_epoch(region.get_region_epoch().clone());\n    block_on(req_tx.send((req.clone(), WriteFlags::default()))).unwrap();\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 1, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    // Try to subscribe region again.\n    let region1 = suite.cluster.get_region(&[]);\n    req.region_id = region1.get_id();\n    req.set_region_epoch(region1.get_region_epoch().clone());\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let mut events = receive_event(false).events.to_vec();\n    assert_eq!(events.len(), 1);\n    match events.pop().unwrap().event.unwrap() {\n        Event_oneof_event::Entries(es) => {\n            assert!(es.entries.len() == 1, \"{:?}\", es);\n            let e = &es.entries[0];\n            assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n        }\n        other => panic!(\"unknown event {:?}\", other),\n    }\n\n    // Make sure resolved ts can be advanced normally.\n    let mut counter = 0;\n    let mut previous_ts = 0;\n    loop {\n        // Even if there is no write,\n        // resolved ts should be advanced regularly.\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            assert!(resolved_ts.ts >= previous_ts);\n            assert!(\n                resolved_ts.regions == vec![region.id, region1.id]\n                    || resolved_ts.regions == vec![region1.id, region.id]\n            );\n            previous_ts = resolved_ts.ts;\n            counter += 1;\n        }\n        if counter > 5 {\n            break;\n        }\n    }\n\n    event_feed_wrap.replace(None);\n    suite.stop();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/threads.rs::test_multi_memory", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "test": "fn test_multi_memory() -> Result<()> {\n    let wat = r#\"(module\n        (import \"env\" \"imported\" (memory $imported 5 10 shared))\n        (memory (export \"owned\") 10 20)\n        (memory (export \"shared\") 1 2 shared)\n        (export \"imported\" (memory $imported))\n    )\"#;\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    config.wasm_multi_memory(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let incoming_shared_memory = SharedMemory::new(&engine, MemoryType::shared(5, 10))?;\n    let instance = Instance::new(&mut store, &module, &[incoming_shared_memory.into()])?;\n    let owned_memory = instance.get_memory(&mut store, \"owned\").unwrap();\n    let shared_memory = instance.get_shared_memory(&mut store, \"shared\").unwrap();\n    let imported_memory = instance.get_shared_memory(&mut store, \"imported\").unwrap();\n\n    assert_eq!(owned_memory.size(&store), 10);\n    assert_eq!(owned_memory.ty(&store).minimum(), 10);\n    assert_eq!(owned_memory.ty(&store).maximum(), Some(20));\n    assert_eq!(owned_memory.ty(&store).is_shared(), false);\n    assert_eq!(shared_memory.size(), 1);\n    assert_eq!(shared_memory.ty().minimum(), 1);\n    assert_eq!(shared_memory.ty().maximum(), Some(2));\n    assert_eq!(shared_memory.ty().is_shared(), true);\n    assert_eq!(imported_memory.size(), 5);\n    assert_eq!(imported_memory.ty().minimum(), 5);\n    assert_eq!(imported_memory.ty().maximum(), Some(10));\n    assert_eq!(imported_memory.ty().is_shared(), true);\n\n    Ok(())\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_even_if_resolver_fails", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "test": "fn server_exposes_offered_sni_even_if_resolver_fails() {\n    let kt = KeyType::Rsa;\n    let resolver = rustls::server::ResolvesServerCertUsingSni::new();\n\n    let mut server_config = make_server_config(kt);\n    server_config.cert_resolver = Arc::new(resolver);\n    let server_config = Arc::new(server_config);\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"thisdoesNOTexist.com\"))\n                .unwrap();\n\n        assert_eq!(None, server.server_name());\n        transfer(&mut client, &mut server);\n        assert_eq!(\n            server.process_new_packets(),\n            Err(Error::General(\n                \"no server certificate chain resolved\".to_string()\n            ))\n        );\n        assert_eq!(Some(\"thisdoesnotexist.com\"), server.server_name());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_owner", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_only_owner() {\n    // test chown username file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    // since only superuser can change owner, we have to change from ourself to ourself\n    let result = scene\n        .ucmd()\n        .arg(user_name)\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    result.stderr_contains(\"retained as\");\n\n    // try to change to another existing user, e.g. 'root'\n    scene\n        .ucmd()\n        .arg(\"root\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_multi.rs::test_server_leader_change_with_uncommitted_log", "code": "fn test_leader_change_with_uncommitted_log<T: Simulator>(cluster: &mut Cluster<T>) {\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 50;\n    // disable compact log to make test more stable.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 1000;\n    // We use three peers([1, 2, 3]) for this test.\n    cluster.run();\n\n    sleep_ms(500);\n\n    // guarantee peer 1 is leader\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // So peer 3 won't replicate any message of the region but still can vote.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 3).msg_type(MessageType::MsgAppend),\n    ));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // peer 1 and peer 2 must have k2, but peer 3 must not.\n    for i in 1..3 {\n        let engine = cluster.get_engine(i);\n        must_get_equal(&engine, b\"k1\", b\"v1\");\n    }\n\n    let engine3 = cluster.get_engine(3);\n    must_get_none(&engine3, b\"k1\");\n\n    // now only peer 1 and peer 2 can step to leader.\n\n    // hack: first MsgAppend will append log, second MsgAppend will set commit\n    // index, So only allowing first MsgAppend to make peer 2 have uncommitted\n    // entries.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv)\n            .allow(1),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it becomes leader.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgHeartbeatResponse)\n            .direction(Direction::Send),\n    ));\n    // Make peer 2's msg won't be replicated when it becomes leader,\n    // so the uncommitted entries won't be applied immediately.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 1)\n            .msg_type(MessageType::MsgAppend)\n            .direction(Direction::Recv),\n    ));\n    // Make peer 2 have no way to know the uncommitted entries can be applied\n    // when it's still follower.\n    cluster.add_send_filter(CloneFilterFactory(\n        RegionPacketFilter::new(1, 2)\n            .msg_type(MessageType::MsgHeartbeat)\n            .direction(Direction::Recv),\n    ));\n    debug!(\"putting k2\");\n    cluster.must_put(b\"k2\", b\"v2\");\n\n    // peer 1 must have committed, but peer 2 has not.\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n\n    must_get_none(&cluster.get_engine(2), b\"k2\");\n\n    let region = cluster.get_region(b\"\");\n    let reqs = vec![new_put_cmd(b\"k3\", b\"v3\")];\n    let mut put = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        reqs,\n        false,\n    );\n    debug!(\"requesting: {:?}\", put);\n    put.mut_header().set_peer(new_peer(2, 2));\n    cluster.clear_send_filters();\n    let resp = cluster.call_command(put, Duration::from_secs(5)).unwrap();\n    assert!(!resp.get_header().has_error(), \"{:?}\", resp);\n\n    for i in 1..4 {\n        must_get_equal(&cluster.get_engine(i), b\"k2\", b\"v2\");\n        must_get_equal(&cluster.get_engine(i), b\"k3\", b\"v3\");\n    }\n}", "test": "fn test_server_leader_change_with_uncommitted_log() {\n    let mut cluster = new_server_cluster(0, 3);\n    test_leader_change_with_uncommitted_log(&mut cluster);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_false.rs::test_help", "code": "pub fn stdout_contains<T: AsRef<str>>(&self, cmp: T) -> &Self {\n        assert!(\n            self.stdout_str().contains(cmp.as_ref()),\n            \"'{}' does not contain '{}'\",\n            self.stdout_str(),\n            cmp.as_ref()\n        );\n        self\n    }", "test": "fn test_help() {\n    new_ucmd!()\n        .args(&[\"--help\"])\n        .fails()\n        .stdout_contains(\"false\");\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::wasi_runner_on_disk_mount_using_relative_directory_on_the_host", "code": "pub(crate) fn stdout(\n        fd_map: &RwLock<HashMap<u32, Fd>>,\n    ) -> Result<InodeValFileReadGuard, FsError> {\n        Self::std_dev_get(fd_map, __WASI_STDOUT_FILENO)\n    }", "test": "fn wasi_runner_on_disk_mount_using_relative_directory_on_the_host() {\n    let temp = TempDir::new_in(env!(\"CARGO_TARGET_TMPDIR\")).unwrap();\n    std::fs::write(temp.path().join(\"main.py\"), \"print('Hello, World!')\").unwrap();\n\n    let assert = Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(fixtures::python())\n        .arg(\"--mapdir=/app:.\")\n        .arg(\"--\")\n        .arg(\"/app/main.py\")\n        .env(\"RUST_LOG\", &*RUST_LOG)\n        .current_dir(temp.path())\n        .assert();\n\n    assert.success().stdout(contains(\"Hello, World!\"));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw \"error\";\n            } catch {\n                a = 20;\n            }\n\n            a;\n        \"#},\n        20,\n    )]);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::subquery_nested", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn subquery_nested() {\n    let needle = \"{int $i = _($i+_($i)); _($i)=10;}\";\n    let source = \"void b(){int bar = 100*17-f(bar+x(bar)); bar = 10;}\";\n\n    let matches = parse_and_match(needle, source);\n\n    assert_eq!(matches, 1);\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/regression.rs::invalid_regexes_no_crash", "code": "pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    }", "test": "fn invalid_regexes_no_crash() {\n    assert!(regex_new!(\"(*)\").is_err());\n    assert!(regex_new!(\"(?:?)\").is_err());\n    assert!(regex_new!(\"(?)\").is_err());\n    assert!(regex_new!(\"*\").is_err());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_nice.rs::test_command_with_args", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_command_with_args() {\n    new_ucmd!()\n        .args(&[\"-n\", \"19\", \"echo\", \"a\", \"b\", \"c\"])\n        .run()\n        .stdout_is(\"a b c\\n\");\n}"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_role", "code": "pub fn assert_eq_vec<T: ToString>(expected: &[&str], actual: &[T]) {\n    assert_eq!(\n        expected,\n        actual.iter().map(ToString::to_string).collect::<Vec<_>>()\n    );\n}", "test": "fn parse_drop_role() {\n    let sql = \"DROP ROLE abc\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names,\n            object_type,\n            if_exists,\n            ..\n        } => {\n            assert_eq_vec(&[\"abc\"], &names);\n            assert_eq!(ObjectType::Role, object_type);\n            assert!(!if_exists);\n        }\n        _ => unreachable!(),\n    };\n\n    let sql = \"DROP ROLE IF EXISTS def, magician, quaternion\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names,\n            object_type,\n            if_exists,\n            ..\n        } => {\n            assert_eq_vec(&[\"def\", \"magician\", \"quaternion\"], &names);\n            assert_eq!(ObjectType::Role, object_type);\n            assert!(if_exists);\n        }\n        _ => unreachable!(),\n    }\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/num.rs::as_primitive_test", "code": "fn check_as_primitive<T: AsPrimitive>(t: T) {\n    let _: u32 = t.as_u32();\n    let _: u64 = t.as_u64();\n    let _: u128 = t.as_u128();\n    let _: usize = t.as_usize();\n    let _: f32 = t.as_f32();\n    let _: f64 = t.as_f64();\n}", "test": "fn as_primitive_test() {\n    check_as_primitive(1u32);\n    check_as_primitive(1u64);\n    check_as_primitive(1u128);\n    check_as_primitive(1usize);\n    check_as_primitive(1f32);\n    check_as_primitive(1f64);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_never", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=never\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/errors.rs::invalid_test_argument", "code": "fn assert_err_msg(input: &str, needles: &[&str]) {\n    let res = parse(input);\n    assert!(res.is_err());\n    let err = res.unwrap_err();\n    let err_msg = err.to_string();\n    println!(\"{}\", err_msg);\n    println!(\"Looking for:\");\n    for needle in needles {\n        println!(\"{}\", needle);\n        assert!(err_msg.contains(needle));\n    }\n}", "test": "fn invalid_test_argument() {\n    assert_err_msg(\n        r#\"{% if a is odd(key=1) %}\"#,\n        &[\n            \"1:19\",\n            \"expected `or`, `and`, `not`, `<=`, `>=`, `<`, `>`, `==`, `!=`, `+`, `-`, `*`, `/`, `%`, or a filter\"\n        ],\n    );\n}"}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/aes_encryption.rs::aes256_encrypted_file", "code": "pub fn name(&self) -> &str {\n        &self.data.file_name\n    }", "test": "fn aes256_encrypted_file() {\n    let mut v = Vec::new();\n    v.extend_from_slice(include_bytes!(\"data/aes_archive.zip\"));\n    let mut archive = ZipArchive::new(io::Cursor::new(v)).expect(\"couldn't open test zip file\");\n\n    let mut file = archive\n        .by_name_decrypt(\"secret_data_256\", PASSWORD)\n        .expect(\"couldn't find file in archive\")\n        .expect(\"invalid password\");\n    assert_eq!(\"secret_data_256\", file.name());\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"couldn't read encrypted and compressed file\");\n    assert_eq!(SECRET_CONTENT, content);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_prevote.rs::test_prevote_partition_leader_in_minority_detect_in_majority", "code": "fn test_prevote<T: Simulator>(\n    cluster: &mut Cluster<T>,\n    failure_type: FailureType<'_>,\n    leader_after_failure_id: impl Into<Option<u64>>,\n    detect_during_failure: impl Into<Option<(u64, bool)>>,\n    detect_during_recovery: impl Into<Option<(u64, bool)>>,\n) {\n    cluster.cfg.raft_store.prevote = true;\n    // Disable this feature because the test could run slow, in which case peers\n    // shouldn't hibernate, otherwise it's possible to detect no vote messages.\n    cluster.cfg.raft_store.hibernate_regions = false;\n    // To stable the test, we use a large election timeout to make\n    // leader's readiness get handle within an election timeout\n    configure_for_lease_read(&mut cluster.cfg, Some(20), Some(10));\n\n    let leader_id = 1;\n    let detect_during_failure = detect_during_failure.into();\n    let detect_during_recovery = detect_during_recovery.into();\n\n    // We must start the cluster before adding send filters, otherwise it panics.\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    // Determine how to fail.\n    let rx = if let Some((id, _)) = detect_during_failure {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached failure prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    match failure_type {\n        FailureType::Partition(majority, minority) => {\n            cluster.partition(majority.to_vec(), minority.to_vec());\n        }\n        FailureType::Reboot(peers) => {\n            peers.iter().for_each(|&peer| cluster.stop_node(peer));\n        }\n    };\n\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        // Once we see a response on the wire we know a prevote round is happening.\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with failure prevote notifier, got {:?}\", received);\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during failure.\",\n        );\n    }\n\n    // Let the cluster recover.\n    match failure_type {\n        FailureType::Partition(..) => {\n            cluster.clear_send_filters();\n        }\n        FailureType::Reboot(peers) => {\n            cluster.clear_send_filters();\n            peers.iter().for_each(|&peer| {\n                cluster.run_node(peer).unwrap();\n            });\n        }\n    };\n\n    // Prepare to listen.\n    let rx = if let Some((id, _)) = detect_during_recovery {\n        let rx = attach_prevote_notifiers(cluster, id);\n        debug!(\"Attached recovery prevote notifier.\");\n        Some(rx)\n    } else {\n        None\n    };\n\n    if let Some(leader_id) = leader_after_failure_id.into() {\n        cluster.must_transfer_leader(1, new_peer(leader_id, 1));\n    };\n\n    // Once we see a response on the wire we know a prevote round is happening.\n    if let (Some(rx), Some((_, should_detect))) = (rx, detect_during_failure) {\n        let received = rx.recv_timeout(Duration::from_secs(5));\n        debug!(\"Done with recovery prevote notifier, got {:?}\", received);\n\n        assert_eq!(\n            received.is_ok(),\n            should_detect,\n            \"Sends a PreVote or PreVoteResponse during recovery.\",\n        );\n    };\n\n    cluster.must_put(b\"k3\", b\"v3\");\n    assert_eq!(cluster.must_get(b\"k1\"), Some(b\"v1\".to_vec()));\n}", "test": "fn test_prevote_partition_leader_in_minority_detect_in_majority() {\n    let mut cluster = new_node_cluster(0, 5);\n    // The follower is in the minority and is part of a prevote process. On rejoin\n    // it adopts the old leader.\n    test_prevote(\n        &mut cluster,\n        FailureType::Partition(&[1, 2], &[3, 4, 5]),\n        None,\n        (4, true),\n        None,\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_raftkv.rs::test_read_on_replica", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_read_on_replica() {\n    let count = 3;\n    let mut cluster = new_server_cluster(0, count);\n    cluster.cfg.raft_store.hibernate_regions = false;\n    cluster.run();\n\n    let k1 = b\"k1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n    let (k3, v3) = (b\"k3\", b\"v3\");\n    let (k4, v4) = (b\"k4\", b\"v4\");\n\n    // make sure leader has been elected.\n    assert_eq!(cluster.must_get(k1), None);\n\n    let region = cluster.get_region(b\"\");\n    let leader = cluster.leader_of_region(region.get_id()).unwrap();\n    let mut leader_storage = cluster.sim.rl().storages[&leader.get_id()].clone();\n\n    let mut leader_ctx = Context::default();\n    leader_ctx.set_region_id(region.get_id());\n    leader_ctx.set_region_epoch(region.get_region_epoch().clone());\n    leader_ctx.set_peer(leader.clone());\n    let leader_snap_ctx = SnapContext {\n        pb_ctx: &leader_ctx,\n        ..Default::default()\n    };\n\n    // write some data\n    let peers = region.get_peers();\n    assert_none(leader_snap_ctx, &mut leader_storage, k2);\n    must_put(&leader_ctx, &leader_storage, k2, v2);\n\n    // read on follower\n    let mut follower_peer = None;\n    let mut follower_id = 0;\n    for p in peers {\n        if p.get_id() != leader.get_id() {\n            follower_id = p.get_id();\n            follower_peer = Some(p.clone());\n            break;\n        }\n    }\n\n    assert!(follower_peer.is_some());\n    let mut follower_ctx = Context::default();\n    follower_ctx.set_region_id(region.get_id());\n    follower_ctx.set_region_epoch(region.get_region_epoch().clone());\n    follower_ctx.set_peer(follower_peer.as_ref().unwrap().clone());\n    follower_ctx.set_replica_read(true);\n    let follower_snap_ctx = SnapContext {\n        pb_ctx: &follower_ctx,\n        ..Default::default()\n    };\n    let mut follower_storage = cluster.sim.rl().storages[&follower_id].clone();\n    assert_has(follower_snap_ctx.clone(), &mut follower_storage, k2, v2);\n\n    must_put(&leader_ctx, &leader_storage, k3, v3);\n    assert_has(follower_snap_ctx.clone(), &mut follower_storage, k3, v3);\n\n    cluster.stop_node(follower_id);\n    must_put(&leader_ctx, &leader_storage, k4, v4);\n    cluster.run_node(follower_id).unwrap();\n    let mut follower_storage = cluster.sim.rl().storages[&follower_id].clone();\n    // sleep to ensure the follower has received a heartbeat from the leader\n    thread::sleep(time::Duration::from_millis(300));\n    assert_has(follower_snap_ctx, &mut follower_storage, k4, v4);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_invalid_threshold", "code": "pub fn fails(&mut self) -> CmdResult {\n        let cmd_result = self.run();\n        cmd_result.failure();\n        cmd_result\n    }", "test": "fn test_du_invalid_threshold() {\n    let ts = TestScenario::new(util_name!());\n\n    let threshold = \"-0\";\n\n    ts.ucmd().arg(format!(\"--threshold={threshold}\")).fails();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_transaction.rs::test_txn_failpoints", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_txn_failpoints() {\n    let mut engine = TestEngineBuilder::new().build().unwrap();\n    let (k, v) = (b\"k\", b\"v\");\n    fail::cfg(\"prewrite\", \"return(WriteConflict)\").unwrap();\n    must_prewrite_put_err(&mut engine, k, v, k, 10);\n    fail::remove(\"prewrite\");\n    must_prewrite_put(&mut engine, k, v, k, 10);\n    fail::cfg(\"commit\", \"delay(100)\").unwrap();\n    must_commit(&mut engine, k, 10, 20);\n    fail::remove(\"commit\");\n\n    let v1 = b\"v1\";\n    let (k2, v2) = (b\"k2\", b\"v2\");\n    must_acquire_pessimistic_lock(&mut engine, k, k, 30, 30);\n    fail::cfg(\"pessimistic_prewrite\", \"return()\").unwrap();\n    must_pessimistic_prewrite_put_err(&mut engine, k, v1, k, 30, 30, DoPessimisticCheck);\n    must_prewrite_put(&mut engine, k2, v2, k2, 31);\n    fail::remove(\"pessimistic_prewrite\");\n    must_pessimistic_prewrite_put(&mut engine, k, v1, k, 30, 30, DoPessimisticCheck);\n    must_commit(&mut engine, k, 30, 40);\n    must_commit(&mut engine, k2, 31, 41);\n    must_get(&mut engine, k, 50, v1);\n    must_get(&mut engine, k2, 50, v2);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_kv_service.rs::test_batch_get_memory_lock", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_batch_get_memory_lock() {\n    let (_cluster, client, ctx) = must_new_cluster_and_kv_client();\n\n    let mut req = BatchGetRequest::default();\n    req.set_context(ctx);\n    req.set_keys(vec![b\"a\".to_vec(), b\"b\".to_vec()].into());\n    req.version = 50;\n\n    fail::cfg(\"raftkv_async_snapshot_err\", \"return\").unwrap();\n    let resp = client.kv_batch_get(&req).unwrap();\n    // the injected error should be returned at both places for backward\n    // compatibility.\n    assert!(!resp.pairs[0].get_error().get_abort().is_empty());\n    assert!(!resp.get_error().get_abort().is_empty());\n    fail::remove(\"raftkv_async_snapshot_err\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/fuel_consumption_mode.rs::eager_consumption_mode", "code": "fn check_consumption_mode(mode: FuelConsumptionMode, given_fuel: u64, consumed_fuel: u64) {\n    assert!(given_fuel >= consumed_fuel);\n    let wasm = wat2wasm(test_module());\n    let (mut store, func) = default_test_setup(mode, &wasm);\n    let func = func.typed::<(), i32>(&store).unwrap();\n    // Now add enough fuel, so execution should succeed.\n    store.add_fuel(given_fuel).unwrap(); // this is just enough fuel for a successful `memory.grow`\n    assert_success(func.call(&mut store, ()));\n    assert_eq!(store.fuel_consumed(), Some(consumed_fuel));\n}", "test": "fn eager_consumption_mode() {\n    check_consumption_mode(FuelConsumptionMode::Eager, 1030, 1028);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_1", "code": "fn remove_all_values<K>(headers: &mut HeaderMap, key: K) -> Vec<HeaderValue>\n    where K: IntoHeaderName\n{\n    match headers.entry(key) {\n        Entry::Occupied(e) => e.remove_entry_mult().1.collect(),\n        Entry::Vacant(_) => vec![],\n    }\n}", "test": "fn remove_entry_multi_1() {\n    let mut headers = HeaderMap::new();\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 1);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/esbuild/mod.rs::class", "code": "fn test(args: &[&str]) -> LintResult {\n        let mut new_args = vec![\"--quiet\"];\n        new_args.extend(args);\n        let options = lint_command().run_inner(new_args.as_slice()).unwrap().lint_options;\n        let CliRunResult::LintResult(lint_result) = LintRunner::new(options).run() else {\n            unreachable!()\n        };\n        lint_result\n    }", "test": "fn class() {\n    test(\"class Foo extends (a, b) {}\", \"class Foo extends (a,b){}\");\n    test(\"class Foo { get foo() {} }\", \"class Foo{get foo(){}}\");\n    test(\"class Foo { set foo(x) {} }\", \"class Foo{set foo(x){}}\");\n    test(\"class Foo { static foo() {} }\", \"class Foo{static foo(){}}\");\n    test(\"class Foo { static get foo() {} }\", \"class Foo{static get foo(){}}\");\n    test(\"class Foo { static set foo(x) {} }\", \"class Foo{static set foo(x){}}\");\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_add3_works", "code": "pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    }", "test": "fn static_add3_works() {\n    let (mut store, add3, add3_dyn) = setup_add3();\n    let add3 = add3.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    let add3_dyn = add3_dyn.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    for a in 0..5 {\n        for b in 0..5 {\n            for c in 0..5 {\n                let expected = a + b + c;\n                assert_eq!(add3.call(&mut store, (a, b, c)).unwrap(), expected);\n                assert_eq!(add3_dyn.call(&mut store, (a, b, c)).unwrap(), expected);\n            }\n        }\n    }\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/tests/control_flow/mod.rs::catch_binding_pattern_array", "code": "pub(crate) fn run_test_actions(actions: impl IntoIterator<Item = TestAction>) {\n        let context = &mut Context::default();\n        run_test_actions_with(actions, context);\n    }", "test": "fn catch_binding_pattern_array() {\n    run_test_actions([TestAction::assert_eq(\n        indoc! {r#\"\n            let a = 10;\n            try {\n                throw [20, 30];\n            } catch ([, n]) {\n                a = n;\n            }\n\n            a;\n        \"#},\n        30,\n    )]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_ymdhm_time", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_ymdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_ymdhm_time\";\n\n    ucmd.args(&[\"-t\", \"1501011234\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_with_group", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_target_new_file_with_group() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n    let gid = getegid();\n\n    at.touch(file);\n    at.mkdir(dir);\n    let result = ucmd\n        .arg(file)\n        .arg(\"--group\")\n        .arg(gid.to_string())\n        .arg(format!(\"{dir}/{file}\"))\n        .run();\n\n    if is_ci() && result.stderr_str().contains(\"no such group:\") {\n        // In the CI, some server are failing to return the group.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_string_handling", "code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }", "test": "fn test_relative_string_handling() {\n    let result = new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefix\", \"prefixed/1\"])\n        .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefixed/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefixed\\\\1\\n\");\n\n    let result = new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefixed\", \"prefix/1\"])\n        .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefix/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefix\\\\1\\n\");\n\n    new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefixed\", \"prefixed/1\"])\n        .succeeds()\n        .stdout_is(\"1\\n\");\n}"}
