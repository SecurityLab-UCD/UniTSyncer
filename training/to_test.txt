{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_realpath.rs::test_relative_string_handling", 
"code": "pub fn stdout_is<T: AsRef<str>>(&self, msg: T) -> &Self {\n        assert_eq!(self.stdout_str(), String::from(msg.as_ref()));\n        self\n    }",
 "test": "fn test_relative_string_handling() {\n    let result = new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefix\", \"prefixed/1\"])\n        .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefixed/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefixed\\\\1\\n\");\n\n    let result = new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefixed\", \"prefix/1\"])\n        .succeeds();\n    #[cfg(not(windows))]\n    result.stdout_is(\"../prefix/1\\n\");\n    #[cfg(windows)]\n    result.stdout_is(\"..\\\\prefix\\\\1\\n\");\n\n    new_ucmd!()\n        .args(&[\"-m\", \"--relative-to=prefixed\", \"prefixed/1\"])\n        .succeeds()\n        .stdout_is(\"1\\n\");\n}"}


{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/multiline.rs::read_lines_test", 
"code": "pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n}", 
"test": "fn read_lines_test() {\n    let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}"}
pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n}", "test": "fn read_lines_test() {\n    let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}
["pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n}_"]}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::chars", "test": ["pub fn call(&self, arguments: &[DataValue]) -> Vec<DataValue> {\n        let mut values = UnboxedValues::make_arguments(arguments, &self.func_signature);\n        let arguments_address = values.as_mut_ptr();\n\n        let function_ptr = self.module.get_finalized_function(self.func_id);\n        let trampoline_ptr = self.module.get_finalized_function(self.trampoline_id);\n\n        let callable_trampoline: fn(*const u8, *mut u128) -> () =\n            unsafe { mem::transmute(trampoline_ptr) };\n        callable_trampoline(function_ptr, arguments_address);\n\n        values.collect_returns(&self.func_signature)\n    }_"



{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_lifetime", 
"code": "fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n                            fixed_key_size,\n                            fixed_value_size,\n                        );\n                        let entry = if reverse {\n                            child_accessor.num_pairs() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Leaf {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            entry,\n                            parent,\n                        }))\n                    }\n                    BRANCH => {\n                        let child_accessor = BranchAccessor::new(&child_page, fixed_key_size);\n                        let child = if reverse {\n                            child_accessor.count_children() - 1\n                        } else {\n                            0\n                        };\n                        Ok(Some(Internal {\n                            page: child_page,\n                            fixed_key_size,\n                            fixed_value_size,\n                            child,\n                            parent,\n                        }))\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n    }", 
"test": "fn range_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.range::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(\n        iter.next()\n            .unwrap()\n            .unwrap()\n            .1\n            .next()\n            .unwrap()\n            .unwrap()\n            .value(),\n        \"world\"\n    );\n    assert!(iter.next().is_none());\n}"}

{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_lifetime", 
"test": ["fn next(\n        self,\n        reverse: bool,\n        manager: &'a TransactionalMemory,\n    ) -> Result<Option<RangeIterState>> {\n        match self {\n            Leaf {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                entry,\n                parent,\n            } => {\n                let accessor = LeafAccessor::new(page.memory(), fixed_key_size, fixed_value_size);\n                let direction = if reverse { -1 } else { 1 };\n                let next_entry = isize::try_from(entry).unwrap() + direction;\n                if 0 <= next_entry && next_entry < accessor.num_pairs().try_into().unwrap() {\n                    Ok(Some(Leaf {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        entry: next_entry.try_into().unwrap(),\n                        parent,\n                    }))\n                } else {\n                    Ok(parent.map(|x| *x))\n                }\n            }\n            Internal {\n                page,\n                fixed_key_size,\n                fixed_value_size,\n                child,\n                mut parent,\n            } => {\n                let accessor = BranchAccessor::new(&page, fixed_key_size);\n                let child_page = accessor.child_page(child).unwrap();\n                let child_page = manager.get_page(child_page)?;\n                let direction = if reverse { -1 } else { 1 };\n                let next_child = isize::try_from(child).unwrap() + direction;\n                if 0 <= next_child && next_child < accessor.count_children().try_into().unwrap() {\n                    parent = Some(Box::new(Internal {\n                        page,\n                        fixed_key_size,\n                        fixed_value_size,\n                        child: next_child.try_into().unwrap(),\n                        parent,\n                    }));\n                }\n                match child_page.memory()[0] {\n                    LEAF => {\n                        let child_accessor = LeafAccessor::new(\n                            child_page.memory(),\n"]}
